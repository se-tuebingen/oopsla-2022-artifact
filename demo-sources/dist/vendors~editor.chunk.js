(self.webpackJsonp=self.webpackJsonp||[]).push([["vendors~editor"],{"./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/base/browser/ui/dropdown/dropdown.css":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/base/browser/ui/dropdown/dropdown.css ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */function(module,exports,__webpack_require__){eval('// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../../../../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, "/*---------------------------------------------------------------------------------------------\\r\\n *  Copyright (c) Microsoft Corporation. All rights reserved.\\r\\n *  Licensed under the MIT License. See License.txt in the project root for license information.\\r\\n *--------------------------------------------------------------------------------------------*/\\r\\n\\r\\n.monaco-dropdown {\\r\\n\\theight: 100%;\\r\\n\\tpadding: 0;\\r\\n}\\r\\n\\r\\n.monaco-dropdown > .dropdown-label {\\r\\n\\tcursor: pointer;\\r\\n\\theight: 100%;\\r\\n\\tdisplay: flex;\\r\\n\\talign-items: center;\\r\\n\\tjustify-content: center;\\r\\n}\\r\\n\\r\\n.monaco-dropdown > .dropdown-label > .action-label.disabled {\\r\\n\\tcursor: default;\\r\\n}\\r\\n\\r\\n.monaco-dropdown-with-primary {\\r\\n\\tdisplay: flex !important;\\r\\n\\tflex-direction: row;\\r\\n\\tborder-radius: 5px;\\r\\n}\\r\\n\\r\\n.monaco-dropdown-with-primary > .action-container > .action-label {\\r\\n\\tmargin-right: 0;\\r\\n}\\r\\n\\r\\n.monaco-dropdown-with-primary > .dropdown-action-container > .monaco-dropdown > .dropdown-label .codicon[class*=\'codicon-\'] {\\r\\n\\tfont-size: 12px;\\r\\n\\tpadding-left: 0px;\\r\\n\\tpadding-right: 0px;\\r\\n\\tline-height: 16px;\\r\\n\\tmargin-left: -3px;\\r\\n}\\r\\n\\r\\n.monaco-dropdown-with-primary > .dropdown-action-container > .monaco-dropdown > .dropdown-label > .action-label {\\r\\n\\tdisplay: block;\\r\\n\\tbackground-size: 16px;\\r\\n\\tbackground-position: center center;\\r\\n\\tbackground-repeat: no-repeat;\\r\\n}\\r\\n", ""]);\n// Exports\nmodule.exports = exports;\n\n\n//# sourceURL=webpack:///./node_modules/monaco-editor/esm/vs/base/browser/ui/dropdown/dropdown.css?./node_modules/css-loader/dist/cjs.js')},"./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/base/browser/ui/hover/hover.css":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/base/browser/ui/hover/hover.css ***!
  \*****************************************************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */function(module,exports,__webpack_require__){eval('// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../../../../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, "/*---------------------------------------------------------------------------------------------\\r\\n *  Copyright (c) Microsoft Corporation. All rights reserved.\\r\\n *  Licensed under the MIT License. See License.txt in the project root for license information.\\r\\n *--------------------------------------------------------------------------------------------*/\\r\\n\\r\\n.monaco-hover {\\r\\n\\tcursor: default;\\r\\n\\tposition: absolute;\\r\\n\\toverflow: hidden;\\r\\n\\tz-index: 50;\\r\\n\\tuser-select: text;\\r\\n\\t-webkit-user-select: text;\\r\\n\\t-ms-user-select: text;\\r\\n\\tbox-sizing: initial;\\r\\n\\tanimation: fadein 100ms linear;\\r\\n\\tline-height: 1.5em;\\r\\n}\\r\\n\\r\\n.monaco-hover.hidden {\\r\\n\\tdisplay: none;\\r\\n}\\r\\n\\r\\n.monaco-hover .hover-contents {\\r\\n\\tpadding: 4px 8px;\\r\\n}\\r\\n\\r\\n.monaco-hover .markdown-hover > .hover-contents:not(.code-hover-contents) {\\r\\n\\tmax-width: 500px;\\r\\n\\tword-wrap: break-word;\\r\\n}\\r\\n\\r\\n.monaco-hover .markdown-hover > .hover-contents:not(.code-hover-contents) hr {\\r\\n\\tmin-width: 100%;\\r\\n}\\r\\n\\r\\n.monaco-hover p,\\r\\n.monaco-hover .code,\\r\\n.monaco-hover ul {\\r\\n\\tmargin: 8px 0;\\r\\n}\\r\\n\\r\\n.monaco-hover code {\\r\\n\\tfont-family: var(--monaco-monospace-font);\\r\\n}\\r\\n\\r\\n.monaco-hover hr {\\r\\n\\tbox-sizing: border-box;\\r\\n\\tborder-left: 0px;\\r\\n\\tborder-right: 0px;\\r\\n\\tmargin-top: 4px;\\r\\n\\tmargin-bottom: -4px;\\r\\n\\tmargin-left: -8px;\\r\\n\\tmargin-right: -8px;\\r\\n\\theight: 1px;\\r\\n}\\r\\n\\r\\n.monaco-hover p:first-child,\\r\\n.monaco-hover .code:first-child,\\r\\n.monaco-hover ul:first-child {\\r\\n\\tmargin-top: 0;\\r\\n}\\r\\n\\r\\n.monaco-hover p:last-child,\\r\\n.monaco-hover .code:last-child,\\r\\n.monaco-hover ul:last-child {\\r\\n\\tmargin-bottom: 0;\\r\\n}\\r\\n\\r\\n/* MarkupContent Layout */\\r\\n.monaco-hover ul {\\r\\n\\tpadding-left: 20px;\\r\\n}\\r\\n.monaco-hover ol {\\r\\n\\tpadding-left: 20px;\\r\\n}\\r\\n\\r\\n.monaco-hover li > p {\\r\\n\\tmargin-bottom: 0;\\r\\n}\\r\\n\\r\\n.monaco-hover li > ul {\\r\\n\\tmargin-top: 0;\\r\\n}\\r\\n\\r\\n.monaco-hover code {\\r\\n\\tborder-radius: 3px;\\r\\n\\tpadding: 0 0.4em;\\r\\n}\\r\\n\\r\\n.monaco-hover .monaco-tokenized-source {\\r\\n\\twhite-space: pre-wrap;\\r\\n}\\r\\n\\r\\n.monaco-hover .hover-row.status-bar {\\r\\n\\tfont-size: 12px;\\r\\n\\tline-height: 22px;\\r\\n}\\r\\n\\r\\n.monaco-hover .hover-row.status-bar .actions {\\r\\n\\tdisplay: flex;\\r\\n\\tpadding: 0px 8px;\\r\\n}\\r\\n\\r\\n.monaco-hover .hover-row.status-bar .actions .action-container {\\r\\n\\tmargin-right: 16px;\\r\\n\\tcursor: pointer;\\r\\n}\\r\\n\\r\\n.monaco-hover .hover-row.status-bar .actions .action-container .action .icon {\\r\\n\\tpadding-right: 4px;\\r\\n}\\r\\n\\r\\n.monaco-hover .markdown-hover .hover-contents .codicon {\\r\\n\\tcolor: inherit;\\r\\n\\tfont-size: inherit;\\r\\n\\tvertical-align: middle;\\r\\n}\\r\\n\\r\\n.monaco-hover .hover-contents a.code-link:hover,\\r\\n.monaco-hover .hover-contents a.code-link {\\r\\n\\tcolor: inherit;\\r\\n}\\r\\n\\r\\n.monaco-hover .hover-contents a.code-link:before {\\r\\n\\tcontent: \'(\';\\r\\n}\\r\\n\\r\\n.monaco-hover .hover-contents a.code-link:after {\\r\\n\\tcontent: \')\';\\r\\n}\\r\\n\\r\\n.monaco-hover .hover-contents a.code-link > span {\\r\\n\\ttext-decoration: underline;\\r\\n\\t/** Hack to force underline to show **/\\r\\n\\tborder-bottom: 1px solid transparent;\\r\\n\\ttext-underline-position: under;\\r\\n}\\r\\n\\r\\n/** Spans in markdown hovers need a margin-bottom to avoid looking cramped: https://github.com/microsoft/vscode/issues/101496 **/\\r\\n.monaco-hover .markdown-hover .hover-contents:not(.code-hover-contents) span {\\r\\n\\tmargin-bottom: 4px;\\r\\n\\tdisplay: inline-block;\\r\\n}\\r\\n\\r\\n.monaco-hover-content .action-container a {\\r\\n\\t-webkit-user-select: none;\\r\\n\\tuser-select: none;\\r\\n}\\r\\n\\r\\n.monaco-hover-content .action-container.disabled {\\r\\n\\tpointer-events: none;\\r\\n\\topacity: 0.4;\\r\\n\\tcursor: default;\\r\\n}\\r\\n", ""]);\n// Exports\nmodule.exports = exports;\n\n\n//# sourceURL=webpack:///./node_modules/monaco-editor/esm/vs/base/browser/ui/hover/hover.css?./node_modules/css-loader/dist/cjs.js')},"./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/lightBulbWidget.css":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/lightBulbWidget.css ***!
  \*******************************************************************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */function(module,exports,__webpack_require__){eval('// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../../../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, "/*---------------------------------------------------------------------------------------------\\r\\n *  Copyright (c) Microsoft Corporation. All rights reserved.\\r\\n *  Licensed under the MIT License. See License.txt in the project root for license information.\\r\\n *--------------------------------------------------------------------------------------------*/\\r\\n\\r\\n.monaco-editor .contentWidgets .codicon-light-bulb,\\r\\n.monaco-editor .contentWidgets .codicon-lightbulb-autofix {\\r\\n\\tdisplay: flex;\\r\\n\\talign-items: center;\\r\\n\\tjustify-content: center;\\r\\n}\\r\\n\\r\\n.monaco-editor .contentWidgets .codicon-light-bulb:hover,\\r\\n.monaco-editor .contentWidgets .codicon-lightbulb-autofix:hover {\\r\\n\\tcursor: pointer;\\r\\n}\\r\\n", ""]);\n// Exports\nmodule.exports = exports;\n\n\n//# sourceURL=webpack:///./node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/lightBulbWidget.css?./node_modules/css-loader/dist/cjs.js')},"./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/colorPicker.css":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/colorPicker.css ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */function(module,exports,__webpack_require__){eval('// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../../../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, "/*---------------------------------------------------------------------------------------------\\r\\n *  Copyright (c) Microsoft Corporation. All rights reserved.\\r\\n *  Licensed under the MIT License. See License.txt in the project root for license information.\\r\\n *--------------------------------------------------------------------------------------------*/\\r\\n\\r\\n.colorpicker-widget {\\r\\n\\theight: 190px;\\r\\n\\tuser-select: none;\\r\\n\\t-webkit-user-select: none;\\r\\n\\t-ms-user-select: none;\\r\\n}\\r\\n\\r\\n.monaco-editor .colorpicker-hover:focus {\\r\\n\\toutline: none;\\r\\n}\\r\\n\\r\\n\\r\\n/* Header */\\r\\n\\r\\n.colorpicker-header {\\r\\n\\tdisplay: flex;\\r\\n\\theight: 24px;\\r\\n\\tposition: relative;\\r\\n\\tbackground: url(\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuMTZEaa/1AAAAHUlEQVQYV2PYvXu3JAi7uLiAMaYAjAGTQBPYLQkAa/0Zef3qRswAAAAASUVORK5CYII=\\");\\r\\n\\tbackground-size: 9px 9px;\\r\\n\\timage-rendering: pixelated;\\r\\n}\\r\\n\\r\\n.colorpicker-header .picked-color {\\r\\n\\twidth: 216px;\\r\\n\\ttext-align: center;\\r\\n\\tline-height: 24px;\\r\\n\\tcursor: pointer;\\r\\n\\tcolor: white;\\r\\n\\tflex: 1;\\r\\n\\ttext-align: center;\\r\\n}\\r\\n\\r\\n.colorpicker-header .picked-color.light {\\r\\n\\tcolor: black;\\r\\n}\\r\\n\\r\\n.colorpicker-header .original-color {\\r\\n\\twidth: 74px;\\r\\n\\tz-index: inherit;\\r\\n\\tcursor: pointer;\\r\\n}\\r\\n\\r\\n\\r\\n/* Body */\\r\\n\\r\\n.colorpicker-body {\\r\\n\\tdisplay: flex;\\r\\n\\tpadding: 8px;\\r\\n\\tposition: relative;\\r\\n}\\r\\n\\r\\n.colorpicker-body .saturation-wrap {\\r\\n\\toverflow: hidden;\\r\\n\\theight: 150px;\\r\\n\\tposition: relative;\\r\\n\\tmin-width: 220px;\\r\\n\\tflex: 1;\\r\\n}\\r\\n\\r\\n.colorpicker-body .saturation-box {\\r\\n\\theight: 150px;\\r\\n\\tposition: absolute;\\r\\n}\\r\\n\\r\\n.colorpicker-body .saturation-selection {\\r\\n\\twidth: 9px;\\r\\n\\theight: 9px;\\r\\n\\tmargin: -5px 0 0 -5px;\\r\\n\\tborder: 1px solid rgb(255, 255, 255);\\r\\n\\tborder-radius: 100%;\\r\\n\\tbox-shadow: 0px 0px 2px rgba(0, 0, 0, 0.8);\\r\\n\\tposition: absolute;\\r\\n}\\r\\n\\r\\n.colorpicker-body .strip {\\r\\n\\twidth: 25px;\\r\\n\\theight: 150px;\\r\\n}\\r\\n\\r\\n.colorpicker-body .hue-strip {\\r\\n\\tposition: relative;\\r\\n\\tmargin-left: 8px;\\r\\n\\tcursor: grab;\\r\\n\\tbackground: linear-gradient(to bottom, #ff0000 0%, #ffff00 17%, #00ff00 33%, #00ffff 50%, #0000ff 67%, #ff00ff 83%, #ff0000 100%);\\r\\n}\\r\\n\\r\\n.colorpicker-body .opacity-strip {\\r\\n\\tposition: relative;\\r\\n\\tmargin-left: 8px;\\r\\n\\tcursor: grab;\\r\\n\\tbackground: url(\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuMTZEaa/1AAAAHUlEQVQYV2PYvXu3JAi7uLiAMaYAjAGTQBPYLQkAa/0Zef3qRswAAAAASUVORK5CYII=\\");\\r\\n\\tbackground-size: 9px 9px;\\r\\n\\timage-rendering: pixelated;\\r\\n}\\r\\n\\r\\n.colorpicker-body .strip.grabbing {\\r\\n\\tcursor: grabbing;\\r\\n}\\r\\n\\r\\n.colorpicker-body .slider {\\r\\n\\tposition: absolute;\\r\\n\\ttop: 0;\\r\\n\\tleft: -2px;\\r\\n\\twidth: calc(100% + 4px);\\r\\n\\theight: 4px;\\r\\n\\tbox-sizing: border-box;\\r\\n\\tborder: 1px solid rgba(255, 255, 255, 0.71);\\r\\n\\tbox-shadow: 0px 0px 1px rgba(0, 0, 0, 0.85);\\r\\n}\\r\\n\\r\\n.colorpicker-body .strip .overlay {\\r\\n\\theight: 150px;\\r\\n\\tpointer-events: none;\\r\\n}\\r\\n", ""]);\n// Exports\nmodule.exports = exports;\n\n\n//# sourceURL=webpack:///./node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/colorPicker.css?./node_modules/css-loader/dist/cjs.js')},"./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/media/gotoErrorWidget.css":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/media/gotoErrorWidget.css ***!
  \************************************************************************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */function(module,exports,__webpack_require__){eval('// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../../../../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, "/*---------------------------------------------------------------------------------------------\\r\\n *  Copyright (c) Microsoft Corporation. All rights reserved.\\r\\n *  Licensed under the MIT License. See License.txt in the project root for license information.\\r\\n *--------------------------------------------------------------------------------------------*/\\r\\n\\r\\n/* marker zone */\\r\\n\\r\\n.monaco-editor .peekview-widget .head .peekview-title .severity-icon {\\r\\n\\tdisplay: inline-block;\\r\\n\\tvertical-align: text-top;\\r\\n\\tmargin-right: 4px;\\r\\n}\\r\\n\\r\\n.monaco-editor .marker-widget {\\r\\n\\ttext-overflow: ellipsis;\\r\\n\\twhite-space: nowrap;\\r\\n}\\r\\n\\r\\n.monaco-editor .marker-widget > .stale {\\r\\n\\topacity: 0.6;\\r\\n\\tfont-style: italic;\\r\\n}\\r\\n\\r\\n.monaco-editor .marker-widget .title {\\r\\n\\tdisplay: inline-block;\\r\\n\\tpadding-right: 5px;\\r\\n}\\r\\n\\r\\n.monaco-editor .marker-widget .descriptioncontainer {\\r\\n\\tposition: absolute;\\r\\n\\twhite-space: pre;\\r\\n\\tuser-select: text;\\r\\n\\t-webkit-user-select: text;\\r\\n\\t-ms-user-select: text;\\r\\n\\tpadding: 8px 12px 0 20px;\\r\\n}\\r\\n\\r\\n.monaco-editor .marker-widget .descriptioncontainer .message {\\r\\n\\tdisplay: flex;\\r\\n\\tflex-direction: column;\\r\\n}\\r\\n\\r\\n.monaco-editor .marker-widget .descriptioncontainer .message .details {\\r\\n\\tpadding-left: 6px;\\r\\n}\\r\\n\\r\\n.monaco-editor .marker-widget .descriptioncontainer .message .source,\\r\\n.monaco-editor .marker-widget .descriptioncontainer .message span.code {\\r\\n\\topacity: 0.6;\\r\\n}\\r\\n\\r\\n.monaco-editor .marker-widget .descriptioncontainer .message a.code-link {\\r\\n\\topacity: 0.6;\\r\\n\\tcolor: inherit;\\r\\n}\\r\\n\\r\\n.monaco-editor .marker-widget .descriptioncontainer .message a.code-link:before {\\r\\n\\tcontent: \'(\';\\r\\n}\\r\\n\\r\\n.monaco-editor .marker-widget .descriptioncontainer .message a.code-link:after {\\r\\n\\tcontent: \')\';\\r\\n}\\r\\n\\r\\n.monaco-editor .marker-widget .descriptioncontainer .message a.code-link > span {\\r\\n\\ttext-decoration: underline;\\r\\n\\t/** Hack to force underline to show **/\\r\\n\\tborder-bottom: 1px solid transparent;\\r\\n\\ttext-underline-position: under;\\r\\n}\\r\\n\\r\\n.monaco-editor .marker-widget .descriptioncontainer .filename {\\r\\n\\tcursor: pointer;\\r\\n}\\r\\n", ""]);\n// Exports\nmodule.exports = exports;\n\n\n//# sourceURL=webpack:///./node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/media/gotoErrorWidget.css?./node_modules/css-loader/dist/cjs.js')},"./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/link/goToDefinitionAtPosition.css":
/*!*********************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/link/goToDefinitionAtPosition.css ***!
  \*********************************************************************************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */function(module,exports,__webpack_require__){eval('// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../../../../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, "/*---------------------------------------------------------------------------------------------\\r\\n *  Copyright (c) Microsoft Corporation. All rights reserved.\\r\\n *  Licensed under the MIT License. See License.txt in the project root for license information.\\r\\n *--------------------------------------------------------------------------------------------*/\\r\\n\\r\\n.monaco-editor .goto-definition-link {\\r\\n\\ttext-decoration: underline;\\r\\n\\tcursor: pointer;\\r\\n}", ""]);\n// Exports\nmodule.exports = exports;\n\n\n//# sourceURL=webpack:///./node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/link/goToDefinitionAtPosition.css?./node_modules/css-loader/dist/cjs.js')},"./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/peek/referencesWidget.css":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/peek/referencesWidget.css ***!
  \*************************************************************************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */function(module,exports,__webpack_require__){eval('// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../../../../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, "/*---------------------------------------------------------------------------------------------\\r\\n *  Copyright (c) Microsoft Corporation. All rights reserved.\\r\\n *  Licensed under the MIT License. See License.txt in the project root for license information.\\r\\n *--------------------------------------------------------------------------------------------*/\\r\\n\\r\\n/* -- zone widget */\\r\\n.monaco-editor .zone-widget .zone-widget-container.reference-zone-widget {\\r\\n\\tborder-top-width: 1px;\\r\\n\\tborder-bottom-width: 1px;\\r\\n}\\r\\n\\r\\n.monaco-editor .reference-zone-widget .inline {\\r\\n\\tdisplay: inline-block;\\r\\n\\tvertical-align: top;\\r\\n}\\r\\n\\r\\n.monaco-editor .reference-zone-widget .messages {\\r\\n\\theight: 100%;\\r\\n\\twidth: 100%;\\r\\n\\ttext-align: center;\\r\\n\\tpadding: 3em 0;\\r\\n}\\r\\n\\r\\n.monaco-editor .reference-zone-widget .ref-tree {\\r\\n\\tline-height: 23px;\\r\\n}\\r\\n\\r\\n.monaco-editor .reference-zone-widget .ref-tree .reference {\\r\\n\\ttext-overflow: ellipsis;\\r\\n\\toverflow: hidden;\\r\\n}\\r\\n\\r\\n.monaco-editor .reference-zone-widget .ref-tree .reference-file {\\r\\n\\tdisplay: inline-flex;\\r\\n\\twidth: 100%;\\r\\n\\theight: 100%;\\r\\n}\\r\\n\\r\\n.monaco-editor .reference-zone-widget .ref-tree .monaco-list:focus .selected .reference-file {\\r\\n\\tcolor: inherit !important;\\r\\n}\\r\\n\\r\\n.monaco-editor .reference-zone-widget .ref-tree .reference-file .count {\\r\\n\\tmargin-right: 12px;\\r\\n\\tmargin-left: auto;\\r\\n}\\r\\n\\r\\n/* High Contrast Theming */\\r\\n\\r\\n.monaco-editor.hc-black .reference-zone-widget .ref-tree .reference-file {\\r\\n\\tfont-weight: bold;\\r\\n}\\r\\n", ""]);\n// Exports\nmodule.exports = exports;\n\n\n//# sourceURL=webpack:///./node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/peek/referencesWidget.css?./node_modules/css-loader/dist/cjs.js')},"./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/ghostText.css":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/ghostText.css ***!
  \********************************************************************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */function(module,exports,__webpack_require__){eval('// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../../../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, "/*---------------------------------------------------------------------------------------------\\r\\n *  Copyright (c) Microsoft Corporation. All rights reserved.\\r\\n *  Licensed under the MIT License. See License.txt in the project root for license information.\\r\\n *--------------------------------------------------------------------------------------------*/\\r\\n\\r\\n.monaco-editor .suggest-preview-additional-widget {\\r\\n\\twhite-space: nowrap;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-preview-additional-widget .content-spacer {\\r\\n\\tcolor: transparent;\\r\\n\\twhite-space: pre;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-preview-additional-widget .button {\\r\\n\\tdisplay: inline-block;\\r\\n\\tcursor: pointer;\\r\\n\\ttext-decoration: underline;\\r\\n\\ttext-underline-position: under;\\r\\n}\\r\\n\\r\\n.monaco-editor .ghost-text-hidden {\\r\\n\\topacity: 0;\\r\\n\\tfont-size: 0;\\r\\n}\\r\\n\\r\\n.monaco-editor .ghost-text-decoration-preview {\\r\\n\\tfont-style: italic;\\r\\n}\\r\\n", ""]);\n// Exports\nmodule.exports = exports;\n\n\n//# sourceURL=webpack:///./node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/ghostText.css?./node_modules/css-loader/dist/cjs.js')},"./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/editor/contrib/message/messageController.css":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/editor/contrib/message/messageController.css ***!
  \******************************************************************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */function(module,exports,__webpack_require__){eval('// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../../../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, "/*---------------------------------------------------------------------------------------------\\r\\n *  Copyright (c) Microsoft Corporation. All rights reserved.\\r\\n *  Licensed under the MIT License. See License.txt in the project root for license information.\\r\\n *--------------------------------------------------------------------------------------------*/\\r\\n\\r\\n.monaco-editor .monaco-editor-overlaymessage {\\r\\n\\tpadding-bottom: 8px;\\r\\n\\tz-index: 10000;\\r\\n}\\r\\n\\r\\n.monaco-editor .monaco-editor-overlaymessage.below {\\r\\n\\tpadding-bottom: 0;\\r\\n\\tpadding-top: 8px;\\r\\n\\tz-index: 10000;\\r\\n}\\r\\n\\r\\n@keyframes fadeIn {\\r\\n\\tfrom { opacity: 0; }\\r\\n\\tto { opacity: 1; }\\r\\n}\\r\\n.monaco-editor .monaco-editor-overlaymessage.fadeIn {\\r\\n\\tanimation: fadeIn 150ms ease-out;\\r\\n}\\r\\n\\r\\n@keyframes fadeOut {\\r\\n\\tfrom { opacity: 1; }\\r\\n\\tto { opacity: 0; }\\r\\n}\\r\\n.monaco-editor .monaco-editor-overlaymessage.fadeOut {\\r\\n\\tanimation: fadeOut 100ms ease-out;\\r\\n}\\r\\n\\r\\n.monaco-editor .monaco-editor-overlaymessage .message {\\r\\n\\tpadding: 1px 4px;\\r\\n}\\r\\n\\r\\n.monaco-editor .monaco-editor-overlaymessage .anchor {\\r\\n\\twidth: 0 !important;\\r\\n\\theight: 0 !important;\\r\\n\\tborder-color: transparent;\\r\\n\\tborder-style: solid;\\r\\n\\tz-index: 1000;\\r\\n\\tborder-width: 8px;\\r\\n\\tposition: absolute;\\r\\n}\\r\\n\\r\\n.monaco-editor .monaco-editor-overlaymessage:not(.below) .anchor.top,\\r\\n.monaco-editor .monaco-editor-overlaymessage.below .anchor.below {\\r\\n\\tdisplay: none;\\r\\n}\\r\\n\\r\\n.monaco-editor .monaco-editor-overlaymessage.below .anchor.top {\\r\\n\\tdisplay: inherit;\\r\\n\\ttop: -8px;\\r\\n}\\r\\n", ""]);\n// Exports\nmodule.exports = exports;\n\n\n//# sourceURL=webpack:///./node_modules/monaco-editor/esm/vs/editor/contrib/message/messageController.css?./node_modules/css-loader/dist/cjs.js')},"./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/editor/contrib/peekView/media/peekViewWidget.css":
/*!**********************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/editor/contrib/peekView/media/peekViewWidget.css ***!
  \**********************************************************************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */function(module,exports,__webpack_require__){eval('// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../../../../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, "/*---------------------------------------------------------------------------------------------\\r\\n *  Copyright (c) Microsoft Corporation. All rights reserved.\\r\\n *  Licensed under the MIT License. See License.txt in the project root for license information.\\r\\n *--------------------------------------------------------------------------------------------*/\\r\\n\\r\\n.monaco-editor .peekview-widget .head {\\r\\n\\tbox-sizing: border-box;\\r\\n\\tdisplay: flex;\\r\\n}\\r\\n\\r\\n.monaco-editor .peekview-widget .head .peekview-title {\\r\\n\\tdisplay: flex;\\r\\n\\talign-items: center;\\r\\n\\tfont-size: 13px;\\r\\n\\tmargin-left: 20px;\\r\\n\\tmin-width: 0;\\r\\n}\\r\\n\\r\\n.monaco-editor .peekview-widget .head .peekview-title.clickable {\\r\\n\\tcursor: pointer;\\r\\n}\\r\\n\\r\\n.monaco-editor .peekview-widget .head .peekview-title .dirname:not(:empty) {\\r\\n\\tfont-size: 0.9em;\\r\\n\\tmargin-left: 0.5em;\\r\\n}\\r\\n\\r\\n.monaco-editor .peekview-widget .head .peekview-title .meta {\\r\\n\\twhite-space: nowrap;\\r\\n}\\r\\n\\r\\n.monaco-editor .peekview-widget .head .peekview-title .dirname {\\r\\n\\twhite-space: nowrap;\\r\\n}\\r\\n\\r\\n.monaco-editor .peekview-widget .head .peekview-title .filename {\\r\\n\\toverflow: hidden;\\r\\n\\ttext-overflow: ellipsis;\\r\\n\\twhite-space: nowrap;\\r\\n}\\r\\n\\r\\n.monaco-editor .peekview-widget .head .peekview-title .meta:not(:empty)::before {\\r\\n\\tcontent: \'-\';\\r\\n\\tpadding: 0 0.3em;\\r\\n}\\r\\n\\r\\n.monaco-editor .peekview-widget .head .peekview-actions {\\r\\n\\tflex: 1;\\r\\n\\ttext-align: right;\\r\\n\\tpadding-right: 2px;\\r\\n}\\r\\n\\r\\n.monaco-editor .peekview-widget .head .peekview-actions > .monaco-action-bar {\\r\\n\\tdisplay: inline-block;\\r\\n}\\r\\n\\r\\n.monaco-editor .peekview-widget .head .peekview-actions > .monaco-action-bar,\\r\\n.monaco-editor .peekview-widget .head .peekview-actions > .monaco-action-bar > .actions-container {\\r\\n\\theight: 100%;\\r\\n}\\r\\n\\r\\n.monaco-editor .peekview-widget > .body {\\r\\n\\tborder-top: 1px solid;\\r\\n\\tposition: relative;\\r\\n}\\r\\n\\r\\n.monaco-editor .peekview-widget .head .peekview-title .codicon {\\r\\n\\tmargin-right: 4px;\\r\\n}\\r\\n\\r\\n.monaco-editor .peekview-widget .monaco-list .monaco-list-row.focused .codicon {\\r\\n\\tcolor: inherit !important;\\r\\n}\\r\\n", ""]);\n// Exports\nmodule.exports = exports;\n\n\n//# sourceURL=webpack:///./node_modules/monaco-editor/esm/vs/editor/contrib/peekView/media/peekViewWidget.css?./node_modules/css-loader/dist/cjs.js')},"./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/editor/contrib/snippet/snippetSession.css":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/editor/contrib/snippet/snippetSession.css ***!
  \***************************************************************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */function(module,exports,__webpack_require__){eval('// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../../../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, "/*---------------------------------------------------------------------------------------------\\r\\n *  Copyright (c) Microsoft Corporation. All rights reserved.\\r\\n *  Licensed under the MIT License. See License.txt in the project root for license information.\\r\\n *--------------------------------------------------------------------------------------------*/\\r\\n\\r\\n.monaco-editor .snippet-placeholder {\\r\\n\\tmin-width: 2px;\\r\\n\\toutline-style: solid;\\r\\n\\toutline-width: 1px;\\r\\n}\\r\\n\\r\\n.monaco-editor .finish-snippet-placeholder {\\r\\n\\toutline-style: solid;\\r\\n\\toutline-width: 1px;\\r\\n}\\r\\n", ""]);\n// Exports\nmodule.exports = exports;\n\n\n//# sourceURL=webpack:///./node_modules/monaco-editor/esm/vs/editor/contrib/snippet/snippetSession.css?./node_modules/css-loader/dist/cjs.js')},"./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/editor/contrib/suggest/media/suggest.css":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/editor/contrib/suggest/media/suggest.css ***!
  \**************************************************************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */function(module,exports,__webpack_require__){eval('// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../../../../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, "/*---------------------------------------------------------------------------------------------\\r\\n *  Copyright (c) Microsoft Corporation. All rights reserved.\\r\\n *  Licensed under the MIT License. See License.txt in the project root for license information.\\r\\n *--------------------------------------------------------------------------------------------*/\\r\\n\\r\\n/* Suggest widget*/\\r\\n\\r\\n.monaco-editor .suggest-widget {\\r\\n\\twidth: 430px;\\r\\n\\tz-index: 40;\\r\\n\\tdisplay: flex;\\r\\n\\tflex-direction: column;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-widget.message {\\r\\n\\tflex-direction: row;\\r\\n\\talign-items: center;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-widget,\\r\\n.monaco-editor .suggest-details {\\r\\n\\tflex: 0 1 auto;\\r\\n\\twidth: 100%;\\r\\n\\tborder-style: solid;\\r\\n\\tborder-width: 1px;\\r\\n}\\r\\n\\r\\n.monaco-editor.hc-black .suggest-widget,\\r\\n.monaco-editor.hc-black .suggest-details {\\r\\n\\tborder-width: 2px;\\r\\n}\\r\\n\\r\\n/* Styles for status bar part */\\r\\n\\r\\n\\r\\n.monaco-editor .suggest-widget .suggest-status-bar {\\r\\n\\tbox-sizing: border-box;\\r\\n\\tdisplay: none;\\r\\n\\tflex-flow: row nowrap;\\r\\n\\tjustify-content: space-between;\\r\\n\\twidth: 100%;\\r\\n\\tfont-size: 80%;\\r\\n\\tpadding: 0 4px 0 4px;\\r\\n\\tborder-top: 1px solid transparent;\\r\\n\\toverflow: hidden;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-widget.with-status-bar .suggest-status-bar {\\r\\n\\tdisplay: flex;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-widget .suggest-status-bar .left {\\r\\n\\tpadding-right: 8px;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-widget.with-status-bar .suggest-status-bar .action-label {\\r\\n\\topacity: 0.5;\\r\\n\\tcolor: inherit;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-widget.with-status-bar .suggest-status-bar .action-item:not(:last-of-type) .action-label {\\r\\n\\tmargin-right: 0;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-widget.with-status-bar .suggest-status-bar .action-item:not(:last-of-type) .action-label::after {\\r\\n\\tcontent: \', \';\\r\\n\\tmargin-right: 0.3em;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-widget.with-status-bar .monaco-list .monaco-list-row>.contents>.main>.right>.readMore,\\r\\n.monaco-editor .suggest-widget.with-status-bar .monaco-list .monaco-list-row.focused.string-label>.contents>.main>.right>.readMore {\\r\\n\\tdisplay: none;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-widget.with-status-bar:not(.docs-side) .monaco-list .monaco-list-row:hover>.contents>.main>.right.can-expand-details>.details-label {\\r\\n\\twidth: 100%;\\r\\n}\\r\\n\\r\\n/* Styles for Message element for when widget is loading or is empty */\\r\\n\\r\\n.monaco-editor .suggest-widget>.message {\\r\\n\\tpadding-left: 22px;\\r\\n}\\r\\n\\r\\n/** Styles for the list element **/\\r\\n\\r\\n.monaco-editor .suggest-widget>.tree {\\r\\n\\theight: 100%;\\r\\n\\twidth: 100%;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-widget .monaco-list {\\r\\n\\tuser-select: none;\\r\\n\\t-webkit-user-select: none;\\r\\n\\t-ms-user-select: none;\\r\\n}\\r\\n\\r\\n/** Styles for each row in the list element **/\\r\\n\\r\\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row {\\r\\n\\tdisplay: flex;\\r\\n\\t-mox-box-sizing: border-box;\\r\\n\\tbox-sizing: border-box;\\r\\n\\tpadding-right: 10px;\\r\\n\\tbackground-repeat: no-repeat;\\r\\n\\tbackground-position: 2px 2px;\\r\\n\\twhite-space: nowrap;\\r\\n\\tcursor: pointer;\\r\\n\\ttouch-action: none;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row>.contents {\\r\\n\\tflex: 1;\\r\\n\\theight: 100%;\\r\\n\\toverflow: hidden;\\r\\n\\tpadding-left: 2px;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row>.contents>.main {\\r\\n\\tdisplay: flex;\\r\\n\\toverflow: hidden;\\r\\n\\ttext-overflow: ellipsis;\\r\\n\\twhite-space: pre;\\r\\n\\tjustify-content: space-between;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row>.contents>.main>.left, .monaco-editor .suggest-widget .monaco-list .monaco-list-row>.contents>.main>.right {\\r\\n\\tdisplay: flex;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-widget:not(.frozen) .monaco-highlighted-label .highlight {\\r\\n\\tfont-weight: bold;\\r\\n}\\r\\n\\r\\n/** ReadMore Icon styles **/\\r\\n\\r\\n.monaco-editor .suggest-details>.monaco-scrollable-element>.body>.header>.codicon-close,\\r\\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row>.contents>.main>.right>.readMore::before {\\r\\n\\tcolor: inherit;\\r\\n\\topacity: 1;\\r\\n\\tfont-size: 14px;\\r\\n\\tcursor: pointer;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-details>.monaco-scrollable-element>.body>.header>.codicon-close {\\r\\n\\tposition: absolute;\\r\\n\\ttop: 6px;\\r\\n\\tright: 2px;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-details>.monaco-scrollable-element>.body>.header>.codicon-close:hover,\\r\\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row>.contents>.main>.right>.readMore:hover {\\r\\n\\topacity: 1;\\r\\n}\\r\\n\\r\\n/** signature, qualifier, type/details opacity **/\\r\\n\\r\\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row>.contents>.main>.right>.details-label {\\r\\n\\topacity: 0.7;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row>.contents>.main>.left>.signature-label {\\r\\n\\toverflow: hidden;\\r\\n\\ttext-overflow: ellipsis;\\r\\n\\topacity: 0.6;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row>.contents>.main>.left>.qualifier-label {\\r\\n\\tmargin-left: 12px;\\r\\n\\topacity: 0.4;\\r\\n\\tfont-size: 85%;\\r\\n\\tline-height: initial;\\r\\n\\ttext-overflow: ellipsis;\\r\\n\\toverflow: hidden;\\r\\n\\talign-self: center;\\r\\n}\\r\\n\\r\\n/** Type Info and icon next to the label in the focused completion item **/\\r\\n\\r\\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row>.contents>.main>.right>.details-label {\\r\\n\\tfont-size: 85%;\\r\\n\\tmargin-left: 1.1em;\\r\\n\\toverflow: hidden;\\r\\n\\ttext-overflow: ellipsis;\\r\\n\\twhite-space: nowrap;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row>.contents>.main>.right>.details-label>.monaco-tokenized-source {\\r\\n\\tdisplay: inline;\\r\\n}\\r\\n\\r\\n/** Details: if using CompletionItem#details, show on focus **/\\r\\n\\r\\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row>.contents>.main>.right>.details-label {\\r\\n\\tdisplay: none;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-widget:not(.shows-details) .monaco-list .monaco-list-row.focused>.contents>.main>.right>.details-label {\\r\\n\\tdisplay: inline;\\r\\n}\\r\\n\\r\\n/** Details: if using CompletionItemLabel#details, always show **/\\r\\n\\r\\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row:not(.string-label)>.contents>.main>.right>.details-label,\\r\\n.monaco-editor .suggest-widget.docs-side .monaco-list .monaco-list-row.focused:not(.string-label)>.contents>.main>.right>.details-label {\\r\\n\\tdisplay: inline;\\r\\n}\\r\\n\\r\\n/** Ellipsis on hover **/\\r\\n\\r\\n.monaco-editor .suggest-widget:not(.docs-side) .monaco-list .monaco-list-row:hover>.contents>.main>.right.can-expand-details>.details-label {\\r\\n\\twidth: calc(100% - 26px);\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row>.contents>.main>.left {\\r\\n\\tflex-shrink: 1;\\r\\n\\tflex-grow: 1;\\r\\n\\toverflow: hidden;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row>.contents>.main>.left>.monaco-icon-label {\\r\\n\\tflex-shrink: 0;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row:not(.string-label)>.contents>.main>.left>.monaco-icon-label {\\r\\n\\tmax-width: 100%;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row.string-label>.contents>.main>.left>.monaco-icon-label {\\r\\n\\tflex-shrink: 1;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row>.contents>.main>.right {\\r\\n\\toverflow: hidden;\\r\\n\\tflex-shrink: 4;\\r\\n\\tmax-width: 70%;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row>.contents>.main>.right>.readMore {\\r\\n\\tdisplay: inline-block;\\r\\n\\tposition: absolute;\\r\\n\\tright: 10px;\\r\\n\\twidth: 18px;\\r\\n\\theight: 18px;\\r\\n\\tvisibility: hidden;\\r\\n}\\r\\n\\r\\n/** Do NOT display ReadMore when docs is side/below **/\\r\\n\\r\\n.monaco-editor .suggest-widget.docs-side .monaco-list .monaco-list-row>.contents>.main>.right>.readMore, .monaco-editor .suggest-widget.docs-below .monaco-list .monaco-list-row>.contents>.main>.right>.readMore {\\r\\n\\tdisplay: none !important;\\r\\n}\\r\\n\\r\\n/** Do NOT display ReadMore when using plain CompletionItemLabel (details/documentation might not be resolved) **/\\r\\n\\r\\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row.string-label>.contents>.main>.right>.readMore {\\r\\n\\tdisplay: none;\\r\\n}\\r\\n\\r\\n/** Focused item can show ReadMore, but can\'t when docs is side/below **/\\r\\n\\r\\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row.focused.string-label>.contents>.main>.right>.readMore {\\r\\n\\tdisplay: inline-block;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-widget.docs-side .monaco-list .monaco-list-row>.contents>.main>.right>.readMore,\\r\\n.monaco-editor .suggest-widget.docs-below .monaco-list .monaco-list-row>.contents>.main>.right>.readMore {\\r\\n\\tdisplay: none;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row:hover>.contents>.main>.right>.readMore {\\r\\n\\tvisibility: visible;\\r\\n}\\r\\n\\r\\n/** Styles for each row in the list **/\\r\\n\\r\\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row .monaco-icon-label.deprecated {\\r\\n\\topacity: 0.66;\\r\\n\\ttext-decoration: unset;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row .monaco-icon-label.deprecated>.monaco-icon-label-container>.monaco-icon-name-container {\\r\\n\\ttext-decoration: line-through;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row .monaco-icon-label::before {\\r\\n\\theight: 100%;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row .icon {\\r\\n\\tdisplay: block;\\r\\n\\theight: 16px;\\r\\n\\twidth: 16px;\\r\\n\\tmargin-left: 2px;\\r\\n\\tbackground-repeat: no-repeat;\\r\\n\\tbackground-size: 80%;\\r\\n\\tbackground-position: center;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row .icon.hide {\\r\\n\\tdisplay: none;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row .suggest-icon {\\r\\n\\tdisplay: flex;\\r\\n\\talign-items: center;\\r\\n\\tmargin-right: 4px;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-widget.no-icons .monaco-list .monaco-list-row .icon, .monaco-editor .suggest-widget.no-icons .monaco-list .monaco-list-row .suggest-icon::before {\\r\\n\\tdisplay: none;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-widget .monaco-list .monaco-list-row .icon.customcolor .colorspan {\\r\\n\\tmargin: 0 0 0 0.3em;\\r\\n\\tborder: 0.1em solid #000;\\r\\n\\twidth: 0.7em;\\r\\n\\theight: 0.7em;\\r\\n\\tdisplay: inline-block;\\r\\n}\\r\\n\\r\\n/** Styles for the docs of the completion item in focus **/\\r\\n\\r\\n.monaco-editor .suggest-details-container {\\r\\n\\tz-index: 41;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-details {\\r\\n\\tdisplay: flex;\\r\\n\\tflex-direction: column;\\r\\n\\tcursor: default;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-details.no-docs {\\r\\n\\tdisplay: none;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-details>.monaco-scrollable-element {\\r\\n\\tflex: 1;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-details>.monaco-scrollable-element>.body {\\r\\n\\tbox-sizing: border-box;\\r\\n\\theight: 100%;\\r\\n\\twidth: 100%;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-details>.monaco-scrollable-element>.body>.header>.type {\\r\\n\\tflex: 2;\\r\\n\\toverflow: hidden;\\r\\n\\ttext-overflow: ellipsis;\\r\\n\\topacity: 0.7;\\r\\n\\twhite-space: pre;\\r\\n\\tmargin: 0 24px 0 0;\\r\\n\\tpadding: 4px 0 12px 5px;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-details>.monaco-scrollable-element>.body>.header>.type.auto-wrap {\\r\\n\\twhite-space: normal;\\r\\n\\tword-break: break-all;\\r\\n}\\r\\n\\r\\n\\r\\n.monaco-editor .suggest-details>.monaco-scrollable-element>.body>.docs {\\r\\n\\tmargin: 0;\\r\\n\\tpadding: 4px 5px;\\r\\n\\twhite-space: pre-wrap;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-details.no-type>.monaco-scrollable-element>.body>.docs {\\r\\n\\tmargin-right: 24px;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-details>.monaco-scrollable-element>.body>.docs.markdown-docs {\\r\\n\\tpadding: 0;\\r\\n\\twhite-space: initial;\\r\\n\\tmin-height: calc(1rem + 8px);\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-details>.monaco-scrollable-element>.body>.docs.markdown-docs>div,\\r\\n.monaco-editor .suggest-details>.monaco-scrollable-element>.body>.docs.markdown-docs>span:not(:empty) {\\r\\n\\tpadding: 4px 5px;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-details>.monaco-scrollable-element>.body>.docs.markdown-docs>div>p:first-child {\\r\\n\\tmargin-top: 0;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-details>.monaco-scrollable-element>.body>.docs.markdown-docs>div>p:last-child {\\r\\n\\tmargin-bottom: 0;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-details>.monaco-scrollable-element>.body>.docs .code {\\r\\n\\twhite-space: pre-wrap;\\r\\n\\tword-wrap: break-word;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-details>.monaco-scrollable-element>.body>.docs.markdown-docs .codicon {\\r\\n\\tvertical-align: sub;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-details>.monaco-scrollable-element>.body>p:empty {\\r\\n\\tdisplay: none;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-details code {\\r\\n\\tborder-radius: 3px;\\r\\n\\tpadding: 0 0.4em;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-details ul {\\r\\n\\tpadding-left: 20px;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-details ol {\\r\\n\\tpadding-left: 20px;\\r\\n}\\r\\n\\r\\n.monaco-editor .suggest-details p code {\\r\\n\\tfont-family: var(--monaco-monospace-font);\\r\\n}\\r\\n", ""]);\n// Exports\nmodule.exports = exports;\n\n\n//# sourceURL=webpack:///./node_modules/monaco-editor/esm/vs/editor/contrib/suggest/media/suggest.css?./node_modules/css-loader/dist/cjs.js')},"./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/editor/contrib/zoneWidget/zoneWidget.css":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/editor/contrib/zoneWidget/zoneWidget.css ***!
  \**************************************************************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */function(module,exports,__webpack_require__){eval('// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../../../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, "/*---------------------------------------------------------------------------------------------\\r\\n *  Copyright (c) Microsoft Corporation. All rights reserved.\\r\\n *  Licensed under the MIT License. See License.txt in the project root for license information.\\r\\n *--------------------------------------------------------------------------------------------*/\\r\\n.monaco-editor .zone-widget {\\r\\n\\tposition: absolute;\\r\\n\\tz-index: 10;\\r\\n}\\r\\n\\r\\n\\r\\n.monaco-editor .zone-widget .zone-widget-container {\\r\\n\\tborder-top-style: solid;\\r\\n\\tborder-bottom-style: solid;\\r\\n\\tborder-top-width: 0;\\r\\n\\tborder-bottom-width: 0;\\r\\n\\tposition: relative;\\r\\n}\\r\\n", ""]);\n// Exports\nmodule.exports = exports;\n\n\n//# sourceURL=webpack:///./node_modules/monaco-editor/esm/vs/editor/contrib/zoneWidget/zoneWidget.css?./node_modules/css-loader/dist/cjs.js')},"./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/platform/actions/browser/menuEntryActionViewItem.css":
/*!**************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/platform/actions/browser/menuEntryActionViewItem.css ***!
  \**************************************************************************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */function(module,exports,__webpack_require__){eval('// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../../../../../css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, "/*---------------------------------------------------------------------------------------------\\r\\n *  Copyright (c) Microsoft Corporation. All rights reserved.\\r\\n *  Licensed under the MIT License. See License.txt in the project root for license information.\\r\\n *--------------------------------------------------------------------------------------------*/\\r\\n\\r\\n.monaco-action-bar .action-item.menu-entry .action-label.icon {\\r\\n\\twidth: 16px;\\r\\n\\theight: 16px;\\r\\n\\tbackground-repeat: no-repeat;\\r\\n\\tbackground-position: 50%;\\r\\n\\tbackground-size: 16px;\\r\\n}\\r\\n\\r\\n.monaco-action-bar .action-item.menu-entry .action-label {\\r\\n\\tbackground-image: var(--menu-entry-icon-light);\\r\\n}\\r\\n\\r\\n.vs-dark .monaco-action-bar .action-item.menu-entry .action-label,\\r\\n.hc-black .monaco-action-bar .action-item.menu-entry .action-label {\\r\\n\\tbackground-image: var(--menu-entry-icon-dark);\\r\\n}\\r\\n\\r\\n\\r\\n.monaco-dropdown-with-default {\\r\\n\\tdisplay: flex !important;\\r\\n\\tflex-direction: row;\\r\\n\\tborder-radius: 5px;\\r\\n}\\r\\n\\r\\n.monaco-dropdown-with-default > .action-container > .action-label {\\r\\n\\tmargin-right: 0;\\r\\n}\\r\\n\\r\\n.monaco-dropdown-with-default > .action-container.menu-entry > .action-label.icon {\\r\\n\\twidth: 16px;\\r\\n\\theight: 16px;\\r\\n\\tbackground-repeat: no-repeat;\\r\\n\\tbackground-position: 50%;\\r\\n\\tbackground-size: 16px;\\r\\n}\\r\\n\\r\\n.monaco-dropdown-with-default > .action-container.menu-entry > .action-label {\\r\\n\\tbackground-image: var(--menu-entry-icon-light);\\r\\n}\\r\\n\\r\\n.vs-dark .monaco-dropdown-with-default > .action-container.menu-entry > .action-label,\\r\\n.hc-black .monaco-dropdown-with-default > .action-container.menu-entry > .action-label {\\r\\n\\tbackground-image: var(--menu-entry-icon-dark);\\r\\n}\\r\\n\\r\\n.monaco-dropdown-with-default > .dropdown-action-container > .monaco-dropdown > .dropdown-label .codicon[class*=\'codicon-\'] {\\r\\n\\tfont-size: 12px;\\r\\n\\tpadding-left: 0px;\\r\\n\\tpadding-right: 0px;\\r\\n\\tline-height: 16px;\\r\\n\\tmargin-left: -3px;\\r\\n}\\r\\n\\r\\n.monaco-dropdown-with-default > .dropdown-action-container > .monaco-dropdown > .dropdown-label > .action-label {\\r\\n\\tdisplay: block;\\r\\n\\tbackground-size: 16px;\\r\\n\\tbackground-position: center center;\\r\\n\\tbackground-repeat: no-repeat;\\r\\n}\\r\\n", ""]);\n// Exports\nmodule.exports = exports;\n\n\n//# sourceURL=webpack:///./node_modules/monaco-editor/esm/vs/platform/actions/browser/menuEntryActionViewItem.css?./node_modules/css-loader/dist/cjs.js')},"./node_modules/monaco-editor/esm/vs/base/browser/ui/dropdown/dropdown.css":
/*!*********************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/browser/ui/dropdown/dropdown.css ***!
  \*********************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */function(module,exports,__webpack_require__){eval('var api = __webpack_require__(/*! ../../../../../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");\n            var content = __webpack_require__(/*! !../../../../../../../css-loader/dist/cjs.js!./dropdown.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/base/browser/ui/dropdown/dropdown.css");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === \'string\') {\n              content = [[module.i, content, \'\']];\n            }\n\nvar options = {};\n\noptions.insert = "head";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nmodule.exports = content.locals || {};\n\n//# sourceURL=webpack:///./node_modules/monaco-editor/esm/vs/base/browser/ui/dropdown/dropdown.css?')},"./node_modules/monaco-editor/esm/vs/base/browser/ui/hover/hover.css":
/*!***************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/browser/ui/hover/hover.css ***!
  \***************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */function(module,exports,__webpack_require__){eval('var api = __webpack_require__(/*! ../../../../../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");\n            var content = __webpack_require__(/*! !../../../../../../../css-loader/dist/cjs.js!./hover.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/base/browser/ui/hover/hover.css");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === \'string\') {\n              content = [[module.i, content, \'\']];\n            }\n\nvar options = {};\n\noptions.insert = "head";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nmodule.exports = content.locals || {};\n\n//# sourceURL=webpack:///./node_modules/monaco-editor/esm/vs/base/browser/ui/hover/hover.css?')},"./node_modules/monaco-editor/esm/vs/base/common/marked/marked.js":
/*!************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/marked/marked.js ***!
  \************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */function(module,exports,__webpack_require__){eval("/**\n * marked - a markdown parser\n * Copyright (c) 2011-2021, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */\n\n/**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */\n\n(function (global, factory) {\n   true ? module.exports = factory() :\n    undefined;\n}(this, (function () {\n  'use strict';\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n\n  function _createForOfIteratorHelperLoose(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      return function () {\n        if (i >= o.length) return {\n          done: true\n        };\n        return {\n          done: false,\n          value: o[i++]\n        };\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var defaults$5 = { exports: {} };\n\n  function getDefaults$1() {\n    return {\n      baseUrl: null,\n      breaks: false,\n      extensions: null,\n      gfm: true,\n      headerIds: true,\n      headerPrefix: '',\n      highlight: null,\n      langPrefix: 'language-',\n      mangle: true,\n      pedantic: false,\n      renderer: null,\n      sanitize: false,\n      sanitizer: null,\n      silent: false,\n      smartLists: false,\n      smartypants: false,\n      tokenizer: null,\n      walkTokens: null,\n      xhtml: false\n    };\n  }\n\n  function changeDefaults$1(newDefaults) {\n    defaults$5.exports.defaults = newDefaults;\n  }\n\n  defaults$5.exports = {\n    defaults: getDefaults$1(),\n    getDefaults: getDefaults$1,\n    changeDefaults: changeDefaults$1\n  };\n\n  /**\n   * Helpers\n   */\n  var escapeTest = /[&<>\"']/;\n  var escapeReplace = /[&<>\"']/g;\n  var escapeTestNoEncode = /[<>\"']|&(?!#?\\w+;)/;\n  var escapeReplaceNoEncode = /[<>\"']|&(?!#?\\w+;)/g;\n  var escapeReplacements = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n\n  var getEscapeReplacement = function getEscapeReplacement(ch) {\n    return escapeReplacements[ch];\n  };\n\n  function escape$2(html, encode) {\n    if (encode) {\n      if (escapeTest.test(html)) {\n        return html.replace(escapeReplace, getEscapeReplacement);\n      }\n    } else {\n      if (escapeTestNoEncode.test(html)) {\n        return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n      }\n    }\n\n    return html;\n  }\n\n  var unescapeTest = /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig;\n\n  function unescape$1(html) {\n    // explicitly match decimal, hex, and named HTML entities\n    return html.replace(unescapeTest, function (_, n) {\n      n = n.toLowerCase();\n      if (n === 'colon') return ':';\n\n      if (n.charAt(0) === '#') {\n        return n.charAt(1) === 'x' ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));\n      }\n\n      return '';\n    });\n  }\n\n  var caret = /(^|[^\\[])\\^/g;\n\n  function edit$1(regex, opt) {\n    regex = regex.source || regex;\n    opt = opt || '';\n    var obj = {\n      replace: function replace(name, val) {\n        val = val.source || val;\n        val = val.replace(caret, '$1');\n        regex = regex.replace(name, val);\n        return obj;\n      },\n      getRegex: function getRegex() {\n        return new RegExp(regex, opt);\n      }\n    };\n    return obj;\n  }\n\n  var nonWordAndColonTest = /[^\\w:]/g;\n  var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;\n\n  function cleanUrl$1(sanitize, base, href) {\n    if (sanitize) {\n      var prot;\n\n      try {\n        prot = decodeURIComponent(unescape$1(href)).replace(nonWordAndColonTest, '').toLowerCase();\n      } catch (e) {\n        return null;\n      }\n\n      if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {\n        return null;\n      }\n    }\n\n    if (base && !originIndependentUrl.test(href)) {\n      href = resolveUrl(base, href);\n    }\n\n    try {\n      href = encodeURI(href).replace(/%25/g, '%');\n    } catch (e) {\n      return null;\n    }\n\n    return href;\n  }\n\n  var baseUrls = {};\n  var justDomain = /^[^:]+:\\/*[^/]*$/;\n  var protocol = /^([^:]+:)[\\s\\S]*$/;\n  var domain = /^([^:]+:\\/*[^/]*)[\\s\\S]*$/;\n\n  function resolveUrl(base, href) {\n    if (!baseUrls[' ' + base]) {\n      // we can ignore everything in base after the last slash of its path component,\n      // but we might need to add _that_\n      // https://tools.ietf.org/html/rfc3986#section-3\n      if (justDomain.test(base)) {\n        baseUrls[' ' + base] = base + '/';\n      } else {\n        baseUrls[' ' + base] = rtrim$1(base, '/', true);\n      }\n    }\n\n    base = baseUrls[' ' + base];\n    var relativeBase = base.indexOf(':') === -1;\n\n    if (href.substring(0, 2) === '//') {\n      if (relativeBase) {\n        return href;\n      }\n\n      return base.replace(protocol, '$1') + href;\n    } else if (href.charAt(0) === '/') {\n      if (relativeBase) {\n        return href;\n      }\n\n      return base.replace(domain, '$1') + href;\n    } else {\n      return base + href;\n    }\n  }\n\n  var noopTest$1 = {\n    exec: function noopTest() { }\n  };\n\n  function merge$2(obj) {\n    var i = 1,\n      target,\n      key;\n\n    for (; i < arguments.length; i++) {\n      target = arguments[i];\n\n      for (key in target) {\n        if (Object.prototype.hasOwnProperty.call(target, key)) {\n          obj[key] = target[key];\n        }\n      }\n    }\n\n    return obj;\n  }\n\n  function splitCells$1(tableRow, count) {\n    // ensure that every cell-delimiting pipe has a space\n    // before it to distinguish it from an escaped pipe\n    var row = tableRow.replace(/\\|/g, function (match, offset, str) {\n      var escaped = false,\n        curr = offset;\n\n      while (--curr >= 0 && str[curr] === '\\\\') {\n        escaped = !escaped;\n      }\n\n      if (escaped) {\n        // odd number of slashes means | is escaped\n        // so we leave it alone\n        return '|';\n      } else {\n        // add space before unescaped |\n        return ' |';\n      }\n    }),\n      cells = row.split(/ \\|/);\n    var i = 0; // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n\n    if (!cells[0].trim()) {\n      cells.shift();\n    }\n\n    if (!cells[cells.length - 1].trim()) {\n      cells.pop();\n    }\n\n    if (cells.length > count) {\n      cells.splice(count);\n    } else {\n      while (cells.length < count) {\n        cells.push('');\n      }\n    }\n\n    for (; i < cells.length; i++) {\n      // leading or trailing whitespace is ignored per the gfm spec\n      cells[i] = cells[i].trim().replace(/\\\\\\|/g, '|');\n    }\n\n    return cells;\n  } // Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n  // /c*$/ is vulnerable to REDOS.\n  // invert: Remove suffix of non-c chars instead. Default falsey.\n\n\n  function rtrim$1(str, c, invert) {\n    var l = str.length;\n\n    if (l === 0) {\n      return '';\n    } // Length of suffix matching the invert condition.\n\n\n    var suffLen = 0; // Step left until we fail to match the invert condition.\n\n    while (suffLen < l) {\n      var currChar = str.charAt(l - suffLen - 1);\n\n      if (currChar === c && !invert) {\n        suffLen++;\n      } else if (currChar !== c && invert) {\n        suffLen++;\n      } else {\n        break;\n      }\n    }\n\n    return str.substr(0, l - suffLen);\n  }\n\n  function findClosingBracket$1(str, b) {\n    if (str.indexOf(b[1]) === -1) {\n      return -1;\n    }\n\n    var l = str.length;\n    var level = 0,\n      i = 0;\n\n    for (; i < l; i++) {\n      if (str[i] === '\\\\') {\n        i++;\n      } else if (str[i] === b[0]) {\n        level++;\n      } else if (str[i] === b[1]) {\n        level--;\n\n        if (level < 0) {\n          return i;\n        }\n      }\n    }\n\n    return -1;\n  }\n\n  function checkSanitizeDeprecation$1(opt) {\n    if (opt && opt.sanitize && !opt.silent) {\n      console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');\n    }\n  } // copied from https://stackoverflow.com/a/5450113/806777\n\n\n  function repeatString$1(pattern, count) {\n    if (count < 1) {\n      return '';\n    }\n\n    var result = '';\n\n    while (count > 1) {\n      if (count & 1) {\n        result += pattern;\n      }\n\n      count >>= 1;\n      pattern += pattern;\n    }\n\n    return result + pattern;\n  }\n\n  var helpers = {\n    escape: escape$2,\n    unescape: unescape$1,\n    edit: edit$1,\n    cleanUrl: cleanUrl$1,\n    resolveUrl: resolveUrl,\n    noopTest: noopTest$1,\n    merge: merge$2,\n    splitCells: splitCells$1,\n    rtrim: rtrim$1,\n    findClosingBracket: findClosingBracket$1,\n    checkSanitizeDeprecation: checkSanitizeDeprecation$1,\n    repeatString: repeatString$1\n  };\n\n  var defaults$4 = defaults$5.exports.defaults;\n  var rtrim = helpers.rtrim,\n    splitCells = helpers.splitCells,\n    _escape = helpers.escape,\n    findClosingBracket = helpers.findClosingBracket;\n\n  function outputLink(cap, link, raw, lexer) {\n    var href = link.href;\n    var title = link.title ? _escape(link.title) : null;\n    var text = cap[1].replace(/\\\\([\\[\\]])/g, '$1');\n\n    if (cap[0].charAt(0) !== '!') {\n      lexer.state.inLink = true;\n      return {\n        type: 'link',\n        raw: raw,\n        href: href,\n        title: title,\n        text: text,\n        tokens: lexer.inlineTokens(text, [])\n      };\n    } else {\n      return {\n        type: 'image',\n        raw: raw,\n        href: href,\n        title: title,\n        text: _escape(text)\n      };\n    }\n  }\n\n  function indentCodeCompensation(raw, text) {\n    var matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n\n    if (matchIndentToCode === null) {\n      return text;\n    }\n\n    var indentToCode = matchIndentToCode[1];\n    return text.split('\\n').map(function (node) {\n      var matchIndentInNode = node.match(/^\\s+/);\n\n      if (matchIndentInNode === null) {\n        return node;\n      }\n\n      var indentInNode = matchIndentInNode[0];\n\n      if (indentInNode.length >= indentToCode.length) {\n        return node.slice(indentToCode.length);\n      }\n\n      return node;\n    }).join('\\n');\n  }\n  /**\n   * Tokenizer\n   */\n\n\n  var Tokenizer_1 = /*#__PURE__*/function () {\n    function Tokenizer(options) {\n      this.options = options || defaults$4;\n    }\n\n    var _proto = Tokenizer.prototype;\n\n    _proto.space = function space(src) {\n      var cap = this.rules.block.newline.exec(src);\n\n      if (cap) {\n        if (cap[0].length > 1) {\n          return {\n            type: 'space',\n            raw: cap[0]\n          };\n        }\n\n        return {\n          raw: '\\n'\n        };\n      }\n    };\n\n    _proto.code = function code(src) {\n      var cap = this.rules.block.code.exec(src);\n\n      if (cap) {\n        var text = cap[0].replace(/^ {1,4}/gm, '');\n        return {\n          type: 'code',\n          raw: cap[0],\n          codeBlockStyle: 'indented',\n          text: !this.options.pedantic ? rtrim(text, '\\n') : text\n        };\n      }\n    };\n\n    _proto.fences = function fences(src) {\n      var cap = this.rules.block.fences.exec(src);\n\n      if (cap) {\n        var raw = cap[0];\n        var text = indentCodeCompensation(raw, cap[3] || '');\n        return {\n          type: 'code',\n          raw: raw,\n          lang: cap[2] ? cap[2].trim() : cap[2],\n          text: text\n        };\n      }\n    };\n\n    _proto.heading = function heading(src) {\n      var cap = this.rules.block.heading.exec(src);\n\n      if (cap) {\n        var text = cap[2].trim(); // remove trailing #s\n\n        if (/#$/.test(text)) {\n          var trimmed = rtrim(text, '#');\n\n          if (this.options.pedantic) {\n            text = trimmed.trim();\n          } else if (!trimmed || / $/.test(trimmed)) {\n            // CommonMark requires space before trailing #s\n            text = trimmed.trim();\n          }\n        }\n\n        var token = {\n          type: 'heading',\n          raw: cap[0],\n          depth: cap[1].length,\n          text: text,\n          tokens: []\n        };\n        this.lexer.inline(token.text, token.tokens);\n        return token;\n      }\n    };\n\n    _proto.hr = function hr(src) {\n      var cap = this.rules.block.hr.exec(src);\n\n      if (cap) {\n        return {\n          type: 'hr',\n          raw: cap[0]\n        };\n      }\n    };\n\n    _proto.blockquote = function blockquote(src) {\n      var cap = this.rules.block.blockquote.exec(src);\n\n      if (cap) {\n        var text = cap[0].replace(/^ *> ?/gm, '');\n        return {\n          type: 'blockquote',\n          raw: cap[0],\n          tokens: this.lexer.blockTokens(text, []),\n          text: text\n        };\n      }\n    };\n\n    _proto.list = function list(src) {\n      var cap = this.rules.block.list.exec(src);\n\n      if (cap) {\n        var raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine, line, lines, itemContents;\n        var bull = cap[1].trim();\n        var isordered = bull.length > 1;\n        var list = {\n          type: 'list',\n          raw: '',\n          ordered: isordered,\n          start: isordered ? +bull.slice(0, -1) : '',\n          loose: false,\n          items: []\n        };\n        bull = isordered ? \"\\\\d{1,9}\\\\\" + bull.slice(-1) : \"\\\\\" + bull;\n\n        if (this.options.pedantic) {\n          bull = isordered ? bull : '[*+-]';\n        } // Get next list item\n\n\n        var itemRegex = new RegExp(\"^( {0,3}\" + bull + \")((?: [^\\\\n]*| *)(?:\\\\n[^\\\\n]*)*(?:\\\\n|$))\"); // Get each top-level item\n\n        while (src) {\n          if (this.rules.block.hr.test(src)) {\n            // End list if we encounter an HR (possibly move into itemRegex?)\n            break;\n          }\n\n          if (!(cap = itemRegex.exec(src))) {\n            break;\n          }\n\n          lines = cap[2].split('\\n');\n\n          if (this.options.pedantic) {\n            indent = 2;\n            itemContents = lines[0].trimLeft();\n          } else {\n            indent = cap[2].search(/[^ ]/); // Find first non-space char\n\n            indent = cap[1].length + (indent > 4 ? 1 : indent); // intented code blocks after 4 spaces; indent is always 1\n\n            itemContents = lines[0].slice(indent - cap[1].length);\n          }\n\n          blankLine = false;\n          raw = cap[0];\n\n          if (!lines[0] && /^ *$/.test(lines[1])) {\n            // items begin with at most one blank line\n            raw = cap[1] + lines.slice(0, 2).join('\\n') + '\\n';\n            list.loose = true;\n            lines = [];\n          }\n\n          var nextBulletRegex = new RegExp(\"^ {0,\" + Math.min(3, indent - 1) + \"}(?:[*+-]|\\\\d{1,9}[.)])\");\n\n          for (i = 1; i < lines.length; i++) {\n            line = lines[i];\n\n            if (this.options.pedantic) {\n              // Re-align to follow commonmark nesting rules\n              line = line.replace(/^ {1,4}(?=( {4})*[^ ])/g, '  ');\n            } // End list item if found start of new bullet\n\n\n            if (nextBulletRegex.test(line)) {\n              raw = cap[1] + lines.slice(0, i).join('\\n') + '\\n';\n              break;\n            } // Until we encounter a blank line, item contents do not need indentation\n\n\n            if (!blankLine) {\n              if (!line.trim()) {\n                // Check if current line is empty\n                blankLine = true;\n              } // Dedent if possible\n\n\n              if (line.search(/[^ ]/) >= indent) {\n                itemContents += '\\n' + line.slice(indent);\n              } else {\n                itemContents += '\\n' + line;\n              }\n\n              continue;\n            } // Dedent this line\n\n\n            if (line.search(/[^ ]/) >= indent || !line.trim()) {\n              itemContents += '\\n' + line.slice(indent);\n              continue;\n            } else {\n              // Line was not properly indented; end of this item\n              raw = cap[1] + lines.slice(0, i).join('\\n') + '\\n';\n              break;\n            }\n          }\n\n          if (!list.loose) {\n            // If the previous item ended with a blank line, the list is loose\n            if (endsWithBlankLine) {\n              list.loose = true;\n            } else if (/\\n *\\n *$/.test(raw)) {\n              endsWithBlankLine = true;\n            }\n          } // Check for task list items\n\n\n          if (this.options.gfm) {\n            istask = /^\\[[ xX]\\] /.exec(itemContents);\n\n            if (istask) {\n              ischecked = istask[0] !== '[ ] ';\n              itemContents = itemContents.replace(/^\\[[ xX]\\] +/, '');\n            }\n          }\n\n          list.items.push({\n            type: 'list_item',\n            raw: raw,\n            task: !!istask,\n            checked: ischecked,\n            loose: false,\n            text: itemContents\n          });\n          list.raw += raw;\n          src = src.slice(raw.length);\n        } // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n\n\n        list.items[list.items.length - 1].raw = raw.trimRight();\n        list.items[list.items.length - 1].text = itemContents.trimRight();\n        list.raw = list.raw.trimRight();\n        var l = list.items.length; // Item child tokens handled here at end because we needed to have the final item to trim it first\n\n        for (i = 0; i < l; i++) {\n          this.lexer.state.top = false;\n          list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n\n          if (list.items[i].tokens.some(function (t) {\n            return t.type === 'space';\n          })) {\n            list.loose = true;\n            list.items[i].loose = true;\n          }\n        }\n\n        return list;\n      }\n    };\n\n    _proto.html = function html(src) {\n      var cap = this.rules.block.html.exec(src);\n\n      if (cap) {\n        var token = {\n          type: 'html',\n          raw: cap[0],\n          pre: !this.options.sanitizer && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),\n          text: cap[0]\n        };\n\n        if (this.options.sanitize) {\n          token.type = 'paragraph';\n          token.text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]);\n          token.tokens = [];\n          this.lexer.inline(token.text, token.tokens);\n        }\n\n        return token;\n      }\n    };\n\n    _proto.def = function def(src) {\n      var cap = this.rules.block.def.exec(src);\n\n      if (cap) {\n        if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);\n        var tag = cap[1].toLowerCase().replace(/\\s+/g, ' ');\n        return {\n          type: 'def',\n          tag: tag,\n          raw: cap[0],\n          href: cap[2],\n          title: cap[3]\n        };\n      }\n    };\n\n    _proto.table = function table(src) {\n      var cap = this.rules.block.table.exec(src);\n\n      if (cap) {\n        var item = {\n          type: 'table',\n          header: splitCells(cap[1]).map(function (c) {\n            return {\n              text: c\n            };\n          }),\n          align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n          rows: cap[3] ? cap[3].replace(/\\n$/, '').split('\\n') : []\n        };\n\n        if (item.header.length === item.align.length) {\n          item.raw = cap[0];\n          var l = item.align.length;\n          var i, j, k, row;\n\n          for (i = 0; i < l; i++) {\n            if (/^ *-+: *$/.test(item.align[i])) {\n              item.align[i] = 'right';\n            } else if (/^ *:-+: *$/.test(item.align[i])) {\n              item.align[i] = 'center';\n            } else if (/^ *:-+ *$/.test(item.align[i])) {\n              item.align[i] = 'left';\n            } else {\n              item.align[i] = null;\n            }\n          }\n\n          l = item.rows.length;\n\n          for (i = 0; i < l; i++) {\n            item.rows[i] = splitCells(item.rows[i], item.header.length).map(function (c) {\n              return {\n                text: c\n              };\n            });\n          } // parse child tokens inside headers and cells\n          // header child tokens\n\n\n          l = item.header.length;\n\n          for (j = 0; j < l; j++) {\n            item.header[j].tokens = [];\n            this.lexer.inlineTokens(item.header[j].text, item.header[j].tokens);\n          } // cell child tokens\n\n\n          l = item.rows.length;\n\n          for (j = 0; j < l; j++) {\n            row = item.rows[j];\n\n            for (k = 0; k < row.length; k++) {\n              row[k].tokens = [];\n              this.lexer.inlineTokens(row[k].text, row[k].tokens);\n            }\n          }\n\n          return item;\n        }\n      }\n    };\n\n    _proto.lheading = function lheading(src) {\n      var cap = this.rules.block.lheading.exec(src);\n\n      if (cap) {\n        var token = {\n          type: 'heading',\n          raw: cap[0],\n          depth: cap[2].charAt(0) === '=' ? 1 : 2,\n          text: cap[1],\n          tokens: []\n        };\n        this.lexer.inline(token.text, token.tokens);\n        return token;\n      }\n    };\n\n    _proto.paragraph = function paragraph(src) {\n      var cap = this.rules.block.paragraph.exec(src);\n\n      if (cap) {\n        var token = {\n          type: 'paragraph',\n          raw: cap[0],\n          text: cap[1].charAt(cap[1].length - 1) === '\\n' ? cap[1].slice(0, -1) : cap[1],\n          tokens: []\n        };\n        this.lexer.inline(token.text, token.tokens);\n        return token;\n      }\n    };\n\n    _proto.text = function text(src) {\n      var cap = this.rules.block.text.exec(src);\n\n      if (cap) {\n        var token = {\n          type: 'text',\n          raw: cap[0],\n          text: cap[0],\n          tokens: []\n        };\n        this.lexer.inline(token.text, token.tokens);\n        return token;\n      }\n    };\n\n    _proto.escape = function escape(src) {\n      var cap = this.rules.inline.escape.exec(src);\n\n      if (cap) {\n        return {\n          type: 'escape',\n          raw: cap[0],\n          text: _escape(cap[1])\n        };\n      }\n    };\n\n    _proto.tag = function tag(src) {\n      var cap = this.rules.inline.tag.exec(src);\n\n      if (cap) {\n        if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {\n          this.lexer.state.inLink = true;\n        } else if (this.lexer.state.inLink && /^<\\/a>/i.test(cap[0])) {\n          this.lexer.state.inLink = false;\n        }\n\n        if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n          this.lexer.state.inRawBlock = true;\n        } else if (this.lexer.state.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n          this.lexer.state.inRawBlock = false;\n        }\n\n        return {\n          type: this.options.sanitize ? 'text' : 'html',\n          raw: cap[0],\n          inLink: this.lexer.state.inLink,\n          inRawBlock: this.lexer.state.inRawBlock,\n          text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0]\n        };\n      }\n    };\n\n    _proto.link = function link(src) {\n      var cap = this.rules.inline.link.exec(src);\n\n      if (cap) {\n        var trimmedUrl = cap[2].trim();\n\n        if (!this.options.pedantic && /^</.test(trimmedUrl)) {\n          // commonmark requires matching angle brackets\n          if (!/>$/.test(trimmedUrl)) {\n            return;\n          } // ending angle bracket cannot be escaped\n\n\n          var rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\\\');\n\n          if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n            return;\n          }\n        } else {\n          // find closing parenthesis\n          var lastParenIndex = findClosingBracket(cap[2], '()');\n\n          if (lastParenIndex > -1) {\n            var start = cap[0].indexOf('!') === 0 ? 5 : 4;\n            var linkLen = start + cap[1].length + lastParenIndex;\n            cap[2] = cap[2].substring(0, lastParenIndex);\n            cap[0] = cap[0].substring(0, linkLen).trim();\n            cap[3] = '';\n          }\n        }\n\n        var href = cap[2];\n        var title = '';\n\n        if (this.options.pedantic) {\n          // split pedantic href and title\n          var link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n\n          if (link) {\n            href = link[1];\n            title = link[3];\n          }\n        } else {\n          title = cap[3] ? cap[3].slice(1, -1) : '';\n        }\n\n        href = href.trim();\n\n        if (/^</.test(href)) {\n          if (this.options.pedantic && !/>$/.test(trimmedUrl)) {\n            // pedantic allows starting angle bracket without ending angle bracket\n            href = href.slice(1);\n          } else {\n            href = href.slice(1, -1);\n          }\n        }\n\n        return outputLink(cap, {\n          href: href ? href.replace(this.rules.inline._escapes, '$1') : href,\n          title: title ? title.replace(this.rules.inline._escapes, '$1') : title\n        }, cap[0], this.lexer);\n      }\n    };\n\n    _proto.reflink = function reflink(src, links) {\n      var cap;\n\n      if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {\n        var link = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n        link = links[link.toLowerCase()];\n\n        if (!link || !link.href) {\n          var text = cap[0].charAt(0);\n          return {\n            type: 'text',\n            raw: text,\n            text: text\n          };\n        }\n\n        return outputLink(cap, link, cap[0], this.lexer);\n      }\n    };\n\n    _proto.emStrong = function emStrong(src, maskedSrc, prevChar) {\n      if (prevChar === void 0) {\n        prevChar = '';\n      }\n\n      var match = this.rules.inline.emStrong.lDelim.exec(src);\n      if (!match) return; // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n\n      if (match[3] && prevChar.match(/(?:[0-9A-Za-z\\xAA\\xB2\\xB3\\xB5\\xB9\\xBA\\xBC-\\xBE\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0620-\\u064A\\u0660-\\u0669\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07C0-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08C7\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0966-\\u096F\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09E6-\\u09F1\\u09F4-\\u09F9\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A6F\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AE6-\\u0AEF\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B66-\\u0B6F\\u0B71-\\u0B77\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0BE6-\\u0BF2\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C66-\\u0C6F\\u0C78-\\u0C7E\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D04-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D58-\\u0D61\\u0D66-\\u0D78\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DE6-\\u0DEF\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F20-\\u0F33\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F-\\u1049\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u1090-\\u1099\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1369-\\u137C\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u17E0-\\u17E9\\u17F0-\\u17F9\\u1810-\\u1819\\u1820-\\u1878\\u1880-\\u1884\\u1887-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B50-\\u1B59\\u1B83-\\u1BA0\\u1BAE-\\u1BE5\\u1C00-\\u1C23\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CE9-\\u1CEC\\u1CEE-\\u1CF3\\u1CF5\\u1CF6\\u1CFA\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2070\\u2071\\u2074-\\u2079\\u207F-\\u2089\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2150-\\u2189\\u2460-\\u249B\\u24EA-\\u24FF\\u2776-\\u2793\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2CFD\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u3192-\\u3195\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3220-\\u3229\\u3248-\\u324F\\u3251-\\u325F\\u3280-\\u3289\\u32B1-\\u32BF\\u3400-\\u4DBF\\u4E00-\\u9FFC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7BF\\uA7C2-\\uA7CA\\uA7F5-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA830-\\uA835\\uA840-\\uA873\\uA882-\\uA8B3\\uA8D0-\\uA8D9\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA8FE\\uA900-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF-\\uA9D9\\uA9E0-\\uA9E4\\uA9E6-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABE2\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD07-\\uDD33\\uDD40-\\uDD78\\uDD8A\\uDD8B\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE1-\\uDEFB\\uDF00-\\uDF23\\uDF2D-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC58-\\uDC76\\uDC79-\\uDC9E\\uDCA7-\\uDCAF\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDCFB-\\uDD1B\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBC-\\uDDCF\\uDDD2-\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE40-\\uDE48\\uDE60-\\uDE7E\\uDE80-\\uDE9F\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDEEB-\\uDEEF\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF58-\\uDF72\\uDF78-\\uDF91\\uDFA9-\\uDFAF]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDCFA-\\uDD23\\uDD30-\\uDD39\\uDE60-\\uDE7E\\uDE80-\\uDEA9\\uDEB0\\uDEB1\\uDF00-\\uDF27\\uDF30-\\uDF45\\uDF51-\\uDF54\\uDFB0-\\uDFCB\\uDFE0-\\uDFF6]|\\uD804[\\uDC03-\\uDC37\\uDC52-\\uDC6F\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD03-\\uDD26\\uDD36-\\uDD3F\\uDD44\\uDD47\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDD0-\\uDDDA\\uDDDC\\uDDE1-\\uDDF4\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDEF0-\\uDEF9\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC50-\\uDC59\\uDC5F-\\uDC61\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEAA\\uDEB8\\uDEC0-\\uDEC9\\uDF00-\\uDF1A\\uDF30-\\uDF3B]|\\uD806[\\uDC00-\\uDC2B\\uDCA0-\\uDCF2\\uDCFF-\\uDD06\\uDD09\\uDD0C-\\uDD13\\uDD15\\uDD16\\uDD18-\\uDD2F\\uDD3F\\uDD41\\uDD50-\\uDD59\\uDDA0-\\uDDA7\\uDDAA-\\uDDD0\\uDDE1\\uDDE3\\uDE00\\uDE0B-\\uDE32\\uDE3A\\uDE50\\uDE5C-\\uDE89\\uDE9D\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC50-\\uDC6C\\uDC72-\\uDC8F\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD30\\uDD46\\uDD50-\\uDD59\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD89\\uDD98\\uDDA0-\\uDDA9\\uDEE0-\\uDEF2\\uDFB0\\uDFC0-\\uDFD4]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD822\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879\\uD880-\\uD883][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF5B-\\uDF61\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDE40-\\uDE96\\uDF00-\\uDF4A\\uDF50\\uDF93-\\uDF9F\\uDFE0\\uDFE1\\uDFE3]|\\uD821[\\uDC00-\\uDFF7]|\\uD823[\\uDC00-\\uDCD5\\uDD00-\\uDD08]|\\uD82C[\\uDC00-\\uDD1E\\uDD50-\\uDD52\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD834[\\uDEE0-\\uDEF3\\uDF60-\\uDF78]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD838[\\uDD00-\\uDD2C\\uDD37-\\uDD3D\\uDD40-\\uDD49\\uDD4E\\uDEC0-\\uDEEB\\uDEF0-\\uDEF9]|\\uD83A[\\uDC00-\\uDCC4\\uDCC7-\\uDCCF\\uDD00-\\uDD43\\uDD4B\\uDD50-\\uDD59]|\\uD83B[\\uDC71-\\uDCAB\\uDCAD-\\uDCAF\\uDCB1-\\uDCB4\\uDD01-\\uDD2D\\uDD2F-\\uDD3D\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD83C[\\uDD00-\\uDD0C]|\\uD83E[\\uDFF0-\\uDFF9]|\\uD869[\\uDC00-\\uDEDD\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]|\\uD884[\\uDC00-\\uDF4A])/)) return;\n      var nextChar = match[1] || match[2] || '';\n\n      if (!nextChar || nextChar && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar))) {\n        var lLength = match[0].length - 1;\n        var rDelim,\n          rLength,\n          delimTotal = lLength,\n          midDelimTotal = 0;\n        var endReg = match[0][0] === '*' ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;\n        endReg.lastIndex = 0; // Clip maskedSrc to same section of string as src (move to lexer?)\n\n        maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n\n        while ((match = endReg.exec(maskedSrc)) != null) {\n          rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n          if (!rDelim) continue; // skip single * in __abc*abc__\n\n          rLength = rDelim.length;\n\n          if (match[3] || match[4]) {\n            // found another Left Delim\n            delimTotal += rLength;\n            continue;\n          } else if (match[5] || match[6]) {\n            // either Left or Right Delim\n            if (lLength % 3 && !((lLength + rLength) % 3)) {\n              midDelimTotal += rLength;\n              continue; // CommonMark Emphasis Rules 9-10\n            }\n          }\n\n          delimTotal -= rLength;\n          if (delimTotal > 0) continue; // Haven't found enough closing delimiters\n          // Remove extra characters. *a*** -> *a*\n\n          rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal); // Create `em` if smallest delimiter has odd char count. *a***\n\n          if (Math.min(lLength, rLength) % 2) {\n            var _text = src.slice(1, lLength + match.index + rLength);\n\n            return {\n              type: 'em',\n              raw: src.slice(0, lLength + match.index + rLength + 1),\n              text: _text,\n              tokens: this.lexer.inlineTokens(_text, [])\n            };\n          } // Create 'strong' if smallest delimiter has even char count. **a***\n\n\n          var text = src.slice(2, lLength + match.index + rLength - 1);\n          return {\n            type: 'strong',\n            raw: src.slice(0, lLength + match.index + rLength + 1),\n            text: text,\n            tokens: this.lexer.inlineTokens(text, [])\n          };\n        }\n      }\n    };\n\n    _proto.codespan = function codespan(src) {\n      var cap = this.rules.inline.code.exec(src);\n\n      if (cap) {\n        var text = cap[2].replace(/\\n/g, ' ');\n        var hasNonSpaceChars = /[^ ]/.test(text);\n        var hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);\n\n        if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n          text = text.substring(1, text.length - 1);\n        }\n\n        text = _escape(text, true);\n        return {\n          type: 'codespan',\n          raw: cap[0],\n          text: text\n        };\n      }\n    };\n\n    _proto.br = function br(src) {\n      var cap = this.rules.inline.br.exec(src);\n\n      if (cap) {\n        return {\n          type: 'br',\n          raw: cap[0]\n        };\n      }\n    };\n\n    _proto.del = function del(src) {\n      var cap = this.rules.inline.del.exec(src);\n\n      if (cap) {\n        return {\n          type: 'del',\n          raw: cap[0],\n          text: cap[2],\n          tokens: this.lexer.inlineTokens(cap[2], [])\n        };\n      }\n    };\n\n    _proto.autolink = function autolink(src, mangle) {\n      var cap = this.rules.inline.autolink.exec(src);\n\n      if (cap) {\n        var text, href;\n\n        if (cap[2] === '@') {\n          text = _escape(this.options.mangle ? mangle(cap[1]) : cap[1]);\n          href = 'mailto:' + text;\n        } else {\n          text = _escape(cap[1]);\n          href = text;\n        }\n\n        return {\n          type: 'link',\n          raw: cap[0],\n          text: text,\n          href: href,\n          tokens: [{\n            type: 'text',\n            raw: text,\n            text: text\n          }]\n        };\n      }\n    };\n\n    _proto.url = function url(src, mangle) {\n      var cap;\n\n      if (cap = this.rules.inline.url.exec(src)) {\n        var text, href;\n\n        if (cap[2] === '@') {\n          text = _escape(this.options.mangle ? mangle(cap[0]) : cap[0]);\n          href = 'mailto:' + text;\n        } else {\n          // do extended autolink path validation\n          var prevCapZero;\n\n          do {\n            prevCapZero = cap[0];\n            cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];\n          } while (prevCapZero !== cap[0]);\n\n          text = _escape(cap[0]);\n\n          if (cap[1] === 'www.') {\n            href = 'http://' + text;\n          } else {\n            href = text;\n          }\n        }\n\n        return {\n          type: 'link',\n          raw: cap[0],\n          text: text,\n          href: href,\n          tokens: [{\n            type: 'text',\n            raw: text,\n            text: text\n          }]\n        };\n      }\n    };\n\n    _proto.inlineText = function inlineText(src, smartypants) {\n      var cap = this.rules.inline.text.exec(src);\n\n      if (cap) {\n        var text;\n\n        if (this.lexer.state.inRawBlock) {\n          text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0];\n        } else {\n          text = _escape(this.options.smartypants ? smartypants(cap[0]) : cap[0]);\n        }\n\n        return {\n          type: 'text',\n          raw: cap[0],\n          text: text\n        };\n      }\n    };\n\n    return Tokenizer;\n  }();\n\n  var noopTest = helpers.noopTest,\n    edit = helpers.edit,\n    merge$1 = helpers.merge;\n  /**\n   * Block-Level Grammar\n   */\n\n  var block$1 = {\n    newline: /^(?: *(?:\\n|$))+/,\n    code: /^( {4}[^\\n]+(?:\\n(?: *(?:\\n|$))*)?)+/,\n    fences: /^ {0,3}(`{3,}(?=[^`\\n]*\\n)|~{3,})([^\\n]*)\\n(?:|([\\s\\S]*?)\\n)(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/,\n    hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)/,\n    heading: /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/,\n    blockquote: /^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/,\n    list: /^( {0,3}bull)( [^\\n]+?)?(?:\\n|$)/,\n    html: '^ {0,3}(?:' // optional indentation\n      + '<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n      + '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n      + '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n      + '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n      + '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n      + '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (6)\n      + '|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (7) open tag\n      + '|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)' // (7) closing tag\n      + ')',\n    def: /^ {0,3}\\[(label)\\]: *\\n? *<?([^\\s>]+)>?(?:(?: +\\n? *| *\\n *)(title))? *(?:\\n+|$)/,\n    table: noopTest,\n    lheading: /^([^\\n]+)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n    // regex template, placeholders will be replaced according to different paragraph\n    // interruption rules of commonmark and the original markdown spec:\n    _paragraph: /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html| +\\n)[^\\n]+)*)/,\n    text: /^[^\\n]+/\n  };\n  block$1._label = /(?!\\s*\\])(?:\\\\[\\[\\]]|[^\\[\\]])+/;\n  block$1._title = /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/;\n  block$1.def = edit(block$1.def).replace('label', block$1._label).replace('title', block$1._title).getRegex();\n  block$1.bullet = /(?:[*+-]|\\d{1,9}[.)])/;\n  block$1.listItemStart = edit(/^( *)(bull) */).replace('bull', block$1.bullet).getRegex();\n  block$1.list = edit(block$1.list).replace(/bull/g, block$1.bullet).replace('hr', '\\\\n+(?=\\\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$))').replace('def', '\\\\n+(?=' + block$1.def.source + ')').getRegex();\n  block$1._tag = 'address|article|aside|base|basefont|blockquote|body|caption' + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption' + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe' + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option' + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr' + '|track|ul';\n  block$1._comment = /\x3c!--(?!-?>)[\\s\\S]*?(?:--\x3e|$)/;\n  block$1.html = edit(block$1.html, 'i').replace('comment', block$1._comment).replace('tag', block$1._tag).replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/).getRegex();\n  block$1.paragraph = edit(block$1._paragraph).replace('hr', block$1.hr).replace('heading', ' {0,3}#{1,6} ').replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs\n    .replace('blockquote', ' {0,3}>').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n    .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', block$1._tag) // pars can be interrupted by type (6) html blocks\n    .getRegex();\n  block$1.blockquote = edit(block$1.blockquote).replace('paragraph', block$1.paragraph).getRegex();\n  /**\n   * Normal Block Grammar\n   */\n\n  block$1.normal = merge$1({}, block$1);\n  /**\n   * GFM Block Grammar\n   */\n\n  block$1.gfm = merge$1({}, block$1.normal, {\n    table: '^ *([^\\\\n ].*\\\\|.*)\\\\n' // Header\n      + ' {0,3}(?:\\\\| *)?(:?-+:? *(?:\\\\| *:?-+:? *)*)\\\\|?' // Align\n      + '(?:\\\\n *((?:(?!\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)' // Cells\n\n  });\n  block$1.gfm.table = edit(block$1.gfm.table).replace('hr', block$1.hr).replace('heading', ' {0,3}#{1,6} ').replace('blockquote', ' {0,3}>').replace('code', ' {4}[^\\\\n]').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n    .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)').replace('tag', block$1._tag) // tables can be interrupted by type (6) html blocks\n    .getRegex();\n  /**\n   * Pedantic grammar (original John Gruber's loose markdown specification)\n   */\n\n  block$1.pedantic = merge$1({}, block$1.normal, {\n    html: edit('^ *(?:comment *(?:\\\\n|\\\\s*$)' + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n      + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))').replace('comment', block$1._comment).replace(/tag/g, '(?!(?:' + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub' + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)' + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b').getRegex(),\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n    heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n    fences: noopTest,\n    // fences not supported\n    paragraph: edit(block$1.normal._paragraph).replace('hr', block$1.hr).replace('heading', ' *#{1,6} *[^\\n]').replace('lheading', block$1.lheading).replace('blockquote', ' {0,3}>').replace('|fences', '').replace('|list', '').replace('|html', '').getRegex()\n  });\n  /**\n   * Inline-Level Grammar\n   */\n\n  var inline$1 = {\n    escape: /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/,\n    autolink: /^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/,\n    url: noopTest,\n    tag: '^comment' + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n      + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n      + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n      + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n      + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>',\n    // CDATA section\n    link: /^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/,\n    reflink: /^!?\\[(label)\\]\\[(?!\\s*\\])((?:\\\\[\\[\\]]?|[^\\[\\]\\\\])+)\\]/,\n    nolink: /^!?\\[(?!\\s*\\])((?:\\[[^\\[\\]]*\\]|\\\\[\\[\\]]|[^\\[\\]])*)\\](?:\\[\\])?/,\n    reflinkSearch: 'reflink|nolink(?!\\\\()',\n    emStrong: {\n      lDelim: /^(?:\\*+(?:([punct_])|[^\\s*]))|^_+(?:([punct*])|([^\\s_]))/,\n      //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.\n      //        () Skip other delimiter (1) #***                   (2) a***#, a***                   (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a\n      rDelimAst: /\\_\\_[^_*]*?\\*[^_*]*?\\_\\_|[punct_](\\*+)(?=[\\s]|$)|[^punct*_\\s](\\*+)(?=[punct_\\s]|$)|[punct_\\s](\\*+)(?=[^punct*_\\s])|[\\s](\\*+)(?=[punct_])|[punct_](\\*+)(?=[punct_])|[^punct*_\\s](\\*+)(?=[^punct*_\\s])/,\n      rDelimUnd: /\\*\\*[^_*]*?\\_[^_*]*?\\*\\*|[punct*](\\_+)(?=[\\s]|$)|[^punct*_\\s](\\_+)(?=[punct*\\s]|$)|[punct*\\s](\\_+)(?=[^punct*_\\s])|[\\s](\\_+)(?=[punct*])|[punct*](\\_+)(?=[punct*])/ // ^- Not allowed for _\n\n    },\n    code: /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/,\n    br: /^( {2,}|\\\\)\\n(?!\\s*$)/,\n    del: noopTest,\n    text: /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/,\n    punctuation: /^([\\spunctuation])/\n  }; // list of punctuation marks from CommonMark spec\n  // without * and _ to handle the different emphasis markers * and _\n\n  inline$1._punctuation = '!\"#$%&\\'()+\\\\-.,/:;<=>?@\\\\[\\\\]`^{|}~';\n  inline$1.punctuation = edit(inline$1.punctuation).replace(/punctuation/g, inline$1._punctuation).getRegex(); // sequences em should skip over [title](link), `code`, <html>\n\n  inline$1.blockSkip = /\\[[^\\]]*?\\]\\([^\\)]*?\\)|`[^`]*?`|<[^>]*?>/g;\n  inline$1.escapedEmSt = /\\\\\\*|\\\\_/g;\n  inline$1._comment = edit(block$1._comment).replace('(?:--\x3e|$)', '--\x3e').getRegex();\n  inline$1.emStrong.lDelim = edit(inline$1.emStrong.lDelim).replace(/punct/g, inline$1._punctuation).getRegex();\n  inline$1.emStrong.rDelimAst = edit(inline$1.emStrong.rDelimAst, 'g').replace(/punct/g, inline$1._punctuation).getRegex();\n  inline$1.emStrong.rDelimUnd = edit(inline$1.emStrong.rDelimUnd, 'g').replace(/punct/g, inline$1._punctuation).getRegex();\n  inline$1._escapes = /\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/g;\n  inline$1._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;\n  inline$1._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;\n  inline$1.autolink = edit(inline$1.autolink).replace('scheme', inline$1._scheme).replace('email', inline$1._email).getRegex();\n  inline$1._attribute = /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/;\n  inline$1.tag = edit(inline$1.tag).replace('comment', inline$1._comment).replace('attribute', inline$1._attribute).getRegex();\n  inline$1._label = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\n  inline$1._href = /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/;\n  inline$1._title = /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/;\n  inline$1.link = edit(inline$1.link).replace('label', inline$1._label).replace('href', inline$1._href).replace('title', inline$1._title).getRegex();\n  inline$1.reflink = edit(inline$1.reflink).replace('label', inline$1._label).getRegex();\n  inline$1.reflinkSearch = edit(inline$1.reflinkSearch, 'g').replace('reflink', inline$1.reflink).replace('nolink', inline$1.nolink).getRegex();\n  /**\n   * Normal Inline Grammar\n   */\n\n  inline$1.normal = merge$1({}, inline$1);\n  /**\n   * Pedantic Inline Grammar\n   */\n\n  inline$1.pedantic = merge$1({}, inline$1.normal, {\n    strong: {\n      start: /^__|\\*\\*/,\n      middle: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\n      endAst: /\\*\\*(?!\\*)/g,\n      endUnd: /__(?!_)/g\n    },\n    em: {\n      start: /^_|\\*/,\n      middle: /^()\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)|^_(?=\\S)([\\s\\S]*?\\S)_(?!_)/,\n      endAst: /\\*(?!\\*)/g,\n      endUnd: /_(?!_)/g\n    },\n    link: edit(/^!?\\[(label)\\]\\((.*?)\\)/).replace('label', inline$1._label).getRegex(),\n    reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/).replace('label', inline$1._label).getRegex()\n  });\n  /**\n   * GFM Inline Grammar\n   */\n\n  inline$1.gfm = merge$1({}, inline$1.normal, {\n    escape: edit(inline$1.escape).replace('])', '~|])').getRegex(),\n    _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,\n    url: /^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/,\n    _backpedal: /(?:[^?!.,:;*_~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,\n    del: /^(~~?)(?=[^\\s~])([\\s\\S]*?[^\\s~])\\1(?=[^~]|$)/,\n    text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/\n  });\n  inline$1.gfm.url = edit(inline$1.gfm.url, 'i').replace('email', inline$1.gfm._extended_email).getRegex();\n  /**\n   * GFM + Line Breaks Inline Grammar\n   */\n\n  inline$1.breaks = merge$1({}, inline$1.gfm, {\n    br: edit(inline$1.br).replace('{2,}', '*').getRegex(),\n    text: edit(inline$1.gfm.text).replace('\\\\b_', '\\\\b_| {2,}\\\\n').replace(/\\{2,\\}/g, '*').getRegex()\n  });\n  var rules = {\n    block: block$1,\n    inline: inline$1\n  };\n\n  var Tokenizer$1 = Tokenizer_1;\n  var defaults$3 = defaults$5.exports.defaults;\n  var block = rules.block,\n    inline = rules.inline;\n  var repeatString = helpers.repeatString;\n  /**\n   * smartypants text replacement\n   */\n\n  function smartypants(text) {\n    return text // em-dashes\n      .replace(/---/g, \"\\u2014\") // en-dashes\n      .replace(/--/g, \"\\u2013\") // opening singles\n      .replace(/(^|[-\\u2014/(\\[{\"\\s])'/g, \"$1\\u2018\") // closing singles & apostrophes\n      .replace(/'/g, \"\\u2019\") // opening doubles\n      .replace(/(^|[-\\u2014/(\\[{\\u2018\\s])\"/g, \"$1\\u201C\") // closing doubles\n      .replace(/\"/g, \"\\u201D\") // ellipses\n      .replace(/\\.{3}/g, \"\\u2026\");\n  }\n  /**\n   * mangle email addresses\n   */\n\n\n  function mangle(text) {\n    var out = '',\n      i,\n      ch;\n    var l = text.length;\n\n    for (i = 0; i < l; i++) {\n      ch = text.charCodeAt(i);\n\n      if (Math.random() > 0.5) {\n        ch = 'x' + ch.toString(16);\n      }\n\n      out += '&#' + ch + ';';\n    }\n\n    return out;\n  }\n  /**\n   * Block Lexer\n   */\n\n\n  var Lexer_1 = /*#__PURE__*/function () {\n    function Lexer(options) {\n      this.tokens = [];\n      this.tokens.links = Object.create(null);\n      this.options = options || defaults$3;\n      this.options.tokenizer = this.options.tokenizer || new Tokenizer$1();\n      this.tokenizer = this.options.tokenizer;\n      this.tokenizer.options = this.options;\n      this.tokenizer.lexer = this;\n      this.inlineQueue = [];\n      this.state = {\n        inLink: false,\n        inRawBlock: false,\n        top: true\n      };\n      var rules = {\n        block: block.normal,\n        inline: inline.normal\n      };\n\n      if (this.options.pedantic) {\n        rules.block = block.pedantic;\n        rules.inline = inline.pedantic;\n      } else if (this.options.gfm) {\n        rules.block = block.gfm;\n\n        if (this.options.breaks) {\n          rules.inline = inline.breaks;\n        } else {\n          rules.inline = inline.gfm;\n        }\n      }\n\n      this.tokenizer.rules = rules;\n    }\n    /**\n     * Expose Rules\n     */\n\n\n    /**\n     * Static Lex Method\n     */\n    Lexer.lex = function lex(src, options) {\n      var lexer = new Lexer(options);\n      return lexer.lex(src);\n    }\n      /**\n       * Static Lex Inline Method\n       */\n      ;\n\n    Lexer.lexInline = function lexInline(src, options) {\n      var lexer = new Lexer(options);\n      return lexer.inlineTokens(src);\n    }\n      /**\n       * Preprocessing\n       */\n      ;\n\n    var _proto = Lexer.prototype;\n\n    _proto.lex = function lex(src) {\n      src = src.replace(/\\r\\n|\\r/g, '\\n').replace(/\\t/g, '    ');\n      this.blockTokens(src, this.tokens);\n      var next;\n\n      while (next = this.inlineQueue.shift()) {\n        this.inlineTokens(next.src, next.tokens);\n      }\n\n      return this.tokens;\n    }\n      /**\n       * Lexing\n       */\n      ;\n\n    _proto.blockTokens = function blockTokens(src, tokens) {\n      var _this = this;\n\n      if (tokens === void 0) {\n        tokens = [];\n      }\n\n      if (this.options.pedantic) {\n        src = src.replace(/^ +$/gm, '');\n      }\n\n      var token, lastToken, cutSrc, lastParagraphClipped;\n\n      while (src) {\n        if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some(function (extTokenizer) {\n          if (token = extTokenizer.call({\n            lexer: _this\n          }, src, tokens)) {\n            src = src.substring(token.raw.length);\n            tokens.push(token);\n            return true;\n          }\n\n          return false;\n        })) {\n          continue;\n        } // newline\n\n\n        if (token = this.tokenizer.space(src)) {\n          src = src.substring(token.raw.length);\n\n          if (token.type) {\n            tokens.push(token);\n          }\n\n          continue;\n        } // code\n\n\n        if (token = this.tokenizer.code(src)) {\n          src = src.substring(token.raw.length);\n          lastToken = tokens[tokens.length - 1]; // An indented code block cannot interrupt a paragraph.\n\n          if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n            lastToken.raw += '\\n' + token.raw;\n            lastToken.text += '\\n' + token.text;\n            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n          } else {\n            tokens.push(token);\n          }\n\n          continue;\n        } // fences\n\n\n        if (token = this.tokenizer.fences(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // heading\n\n\n        if (token = this.tokenizer.heading(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // hr\n\n\n        if (token = this.tokenizer.hr(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // blockquote\n\n\n        if (token = this.tokenizer.blockquote(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // list\n\n\n        if (token = this.tokenizer.list(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // html\n\n\n        if (token = this.tokenizer.html(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // def\n\n\n        if (token = this.tokenizer.def(src)) {\n          src = src.substring(token.raw.length);\n          lastToken = tokens[tokens.length - 1];\n\n          if (lastToken && (lastToken.type === 'paragraph' || lastToken.type === 'text')) {\n            lastToken.raw += '\\n' + token.raw;\n            lastToken.text += '\\n' + token.raw;\n            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n          } else if (!this.tokens.links[token.tag]) {\n            this.tokens.links[token.tag] = {\n              href: token.href,\n              title: token.title\n            };\n          }\n\n          continue;\n        } // table (gfm)\n\n\n        if (token = this.tokenizer.table(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // lheading\n\n\n        if (token = this.tokenizer.lheading(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // top-level paragraph\n        // prevent paragraph consuming extensions by clipping 'src' to extension start\n\n\n        cutSrc = src;\n\n        if (this.options.extensions && this.options.extensions.startBlock) {\n          (function () {\n            var startIndex = Infinity;\n            var tempSrc = src.slice(1);\n            var tempStart = void 0;\n\n            _this.options.extensions.startBlock.forEach(function (getStartIndex) {\n              tempStart = getStartIndex.call({\n                lexer: this\n              }, tempSrc);\n\n              if (typeof tempStart === 'number' && tempStart >= 0) {\n                startIndex = Math.min(startIndex, tempStart);\n              }\n            });\n\n            if (startIndex < Infinity && startIndex >= 0) {\n              cutSrc = src.substring(0, startIndex + 1);\n            }\n          })();\n        }\n\n        if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n          lastToken = tokens[tokens.length - 1];\n\n          if (lastParagraphClipped && lastToken.type === 'paragraph') {\n            lastToken.raw += '\\n' + token.raw;\n            lastToken.text += '\\n' + token.text;\n            this.inlineQueue.pop();\n            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n          } else {\n            tokens.push(token);\n          }\n\n          lastParagraphClipped = cutSrc.length !== src.length;\n          src = src.substring(token.raw.length);\n          continue;\n        } // text\n\n\n        if (token = this.tokenizer.text(src)) {\n          src = src.substring(token.raw.length);\n          lastToken = tokens[tokens.length - 1];\n\n          if (lastToken && lastToken.type === 'text') {\n            lastToken.raw += '\\n' + token.raw;\n            lastToken.text += '\\n' + token.text;\n            this.inlineQueue.pop();\n            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n          } else {\n            tokens.push(token);\n          }\n\n          continue;\n        }\n\n        if (src) {\n          var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n\n          if (this.options.silent) {\n            console.error(errMsg);\n            break;\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n\n      this.state.top = true;\n      return tokens;\n    };\n\n    _proto.inline = function inline(src, tokens) {\n      this.inlineQueue.push({\n        src: src,\n        tokens: tokens\n      });\n    }\n      /**\n       * Lexing/Compiling\n       */\n      ;\n\n    _proto.inlineTokens = function inlineTokens(src, tokens) {\n      var _this2 = this;\n\n      if (tokens === void 0) {\n        tokens = [];\n      }\n\n      var token, lastToken, cutSrc; // String with links masked to avoid interference with em and strong\n\n      var maskedSrc = src;\n      var match;\n      var keepPrevChar, prevChar; // Mask out reflinks\n\n      if (this.tokens.links) {\n        var links = Object.keys(this.tokens.links);\n\n        if (links.length > 0) {\n          while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n            if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n              maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n            }\n          }\n        }\n      } // Mask out other blocks\n\n\n      while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n        maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n      } // Mask out escaped em & strong delimiters\n\n\n      while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {\n        maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);\n      }\n\n      while (src) {\n        if (!keepPrevChar) {\n          prevChar = '';\n        }\n\n        keepPrevChar = false; // extensions\n\n        if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some(function (extTokenizer) {\n          if (token = extTokenizer.call({\n            lexer: _this2\n          }, src, tokens)) {\n            src = src.substring(token.raw.length);\n            tokens.push(token);\n            return true;\n          }\n\n          return false;\n        })) {\n          continue;\n        } // escape\n\n\n        if (token = this.tokenizer.escape(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // tag\n\n\n        if (token = this.tokenizer.tag(src)) {\n          src = src.substring(token.raw.length);\n          lastToken = tokens[tokens.length - 1];\n\n          if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n            lastToken.raw += token.raw;\n            lastToken.text += token.text;\n          } else {\n            tokens.push(token);\n          }\n\n          continue;\n        } // link\n\n\n        if (token = this.tokenizer.link(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // reflink, nolink\n\n\n        if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n          src = src.substring(token.raw.length);\n          lastToken = tokens[tokens.length - 1];\n\n          if (lastToken && token.type === 'text' && lastToken.type === 'text') {\n            lastToken.raw += token.raw;\n            lastToken.text += token.text;\n          } else {\n            tokens.push(token);\n          }\n\n          continue;\n        } // em & strong\n\n\n        if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // code\n\n\n        if (token = this.tokenizer.codespan(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // br\n\n\n        if (token = this.tokenizer.br(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // del (gfm)\n\n\n        if (token = this.tokenizer.del(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // autolink\n\n\n        if (token = this.tokenizer.autolink(src, mangle)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // url (gfm)\n\n\n        if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // text\n        // prevent inlineText consuming extensions by clipping 'src' to extension start\n\n\n        cutSrc = src;\n\n        if (this.options.extensions && this.options.extensions.startInline) {\n          (function () {\n            var startIndex = Infinity;\n            var tempSrc = src.slice(1);\n            var tempStart = void 0;\n\n            _this2.options.extensions.startInline.forEach(function (getStartIndex) {\n              tempStart = getStartIndex.call({\n                lexer: this\n              }, tempSrc);\n\n              if (typeof tempStart === 'number' && tempStart >= 0) {\n                startIndex = Math.min(startIndex, tempStart);\n              }\n            });\n\n            if (startIndex < Infinity && startIndex >= 0) {\n              cutSrc = src.substring(0, startIndex + 1);\n            }\n          })();\n        }\n\n        if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {\n          src = src.substring(token.raw.length);\n\n          if (token.raw.slice(-1) !== '_') {\n            // Track prevChar before string of ____ started\n            prevChar = token.raw.slice(-1);\n          }\n\n          keepPrevChar = true;\n          lastToken = tokens[tokens.length - 1];\n\n          if (lastToken && lastToken.type === 'text') {\n            lastToken.raw += token.raw;\n            lastToken.text += token.text;\n          } else {\n            tokens.push(token);\n          }\n\n          continue;\n        }\n\n        if (src) {\n          var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n\n          if (this.options.silent) {\n            console.error(errMsg);\n            break;\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n\n      return tokens;\n    };\n\n    _createClass(Lexer, null, [{\n      key: \"rules\",\n      get: function get() {\n        return {\n          block: block,\n          inline: inline\n        };\n      }\n    }]);\n\n    return Lexer;\n  }();\n\n  var defaults$2 = defaults$5.exports.defaults;\n  var cleanUrl = helpers.cleanUrl,\n    escape$1 = helpers.escape;\n  /**\n   * Renderer\n   */\n\n  var Renderer_1 = /*#__PURE__*/function () {\n    function Renderer(options) {\n      this.options = options || defaults$2;\n    }\n\n    var _proto = Renderer.prototype;\n\n    _proto.code = function code(_code, infostring, escaped) {\n      var lang = (infostring || '').match(/\\S*/)[0];\n\n      if (this.options.highlight) {\n        var out = this.options.highlight(_code, lang);\n\n        if (out != null && out !== _code) {\n          escaped = true;\n          _code = out;\n        }\n      }\n\n      _code = _code.replace(/\\n$/, '') + '\\n';\n\n      if (!lang) {\n        return '<pre><code>' + (escaped ? _code : escape$1(_code, true)) + '</code></pre>\\n';\n      }\n\n      return '<pre><code class=\"' + this.options.langPrefix + escape$1(lang, true) + '\">' + (escaped ? _code : escape$1(_code, true)) + '</code></pre>\\n';\n    };\n\n    _proto.blockquote = function blockquote(quote) {\n      return '<blockquote>\\n' + quote + '</blockquote>\\n';\n    };\n\n    _proto.html = function html(_html) {\n      return _html;\n    };\n\n    _proto.heading = function heading(text, level, raw, slugger) {\n      if (this.options.headerIds) {\n        return '<h' + level + ' id=\"' + this.options.headerPrefix + slugger.slug(raw) + '\">' + text + '</h' + level + '>\\n';\n      } // ignore IDs\n\n\n      return '<h' + level + '>' + text + '</h' + level + '>\\n';\n    };\n\n    _proto.hr = function hr() {\n      return this.options.xhtml ? '<hr/>\\n' : '<hr>\\n';\n    };\n\n    _proto.list = function list(body, ordered, start) {\n      var type = ordered ? 'ol' : 'ul',\n        startatt = ordered && start !== 1 ? ' start=\"' + start + '\"' : '';\n      return '<' + type + startatt + '>\\n' + body + '</' + type + '>\\n';\n    };\n\n    _proto.listitem = function listitem(text) {\n      return '<li>' + text + '</li>\\n';\n    };\n\n    _proto.checkbox = function checkbox(checked) {\n      return '<input ' + (checked ? 'checked=\"\" ' : '') + 'disabled=\"\" type=\"checkbox\"' + (this.options.xhtml ? ' /' : '') + '> ';\n    };\n\n    _proto.paragraph = function paragraph(text) {\n      return '<p>' + text + '</p>\\n';\n    };\n\n    _proto.table = function table(header, body) {\n      if (body) body = '<tbody>' + body + '</tbody>';\n      return '<table>\\n' + '<thead>\\n' + header + '</thead>\\n' + body + '</table>\\n';\n    };\n\n    _proto.tablerow = function tablerow(content) {\n      return '<tr>\\n' + content + '</tr>\\n';\n    };\n\n    _proto.tablecell = function tablecell(content, flags) {\n      var type = flags.header ? 'th' : 'td';\n      var tag = flags.align ? '<' + type + ' align=\"' + flags.align + '\">' : '<' + type + '>';\n      return tag + content + '</' + type + '>\\n';\n    } // span level renderer\n      ;\n\n    _proto.strong = function strong(text) {\n      return '<strong>' + text + '</strong>';\n    };\n\n    _proto.em = function em(text) {\n      return '<em>' + text + '</em>';\n    };\n\n    _proto.codespan = function codespan(text) {\n      return '<code>' + text + '</code>';\n    };\n\n    _proto.br = function br() {\n      return this.options.xhtml ? '<br/>' : '<br>';\n    };\n\n    _proto.del = function del(text) {\n      return '<del>' + text + '</del>';\n    };\n\n    _proto.link = function link(href, title, text) {\n      href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n\n      if (href === null) {\n        return text;\n      }\n\n      var out = '<a href=\"' + escape$1(href) + '\"';\n\n      if (title) {\n        out += ' title=\"' + title + '\"';\n      }\n\n      out += '>' + text + '</a>';\n      return out;\n    };\n\n    _proto.image = function image(href, title, text) {\n      href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n\n      if (href === null) {\n        return text;\n      }\n\n      var out = '<img src=\"' + href + '\" alt=\"' + text + '\"';\n\n      if (title) {\n        out += ' title=\"' + title + '\"';\n      }\n\n      out += this.options.xhtml ? '/>' : '>';\n      return out;\n    };\n\n    _proto.text = function text(_text) {\n      return _text;\n    };\n\n    return Renderer;\n  }();\n\n  /**\n   * TextRenderer\n   * returns only the textual part of the token\n   */\n\n  var TextRenderer_1 = /*#__PURE__*/function () {\n    function TextRenderer() { }\n\n    var _proto = TextRenderer.prototype;\n\n    // no need for block level renderers\n    _proto.strong = function strong(text) {\n      return text;\n    };\n\n    _proto.em = function em(text) {\n      return text;\n    };\n\n    _proto.codespan = function codespan(text) {\n      return text;\n    };\n\n    _proto.del = function del(text) {\n      return text;\n    };\n\n    _proto.html = function html(text) {\n      return text;\n    };\n\n    _proto.text = function text(_text) {\n      return _text;\n    };\n\n    _proto.link = function link(href, title, text) {\n      return '' + text;\n    };\n\n    _proto.image = function image(href, title, text) {\n      return '' + text;\n    };\n\n    _proto.br = function br() {\n      return '';\n    };\n\n    return TextRenderer;\n  }();\n\n  /**\n   * Slugger generates header id\n   */\n\n  var Slugger_1 = /*#__PURE__*/function () {\n    function Slugger() {\n      this.seen = {};\n    }\n\n    var _proto = Slugger.prototype;\n\n    _proto.serialize = function serialize(value) {\n      return value.toLowerCase().trim() // remove html tags\n        .replace(/<[!\\/a-z].*?>/ig, '') // remove unwanted chars\n        .replace(/[\\u2000-\\u206F\\u2E00-\\u2E7F\\\\'!\"#$%&()*+,./:;<=>?@[\\]^`{|}~]/g, '').replace(/\\s/g, '-');\n    }\n      /**\n       * Finds the next safe (unique) slug to use\n       */\n      ;\n\n    _proto.getNextSafeSlug = function getNextSafeSlug(originalSlug, isDryRun) {\n      var slug = originalSlug;\n      var occurenceAccumulator = 0;\n\n      if (this.seen.hasOwnProperty(slug)) {\n        occurenceAccumulator = this.seen[originalSlug];\n\n        do {\n          occurenceAccumulator++;\n          slug = originalSlug + '-' + occurenceAccumulator;\n        } while (this.seen.hasOwnProperty(slug));\n      }\n\n      if (!isDryRun) {\n        this.seen[originalSlug] = occurenceAccumulator;\n        this.seen[slug] = 0;\n      }\n\n      return slug;\n    }\n      /**\n       * Convert string to unique id\n       * @param {object} options\n       * @param {boolean} options.dryrun Generates the next unique slug without updating the internal accumulator.\n       */\n      ;\n\n    _proto.slug = function slug(value, options) {\n      if (options === void 0) {\n        options = {};\n      }\n\n      var slug = this.serialize(value);\n      return this.getNextSafeSlug(slug, options.dryrun);\n    };\n\n    return Slugger;\n  }();\n\n  var Renderer$1 = Renderer_1;\n  var TextRenderer$1 = TextRenderer_1;\n  var Slugger$1 = Slugger_1;\n  var defaults$1 = defaults$5.exports.defaults;\n  var unescape = helpers.unescape;\n  /**\n   * Parsing & Compiling\n   */\n\n  var Parser_1 = /*#__PURE__*/function () {\n    function Parser(options) {\n      this.options = options || defaults$1;\n      this.options.renderer = this.options.renderer || new Renderer$1();\n      this.renderer = this.options.renderer;\n      this.renderer.options = this.options;\n      this.textRenderer = new TextRenderer$1();\n      this.slugger = new Slugger$1();\n    }\n    /**\n     * Static Parse Method\n     */\n\n\n    Parser.parse = function parse(tokens, options) {\n      var parser = new Parser(options);\n      return parser.parse(tokens);\n    }\n      /**\n       * Static Parse Inline Method\n       */\n      ;\n\n    Parser.parseInline = function parseInline(tokens, options) {\n      var parser = new Parser(options);\n      return parser.parseInline(tokens);\n    }\n      /**\n       * Parse Loop\n       */\n      ;\n\n    var _proto = Parser.prototype;\n\n    _proto.parse = function parse(tokens, top) {\n      if (top === void 0) {\n        top = true;\n      }\n\n      var out = '',\n        i,\n        j,\n        k,\n        l2,\n        l3,\n        row,\n        cell,\n        header,\n        body,\n        token,\n        ordered,\n        start,\n        loose,\n        itemBody,\n        item,\n        checked,\n        task,\n        checkbox,\n        ret;\n      var l = tokens.length;\n\n      for (i = 0; i < l; i++) {\n        token = tokens[i]; // Run any renderer extensions\n\n        if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n          ret = this.options.extensions.renderers[token.type].call({\n            parser: this\n          }, token);\n\n          if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(token.type)) {\n            out += ret || '';\n            continue;\n          }\n        }\n\n        switch (token.type) {\n          case 'space':\n            {\n              continue;\n            }\n\n          case 'hr':\n            {\n              out += this.renderer.hr();\n              continue;\n            }\n\n          case 'heading':\n            {\n              out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape(this.parseInline(token.tokens, this.textRenderer)), this.slugger);\n              continue;\n            }\n\n          case 'code':\n            {\n              out += this.renderer.code(token.text, token.lang, token.escaped);\n              continue;\n            }\n\n          case 'table':\n            {\n              header = ''; // header\n\n              cell = '';\n              l2 = token.header.length;\n\n              for (j = 0; j < l2; j++) {\n                cell += this.renderer.tablecell(this.parseInline(token.header[j].tokens), {\n                  header: true,\n                  align: token.align[j]\n                });\n              }\n\n              header += this.renderer.tablerow(cell);\n              body = '';\n              l2 = token.rows.length;\n\n              for (j = 0; j < l2; j++) {\n                row = token.rows[j];\n                cell = '';\n                l3 = row.length;\n\n                for (k = 0; k < l3; k++) {\n                  cell += this.renderer.tablecell(this.parseInline(row[k].tokens), {\n                    header: false,\n                    align: token.align[k]\n                  });\n                }\n\n                body += this.renderer.tablerow(cell);\n              }\n\n              out += this.renderer.table(header, body);\n              continue;\n            }\n\n          case 'blockquote':\n            {\n              body = this.parse(token.tokens);\n              out += this.renderer.blockquote(body);\n              continue;\n            }\n\n          case 'list':\n            {\n              ordered = token.ordered;\n              start = token.start;\n              loose = token.loose;\n              l2 = token.items.length;\n              body = '';\n\n              for (j = 0; j < l2; j++) {\n                item = token.items[j];\n                checked = item.checked;\n                task = item.task;\n                itemBody = '';\n\n                if (item.task) {\n                  checkbox = this.renderer.checkbox(checked);\n\n                  if (loose) {\n                    if (item.tokens.length > 0 && item.tokens[0].type === 'paragraph') {\n                      item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;\n\n                      if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {\n                        item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;\n                      }\n                    } else {\n                      item.tokens.unshift({\n                        type: 'text',\n                        text: checkbox\n                      });\n                    }\n                  } else {\n                    itemBody += checkbox;\n                  }\n                }\n\n                itemBody += this.parse(item.tokens, loose);\n                body += this.renderer.listitem(itemBody, task, checked);\n              }\n\n              out += this.renderer.list(body, ordered, start);\n              continue;\n            }\n\n          case 'html':\n            {\n              // TODO parse inline content if parameter markdown=1\n              out += this.renderer.html(token.text);\n              continue;\n            }\n\n          case 'paragraph':\n            {\n              out += this.renderer.paragraph(this.parseInline(token.tokens));\n              continue;\n            }\n\n          case 'text':\n            {\n              body = token.tokens ? this.parseInline(token.tokens) : token.text;\n\n              while (i + 1 < l && tokens[i + 1].type === 'text') {\n                token = tokens[++i];\n                body += '\\n' + (token.tokens ? this.parseInline(token.tokens) : token.text);\n              }\n\n              out += top ? this.renderer.paragraph(body) : body;\n              continue;\n            }\n\n          default:\n            {\n              var errMsg = 'Token with \"' + token.type + '\" type was not found.';\n\n              if (this.options.silent) {\n                console.error(errMsg);\n                return;\n              } else {\n                throw new Error(errMsg);\n              }\n            }\n        }\n      }\n\n      return out;\n    }\n      /**\n       * Parse Inline Tokens\n       */\n      ;\n\n    _proto.parseInline = function parseInline(tokens, renderer) {\n      renderer = renderer || this.renderer;\n      var out = '',\n        i,\n        token,\n        ret;\n      var l = tokens.length;\n\n      for (i = 0; i < l; i++) {\n        token = tokens[i]; // Run any renderer extensions\n\n        if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n          ret = this.options.extensions.renderers[token.type].call({\n            parser: this\n          }, token);\n\n          if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(token.type)) {\n            out += ret || '';\n            continue;\n          }\n        }\n\n        switch (token.type) {\n          case 'escape':\n            {\n              out += renderer.text(token.text);\n              break;\n            }\n\n          case 'html':\n            {\n              out += renderer.html(token.text);\n              break;\n            }\n\n          case 'link':\n            {\n              out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));\n              break;\n            }\n\n          case 'image':\n            {\n              out += renderer.image(token.href, token.title, token.text);\n              break;\n            }\n\n          case 'strong':\n            {\n              out += renderer.strong(this.parseInline(token.tokens, renderer));\n              break;\n            }\n\n          case 'em':\n            {\n              out += renderer.em(this.parseInline(token.tokens, renderer));\n              break;\n            }\n\n          case 'codespan':\n            {\n              out += renderer.codespan(token.text);\n              break;\n            }\n\n          case 'br':\n            {\n              out += renderer.br();\n              break;\n            }\n\n          case 'del':\n            {\n              out += renderer.del(this.parseInline(token.tokens, renderer));\n              break;\n            }\n\n          case 'text':\n            {\n              out += renderer.text(token.text);\n              break;\n            }\n\n          default:\n            {\n              var errMsg = 'Token with \"' + token.type + '\" type was not found.';\n\n              if (this.options.silent) {\n                console.error(errMsg);\n                return;\n              } else {\n                throw new Error(errMsg);\n              }\n            }\n        }\n      }\n\n      return out;\n    };\n\n    return Parser;\n  }();\n\n  var Lexer = Lexer_1;\n  var Parser = Parser_1;\n  var Tokenizer = Tokenizer_1;\n  var Renderer = Renderer_1;\n  var TextRenderer = TextRenderer_1;\n  var Slugger = Slugger_1;\n  var merge = helpers.merge,\n    checkSanitizeDeprecation = helpers.checkSanitizeDeprecation,\n    escape = helpers.escape;\n  var getDefaults = defaults$5.exports.getDefaults,\n    changeDefaults = defaults$5.exports.changeDefaults,\n    defaults = defaults$5.exports.defaults;\n  /**\n   * Marked\n   */\n\n  function marked(src, opt, callback) {\n    // throw error in case of non string input\n    if (typeof src === 'undefined' || src === null) {\n      throw new Error('marked(): input parameter is undefined or null');\n    }\n\n    if (typeof src !== 'string') {\n      throw new Error('marked(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');\n    }\n\n    if (typeof opt === 'function') {\n      callback = opt;\n      opt = null;\n    }\n\n    opt = merge({}, marked.defaults, opt || {});\n    checkSanitizeDeprecation(opt);\n\n    if (callback) {\n      var highlight = opt.highlight;\n      var tokens;\n\n      try {\n        tokens = Lexer.lex(src, opt);\n      } catch (e) {\n        return callback(e);\n      }\n\n      var done = function done(err) {\n        var out;\n\n        if (!err) {\n          try {\n            if (opt.walkTokens) {\n              marked.walkTokens(tokens, opt.walkTokens);\n            }\n\n            out = Parser.parse(tokens, opt);\n          } catch (e) {\n            err = e;\n          }\n        }\n\n        opt.highlight = highlight;\n        return err ? callback(err) : callback(null, out);\n      };\n\n      if (!highlight || highlight.length < 3) {\n        return done();\n      }\n\n      delete opt.highlight;\n      if (!tokens.length) return done();\n      var pending = 0;\n      marked.walkTokens(tokens, function (token) {\n        if (token.type === 'code') {\n          pending++;\n          setTimeout(function () {\n            highlight(token.text, token.lang, function (err, code) {\n              if (err) {\n                return done(err);\n              }\n\n              if (code != null && code !== token.text) {\n                token.text = code;\n                token.escaped = true;\n              }\n\n              pending--;\n\n              if (pending === 0) {\n                done();\n              }\n            });\n          }, 0);\n        }\n      });\n\n      if (pending === 0) {\n        done();\n      }\n\n      return;\n    }\n\n    try {\n      var _tokens = Lexer.lex(src, opt);\n\n      if (opt.walkTokens) {\n        marked.walkTokens(_tokens, opt.walkTokens);\n      }\n\n      return Parser.parse(_tokens, opt);\n    } catch (e) {\n      e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n\n      if (opt.silent) {\n        return '<p>An error occurred:</p><pre>' + escape(e.message + '', true) + '</pre>';\n      }\n\n      throw e;\n    }\n  }\n  /**\n   * Options\n   */\n\n\n  marked.options = marked.setOptions = function (opt) {\n    merge(marked.defaults, opt);\n    changeDefaults(marked.defaults);\n    return marked;\n  };\n\n  marked.getDefaults = getDefaults;\n  marked.defaults = defaults;\n  /**\n   * Use Extension\n   */\n\n  marked.use = function () {\n    var _this = this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var opts = merge.apply(void 0, [{}].concat(args));\n    var extensions = marked.defaults.extensions || {\n      renderers: {},\n      childTokens: {}\n    };\n    var hasExtensions;\n    args.forEach(function (pack) {\n      // ==-- Parse \"addon\" extensions --== //\n      if (pack.extensions) {\n        hasExtensions = true;\n        pack.extensions.forEach(function (ext) {\n          if (!ext.name) {\n            throw new Error('extension name required');\n          }\n\n          if (ext.renderer) {\n            // Renderer extensions\n            var prevRenderer = extensions.renderers ? extensions.renderers[ext.name] : null;\n\n            if (prevRenderer) {\n              // Replace extension with func to run new extension but fall back if false\n              extensions.renderers[ext.name] = function () {\n                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                  args[_key2] = arguments[_key2];\n                }\n\n                var ret = ext.renderer.apply(this, args);\n\n                if (ret === false) {\n                  ret = prevRenderer.apply(this, args);\n                }\n\n                return ret;\n              };\n            } else {\n              extensions.renderers[ext.name] = ext.renderer;\n            }\n          }\n\n          if (ext.tokenizer) {\n            // Tokenizer Extensions\n            if (!ext.level || ext.level !== 'block' && ext.level !== 'inline') {\n              throw new Error(\"extension level must be 'block' or 'inline'\");\n            }\n\n            if (extensions[ext.level]) {\n              extensions[ext.level].unshift(ext.tokenizer);\n            } else {\n              extensions[ext.level] = [ext.tokenizer];\n            }\n\n            if (ext.start) {\n              // Function to check for start of token\n              if (ext.level === 'block') {\n                if (extensions.startBlock) {\n                  extensions.startBlock.push(ext.start);\n                } else {\n                  extensions.startBlock = [ext.start];\n                }\n              } else if (ext.level === 'inline') {\n                if (extensions.startInline) {\n                  extensions.startInline.push(ext.start);\n                } else {\n                  extensions.startInline = [ext.start];\n                }\n              }\n            }\n          }\n\n          if (ext.childTokens) {\n            // Child tokens to be visited by walkTokens\n            extensions.childTokens[ext.name] = ext.childTokens;\n          }\n        });\n      } // ==-- Parse \"overwrite\" extensions --== //\n\n\n      if (pack.renderer) {\n        (function () {\n          var renderer = marked.defaults.renderer || new Renderer();\n\n          var _loop = function _loop(prop) {\n            var prevRenderer = renderer[prop]; // Replace renderer with func to run extension, but fall back if false\n\n            renderer[prop] = function () {\n              for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n                args[_key3] = arguments[_key3];\n              }\n\n              var ret = pack.renderer[prop].apply(renderer, args);\n\n              if (ret === false) {\n                ret = prevRenderer.apply(renderer, args);\n              }\n\n              return ret;\n            };\n          };\n\n          for (var prop in pack.renderer) {\n            _loop(prop);\n          }\n\n          opts.renderer = renderer;\n        })();\n      }\n\n      if (pack.tokenizer) {\n        (function () {\n          var tokenizer = marked.defaults.tokenizer || new Tokenizer();\n\n          var _loop2 = function _loop2(prop) {\n            var prevTokenizer = tokenizer[prop]; // Replace tokenizer with func to run extension, but fall back if false\n\n            tokenizer[prop] = function () {\n              for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n                args[_key4] = arguments[_key4];\n              }\n\n              var ret = pack.tokenizer[prop].apply(tokenizer, args);\n\n              if (ret === false) {\n                ret = prevTokenizer.apply(tokenizer, args);\n              }\n\n              return ret;\n            };\n          };\n\n          for (var prop in pack.tokenizer) {\n            _loop2(prop);\n          }\n\n          opts.tokenizer = tokenizer;\n        })();\n      } // ==-- Parse WalkTokens extensions --== //\n\n\n      if (pack.walkTokens) {\n        var walkTokens = marked.defaults.walkTokens;\n\n        opts.walkTokens = function (token) {\n          pack.walkTokens.call(_this, token);\n\n          if (walkTokens) {\n            walkTokens(token);\n          }\n        };\n      }\n\n      if (hasExtensions) {\n        opts.extensions = extensions;\n      }\n\n      marked.setOptions(opts);\n    });\n  };\n  /**\n   * Run callback for every token\n   */\n\n\n  marked.walkTokens = function (tokens, callback) {\n    var _loop3 = function _loop3() {\n      var token = _step.value;\n      callback(token);\n\n      switch (token.type) {\n        case 'table':\n          {\n            for (var _iterator2 = _createForOfIteratorHelperLoose(token.header), _step2; !(_step2 = _iterator2()).done;) {\n              var cell = _step2.value;\n              marked.walkTokens(cell.tokens, callback);\n            }\n\n            for (var _iterator3 = _createForOfIteratorHelperLoose(token.rows), _step3; !(_step3 = _iterator3()).done;) {\n              var row = _step3.value;\n\n              for (var _iterator4 = _createForOfIteratorHelperLoose(row), _step4; !(_step4 = _iterator4()).done;) {\n                var _cell = _step4.value;\n                marked.walkTokens(_cell.tokens, callback);\n              }\n            }\n\n            break;\n          }\n\n        case 'list':\n          {\n            marked.walkTokens(token.items, callback);\n            break;\n          }\n\n        default:\n          {\n            if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) {\n              // Walk any extensions\n              marked.defaults.extensions.childTokens[token.type].forEach(function (childTokens) {\n                marked.walkTokens(token[childTokens], callback);\n              });\n            } else if (token.tokens) {\n              marked.walkTokens(token.tokens, callback);\n            }\n          }\n      }\n    };\n\n    for (var _iterator = _createForOfIteratorHelperLoose(tokens), _step; !(_step = _iterator()).done;) {\n      _loop3();\n    }\n  };\n  /**\n   * Parse Inline\n   */\n\n\n  marked.parseInline = function (src, opt) {\n    // throw error in case of non string input\n    if (typeof src === 'undefined' || src === null) {\n      throw new Error('marked.parseInline(): input parameter is undefined or null');\n    }\n\n    if (typeof src !== 'string') {\n      throw new Error('marked.parseInline(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');\n    }\n\n    opt = merge({}, marked.defaults, opt || {});\n    checkSanitizeDeprecation(opt);\n\n    try {\n      var tokens = Lexer.lexInline(src, opt);\n\n      if (opt.walkTokens) {\n        marked.walkTokens(tokens, opt.walkTokens);\n      }\n\n      return Parser.parseInline(tokens, opt);\n    } catch (e) {\n      e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n\n      if (opt.silent) {\n        return '<p>An error occurred:</p><pre>' + escape(e.message + '', true) + '</pre>';\n      }\n\n      throw e;\n    }\n  };\n  /**\n   * Expose\n   */\n\n\n  marked.Parser = Parser;\n  marked.parser = Parser.parse;\n  marked.Renderer = Renderer;\n  marked.TextRenderer = TextRenderer;\n  marked.Lexer = Lexer;\n  marked.lexer = Lexer.lex;\n  marked.Tokenizer = Tokenizer;\n  marked.Slugger = Slugger;\n  marked.parse = marked;\n  var marked_1 = marked;\n\n  return marked_1;\n\n})));\n\n\n//# sourceURL=webpack:///./node_modules/monaco-editor/esm/vs/base/common/marked/marked.js?")},"./node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/lightBulbWidget.css":
/*!*****************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/lightBulbWidget.css ***!
  \*****************************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */function(module,exports,__webpack_require__){eval('var api = __webpack_require__(/*! ../../../../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");\n            var content = __webpack_require__(/*! !../../../../../../css-loader/dist/cjs.js!./lightBulbWidget.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/lightBulbWidget.css");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === \'string\') {\n              content = [[module.i, content, \'\']];\n            }\n\nvar options = {};\n\noptions.insert = "head";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nmodule.exports = content.locals || {};\n\n//# sourceURL=webpack:///./node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/lightBulbWidget.css?')},"./node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/colorPicker.css":
/*!**************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/colorPicker.css ***!
  \**************************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */function(module,exports,__webpack_require__){eval('var api = __webpack_require__(/*! ../../../../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");\n            var content = __webpack_require__(/*! !../../../../../../css-loader/dist/cjs.js!./colorPicker.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/colorPicker.css");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === \'string\') {\n              content = [[module.i, content, \'\']];\n            }\n\nvar options = {};\n\noptions.insert = "head";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nmodule.exports = content.locals || {};\n\n//# sourceURL=webpack:///./node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/colorPicker.css?')},"./node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/media/gotoErrorWidget.css":
/*!**********************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/media/gotoErrorWidget.css ***!
  \**********************************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */function(module,exports,__webpack_require__){eval('var api = __webpack_require__(/*! ../../../../../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");\n            var content = __webpack_require__(/*! !../../../../../../../css-loader/dist/cjs.js!./gotoErrorWidget.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/media/gotoErrorWidget.css");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === \'string\') {\n              content = [[module.i, content, \'\']];\n            }\n\nvar options = {};\n\noptions.insert = "head";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nmodule.exports = content.locals || {};\n\n//# sourceURL=webpack:///./node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/media/gotoErrorWidget.css?')},"./node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/link/goToDefinitionAtPosition.css":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/link/goToDefinitionAtPosition.css ***!
  \*******************************************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */function(module,exports,__webpack_require__){eval('var api = __webpack_require__(/*! ../../../../../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");\n            var content = __webpack_require__(/*! !../../../../../../../css-loader/dist/cjs.js!./goToDefinitionAtPosition.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/link/goToDefinitionAtPosition.css");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === \'string\') {\n              content = [[module.i, content, \'\']];\n            }\n\nvar options = {};\n\noptions.insert = "head";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nmodule.exports = content.locals || {};\n\n//# sourceURL=webpack:///./node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/link/goToDefinitionAtPosition.css?')},"./node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/peek/referencesWidget.css":
/*!***********************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/peek/referencesWidget.css ***!
  \***********************************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */function(module,exports,__webpack_require__){eval('var api = __webpack_require__(/*! ../../../../../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");\n            var content = __webpack_require__(/*! !../../../../../../../css-loader/dist/cjs.js!./referencesWidget.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/peek/referencesWidget.css");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === \'string\') {\n              content = [[module.i, content, \'\']];\n            }\n\nvar options = {};\n\noptions.insert = "head";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nmodule.exports = content.locals || {};\n\n//# sourceURL=webpack:///./node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/peek/referencesWidget.css?')},"./node_modules/monaco-editor/esm/vs/editor/contrib/hover/hover.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/contrib/hover/hover.js + 83 modules ***!
  \**************************************************************************************/
/*! exports provided: ModesHoverController */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/browser/browser.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/browser/dom.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/browser/event.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/browser/formattedTextRenderer.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/browser/globalMouseMoveMonitor.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/browser/keyboardEvent.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/browser/mouseEvent.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/browser/touch.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/browser/ui/actionbar/actionViewItems.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/browser/ui/actionbar/actionbar.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/browser/ui/aria/aria.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/browser/ui/codicons/codiconStyles.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/browser/ui/countBadge/countBadge.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/browser/ui/highlightedlabel/highlightedLabel.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/browser/ui/iconLabel/iconLabel.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/browser/ui/iconLabel/iconLabels.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/browser/ui/list/listWidget.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/browser/ui/sash/sash.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/scrollableElement.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/browser/ui/splitview/splitview.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/browser/ui/widget.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/common/actions.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/common/arrays.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/common/async.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/common/cancellation.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/common/codicons.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/common/color.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/common/diff/diff.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/common/errors.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/common/event.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/common/extpath.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/common/filters.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/common/hash.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/common/iconLabels.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/common/idGenerator.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/common/keyCodes.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/common/keybindingLabels.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/common/linkedList.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/common/map.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/common/marked/marked.js (<- Module is not an ECMAScript module) */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/common/marshalling.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/common/network.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/common/numbers.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/common/objects.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/common/path.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/common/platform.js (<- Module uses injected variables (global, process)) */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/common/resources.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/common/severity.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/common/stopwatch.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/common/strings.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/common/types.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/base/common/uri.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/editor/browser/config/configuration.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/editor/browser/controller/coreCommands.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/editor/browser/core/editorState.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/editor/browser/editorBrowser.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/editor/browser/editorExtensions.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/editor/browser/services/bulkEditService.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/editor/browser/services/codeEditorService.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/editor/browser/widget/codeEditorWidget.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/editor/common/config/editorOptions.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/editor/common/controller/cursorCommon.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/editor/common/core/editOperation.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/editor/common/core/lineTokens.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/editor/common/core/position.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/editor/common/core/range.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/editor/common/core/selection.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/editor/common/core/stringBuilder.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/editor/common/editorContextKeys.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/editor/common/model/textModel.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/editor/common/modes.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/editor/common/modes/languageConfigurationRegistry.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/editor/common/modes/modesRegistry.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/editor/common/modes/textToHtmlTokenizer.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/editor/common/services/editorWorkerService.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/editor/common/services/markersDecorationService.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/editor/common/services/modeService.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/editor/common/services/modelService.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/editor/common/services/resolverService.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/editor/common/view/editorColorRegistry.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/editor/common/viewLayout/lineDecorations.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLineRenderer.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/nls.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/platform/accessibility/common/accessibility.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/platform/actions/common/actions.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/platform/clipboard/common/clipboardService.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/platform/commands/common/commands.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/platform/configuration/common/configuration.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/platform/contextkey/common/contextkey.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/platform/contextview/browser/contextView.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/platform/instantiation/common/extensions.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/platform/instantiation/common/instantiation.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/platform/keybinding/common/keybinding.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/platform/keybinding/common/keybindingsRegistry.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/platform/label/common/label.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/platform/list/browser/listService.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/platform/log/common/log.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/platform/markers/common/markers.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/platform/notification/common/notification.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/platform/opener/common/opener.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/platform/progress/common/progress.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/platform/storage/common/storage.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/platform/telemetry/common/telemetry.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/platform/theme/common/colorRegistry.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/platform/theme/common/iconRegistry.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/platform/theme/common/styler.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/platform/theme/common/theme.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/platform/theme/common/themeService.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/platform/undoRedo/common/undoRedo.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/monaco-editor/esm/vs/platform/workspace/common/workspace.js */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, "ModesHoverController", function() { return /* binding */ hover_ModesHoverController; });\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/nls.js\nvar nls = __webpack_require__("./node_modules/monaco-editor/esm/vs/nls.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/common/keyCodes.js\nvar keyCodes = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/common/keyCodes.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js\nvar lifecycle = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/browser/editorExtensions.js\nvar editorExtensions = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/browser/editorExtensions.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/core/range.js\nvar core_range = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/common/core/range.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/editorContextKeys.js\nvar editorContextKeys = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/common/editorContextKeys.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/services/modeService.js\nvar services_modeService = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/common/services/modeService.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/browser/dom.js\nvar dom = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/browser/dom.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/core/position.js\nvar core_position = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/common/core/position.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/model/textModel.js + 18 modules\nvar model_textModel = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/common/model/textModel.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/modes.js + 3 modules\nvar modes = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/common/modes.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/common/async.js\nvar common_async = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/common/async.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/common/errors.js\nvar errors = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/common/errors.js");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/hover/hoverOperation.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\nclass hoverOperation_HoverOperation {\r\n    constructor(computer, success, error, progress, hoverTime) {\r\n        this._computer = computer;\r\n        this._state = 0 /* IDLE */;\r\n        this._hoverTime = hoverTime;\r\n        this._firstWaitScheduler = new common_async["RunOnceScheduler"](() => this._triggerAsyncComputation(), 0);\r\n        this._secondWaitScheduler = new common_async["RunOnceScheduler"](() => this._triggerSyncComputation(), 0);\r\n        this._loadingMessageScheduler = new common_async["RunOnceScheduler"](() => this._showLoadingMessage(), 0);\r\n        this._asyncComputationPromise = null;\r\n        this._asyncComputationPromiseDone = false;\r\n        this._completeCallback = success;\r\n        this._errorCallback = error;\r\n        this._progressCallback = progress;\r\n    }\r\n    setHoverTime(hoverTime) {\r\n        this._hoverTime = hoverTime;\r\n    }\r\n    _firstWaitTime() {\r\n        return this._hoverTime / 2;\r\n    }\r\n    _secondWaitTime() {\r\n        return this._hoverTime / 2;\r\n    }\r\n    _loadingMessageTime() {\r\n        return 3 * this._hoverTime;\r\n    }\r\n    _triggerAsyncComputation() {\r\n        this._state = 2 /* SECOND_WAIT */;\r\n        this._secondWaitScheduler.schedule(this._secondWaitTime());\r\n        if (this._computer.computeAsync) {\r\n            this._asyncComputationPromiseDone = false;\r\n            this._asyncComputationPromise = Object(common_async["createCancelablePromise"])(token => this._computer.computeAsync(token));\r\n            this._asyncComputationPromise.then((asyncResult) => {\r\n                this._asyncComputationPromiseDone = true;\r\n                this._withAsyncResult(asyncResult);\r\n            }, (e) => this._onError(e));\r\n        }\r\n        else {\r\n            this._asyncComputationPromiseDone = true;\r\n        }\r\n    }\r\n    _triggerSyncComputation() {\r\n        if (this._computer.computeSync) {\r\n            this._computer.onResult(this._computer.computeSync(), true);\r\n        }\r\n        if (this._asyncComputationPromiseDone) {\r\n            this._state = 0 /* IDLE */;\r\n            this._onComplete(this._computer.getResult());\r\n        }\r\n        else {\r\n            this._state = 3 /* WAITING_FOR_ASYNC_COMPUTATION */;\r\n            this._onProgress(this._computer.getResult());\r\n        }\r\n    }\r\n    _showLoadingMessage() {\r\n        if (this._state === 3 /* WAITING_FOR_ASYNC_COMPUTATION */) {\r\n            this._onProgress(this._computer.getResultWithLoadingMessage());\r\n        }\r\n    }\r\n    _withAsyncResult(asyncResult) {\r\n        if (asyncResult) {\r\n            this._computer.onResult(asyncResult, false);\r\n        }\r\n        if (this._state === 3 /* WAITING_FOR_ASYNC_COMPUTATION */) {\r\n            this._state = 0 /* IDLE */;\r\n            this._onComplete(this._computer.getResult());\r\n        }\r\n    }\r\n    _onComplete(value) {\r\n        this._completeCallback(value);\r\n    }\r\n    _onError(error) {\r\n        if (this._errorCallback) {\r\n            this._errorCallback(error);\r\n        }\r\n        else {\r\n            Object(errors["onUnexpectedError"])(error);\r\n        }\r\n    }\r\n    _onProgress(value) {\r\n        this._progressCallback(value);\r\n    }\r\n    start(mode) {\r\n        if (mode === 0 /* Delayed */) {\r\n            if (this._state === 0 /* IDLE */) {\r\n                this._state = 1 /* FIRST_WAIT */;\r\n                this._firstWaitScheduler.schedule(this._firstWaitTime());\r\n                this._loadingMessageScheduler.schedule(this._loadingMessageTime());\r\n            }\r\n        }\r\n        else {\r\n            switch (this._state) {\r\n                case 0 /* IDLE */:\r\n                    this._triggerAsyncComputation();\r\n                    this._secondWaitScheduler.cancel();\r\n                    this._triggerSyncComputation();\r\n                    break;\r\n                case 2 /* SECOND_WAIT */:\r\n                    this._secondWaitScheduler.cancel();\r\n                    this._triggerSyncComputation();\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n    cancel() {\r\n        this._loadingMessageScheduler.cancel();\r\n        if (this._state === 1 /* FIRST_WAIT */) {\r\n            this._firstWaitScheduler.cancel();\r\n        }\r\n        if (this._state === 2 /* SECOND_WAIT */) {\r\n            this._secondWaitScheduler.cancel();\r\n            if (this._asyncComputationPromise) {\r\n                this._asyncComputationPromise.cancel();\r\n                this._asyncComputationPromise = null;\r\n            }\r\n        }\r\n        if (this._state === 3 /* WAITING_FOR_ASYNC_COMPUTATION */) {\r\n            if (this._asyncComputationPromise) {\r\n                this._asyncComputationPromise.cancel();\r\n                this._asyncComputationPromise = null;\r\n            }\r\n        }\r\n        this._state = 0 /* IDLE */;\r\n    }\r\n}\r\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/common/arrays.js\nvar arrays = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/common/arrays.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/browser/ui/widget.js\nvar ui_widget = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/browser/ui/widget.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/scrollableElement.js + 6 modules\nvar scrollableElement = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/browser/ui/scrollbar/scrollableElement.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/browser/ui/hover/hover.css\nvar hover_hover = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/browser/ui/hover/hover.css");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/browser/ui/hover/hoverWidget.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\n\r\nconst hoverWidget_$ = dom["$"];\r\nclass hoverWidget_HoverWidget extends lifecycle["Disposable"] {\r\n    constructor() {\r\n        super();\r\n        this.containerDomNode = document.createElement(\'div\');\r\n        this.containerDomNode.className = \'monaco-hover\';\r\n        this.containerDomNode.tabIndex = 0;\r\n        this.containerDomNode.setAttribute(\'role\', \'tooltip\');\r\n        this.contentsDomNode = document.createElement(\'div\');\r\n        this.contentsDomNode.className = \'monaco-hover-content\';\r\n        this._scrollbar = this._register(new scrollableElement["DomScrollableElement"](this.contentsDomNode, {\r\n            consumeMouseWheelIfScrollbarIsNeeded: true\r\n        }));\r\n        this.containerDomNode.appendChild(this._scrollbar.getDomNode());\r\n    }\r\n    onContentsChanged() {\r\n        this._scrollbar.scanDomNode();\r\n    }\r\n}\r\nclass hoverWidget_HoverAction extends lifecycle["Disposable"] {\r\n    constructor(parent, actionOptions, keybindingLabel) {\r\n        super();\r\n        this.actionContainer = dom["append"](parent, hoverWidget_$(\'div.action-container\'));\r\n        this.action = dom["append"](this.actionContainer, hoverWidget_$(\'a.action\'));\r\n        this.action.setAttribute(\'href\', \'#\');\r\n        this.action.setAttribute(\'role\', \'button\');\r\n        if (actionOptions.iconClass) {\r\n            dom["append"](this.action, hoverWidget_$(`span.icon.${actionOptions.iconClass}`));\r\n        }\r\n        const label = dom["append"](this.action, hoverWidget_$(\'span\'));\r\n        label.textContent = keybindingLabel ? `${actionOptions.label} (${keybindingLabel})` : actionOptions.label;\r\n        this._register(dom["addDisposableListener"](this.actionContainer, dom["EventType"].CLICK, e => {\r\n            e.stopPropagation();\r\n            e.preventDefault();\r\n            actionOptions.run(this.actionContainer);\r\n        }));\r\n        this.setEnabled(true);\r\n    }\r\n    static render(parent, actionOptions, keybindingLabel) {\r\n        return new hoverWidget_HoverAction(parent, actionOptions, keybindingLabel);\r\n    }\r\n    setEnabled(enabled) {\r\n        if (enabled) {\r\n            this.actionContainer.classList.remove(\'disabled\');\r\n            this.actionContainer.removeAttribute(\'aria-disabled\');\r\n        }\r\n        else {\r\n            this.actionContainer.classList.add(\'disabled\');\r\n            this.actionContainer.setAttribute(\'aria-disabled\', \'true\');\r\n        }\r\n    }\r\n}\r\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/platform/markers/common/markers.js\nvar markers = __webpack_require__("./node_modules/monaco-editor/esm/vs/platform/markers/common/markers.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/common/resources.js\nvar common_resources = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/common/resources.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/services/markersDecorationService.js\nvar markersDecorationService = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/common/services/markersDecorationService.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/platform/opener/common/opener.js\nvar common_opener = __webpack_require__("./node_modules/monaco-editor/esm/vs/platform/opener/common/opener.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/platform/contextkey/common/contextkey.js\nvar contextkey = __webpack_require__("./node_modules/monaco-editor/esm/vs/platform/contextkey/common/contextkey.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/media/gotoErrorWidget.css\nvar gotoErrorWidget = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/media/gotoErrorWidget.css");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/platform/theme/common/colorRegistry.js\nvar colorRegistry = __webpack_require__("./node_modules/monaco-editor/esm/vs/platform/theme/common/colorRegistry.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/platform/theme/common/themeService.js\nvar common_themeService = __webpack_require__("./node_modules/monaco-editor/esm/vs/platform/theme/common/themeService.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/common/color.js\nvar common_color = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/common/color.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/common/extpath.js\nvar extpath = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/common/extpath.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/common/network.js\nvar network = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/common/network.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/common/platform.js\nvar platform = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/common/platform.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/common/uri.js\nvar common_uri = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/common/uri.js");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/labels.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\n\r\n\r\nfunction getBaseLabel(resource) {\r\n    if (!resource) {\r\n        return undefined;\r\n    }\r\n    if (typeof resource === \'string\') {\r\n        resource = common_uri["URI"].file(resource);\r\n    }\r\n    const base = Object(common_resources["basename"])(resource) || (resource.scheme === network["Schemas"].file ? resource.fsPath : resource.path) /* can be empty string if \'/\' is passed in */;\r\n    // convert c: => C:\r\n    if (platform["isWindows"] && Object(extpath["isRootOrDriveLetter"])(base)) {\r\n        return normalizeDriveLetter(base);\r\n    }\r\n    return base;\r\n}\r\nfunction normalizeDriveLetter(path) {\r\n    if (Object(extpath["hasDriveLetter"])(path)) {\r\n        return path.charAt(0).toUpperCase() + path.slice(1);\r\n    }\r\n    return path;\r\n}\r\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/common/event.js\nvar common_event = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/common/event.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/peekView/media/peekViewWidget.css\nvar peekViewWidget = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/contrib/peekView/media/peekViewWidget.css");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/browser/ui/actionbar/actionbar.js\nvar actionbar = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/browser/ui/actionbar/actionbar.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/common/actions.js\nvar common_actions = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/common/actions.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/common/objects.js\nvar objects = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/common/objects.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/browser/services/codeEditorService.js\nvar services_codeEditorService = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/browser/services/codeEditorService.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/browser/widget/codeEditorWidget.js + 60 modules\nvar codeEditorWidget = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/browser/widget/codeEditorWidget.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/platform/commands/common/commands.js\nvar common_commands = __webpack_require__("./node_modules/monaco-editor/esm/vs/platform/commands/common/commands.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/platform/instantiation/common/instantiation.js\nvar instantiation = __webpack_require__("./node_modules/monaco-editor/esm/vs/platform/instantiation/common/instantiation.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/platform/notification/common/notification.js\nvar notification = __webpack_require__("./node_modules/monaco-editor/esm/vs/platform/notification/common/notification.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/platform/accessibility/common/accessibility.js\nvar accessibility = __webpack_require__("./node_modules/monaco-editor/esm/vs/platform/accessibility/common/accessibility.js");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/browser/widget/embeddedCodeEditorWidget.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __param = (undefined && undefined.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nlet embeddedCodeEditorWidget_EmbeddedCodeEditorWidget = class EmbeddedCodeEditorWidget extends codeEditorWidget["CodeEditorWidget"] {\r\n    constructor(domElement, options, parentEditor, instantiationService, codeEditorService, commandService, contextKeyService, themeService, notificationService, accessibilityService) {\r\n        super(domElement, Object.assign(Object.assign({}, parentEditor.getRawOptions()), { overflowWidgetsDomNode: parentEditor.getOverflowWidgetsDomNode() }), {}, instantiationService, codeEditorService, commandService, contextKeyService, themeService, notificationService, accessibilityService);\r\n        this._parentEditor = parentEditor;\r\n        this._overwriteOptions = options;\r\n        // Overwrite parent\'s options\r\n        super.updateOptions(this._overwriteOptions);\r\n        this._register(parentEditor.onDidChangeConfiguration((e) => this._onParentConfigurationChanged(e)));\r\n    }\r\n    getParentEditor() {\r\n        return this._parentEditor;\r\n    }\r\n    _onParentConfigurationChanged(e) {\r\n        super.updateOptions(this._parentEditor.getRawOptions());\r\n        super.updateOptions(this._overwriteOptions);\r\n    }\r\n    updateOptions(newOptions) {\r\n        objects["mixin"](this._overwriteOptions, newOptions, true);\r\n        super.updateOptions(this._overwriteOptions);\r\n    }\r\n};\r\nembeddedCodeEditorWidget_EmbeddedCodeEditorWidget = __decorate([\r\n    __param(3, instantiation["IInstantiationService"]),\r\n    __param(4, services_codeEditorService["ICodeEditorService"]),\r\n    __param(5, common_commands["ICommandService"]),\r\n    __param(6, contextkey["IContextKeyService"]),\r\n    __param(7, common_themeService["IThemeService"]),\r\n    __param(8, notification["INotificationService"]),\r\n    __param(9, accessibility["IAccessibilityService"])\r\n], embeddedCodeEditorWidget_EmbeddedCodeEditorWidget);\r\n\r\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/zoneWidget/zoneWidget.css\nvar zoneWidget = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/contrib/zoneWidget/zoneWidget.css");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/browser/ui/sash/sash.js\nvar sash = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/browser/ui/sash/sash.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/common/idGenerator.js\nvar idGenerator = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/common/idGenerator.js");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/zoneWidget/zoneWidget.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst defaultColor = new common_color["Color"](new common_color["RGBA"](0, 122, 204));\r\nconst defaultOptions = {\r\n    showArrow: true,\r\n    showFrame: true,\r\n    className: \'\',\r\n    frameColor: defaultColor,\r\n    arrowColor: defaultColor,\r\n    keepEditorSelection: false\r\n};\r\nconst WIDGET_ID = \'vs.editor.contrib.zoneWidget\';\r\nclass ViewZoneDelegate {\r\n    constructor(domNode, afterLineNumber, afterColumn, heightInLines, onDomNodeTop, onComputedHeight) {\r\n        this.id = \'\'; // A valid zone id should be greater than 0\r\n        this.domNode = domNode;\r\n        this.afterLineNumber = afterLineNumber;\r\n        this.afterColumn = afterColumn;\r\n        this.heightInLines = heightInLines;\r\n        this._onDomNodeTop = onDomNodeTop;\r\n        this._onComputedHeight = onComputedHeight;\r\n    }\r\n    onDomNodeTop(top) {\r\n        this._onDomNodeTop(top);\r\n    }\r\n    onComputedHeight(height) {\r\n        this._onComputedHeight(height);\r\n    }\r\n}\r\nclass OverlayWidgetDelegate {\r\n    constructor(id, domNode) {\r\n        this._id = id;\r\n        this._domNode = domNode;\r\n    }\r\n    getId() {\r\n        return this._id;\r\n    }\r\n    getDomNode() {\r\n        return this._domNode;\r\n    }\r\n    getPosition() {\r\n        return null;\r\n    }\r\n}\r\nclass zoneWidget_Arrow {\r\n    constructor(_editor) {\r\n        this._editor = _editor;\r\n        this._ruleName = zoneWidget_Arrow._IdGenerator.nextId();\r\n        this._decorations = [];\r\n        this._color = null;\r\n        this._height = -1;\r\n        //\r\n    }\r\n    dispose() {\r\n        this.hide();\r\n        dom["removeCSSRulesContainingSelector"](this._ruleName);\r\n    }\r\n    set color(value) {\r\n        if (this._color !== value) {\r\n            this._color = value;\r\n            this._updateStyle();\r\n        }\r\n    }\r\n    set height(value) {\r\n        if (this._height !== value) {\r\n            this._height = value;\r\n            this._updateStyle();\r\n        }\r\n    }\r\n    _updateStyle() {\r\n        dom["removeCSSRulesContainingSelector"](this._ruleName);\r\n        dom["createCSSRule"](`.monaco-editor ${this._ruleName}`, `border-style: solid; border-color: transparent; border-bottom-color: ${this._color}; border-width: ${this._height}px; bottom: -${this._height}px; margin-left: -${this._height}px; `);\r\n    }\r\n    show(where) {\r\n        this._decorations = this._editor.deltaDecorations(this._decorations, [{ range: core_range["Range"].fromPositions(where), options: { description: \'zone-widget-arrow\', className: this._ruleName, stickiness: 1 /* NeverGrowsWhenTypingAtEdges */ } }]);\r\n    }\r\n    hide() {\r\n        this._editor.deltaDecorations(this._decorations, []);\r\n    }\r\n}\r\nzoneWidget_Arrow._IdGenerator = new idGenerator["IdGenerator"](\'.arrow-decoration-\');\r\nclass zoneWidget_ZoneWidget {\r\n    constructor(editor, options = {}) {\r\n        this._arrow = null;\r\n        this._overlayWidget = null;\r\n        this._resizeSash = null;\r\n        this._positionMarkerId = [];\r\n        this._viewZone = null;\r\n        this._disposables = new lifecycle["DisposableStore"]();\r\n        this.container = null;\r\n        this._isShowing = false;\r\n        this.editor = editor;\r\n        this.options = objects["deepClone"](options);\r\n        objects["mixin"](this.options, defaultOptions, false);\r\n        this.domNode = document.createElement(\'div\');\r\n        if (!this.options.isAccessible) {\r\n            this.domNode.setAttribute(\'aria-hidden\', \'true\');\r\n            this.domNode.setAttribute(\'role\', \'presentation\');\r\n        }\r\n        this._disposables.add(this.editor.onDidLayoutChange((info) => {\r\n            const width = this._getWidth(info);\r\n            this.domNode.style.width = width + \'px\';\r\n            this.domNode.style.left = this._getLeft(info) + \'px\';\r\n            this._onWidth(width);\r\n        }));\r\n    }\r\n    dispose() {\r\n        if (this._overlayWidget) {\r\n            this.editor.removeOverlayWidget(this._overlayWidget);\r\n            this._overlayWidget = null;\r\n        }\r\n        if (this._viewZone) {\r\n            this.editor.changeViewZones(accessor => {\r\n                if (this._viewZone) {\r\n                    accessor.removeZone(this._viewZone.id);\r\n                }\r\n                this._viewZone = null;\r\n            });\r\n        }\r\n        this.editor.deltaDecorations(this._positionMarkerId, []);\r\n        this._positionMarkerId = [];\r\n        this._disposables.dispose();\r\n    }\r\n    create() {\r\n        this.domNode.classList.add(\'zone-widget\');\r\n        if (this.options.className) {\r\n            this.domNode.classList.add(this.options.className);\r\n        }\r\n        this.container = document.createElement(\'div\');\r\n        this.container.classList.add(\'zone-widget-container\');\r\n        this.domNode.appendChild(this.container);\r\n        if (this.options.showArrow) {\r\n            this._arrow = new zoneWidget_Arrow(this.editor);\r\n            this._disposables.add(this._arrow);\r\n        }\r\n        this._fillContainer(this.container);\r\n        this._initSash();\r\n        this._applyStyles();\r\n    }\r\n    style(styles) {\r\n        if (styles.frameColor) {\r\n            this.options.frameColor = styles.frameColor;\r\n        }\r\n        if (styles.arrowColor) {\r\n            this.options.arrowColor = styles.arrowColor;\r\n        }\r\n        this._applyStyles();\r\n    }\r\n    _applyStyles() {\r\n        if (this.container && this.options.frameColor) {\r\n            let frameColor = this.options.frameColor.toString();\r\n            this.container.style.borderTopColor = frameColor;\r\n            this.container.style.borderBottomColor = frameColor;\r\n        }\r\n        if (this._arrow && this.options.arrowColor) {\r\n            let arrowColor = this.options.arrowColor.toString();\r\n            this._arrow.color = arrowColor;\r\n        }\r\n    }\r\n    _getWidth(info) {\r\n        return info.width - info.minimap.minimapWidth - info.verticalScrollbarWidth;\r\n    }\r\n    _getLeft(info) {\r\n        // If minimap is to the left, we move beyond it\r\n        if (info.minimap.minimapWidth > 0 && info.minimap.minimapLeft === 0) {\r\n            return info.minimap.minimapWidth;\r\n        }\r\n        return 0;\r\n    }\r\n    _onViewZoneTop(top) {\r\n        this.domNode.style.top = top + \'px\';\r\n    }\r\n    _onViewZoneHeight(height) {\r\n        this.domNode.style.height = `${height}px`;\r\n        if (this.container) {\r\n            let containerHeight = height - this._decoratingElementsHeight();\r\n            this.container.style.height = `${containerHeight}px`;\r\n            const layoutInfo = this.editor.getLayoutInfo();\r\n            this._doLayout(containerHeight, this._getWidth(layoutInfo));\r\n        }\r\n        if (this._resizeSash) {\r\n            this._resizeSash.layout();\r\n        }\r\n    }\r\n    get position() {\r\n        const [id] = this._positionMarkerId;\r\n        if (!id) {\r\n            return undefined;\r\n        }\r\n        const model = this.editor.getModel();\r\n        if (!model) {\r\n            return undefined;\r\n        }\r\n        const range = model.getDecorationRange(id);\r\n        if (!range) {\r\n            return undefined;\r\n        }\r\n        return range.getStartPosition();\r\n    }\r\n    show(rangeOrPos, heightInLines) {\r\n        const range = core_range["Range"].isIRange(rangeOrPos) ? core_range["Range"].lift(rangeOrPos) : core_range["Range"].fromPositions(rangeOrPos);\r\n        this._isShowing = true;\r\n        this._showImpl(range, heightInLines);\r\n        this._isShowing = false;\r\n        this._positionMarkerId = this.editor.deltaDecorations(this._positionMarkerId, [{ range, options: model_textModel["ModelDecorationOptions"].EMPTY }]);\r\n    }\r\n    hide() {\r\n        if (this._viewZone) {\r\n            this.editor.changeViewZones(accessor => {\r\n                if (this._viewZone) {\r\n                    accessor.removeZone(this._viewZone.id);\r\n                }\r\n            });\r\n            this._viewZone = null;\r\n        }\r\n        if (this._overlayWidget) {\r\n            this.editor.removeOverlayWidget(this._overlayWidget);\r\n            this._overlayWidget = null;\r\n        }\r\n        if (this._arrow) {\r\n            this._arrow.hide();\r\n        }\r\n    }\r\n    _decoratingElementsHeight() {\r\n        let lineHeight = this.editor.getOption(58 /* lineHeight */);\r\n        let result = 0;\r\n        if (this.options.showArrow) {\r\n            let arrowHeight = Math.round(lineHeight / 3);\r\n            result += 2 * arrowHeight;\r\n        }\r\n        if (this.options.showFrame) {\r\n            let frameThickness = Math.round(lineHeight / 9);\r\n            result += 2 * frameThickness;\r\n        }\r\n        return result;\r\n    }\r\n    _showImpl(where, heightInLines) {\r\n        const position = where.getStartPosition();\r\n        const layoutInfo = this.editor.getLayoutInfo();\r\n        const width = this._getWidth(layoutInfo);\r\n        this.domNode.style.width = `${width}px`;\r\n        this.domNode.style.left = this._getLeft(layoutInfo) + \'px\';\r\n        // Render the widget as zone (rendering) and widget (lifecycle)\r\n        const viewZoneDomNode = document.createElement(\'div\');\r\n        viewZoneDomNode.style.overflow = \'hidden\';\r\n        const lineHeight = this.editor.getOption(58 /* lineHeight */);\r\n        // adjust heightInLines to viewport\r\n        const maxHeightInLines = Math.max(12, (this.editor.getLayoutInfo().height / lineHeight) * 0.8);\r\n        heightInLines = Math.min(heightInLines, maxHeightInLines);\r\n        let arrowHeight = 0;\r\n        let frameThickness = 0;\r\n        // Render the arrow one 1/3 of an editor line height\r\n        if (this._arrow && this.options.showArrow) {\r\n            arrowHeight = Math.round(lineHeight / 3);\r\n            this._arrow.height = arrowHeight;\r\n            this._arrow.show(position);\r\n        }\r\n        // Render the frame as 1/9 of an editor line height\r\n        if (this.options.showFrame) {\r\n            frameThickness = Math.round(lineHeight / 9);\r\n        }\r\n        // insert zone widget\r\n        this.editor.changeViewZones((accessor) => {\r\n            if (this._viewZone) {\r\n                accessor.removeZone(this._viewZone.id);\r\n            }\r\n            if (this._overlayWidget) {\r\n                this.editor.removeOverlayWidget(this._overlayWidget);\r\n                this._overlayWidget = null;\r\n            }\r\n            this.domNode.style.top = \'-1000px\';\r\n            this._viewZone = new ViewZoneDelegate(viewZoneDomNode, position.lineNumber, position.column, heightInLines, (top) => this._onViewZoneTop(top), (height) => this._onViewZoneHeight(height));\r\n            this._viewZone.id = accessor.addZone(this._viewZone);\r\n            this._overlayWidget = new OverlayWidgetDelegate(WIDGET_ID + this._viewZone.id, this.domNode);\r\n            this.editor.addOverlayWidget(this._overlayWidget);\r\n        });\r\n        if (this.container && this.options.showFrame) {\r\n            const width = this.options.frameWidth ? this.options.frameWidth : frameThickness;\r\n            this.container.style.borderTopWidth = width + \'px\';\r\n            this.container.style.borderBottomWidth = width + \'px\';\r\n        }\r\n        let containerHeight = heightInLines * lineHeight - this._decoratingElementsHeight();\r\n        if (this.container) {\r\n            this.container.style.top = arrowHeight + \'px\';\r\n            this.container.style.height = containerHeight + \'px\';\r\n            this.container.style.overflow = \'hidden\';\r\n        }\r\n        this._doLayout(containerHeight, width);\r\n        if (!this.options.keepEditorSelection) {\r\n            this.editor.setSelection(where);\r\n        }\r\n        const model = this.editor.getModel();\r\n        if (model) {\r\n            const revealLine = where.endLineNumber + 1;\r\n            if (revealLine <= model.getLineCount()) {\r\n                // reveal line below the zone widget\r\n                this.revealLine(revealLine, false);\r\n            }\r\n            else {\r\n                // reveal last line atop\r\n                this.revealLine(model.getLineCount(), true);\r\n            }\r\n        }\r\n    }\r\n    revealLine(lineNumber, isLastLine) {\r\n        if (isLastLine) {\r\n            this.editor.revealLineInCenter(lineNumber, 0 /* Smooth */);\r\n        }\r\n        else {\r\n            this.editor.revealLine(lineNumber, 0 /* Smooth */);\r\n        }\r\n    }\r\n    setCssClass(className, classToReplace) {\r\n        if (!this.container) {\r\n            return;\r\n        }\r\n        if (classToReplace) {\r\n            this.container.classList.remove(classToReplace);\r\n        }\r\n        this.container.classList.add(className);\r\n    }\r\n    _onWidth(widthInPixel) {\r\n        // implement in subclass\r\n    }\r\n    _doLayout(heightInPixel, widthInPixel) {\r\n        // implement in subclass\r\n    }\r\n    _relayout(newHeightInLines) {\r\n        if (this._viewZone && this._viewZone.heightInLines !== newHeightInLines) {\r\n            this.editor.changeViewZones(accessor => {\r\n                if (this._viewZone) {\r\n                    this._viewZone.heightInLines = newHeightInLines;\r\n                    accessor.layoutZone(this._viewZone.id);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    // --- sash\r\n    _initSash() {\r\n        if (this._resizeSash) {\r\n            return;\r\n        }\r\n        this._resizeSash = this._disposables.add(new sash["Sash"](this.domNode, this, { orientation: 1 /* HORIZONTAL */ }));\r\n        if (!this.options.isResizeable) {\r\n            this._resizeSash.hide();\r\n            this._resizeSash.state = 0 /* Disabled */;\r\n        }\r\n        let data;\r\n        this._disposables.add(this._resizeSash.onDidStart((e) => {\r\n            if (this._viewZone) {\r\n                data = {\r\n                    startY: e.startY,\r\n                    heightInLines: this._viewZone.heightInLines,\r\n                };\r\n            }\r\n        }));\r\n        this._disposables.add(this._resizeSash.onDidEnd(() => {\r\n            data = undefined;\r\n        }));\r\n        this._disposables.add(this._resizeSash.onDidChange((evt) => {\r\n            if (data) {\r\n                let lineDelta = (evt.currentY - data.startY) / this.editor.getOption(58 /* lineHeight */);\r\n                let roundedLineDelta = lineDelta < 0 ? Math.ceil(lineDelta) : Math.floor(lineDelta);\r\n                let newHeightInLines = data.heightInLines + roundedLineDelta;\r\n                if (newHeightInLines > 5 && newHeightInLines < 35) {\r\n                    this._relayout(newHeightInLines);\r\n                }\r\n            }\r\n        }));\r\n    }\r\n    getHorizontalSashLeft() {\r\n        return 0;\r\n    }\r\n    getHorizontalSashTop() {\r\n        return (this.domNode.style.height === null ? 0 : parseInt(this.domNode.style.height)) - (this._decoratingElementsHeight() / 2);\r\n    }\r\n    getHorizontalSashWidth() {\r\n        const layoutInfo = this.editor.getLayoutInfo();\r\n        return layoutInfo.width - layoutInfo.minimap.minimapWidth;\r\n    }\r\n}\r\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/platform/instantiation/common/extensions.js\nvar extensions = __webpack_require__("./node_modules/monaco-editor/esm/vs/platform/instantiation/common/extensions.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/common/codicons.js\nvar codicons = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/common/codicons.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/browser/keyboardEvent.js\nvar browser_keyboardEvent = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/browser/keyboardEvent.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/browser/ui/actionbar/actionViewItems.js\nvar actionViewItems = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/browser/ui/actionbar/actionViewItems.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/browser/touch.js\nvar touch = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/browser/touch.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/browser/ui/dropdown/dropdown.css\nvar dropdown = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/browser/ui/dropdown/dropdown.css");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/browser/ui/dropdown/dropdown.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass dropdown_BaseDropdown extends common_actions["ActionRunner"] {\r\n    constructor(container, options) {\r\n        super();\r\n        this._onDidChangeVisibility = new common_event["Emitter"]();\r\n        this.onDidChangeVisibility = this._onDidChangeVisibility.event;\r\n        this._element = Object(dom["append"])(container, Object(dom["$"])(\'.monaco-dropdown\'));\r\n        this._label = Object(dom["append"])(this._element, Object(dom["$"])(\'.dropdown-label\'));\r\n        let labelRenderer = options.labelRenderer;\r\n        if (!labelRenderer) {\r\n            labelRenderer = (container) => {\r\n                container.textContent = options.label || \'\';\r\n                return null;\r\n            };\r\n        }\r\n        for (const event of [dom["EventType"].CLICK, dom["EventType"].MOUSE_DOWN, touch["EventType"].Tap]) {\r\n            this._register(Object(dom["addDisposableListener"])(this.element, event, e => dom["EventHelper"].stop(e, true))); // prevent default click behaviour to trigger\r\n        }\r\n        for (const event of [dom["EventType"].MOUSE_DOWN, touch["EventType"].Tap]) {\r\n            this._register(Object(dom["addDisposableListener"])(this._label, event, e => {\r\n                if (e instanceof MouseEvent && e.detail > 1) {\r\n                    return; // prevent multiple clicks to open multiple context menus (https://github.com/microsoft/vscode/issues/41363)\r\n                }\r\n                if (this.visible) {\r\n                    this.hide();\r\n                }\r\n                else {\r\n                    this.show();\r\n                }\r\n            }));\r\n        }\r\n        this._register(Object(dom["addDisposableListener"])(this._label, dom["EventType"].KEY_UP, e => {\r\n            const event = new browser_keyboardEvent["StandardKeyboardEvent"](e);\r\n            if (event.equals(3 /* Enter */) || event.equals(10 /* Space */)) {\r\n                dom["EventHelper"].stop(e, true); // https://github.com/microsoft/vscode/issues/57997\r\n                if (this.visible) {\r\n                    this.hide();\r\n                }\r\n                else {\r\n                    this.show();\r\n                }\r\n            }\r\n        }));\r\n        const cleanupFn = labelRenderer(this._label);\r\n        if (cleanupFn) {\r\n            this._register(cleanupFn);\r\n        }\r\n        this._register(touch["Gesture"].addTarget(this._label));\r\n    }\r\n    get element() {\r\n        return this._element;\r\n    }\r\n    show() {\r\n        if (!this.visible) {\r\n            this.visible = true;\r\n            this._onDidChangeVisibility.fire(true);\r\n        }\r\n    }\r\n    hide() {\r\n        if (this.visible) {\r\n            this.visible = false;\r\n            this._onDidChangeVisibility.fire(false);\r\n        }\r\n    }\r\n    dispose() {\r\n        super.dispose();\r\n        this.hide();\r\n        if (this.boxContainer) {\r\n            this.boxContainer.remove();\r\n            this.boxContainer = undefined;\r\n        }\r\n        if (this.contents) {\r\n            this.contents.remove();\r\n            this.contents = undefined;\r\n        }\r\n        if (this._label) {\r\n            this._label.remove();\r\n            this._label = undefined;\r\n        }\r\n    }\r\n}\r\nclass DropdownMenu extends dropdown_BaseDropdown {\r\n    constructor(container, options) {\r\n        super(container, options);\r\n        this._actions = [];\r\n        this._contextMenuProvider = options.contextMenuProvider;\r\n        this.actions = options.actions || [];\r\n        this.actionProvider = options.actionProvider;\r\n        this.menuClassName = options.menuClassName || \'\';\r\n        this.menuAsChild = !!options.menuAsChild;\r\n    }\r\n    set menuOptions(options) {\r\n        this._menuOptions = options;\r\n    }\r\n    get menuOptions() {\r\n        return this._menuOptions;\r\n    }\r\n    get actions() {\r\n        if (this.actionProvider) {\r\n            return this.actionProvider.getActions();\r\n        }\r\n        return this._actions;\r\n    }\r\n    set actions(actions) {\r\n        this._actions = actions;\r\n    }\r\n    show() {\r\n        super.show();\r\n        this.element.classList.add(\'active\');\r\n        this._contextMenuProvider.showContextMenu({\r\n            getAnchor: () => this.element,\r\n            getActions: () => this.actions,\r\n            getActionsContext: () => this.menuOptions ? this.menuOptions.context : null,\r\n            getActionViewItem: action => this.menuOptions && this.menuOptions.actionViewItemProvider ? this.menuOptions.actionViewItemProvider(action) : undefined,\r\n            getKeyBinding: action => this.menuOptions && this.menuOptions.getKeyBinding ? this.menuOptions.getKeyBinding(action) : undefined,\r\n            getMenuClassName: () => this.menuClassName,\r\n            onHide: () => this.onHide(),\r\n            actionRunner: this.menuOptions ? this.menuOptions.actionRunner : undefined,\r\n            anchorAlignment: this.menuOptions ? this.menuOptions.anchorAlignment : 0 /* LEFT */,\r\n            domForShadowRoot: this.menuAsChild ? this.element : undefined\r\n        });\r\n    }\r\n    hide() {\r\n        super.hide();\r\n    }\r\n    onHide() {\r\n        this.hide();\r\n        this.element.classList.remove(\'active\');\r\n    }\r\n}\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/browser/ui/dropdown/dropdownActionViewItem.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\n\r\n\r\nclass dropdownActionViewItem_DropdownMenuActionViewItem extends actionViewItems["BaseActionViewItem"] {\r\n    constructor(action, menuActionsOrProvider, contextMenuProvider, options = Object.create(null)) {\r\n        super(null, action, options);\r\n        this.actionItem = null;\r\n        this._onDidChangeVisibility = this._register(new common_event["Emitter"]());\r\n        this.menuActionsOrProvider = menuActionsOrProvider;\r\n        this.contextMenuProvider = contextMenuProvider;\r\n        this.options = options;\r\n        if (this.options.actionRunner) {\r\n            this.actionRunner = this.options.actionRunner;\r\n        }\r\n    }\r\n    render(container) {\r\n        this.actionItem = container;\r\n        const labelRenderer = (el) => {\r\n            this.element = Object(dom["append"])(el, Object(dom["$"])(\'a.action-label\'));\r\n            let classNames = [];\r\n            if (typeof this.options.classNames === \'string\') {\r\n                classNames = this.options.classNames.split(/\\s+/g).filter(s => !!s);\r\n            }\r\n            else if (this.options.classNames) {\r\n                classNames = this.options.classNames;\r\n            }\r\n            // todo@aeschli: remove codicon, should come through `this.options.classNames`\r\n            if (!classNames.find(c => c === \'icon\')) {\r\n                classNames.push(\'codicon\');\r\n            }\r\n            this.element.classList.add(...classNames);\r\n            this.element.setAttribute(\'role\', \'button\');\r\n            this.element.setAttribute(\'aria-haspopup\', \'true\');\r\n            this.element.setAttribute(\'aria-expanded\', \'false\');\r\n            this.element.title = this._action.label || \'\';\r\n            return null;\r\n        };\r\n        const isActionsArray = Array.isArray(this.menuActionsOrProvider);\r\n        const options = {\r\n            contextMenuProvider: this.contextMenuProvider,\r\n            labelRenderer: labelRenderer,\r\n            menuAsChild: this.options.menuAsChild,\r\n            actions: isActionsArray ? this.menuActionsOrProvider : undefined,\r\n            actionProvider: isActionsArray ? undefined : this.menuActionsOrProvider\r\n        };\r\n        this.dropdownMenu = this._register(new DropdownMenu(container, options));\r\n        this._register(this.dropdownMenu.onDidChangeVisibility(visible => {\r\n            var _a;\r\n            (_a = this.element) === null || _a === void 0 ? void 0 : _a.setAttribute(\'aria-expanded\', `${visible}`);\r\n            this._onDidChangeVisibility.fire(visible);\r\n        }));\r\n        this.dropdownMenu.menuOptions = {\r\n            actionViewItemProvider: this.options.actionViewItemProvider,\r\n            actionRunner: this.actionRunner,\r\n            getKeyBinding: this.options.keybindingProvider,\r\n            context: this._context\r\n        };\r\n        if (this.options.anchorAlignmentProvider) {\r\n            const that = this;\r\n            this.dropdownMenu.menuOptions = Object.assign(Object.assign({}, this.dropdownMenu.menuOptions), { get anchorAlignment() {\r\n                    return that.options.anchorAlignmentProvider();\r\n                } });\r\n        }\r\n        this.updateEnabled();\r\n    }\r\n    setActionContext(newContext) {\r\n        super.setActionContext(newContext);\r\n        if (this.dropdownMenu) {\r\n            if (this.dropdownMenu.menuOptions) {\r\n                this.dropdownMenu.menuOptions.context = newContext;\r\n            }\r\n            else {\r\n                this.dropdownMenu.menuOptions = { context: newContext };\r\n            }\r\n        }\r\n    }\r\n    updateEnabled() {\r\n        var _a, _b;\r\n        const disabled = !this.getAction().enabled;\r\n        (_a = this.actionItem) === null || _a === void 0 ? void 0 : _a.classList.toggle(\'disabled\', disabled);\r\n        (_b = this.element) === null || _b === void 0 ? void 0 : _b.classList.toggle(\'disabled\', disabled);\r\n    }\r\n}\r\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/common/keybindingLabels.js\nvar keybindingLabels = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/common/keybindingLabels.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/platform/actions/browser/menuEntryActionViewItem.css\nvar menuEntryActionViewItem = __webpack_require__("./node_modules/monaco-editor/esm/vs/platform/actions/browser/menuEntryActionViewItem.css");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/platform/actions/common/actions.js\nvar actions_common_actions = __webpack_require__("./node_modules/monaco-editor/esm/vs/platform/actions/common/actions.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/platform/contextview/browser/contextView.js\nvar contextView = __webpack_require__("./node_modules/monaco-editor/esm/vs/platform/contextview/browser/contextView.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/platform/keybinding/common/keybinding.js\nvar common_keybinding = __webpack_require__("./node_modules/monaco-editor/esm/vs/platform/keybinding/common/keybinding.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/platform/storage/common/storage.js + 1 modules\nvar storage = __webpack_require__("./node_modules/monaco-editor/esm/vs/platform/storage/common/storage.js");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/platform/actions/browser/menuEntryActionViewItem.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar menuEntryActionViewItem_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar menuEntryActionViewItem_param = (undefined && undefined.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction createAndFillInActionBarActions(menu, options, target, primaryGroup, primaryMaxCount, shouldInlineSubmenu, useSeparatorsInPrimaryActions) {\r\n    const groups = menu.getActions(options);\r\n    const isPrimaryAction = typeof primaryGroup === \'string\' ? (actionGroup) => actionGroup === primaryGroup : primaryGroup;\r\n    // Action bars handle alternative actions on their own so the alternative actions should be ignored\r\n    fillInActions(groups, target, false, isPrimaryAction, primaryMaxCount, shouldInlineSubmenu, useSeparatorsInPrimaryActions);\r\n    return asDisposable(groups);\r\n}\r\nfunction asDisposable(groups) {\r\n    const disposables = new lifecycle["DisposableStore"]();\r\n    for (const [, actions] of groups) {\r\n        for (const action of actions) {\r\n            disposables.add(action);\r\n        }\r\n    }\r\n    return disposables;\r\n}\r\nfunction fillInActions(groups, target, useAlternativeActions, isPrimaryAction = actionGroup => actionGroup === \'navigation\', primaryMaxCount = Number.MAX_SAFE_INTEGER, shouldInlineSubmenu = () => false, useSeparatorsInPrimaryActions = false) {\r\n    let primaryBucket;\r\n    let secondaryBucket;\r\n    if (Array.isArray(target)) {\r\n        primaryBucket = target;\r\n        secondaryBucket = target;\r\n    }\r\n    else {\r\n        primaryBucket = target.primary;\r\n        secondaryBucket = target.secondary;\r\n    }\r\n    const submenuInfo = new Set();\r\n    for (const [group, actions] of groups) {\r\n        let target;\r\n        if (isPrimaryAction(group)) {\r\n            target = primaryBucket;\r\n            if (target.length > 0 && useSeparatorsInPrimaryActions) {\r\n                target.push(new common_actions["Separator"]());\r\n            }\r\n        }\r\n        else {\r\n            target = secondaryBucket;\r\n            if (target.length > 0) {\r\n                target.push(new common_actions["Separator"]());\r\n            }\r\n        }\r\n        for (let action of actions) {\r\n            if (useAlternativeActions) {\r\n                action = action instanceof actions_common_actions["MenuItemAction"] && action.alt ? action.alt : action;\r\n            }\r\n            const newLen = target.push(action);\r\n            // keep submenu info for later inlining\r\n            if (action instanceof common_actions["SubmenuAction"]) {\r\n                submenuInfo.add({ group, action, index: newLen - 1 });\r\n            }\r\n        }\r\n    }\r\n    // ask the outside if submenu should be inlined or not. only ask when\r\n    // there would be enough space\r\n    for (const { group, action, index } of submenuInfo) {\r\n        const target = isPrimaryAction(group) ? primaryBucket : secondaryBucket;\r\n        // inlining submenus with length 0 or 1 is easy,\r\n        // larger submenus need to be checked with the overall limit\r\n        const submenuActions = action.actions;\r\n        if ((submenuActions.length <= 1 || target.length + submenuActions.length - 2 <= primaryMaxCount) && shouldInlineSubmenu(action, group, target.length)) {\r\n            target.splice(index, 1, ...submenuActions);\r\n        }\r\n    }\r\n    // overflow items from the primary group into the secondary bucket\r\n    if (primaryBucket !== secondaryBucket && primaryBucket.length > primaryMaxCount) {\r\n        const overflow = primaryBucket.splice(primaryMaxCount, primaryBucket.length - primaryMaxCount);\r\n        secondaryBucket.unshift(...overflow, new common_actions["Separator"]());\r\n    }\r\n}\r\nlet menuEntryActionViewItem_MenuEntryActionViewItem = class MenuEntryActionViewItem extends actionViewItems["ActionViewItem"] {\r\n    constructor(_action, options, _keybindingService, _notificationService, _contextKeyService) {\r\n        super(undefined, _action, { icon: !!(_action.class || _action.item.icon), label: !_action.class && !_action.item.icon, draggable: options === null || options === void 0 ? void 0 : options.draggable });\r\n        this._keybindingService = _keybindingService;\r\n        this._notificationService = _notificationService;\r\n        this._contextKeyService = _contextKeyService;\r\n        this._wantsAltCommand = false;\r\n        this._itemClassDispose = this._register(new lifecycle["MutableDisposable"]());\r\n        this._altKey = dom["ModifierKeyEmitter"].getInstance();\r\n    }\r\n    get _menuItemAction() {\r\n        return this._action;\r\n    }\r\n    get _commandAction() {\r\n        return this._wantsAltCommand && this._menuItemAction.alt || this._menuItemAction;\r\n    }\r\n    onClick(event) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            event.preventDefault();\r\n            event.stopPropagation();\r\n            try {\r\n                yield this.actionRunner.run(this._commandAction, this._context);\r\n            }\r\n            catch (err) {\r\n                this._notificationService.error(err);\r\n            }\r\n        });\r\n    }\r\n    render(container) {\r\n        super.render(container);\r\n        container.classList.add(\'menu-entry\');\r\n        this._updateItemClass(this._menuItemAction.item);\r\n        let mouseOver = false;\r\n        let alternativeKeyDown = this._altKey.keyStatus.altKey || ((platform["isWindows"] || platform["isLinux"]) && this._altKey.keyStatus.shiftKey);\r\n        const updateAltState = () => {\r\n            const wantsAltCommand = mouseOver && alternativeKeyDown;\r\n            if (wantsAltCommand !== this._wantsAltCommand) {\r\n                this._wantsAltCommand = wantsAltCommand;\r\n                this.updateLabel();\r\n                this.updateTooltip();\r\n                this.updateClass();\r\n            }\r\n        };\r\n        if (this._menuItemAction.alt) {\r\n            this._register(this._altKey.event(value => {\r\n                alternativeKeyDown = value.altKey || ((platform["isWindows"] || platform["isLinux"]) && value.shiftKey);\r\n                updateAltState();\r\n            }));\r\n        }\r\n        this._register(Object(dom["addDisposableListener"])(container, \'mouseleave\', _ => {\r\n            mouseOver = false;\r\n            updateAltState();\r\n        }));\r\n        this._register(Object(dom["addDisposableListener"])(container, \'mouseenter\', _ => {\r\n            mouseOver = true;\r\n            updateAltState();\r\n        }));\r\n    }\r\n    updateLabel() {\r\n        if (this.options.label && this.label) {\r\n            this.label.textContent = this._commandAction.label;\r\n        }\r\n    }\r\n    updateTooltip() {\r\n        if (this.label) {\r\n            const keybinding = this._keybindingService.lookupKeybinding(this._commandAction.id, this._contextKeyService);\r\n            const keybindingLabel = keybinding && keybinding.getLabel();\r\n            const tooltip = this._commandAction.tooltip || this._commandAction.label;\r\n            let title = keybindingLabel\r\n                ? Object(nls["localize"])(\'titleAndKb\', "{0} ({1})", tooltip, keybindingLabel)\r\n                : tooltip;\r\n            if (!this._wantsAltCommand && this._menuItemAction.alt) {\r\n                const altTooltip = this._menuItemAction.alt.tooltip || this._menuItemAction.alt.label;\r\n                const altKeybinding = this._keybindingService.lookupKeybinding(this._menuItemAction.alt.id, this._contextKeyService);\r\n                const altKeybindingLabel = altKeybinding && altKeybinding.getLabel();\r\n                const altTitleSection = altKeybindingLabel\r\n                    ? Object(nls["localize"])(\'titleAndKb\', "{0} ({1})", altTooltip, altKeybindingLabel)\r\n                    : altTooltip;\r\n                title += `\\n[${keybindingLabels["UILabelProvider"].modifierLabels[platform["OS"]].altKey}] ${altTitleSection}`;\r\n            }\r\n            this.label.title = title;\r\n        }\r\n    }\r\n    updateClass() {\r\n        if (this.options.icon) {\r\n            if (this._commandAction !== this._menuItemAction) {\r\n                if (this._menuItemAction.alt) {\r\n                    this._updateItemClass(this._menuItemAction.alt.item);\r\n                }\r\n            }\r\n            else if (this._menuItemAction.alt) {\r\n                this._updateItemClass(this._menuItemAction.item);\r\n            }\r\n        }\r\n    }\r\n    _updateItemClass(item) {\r\n        var _a;\r\n        this._itemClassDispose.value = undefined;\r\n        const { element, label } = this;\r\n        if (!element || !label) {\r\n            return;\r\n        }\r\n        const icon = this._commandAction.checked && ((_a = item.toggled) === null || _a === void 0 ? void 0 : _a.icon) ? item.toggled.icon : item.icon;\r\n        if (!icon) {\r\n            return;\r\n        }\r\n        if (common_themeService["ThemeIcon"].isThemeIcon(icon)) {\r\n            // theme icons\r\n            const iconClasses = common_themeService["ThemeIcon"].asClassNameArray(icon);\r\n            label.classList.add(...iconClasses);\r\n            this._itemClassDispose.value = Object(lifecycle["toDisposable"])(() => {\r\n                label.classList.remove(...iconClasses);\r\n            });\r\n        }\r\n        else {\r\n            // icon path/url\r\n            if (icon.light) {\r\n                label.style.setProperty(\'--menu-entry-icon-light\', Object(dom["asCSSUrl"])(icon.light));\r\n            }\r\n            if (icon.dark) {\r\n                label.style.setProperty(\'--menu-entry-icon-dark\', Object(dom["asCSSUrl"])(icon.dark));\r\n            }\r\n            label.classList.add(\'icon\');\r\n            this._itemClassDispose.value = Object(lifecycle["toDisposable"])(() => {\r\n                label.classList.remove(\'icon\');\r\n                label.style.removeProperty(\'--menu-entry-icon-light\');\r\n                label.style.removeProperty(\'--menu-entry-icon-dark\');\r\n            });\r\n        }\r\n    }\r\n};\r\nmenuEntryActionViewItem_MenuEntryActionViewItem = menuEntryActionViewItem_decorate([\r\n    menuEntryActionViewItem_param(2, common_keybinding["IKeybindingService"]),\r\n    menuEntryActionViewItem_param(3, notification["INotificationService"]),\r\n    menuEntryActionViewItem_param(4, contextkey["IContextKeyService"])\r\n], menuEntryActionViewItem_MenuEntryActionViewItem);\r\n\r\nlet menuEntryActionViewItem_SubmenuEntryActionViewItem = class SubmenuEntryActionViewItem extends dropdownActionViewItem_DropdownMenuActionViewItem {\r\n    constructor(action, options, contextMenuService) {\r\n        var _a, _b;\r\n        const dropdownOptions = Object.assign({}, options !== null && options !== void 0 ? options : Object.create(null), {\r\n            menuAsChild: (_a = options === null || options === void 0 ? void 0 : options.menuAsChild) !== null && _a !== void 0 ? _a : true,\r\n            classNames: (_b = options === null || options === void 0 ? void 0 : options.classNames) !== null && _b !== void 0 ? _b : (common_themeService["ThemeIcon"].isThemeIcon(action.item.icon) ? common_themeService["ThemeIcon"].asClassName(action.item.icon) : undefined),\r\n        });\r\n        super(action, { getActions: () => action.actions }, contextMenuService, dropdownOptions);\r\n    }\r\n    render(container) {\r\n        super.render(container);\r\n        if (this.element) {\r\n            container.classList.add(\'menu-entry\');\r\n            const { icon } = this._action.item;\r\n            if (icon && !common_themeService["ThemeIcon"].isThemeIcon(icon)) {\r\n                this.element.classList.add(\'icon\');\r\n                if (icon.light) {\r\n                    this.element.style.setProperty(\'--menu-entry-icon-light\', Object(dom["asCSSUrl"])(icon.light));\r\n                }\r\n                if (icon.dark) {\r\n                    this.element.style.setProperty(\'--menu-entry-icon-dark\', Object(dom["asCSSUrl"])(icon.dark));\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\nmenuEntryActionViewItem_SubmenuEntryActionViewItem = menuEntryActionViewItem_decorate([\r\n    menuEntryActionViewItem_param(2, contextView["IContextMenuService"])\r\n], menuEntryActionViewItem_SubmenuEntryActionViewItem);\r\n\r\nlet menuEntryActionViewItem_DropdownWithDefaultActionViewItem = class DropdownWithDefaultActionViewItem extends actionViewItems["BaseActionViewItem"] {\r\n    constructor(submenuAction, options, _keybindingService, _notificationService, _contextMenuService, _menuService, _instaService, _storageService) {\r\n        var _a, _b, _c;\r\n        super(null, submenuAction);\r\n        this._keybindingService = _keybindingService;\r\n        this._notificationService = _notificationService;\r\n        this._contextMenuService = _contextMenuService;\r\n        this._menuService = _menuService;\r\n        this._instaService = _instaService;\r\n        this._storageService = _storageService;\r\n        this._container = null;\r\n        this._storageKey = `${submenuAction.item.submenu._debugName}_lastActionId`;\r\n        // determine default action\r\n        let defaultAction;\r\n        let defaultActionId = _storageService.get(this._storageKey, 1 /* WORKSPACE */);\r\n        if (defaultActionId) {\r\n            defaultAction = submenuAction.actions.find(a => defaultActionId === a.id);\r\n        }\r\n        if (!defaultAction) {\r\n            defaultAction = submenuAction.actions[0];\r\n        }\r\n        this._defaultAction = this._instaService.createInstance(menuEntryActionViewItem_MenuEntryActionViewItem, defaultAction, undefined);\r\n        const dropdownOptions = Object.assign({}, options !== null && options !== void 0 ? options : Object.create(null), {\r\n            menuAsChild: (_a = options === null || options === void 0 ? void 0 : options.menuAsChild) !== null && _a !== void 0 ? _a : true,\r\n            classNames: (_b = options === null || options === void 0 ? void 0 : options.classNames) !== null && _b !== void 0 ? _b : [\'codicon\', \'codicon-chevron-down\'],\r\n            actionRunner: (_c = options === null || options === void 0 ? void 0 : options.actionRunner) !== null && _c !== void 0 ? _c : new common_actions["ActionRunner"]()\r\n        });\r\n        this._dropdown = new dropdownActionViewItem_DropdownMenuActionViewItem(submenuAction, submenuAction.actions, this._contextMenuService, dropdownOptions);\r\n        this._dropdown.actionRunner.onDidRun((e) => {\r\n            if (e.action instanceof actions_common_actions["MenuItemAction"]) {\r\n                this.update(e.action);\r\n            }\r\n        });\r\n    }\r\n    update(lastAction) {\r\n        this._storageService.store(this._storageKey, lastAction.id, 1 /* WORKSPACE */, 0 /* USER */);\r\n        this._defaultAction.dispose();\r\n        this._defaultAction = this._instaService.createInstance(menuEntryActionViewItem_MenuEntryActionViewItem, lastAction, undefined);\r\n        this._defaultAction.actionRunner = new class extends common_actions["ActionRunner"] {\r\n            runAction(action, context) {\r\n                return __awaiter(this, void 0, void 0, function* () {\r\n                    yield action.run(undefined);\r\n                });\r\n            }\r\n        }();\r\n        if (this._container) {\r\n            this._defaultAction.render(Object(dom["prepend"])(this._container, Object(dom["$"])(\'.action-container\')));\r\n        }\r\n    }\r\n    setActionContext(newContext) {\r\n        super.setActionContext(newContext);\r\n        this._defaultAction.setActionContext(newContext);\r\n        this._dropdown.setActionContext(newContext);\r\n    }\r\n    render(container) {\r\n        this._container = container;\r\n        super.render(this._container);\r\n        this._container.classList.add(\'monaco-dropdown-with-default\');\r\n        const primaryContainer = Object(dom["$"])(\'.action-container\');\r\n        this._defaultAction.render(Object(dom["append"])(this._container, primaryContainer));\r\n        this._register(Object(dom["addDisposableListener"])(primaryContainer, dom["EventType"].KEY_DOWN, (e) => {\r\n            const event = new browser_keyboardEvent["StandardKeyboardEvent"](e);\r\n            if (event.equals(17 /* RightArrow */)) {\r\n                this._defaultAction.element.tabIndex = -1;\r\n                this._dropdown.focus();\r\n                event.stopPropagation();\r\n            }\r\n        }));\r\n        const dropdownContainer = Object(dom["$"])(\'.dropdown-action-container\');\r\n        this._dropdown.render(Object(dom["append"])(this._container, dropdownContainer));\r\n        this._register(Object(dom["addDisposableListener"])(dropdownContainer, dom["EventType"].KEY_DOWN, (e) => {\r\n            var _a;\r\n            const event = new browser_keyboardEvent["StandardKeyboardEvent"](e);\r\n            if (event.equals(15 /* LeftArrow */)) {\r\n                this._defaultAction.element.tabIndex = 0;\r\n                this._dropdown.setFocusable(false);\r\n                (_a = this._defaultAction.element) === null || _a === void 0 ? void 0 : _a.focus();\r\n                event.stopPropagation();\r\n            }\r\n        }));\r\n    }\r\n    focus(fromRight) {\r\n        if (fromRight) {\r\n            this._dropdown.focus();\r\n        }\r\n        else {\r\n            this._defaultAction.element.tabIndex = 0;\r\n            this._defaultAction.element.focus();\r\n        }\r\n    }\r\n    blur() {\r\n        this._defaultAction.element.tabIndex = -1;\r\n        this._dropdown.blur();\r\n        this._container.blur();\r\n    }\r\n    setFocusable(focusable) {\r\n        if (focusable) {\r\n            this._defaultAction.element.tabIndex = 0;\r\n        }\r\n        else {\r\n            this._defaultAction.element.tabIndex = -1;\r\n            this._dropdown.setFocusable(false);\r\n        }\r\n    }\r\n    dispose() {\r\n        this._defaultAction.dispose();\r\n        this._dropdown.dispose();\r\n        super.dispose();\r\n    }\r\n};\r\nmenuEntryActionViewItem_DropdownWithDefaultActionViewItem = menuEntryActionViewItem_decorate([\r\n    menuEntryActionViewItem_param(2, common_keybinding["IKeybindingService"]),\r\n    menuEntryActionViewItem_param(3, notification["INotificationService"]),\r\n    menuEntryActionViewItem_param(4, contextView["IContextMenuService"]),\r\n    menuEntryActionViewItem_param(5, actions_common_actions["IMenuService"]),\r\n    menuEntryActionViewItem_param(6, instantiation["IInstantiationService"]),\r\n    menuEntryActionViewItem_param(7, storage["IStorageService"])\r\n], menuEntryActionViewItem_DropdownWithDefaultActionViewItem);\r\n/**\r\n * Creates action view items for menu actions or submenu actions.\r\n */\r\nfunction createActionViewItem(instaService, action, options) {\r\n    if (action instanceof actions_common_actions["MenuItemAction"]) {\r\n        return instaService.createInstance(menuEntryActionViewItem_MenuEntryActionViewItem, action, undefined);\r\n    }\r\n    else if (action instanceof actions_common_actions["SubmenuItemAction"]) {\r\n        if (action.item.rememberDefaultAction) {\r\n            return instaService.createInstance(menuEntryActionViewItem_DropdownWithDefaultActionViewItem, action, options);\r\n        }\r\n        else {\r\n            return instaService.createInstance(menuEntryActionViewItem_SubmenuEntryActionViewItem, action, options);\r\n        }\r\n    }\r\n    else {\r\n        return undefined;\r\n    }\r\n}\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/peekView/peekView.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar peekView_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar peekView_param = (undefined && undefined.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst IPeekViewService = Object(instantiation["createDecorator"])(\'IPeekViewService\');\r\nObject(extensions["registerSingleton"])(IPeekViewService, class {\r\n    constructor() {\r\n        this._widgets = new Map();\r\n    }\r\n    addExclusiveWidget(editor, widget) {\r\n        const existing = this._widgets.get(editor);\r\n        if (existing) {\r\n            existing.listener.dispose();\r\n            existing.widget.dispose();\r\n        }\r\n        const remove = () => {\r\n            const data = this._widgets.get(editor);\r\n            if (data && data.widget === widget) {\r\n                data.listener.dispose();\r\n                this._widgets.delete(editor);\r\n            }\r\n        };\r\n        this._widgets.set(editor, { widget, listener: widget.onDidClose(remove) });\r\n    }\r\n});\r\nvar peekView_PeekContext;\r\n(function (PeekContext) {\r\n    PeekContext.inPeekEditor = new contextkey["RawContextKey"](\'inReferenceSearchEditor\', true, nls["localize"](\'inReferenceSearchEditor\', "Whether the current code editor is embedded inside peek"));\r\n    PeekContext.notInPeekEditor = PeekContext.inPeekEditor.toNegated();\r\n})(peekView_PeekContext || (peekView_PeekContext = {}));\r\nlet peekView_PeekContextController = class PeekContextController {\r\n    constructor(editor, contextKeyService) {\r\n        if (editor instanceof embeddedCodeEditorWidget_EmbeddedCodeEditorWidget) {\r\n            peekView_PeekContext.inPeekEditor.bindTo(contextKeyService);\r\n        }\r\n    }\r\n    dispose() { }\r\n};\r\npeekView_PeekContextController.ID = \'editor.contrib.referenceController\';\r\npeekView_PeekContextController = peekView_decorate([\r\n    peekView_param(1, contextkey["IContextKeyService"])\r\n], peekView_PeekContextController);\r\nObject(editorExtensions["registerEditorContribution"])(peekView_PeekContextController.ID, peekView_PeekContextController);\r\nfunction getOuterEditor(accessor) {\r\n    let editor = accessor.get(services_codeEditorService["ICodeEditorService"]).getFocusedCodeEditor();\r\n    if (editor instanceof embeddedCodeEditorWidget_EmbeddedCodeEditorWidget) {\r\n        return editor.getParentEditor();\r\n    }\r\n    return editor;\r\n}\r\nconst peekView_defaultOptions = {\r\n    headerBackgroundColor: common_color["Color"].white,\r\n    primaryHeadingColor: common_color["Color"].fromHex(\'#333333\'),\r\n    secondaryHeadingColor: common_color["Color"].fromHex(\'#6c6c6cb3\')\r\n};\r\nlet peekView_PeekViewWidget = class PeekViewWidget extends zoneWidget_ZoneWidget {\r\n    constructor(editor, options, instantiationService) {\r\n        super(editor, options);\r\n        this.instantiationService = instantiationService;\r\n        this._onDidClose = new common_event["Emitter"]();\r\n        this.onDidClose = this._onDidClose.event;\r\n        objects["mixin"](this.options, peekView_defaultOptions, false);\r\n    }\r\n    dispose() {\r\n        if (!this.disposed) {\r\n            this.disposed = true; // prevent consumers who dispose on onDidClose from looping\r\n            super.dispose();\r\n            this._onDidClose.fire(this);\r\n        }\r\n    }\r\n    style(styles) {\r\n        let options = this.options;\r\n        if (styles.headerBackgroundColor) {\r\n            options.headerBackgroundColor = styles.headerBackgroundColor;\r\n        }\r\n        if (styles.primaryHeadingColor) {\r\n            options.primaryHeadingColor = styles.primaryHeadingColor;\r\n        }\r\n        if (styles.secondaryHeadingColor) {\r\n            options.secondaryHeadingColor = styles.secondaryHeadingColor;\r\n        }\r\n        super.style(styles);\r\n    }\r\n    _applyStyles() {\r\n        super._applyStyles();\r\n        let options = this.options;\r\n        if (this._headElement && options.headerBackgroundColor) {\r\n            this._headElement.style.backgroundColor = options.headerBackgroundColor.toString();\r\n        }\r\n        if (this._primaryHeading && options.primaryHeadingColor) {\r\n            this._primaryHeading.style.color = options.primaryHeadingColor.toString();\r\n        }\r\n        if (this._secondaryHeading && options.secondaryHeadingColor) {\r\n            this._secondaryHeading.style.color = options.secondaryHeadingColor.toString();\r\n        }\r\n        if (this._bodyElement && options.frameColor) {\r\n            this._bodyElement.style.borderColor = options.frameColor.toString();\r\n        }\r\n    }\r\n    _fillContainer(container) {\r\n        this.setCssClass(\'peekview-widget\');\r\n        this._headElement = dom["$"](\'.head\');\r\n        this._bodyElement = dom["$"](\'.body\');\r\n        this._fillHead(this._headElement);\r\n        this._fillBody(this._bodyElement);\r\n        container.appendChild(this._headElement);\r\n        container.appendChild(this._bodyElement);\r\n    }\r\n    _fillHead(container, noCloseAction) {\r\n        const titleElement = dom["$"](\'.peekview-title\');\r\n        if (this.options.supportOnTitleClick) {\r\n            titleElement.classList.add(\'clickable\');\r\n            dom["addStandardDisposableListener"](titleElement, \'click\', event => this._onTitleClick(event));\r\n        }\r\n        dom["append"](this._headElement, titleElement);\r\n        this._fillTitleIcon(titleElement);\r\n        this._primaryHeading = dom["$"](\'span.filename\');\r\n        this._secondaryHeading = dom["$"](\'span.dirname\');\r\n        this._metaHeading = dom["$"](\'span.meta\');\r\n        dom["append"](titleElement, this._primaryHeading, this._secondaryHeading, this._metaHeading);\r\n        const actionsContainer = dom["$"](\'.peekview-actions\');\r\n        dom["append"](this._headElement, actionsContainer);\r\n        const actionBarOptions = this._getActionBarOptions();\r\n        this._actionbarWidget = new actionbar["ActionBar"](actionsContainer, actionBarOptions);\r\n        this._disposables.add(this._actionbarWidget);\r\n        if (!noCloseAction) {\r\n            this._actionbarWidget.push(new common_actions["Action"](\'peekview.close\', nls["localize"](\'label.close\', "Close"), codicons["Codicon"].close.classNames, true, () => {\r\n                this.dispose();\r\n                return Promise.resolve();\r\n            }), { label: false, icon: true });\r\n        }\r\n    }\r\n    _fillTitleIcon(container) {\r\n    }\r\n    _getActionBarOptions() {\r\n        return {\r\n            actionViewItemProvider: createActionViewItem.bind(undefined, this.instantiationService),\r\n            orientation: 0 /* HORIZONTAL */\r\n        };\r\n    }\r\n    _onTitleClick(event) {\r\n        // implement me if supportOnTitleClick option is set\r\n    }\r\n    setTitle(primaryHeading, secondaryHeading) {\r\n        if (this._primaryHeading && this._secondaryHeading) {\r\n            this._primaryHeading.innerText = primaryHeading;\r\n            this._primaryHeading.setAttribute(\'title\', primaryHeading);\r\n            if (secondaryHeading) {\r\n                this._secondaryHeading.innerText = secondaryHeading;\r\n            }\r\n            else {\r\n                dom["clearNode"](this._secondaryHeading);\r\n            }\r\n        }\r\n    }\r\n    setMetaTitle(value) {\r\n        if (this._metaHeading) {\r\n            if (value) {\r\n                this._metaHeading.innerText = value;\r\n                dom["show"](this._metaHeading);\r\n            }\r\n            else {\r\n                dom["hide"](this._metaHeading);\r\n            }\r\n        }\r\n    }\r\n    _doLayout(heightInPixel, widthInPixel) {\r\n        if (!this._isShowing && heightInPixel < 0) {\r\n            // Looks like the view zone got folded away!\r\n            this.dispose();\r\n            return;\r\n        }\r\n        const headHeight = Math.ceil(this.editor.getOption(58 /* lineHeight */) * 1.2);\r\n        const bodyHeight = Math.round(heightInPixel - (headHeight + 2 /* the border-top/bottom width*/));\r\n        this._doLayoutHead(headHeight, widthInPixel);\r\n        this._doLayoutBody(bodyHeight, widthInPixel);\r\n    }\r\n    _doLayoutHead(heightInPixel, widthInPixel) {\r\n        if (this._headElement) {\r\n            this._headElement.style.height = `${heightInPixel}px`;\r\n            this._headElement.style.lineHeight = this._headElement.style.height;\r\n        }\r\n    }\r\n    _doLayoutBody(heightInPixel, widthInPixel) {\r\n        if (this._bodyElement) {\r\n            this._bodyElement.style.height = `${heightInPixel}px`;\r\n        }\r\n    }\r\n};\r\npeekView_PeekViewWidget = peekView_decorate([\r\n    peekView_param(2, instantiation["IInstantiationService"])\r\n], peekView_PeekViewWidget);\r\n\r\nconst peekViewTitleBackground = Object(colorRegistry["registerColor"])(\'peekViewTitle.background\', { dark: Object(colorRegistry["transparent"])(colorRegistry["editorInfoForeground"], .1), light: Object(colorRegistry["transparent"])(colorRegistry["editorInfoForeground"], .1), hc: null }, nls["localize"](\'peekViewTitleBackground\', \'Background color of the peek view title area.\'));\r\nconst peekViewTitleForeground = Object(colorRegistry["registerColor"])(\'peekViewTitleLabel.foreground\', { dark: common_color["Color"].white, light: common_color["Color"].black, hc: common_color["Color"].white }, nls["localize"](\'peekViewTitleForeground\', \'Color of the peek view title.\'));\r\nconst peekViewTitleInfoForeground = Object(colorRegistry["registerColor"])(\'peekViewTitleDescription.foreground\', { dark: \'#ccccccb3\', light: \'#616161e6\', hc: \'#FFFFFF99\' }, nls["localize"](\'peekViewTitleInfoForeground\', \'Color of the peek view title info.\'));\r\nconst peekViewBorder = Object(colorRegistry["registerColor"])(\'peekView.border\', { dark: colorRegistry["editorInfoForeground"], light: colorRegistry["editorInfoForeground"], hc: colorRegistry["contrastBorder"] }, nls["localize"](\'peekViewBorder\', \'Color of the peek view borders and arrow.\'));\r\nconst peekViewResultsBackground = Object(colorRegistry["registerColor"])(\'peekViewResult.background\', { dark: \'#252526\', light: \'#F3F3F3\', hc: common_color["Color"].black }, nls["localize"](\'peekViewResultsBackground\', \'Background color of the peek view result list.\'));\r\nconst peekViewResultsMatchForeground = Object(colorRegistry["registerColor"])(\'peekViewResult.lineForeground\', { dark: \'#bbbbbb\', light: \'#646465\', hc: common_color["Color"].white }, nls["localize"](\'peekViewResultsMatchForeground\', \'Foreground color for line nodes in the peek view result list.\'));\r\nconst peekViewResultsFileForeground = Object(colorRegistry["registerColor"])(\'peekViewResult.fileForeground\', { dark: common_color["Color"].white, light: \'#1E1E1E\', hc: common_color["Color"].white }, nls["localize"](\'peekViewResultsFileForeground\', \'Foreground color for file nodes in the peek view result list.\'));\r\nconst peekViewResultsSelectionBackground = Object(colorRegistry["registerColor"])(\'peekViewResult.selectionBackground\', { dark: \'#3399ff33\', light: \'#3399ff33\', hc: null }, nls["localize"](\'peekViewResultsSelectionBackground\', \'Background color of the selected entry in the peek view result list.\'));\r\nconst peekViewResultsSelectionForeground = Object(colorRegistry["registerColor"])(\'peekViewResult.selectionForeground\', { dark: common_color["Color"].white, light: \'#6C6C6C\', hc: common_color["Color"].white }, nls["localize"](\'peekViewResultsSelectionForeground\', \'Foreground color of the selected entry in the peek view result list.\'));\r\nconst peekViewEditorBackground = Object(colorRegistry["registerColor"])(\'peekViewEditor.background\', { dark: \'#001F33\', light: \'#F2F8FC\', hc: common_color["Color"].black }, nls["localize"](\'peekViewEditorBackground\', \'Background color of the peek view editor.\'));\r\nconst peekViewEditorGutterBackground = Object(colorRegistry["registerColor"])(\'peekViewEditorGutter.background\', { dark: peekViewEditorBackground, light: peekViewEditorBackground, hc: peekViewEditorBackground }, nls["localize"](\'peekViewEditorGutterBackground\', \'Background color of the gutter in the peek view editor.\'));\r\nconst peekViewResultsMatchHighlight = Object(colorRegistry["registerColor"])(\'peekViewResult.matchHighlightBackground\', { dark: \'#ea5c004d\', light: \'#ea5c004d\', hc: null }, nls["localize"](\'peekViewResultsMatchHighlight\', \'Match highlight color in the peek view result list.\'));\r\nconst peekViewEditorMatchHighlight = Object(colorRegistry["registerColor"])(\'peekViewEditor.matchHighlightBackground\', { dark: \'#ff8f0099\', light: \'#f5d802de\', hc: null }, nls["localize"](\'peekViewEditorMatchHighlight\', \'Match highlight color in the peek view editor.\'));\r\nconst peekViewEditorMatchHighlightBorder = Object(colorRegistry["registerColor"])(\'peekViewEditor.matchHighlightBorder\', { dark: null, light: null, hc: colorRegistry["activeContrastBorder"] }, nls["localize"](\'peekViewEditorMatchHighlightBorder\', \'Match highlight border in the peek view editor.\'));\r\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/common/severity.js\nvar common_severity = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/common/severity.js");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/platform/severityIcon/common/severityIcon.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\n\r\nvar severityIcon_SeverityIcon;\r\n(function (SeverityIcon) {\r\n    function className(severity) {\r\n        switch (severity) {\r\n            case common_severity["default"].Ignore:\r\n                return \'severity-ignore \' + codicons["Codicon"].info.classNames;\r\n            case common_severity["default"].Info:\r\n                return codicons["Codicon"].info.classNames;\r\n            case common_severity["default"].Warning:\r\n                return codicons["Codicon"].warning.classNames;\r\n            case common_severity["default"].Error:\r\n                return codicons["Codicon"].error.classNames;\r\n            default:\r\n                return \'\';\r\n        }\r\n    }\r\n    SeverityIcon.className = className;\r\n})(severityIcon_SeverityIcon || (severityIcon_SeverityIcon = {}));\r\nObject(common_themeService["registerThemingParticipant"])((theme, collector) => {\r\n    const errorIconForeground = theme.getColor(colorRegistry["problemsErrorIconForeground"]);\r\n    if (errorIconForeground) {\r\n        const errorCodiconSelector = codicons["Codicon"].error.cssSelector;\r\n        collector.addRule(`\n\t\t\t.monaco-editor .zone-widget ${errorCodiconSelector},\n\t\t\t.markers-panel .marker-icon${errorCodiconSelector},\n\t\t\t.text-search-provider-messages .providerMessage ${errorCodiconSelector},\n\t\t\t.extensions-viewlet > .extensions ${errorCodiconSelector} {\n\t\t\t\tcolor: ${errorIconForeground};\n\t\t\t}\n\t\t`);\r\n    }\r\n    const warningIconForeground = theme.getColor(colorRegistry["problemsWarningIconForeground"]);\r\n    if (warningIconForeground) {\r\n        const warningCodiconSelector = codicons["Codicon"].warning.cssSelector;\r\n        collector.addRule(`\n\t\t\t.monaco-editor .zone-widget ${warningCodiconSelector},\n\t\t\t.markers-panel .marker-icon${warningCodiconSelector},\n\t\t\t.extensions-viewlet > .extensions ${warningCodiconSelector},\n\t\t\t.extension-editor ${warningCodiconSelector},\n\t\t\t.text-search-provider-messages .providerMessage ${warningCodiconSelector},\n\t\t\t.preferences-editor ${warningCodiconSelector} {\n\t\t\t\tcolor: ${warningIconForeground};\n\t\t\t}\n\t\t`);\r\n    }\r\n    const infoIconForeground = theme.getColor(colorRegistry["problemsInfoIconForeground"]);\r\n    if (infoIconForeground) {\r\n        const infoCodiconSelector = codicons["Codicon"].info.cssSelector;\r\n        collector.addRule(`\n\t\t\t.monaco-editor .zone-widget ${infoCodiconSelector},\n\t\t\t.markers-panel .marker-icon${infoCodiconSelector},\n\t\t\t.extensions-viewlet > .extensions ${infoCodiconSelector},\n\t\t\t.text-search-provider-messages .providerMessage ${infoCodiconSelector},\n\t\t\t.extension-editor ${infoCodiconSelector} {\n\t\t\t\tcolor: ${infoIconForeground};\n\t\t\t}\n\t\t`);\r\n    }\r\n});\r\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/common/strings.js\nvar strings = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/common/strings.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/platform/label/common/label.js\nvar common_label = __webpack_require__("./node_modules/monaco-editor/esm/vs/platform/label/common/label.js");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/gotoErrorWidget.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar gotoErrorWidget_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar gotoErrorWidget_param = (undefined && undefined.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass gotoErrorWidget_MessageWidget {\r\n    constructor(parent, editor, onRelatedInformation, _openerService, _labelService) {\r\n        this._openerService = _openerService;\r\n        this._labelService = _labelService;\r\n        this._lines = 0;\r\n        this._longestLineLength = 0;\r\n        this._relatedDiagnostics = new WeakMap();\r\n        this._disposables = new lifecycle["DisposableStore"]();\r\n        this._editor = editor;\r\n        const domNode = document.createElement(\'div\');\r\n        domNode.className = \'descriptioncontainer\';\r\n        this._messageBlock = document.createElement(\'div\');\r\n        this._messageBlock.classList.add(\'message\');\r\n        this._messageBlock.setAttribute(\'aria-live\', \'assertive\');\r\n        this._messageBlock.setAttribute(\'role\', \'alert\');\r\n        domNode.appendChild(this._messageBlock);\r\n        this._relatedBlock = document.createElement(\'div\');\r\n        domNode.appendChild(this._relatedBlock);\r\n        this._disposables.add(dom["addStandardDisposableListener"](this._relatedBlock, \'click\', event => {\r\n            event.preventDefault();\r\n            const related = this._relatedDiagnostics.get(event.target);\r\n            if (related) {\r\n                onRelatedInformation(related);\r\n            }\r\n        }));\r\n        this._scrollable = new scrollableElement["ScrollableElement"](domNode, {\r\n            horizontal: 1 /* Auto */,\r\n            vertical: 1 /* Auto */,\r\n            useShadows: false,\r\n            horizontalScrollbarSize: 3,\r\n            verticalScrollbarSize: 3\r\n        });\r\n        parent.appendChild(this._scrollable.getDomNode());\r\n        this._disposables.add(this._scrollable.onScroll(e => {\r\n            domNode.style.left = `-${e.scrollLeft}px`;\r\n            domNode.style.top = `-${e.scrollTop}px`;\r\n        }));\r\n        this._disposables.add(this._scrollable);\r\n    }\r\n    dispose() {\r\n        Object(lifecycle["dispose"])(this._disposables);\r\n    }\r\n    update(marker) {\r\n        const { source, message, relatedInformation, code } = marker;\r\n        let sourceAndCodeLength = ((source === null || source === void 0 ? void 0 : source.length) || 0) + \'()\'.length;\r\n        if (code) {\r\n            if (typeof code === \'string\') {\r\n                sourceAndCodeLength += code.length;\r\n            }\r\n            else {\r\n                sourceAndCodeLength += code.value.length;\r\n            }\r\n        }\r\n        const lines = Object(strings["splitLines"])(message);\r\n        this._lines = lines.length;\r\n        this._longestLineLength = 0;\r\n        for (const line of lines) {\r\n            this._longestLineLength = Math.max(line.length + sourceAndCodeLength, this._longestLineLength);\r\n        }\r\n        dom["clearNode"](this._messageBlock);\r\n        this._messageBlock.setAttribute(\'aria-label\', this.getAriaLabel(marker));\r\n        this._editor.applyFontInfo(this._messageBlock);\r\n        let lastLineElement = this._messageBlock;\r\n        for (const line of lines) {\r\n            lastLineElement = document.createElement(\'div\');\r\n            lastLineElement.innerText = line;\r\n            if (line === \'\') {\r\n                lastLineElement.style.height = this._messageBlock.style.lineHeight;\r\n            }\r\n            this._messageBlock.appendChild(lastLineElement);\r\n        }\r\n        if (source || code) {\r\n            const detailsElement = document.createElement(\'span\');\r\n            detailsElement.classList.add(\'details\');\r\n            lastLineElement.appendChild(detailsElement);\r\n            if (source) {\r\n                const sourceElement = document.createElement(\'span\');\r\n                sourceElement.innerText = source;\r\n                sourceElement.classList.add(\'source\');\r\n                detailsElement.appendChild(sourceElement);\r\n            }\r\n            if (code) {\r\n                if (typeof code === \'string\') {\r\n                    const codeElement = document.createElement(\'span\');\r\n                    codeElement.innerText = `(${code})`;\r\n                    codeElement.classList.add(\'code\');\r\n                    detailsElement.appendChild(codeElement);\r\n                }\r\n                else {\r\n                    this._codeLink = dom["$"](\'a.code-link\');\r\n                    this._codeLink.setAttribute(\'href\', `${code.target.toString()}`);\r\n                    this._codeLink.onclick = (e) => {\r\n                        this._openerService.open(code.target, { allowCommands: true });\r\n                        e.preventDefault();\r\n                        e.stopPropagation();\r\n                    };\r\n                    const codeElement = dom["append"](this._codeLink, dom["$"](\'span\'));\r\n                    codeElement.innerText = code.value;\r\n                    detailsElement.appendChild(this._codeLink);\r\n                }\r\n            }\r\n        }\r\n        dom["clearNode"](this._relatedBlock);\r\n        this._editor.applyFontInfo(this._relatedBlock);\r\n        if (Object(arrays["isNonEmptyArray"])(relatedInformation)) {\r\n            const relatedInformationNode = this._relatedBlock.appendChild(document.createElement(\'div\'));\r\n            relatedInformationNode.style.paddingTop = `${Math.floor(this._editor.getOption(58 /* lineHeight */) * 0.66)}px`;\r\n            this._lines += 1;\r\n            for (const related of relatedInformation) {\r\n                let container = document.createElement(\'div\');\r\n                let relatedResource = document.createElement(\'a\');\r\n                relatedResource.classList.add(\'filename\');\r\n                relatedResource.innerText = `${getBaseLabel(related.resource)}(${related.startLineNumber}, ${related.startColumn}): `;\r\n                relatedResource.title = this._labelService.getUriLabel(related.resource);\r\n                this._relatedDiagnostics.set(relatedResource, related);\r\n                let relatedMessage = document.createElement(\'span\');\r\n                relatedMessage.innerText = related.message;\r\n                container.appendChild(relatedResource);\r\n                container.appendChild(relatedMessage);\r\n                this._lines += 1;\r\n                relatedInformationNode.appendChild(container);\r\n            }\r\n        }\r\n        const fontInfo = this._editor.getOption(42 /* fontInfo */);\r\n        const scrollWidth = Math.ceil(fontInfo.typicalFullwidthCharacterWidth * this._longestLineLength * 0.75);\r\n        const scrollHeight = fontInfo.lineHeight * this._lines;\r\n        this._scrollable.setScrollDimensions({ scrollWidth, scrollHeight });\r\n    }\r\n    layout(height, width) {\r\n        this._scrollable.getDomNode().style.height = `${height}px`;\r\n        this._scrollable.getDomNode().style.width = `${width}px`;\r\n        this._scrollable.setScrollDimensions({ width, height });\r\n    }\r\n    getHeightInLines() {\r\n        return Math.min(17, this._lines);\r\n    }\r\n    getAriaLabel(marker) {\r\n        let severityLabel = \'\';\r\n        switch (marker.severity) {\r\n            case markers["MarkerSeverity"].Error:\r\n                severityLabel = nls["localize"](\'Error\', "Error");\r\n                break;\r\n            case markers["MarkerSeverity"].Warning:\r\n                severityLabel = nls["localize"](\'Warning\', "Warning");\r\n                break;\r\n            case markers["MarkerSeverity"].Info:\r\n                severityLabel = nls["localize"](\'Info\', "Info");\r\n                break;\r\n            case markers["MarkerSeverity"].Hint:\r\n                severityLabel = nls["localize"](\'Hint\', "Hint");\r\n                break;\r\n        }\r\n        let ariaLabel = nls["localize"](\'marker aria\', "{0} at {1}. ", severityLabel, marker.startLineNumber + \':\' + marker.startColumn);\r\n        const model = this._editor.getModel();\r\n        if (model && (marker.startLineNumber <= model.getLineCount()) && (marker.startLineNumber >= 1)) {\r\n            const lineContent = model.getLineContent(marker.startLineNumber);\r\n            ariaLabel = `${lineContent}, ${ariaLabel}`;\r\n        }\r\n        return ariaLabel;\r\n    }\r\n}\r\nlet gotoErrorWidget_MarkerNavigationWidget = class MarkerNavigationWidget extends peekView_PeekViewWidget {\r\n    constructor(editor, _themeService, _openerService, _menuService, instantiationService, _contextKeyService, _labelService) {\r\n        super(editor, { showArrow: true, showFrame: true, isAccessible: true, frameWidth: 1 }, instantiationService);\r\n        this._themeService = _themeService;\r\n        this._openerService = _openerService;\r\n        this._menuService = _menuService;\r\n        this._contextKeyService = _contextKeyService;\r\n        this._labelService = _labelService;\r\n        this._callOnDispose = new lifecycle["DisposableStore"]();\r\n        this._onDidSelectRelatedInformation = new common_event["Emitter"]();\r\n        this.onDidSelectRelatedInformation = this._onDidSelectRelatedInformation.event;\r\n        this._severity = markers["MarkerSeverity"].Warning;\r\n        this._backgroundColor = common_color["Color"].white;\r\n        this._applyTheme(_themeService.getColorTheme());\r\n        this._callOnDispose.add(_themeService.onDidColorThemeChange(this._applyTheme.bind(this)));\r\n        this.create();\r\n    }\r\n    _applyTheme(theme) {\r\n        this._backgroundColor = theme.getColor(editorMarkerNavigationBackground);\r\n        let colorId = editorMarkerNavigationError;\r\n        let headerBackground = editorMarkerNavigationErrorHeader;\r\n        if (this._severity === markers["MarkerSeverity"].Warning) {\r\n            colorId = editorMarkerNavigationWarning;\r\n            headerBackground = editorMarkerNavigationWarningHeader;\r\n        }\r\n        else if (this._severity === markers["MarkerSeverity"].Info) {\r\n            colorId = editorMarkerNavigationInfo;\r\n            headerBackground = editorMarkerNavigationInfoHeader;\r\n        }\r\n        const frameColor = theme.getColor(colorId);\r\n        const headerBg = theme.getColor(headerBackground);\r\n        this.style({\r\n            arrowColor: frameColor,\r\n            frameColor: frameColor,\r\n            headerBackgroundColor: headerBg,\r\n            primaryHeadingColor: theme.getColor(peekViewTitleForeground),\r\n            secondaryHeadingColor: theme.getColor(peekViewTitleInfoForeground)\r\n        }); // style() will trigger _applyStyles\r\n    }\r\n    _applyStyles() {\r\n        if (this._parentContainer) {\r\n            this._parentContainer.style.backgroundColor = this._backgroundColor ? this._backgroundColor.toString() : \'\';\r\n        }\r\n        super._applyStyles();\r\n    }\r\n    dispose() {\r\n        this._callOnDispose.dispose();\r\n        super.dispose();\r\n    }\r\n    _fillHead(container) {\r\n        super._fillHead(container);\r\n        this._disposables.add(this._actionbarWidget.actionRunner.onBeforeRun(e => this.editor.focus()));\r\n        const actions = [];\r\n        const menu = this._menuService.createMenu(MarkerNavigationWidget.TitleMenu, this._contextKeyService);\r\n        createAndFillInActionBarActions(menu, undefined, actions);\r\n        this._actionbarWidget.push(actions, { label: false, icon: true, index: 0 });\r\n        menu.dispose();\r\n    }\r\n    _fillTitleIcon(container) {\r\n        this._icon = dom["append"](container, dom["$"](\'\'));\r\n    }\r\n    _fillBody(container) {\r\n        this._parentContainer = container;\r\n        container.classList.add(\'marker-widget\');\r\n        this._parentContainer.tabIndex = 0;\r\n        this._parentContainer.setAttribute(\'role\', \'tooltip\');\r\n        this._container = document.createElement(\'div\');\r\n        container.appendChild(this._container);\r\n        this._message = new gotoErrorWidget_MessageWidget(this._container, this.editor, related => this._onDidSelectRelatedInformation.fire(related), this._openerService, this._labelService);\r\n        this._disposables.add(this._message);\r\n    }\r\n    show() {\r\n        throw new Error(\'call showAtMarker\');\r\n    }\r\n    showAtMarker(marker, markerIdx, markerCount) {\r\n        // update:\r\n        // * title\r\n        // * message\r\n        this._container.classList.remove(\'stale\');\r\n        this._message.update(marker);\r\n        // update frame color (only applied on \'show\')\r\n        this._severity = marker.severity;\r\n        this._applyTheme(this._themeService.getColorTheme());\r\n        // show\r\n        let range = core_range["Range"].lift(marker);\r\n        const editorPosition = this.editor.getPosition();\r\n        let position = editorPosition && range.containsPosition(editorPosition) ? editorPosition : range.getStartPosition();\r\n        super.show(position, this.computeRequiredHeight());\r\n        const model = this.editor.getModel();\r\n        if (model) {\r\n            const detail = markerCount > 1\r\n                ? nls["localize"](\'problems\', "{0} of {1} problems", markerIdx, markerCount)\r\n                : nls["localize"](\'change\', "{0} of {1} problem", markerIdx, markerCount);\r\n            this.setTitle(Object(common_resources["basename"])(model.uri), detail);\r\n        }\r\n        this._icon.className = `codicon ${severityIcon_SeverityIcon.className(markers["MarkerSeverity"].toSeverity(this._severity))}`;\r\n        this.editor.revealPositionNearTop(position, 0 /* Smooth */);\r\n        this.editor.focus();\r\n    }\r\n    updateMarker(marker) {\r\n        this._container.classList.remove(\'stale\');\r\n        this._message.update(marker);\r\n    }\r\n    showStale() {\r\n        this._container.classList.add(\'stale\');\r\n        this._relayout();\r\n    }\r\n    _doLayoutBody(heightInPixel, widthInPixel) {\r\n        super._doLayoutBody(heightInPixel, widthInPixel);\r\n        this._heightInPixel = heightInPixel;\r\n        this._message.layout(heightInPixel, widthInPixel);\r\n        this._container.style.height = `${heightInPixel}px`;\r\n    }\r\n    _onWidth(widthInPixel) {\r\n        this._message.layout(this._heightInPixel, widthInPixel);\r\n    }\r\n    _relayout() {\r\n        super._relayout(this.computeRequiredHeight());\r\n    }\r\n    computeRequiredHeight() {\r\n        return 3 + this._message.getHeightInLines();\r\n    }\r\n};\r\ngotoErrorWidget_MarkerNavigationWidget.TitleMenu = new actions_common_actions["MenuId"](\'gotoErrorTitleMenu\');\r\ngotoErrorWidget_MarkerNavigationWidget = gotoErrorWidget_decorate([\r\n    gotoErrorWidget_param(1, common_themeService["IThemeService"]),\r\n    gotoErrorWidget_param(2, common_opener["IOpenerService"]),\r\n    gotoErrorWidget_param(3, actions_common_actions["IMenuService"]),\r\n    gotoErrorWidget_param(4, instantiation["IInstantiationService"]),\r\n    gotoErrorWidget_param(5, contextkey["IContextKeyService"]),\r\n    gotoErrorWidget_param(6, common_label["ILabelService"])\r\n], gotoErrorWidget_MarkerNavigationWidget);\r\n\r\n// theming\r\nlet errorDefault = Object(colorRegistry["oneOf"])(colorRegistry["editorErrorForeground"], colorRegistry["editorErrorBorder"]);\r\nlet warningDefault = Object(colorRegistry["oneOf"])(colorRegistry["editorWarningForeground"], colorRegistry["editorWarningBorder"]);\r\nlet infoDefault = Object(colorRegistry["oneOf"])(colorRegistry["editorInfoForeground"], colorRegistry["editorInfoBorder"]);\r\nconst editorMarkerNavigationError = Object(colorRegistry["registerColor"])(\'editorMarkerNavigationError.background\', { dark: errorDefault, light: errorDefault, hc: colorRegistry["contrastBorder"] }, nls["localize"](\'editorMarkerNavigationError\', \'Editor marker navigation widget error color.\'));\r\nconst editorMarkerNavigationErrorHeader = Object(colorRegistry["registerColor"])(\'editorMarkerNavigationError.headerBackground\', { dark: Object(colorRegistry["transparent"])(editorMarkerNavigationError, .1), light: Object(colorRegistry["transparent"])(editorMarkerNavigationError, .1), hc: null }, nls["localize"](\'editorMarkerNavigationErrorHeaderBackground\', \'Editor marker navigation widget error heading background.\'));\r\nconst editorMarkerNavigationWarning = Object(colorRegistry["registerColor"])(\'editorMarkerNavigationWarning.background\', { dark: warningDefault, light: warningDefault, hc: colorRegistry["contrastBorder"] }, nls["localize"](\'editorMarkerNavigationWarning\', \'Editor marker navigation widget warning color.\'));\r\nconst editorMarkerNavigationWarningHeader = Object(colorRegistry["registerColor"])(\'editorMarkerNavigationWarning.headerBackground\', { dark: Object(colorRegistry["transparent"])(editorMarkerNavigationWarning, .1), light: Object(colorRegistry["transparent"])(editorMarkerNavigationWarning, .1), hc: \'#0C141F\' }, nls["localize"](\'editorMarkerNavigationWarningBackground\', \'Editor marker navigation widget warning heading background.\'));\r\nconst editorMarkerNavigationInfo = Object(colorRegistry["registerColor"])(\'editorMarkerNavigationInfo.background\', { dark: infoDefault, light: infoDefault, hc: colorRegistry["contrastBorder"] }, nls["localize"](\'editorMarkerNavigationInfo\', \'Editor marker navigation widget info color.\'));\r\nconst editorMarkerNavigationInfoHeader = Object(colorRegistry["registerColor"])(\'editorMarkerNavigationInfo.headerBackground\', { dark: Object(colorRegistry["transparent"])(editorMarkerNavigationInfo, .1), light: Object(colorRegistry["transparent"])(editorMarkerNavigationInfo, .1), hc: null }, nls["localize"](\'editorMarkerNavigationInfoHeaderBackground\', \'Editor marker navigation widget info heading background.\'));\r\nconst editorMarkerNavigationBackground = Object(colorRegistry["registerColor"])(\'editorMarkerNavigation.background\', { dark: colorRegistry["editorBackground"], light: colorRegistry["editorBackground"], hc: colorRegistry["editorBackground"] }, nls["localize"](\'editorMarkerNavigationBackground\', \'Editor marker navigation widget background.\'));\r\nObject(common_themeService["registerThemingParticipant"])((theme, collector) => {\r\n    const linkFg = theme.getColor(colorRegistry["textLinkForeground"]);\r\n    if (linkFg) {\r\n        collector.addRule(`.monaco-editor .marker-widget a.code-link span { color: ${linkFg}; }`);\r\n    }\r\n    const activeLinkFg = theme.getColor(colorRegistry["textLinkActiveForeground"]);\r\n    if (activeLinkFg) {\r\n        collector.addRule(`.monaco-editor .marker-widget a.code-link span:hover { color: ${activeLinkFg}; }`);\r\n    }\r\n});\r\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/common/linkedList.js\nvar linkedList = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/common/linkedList.js");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/markerNavigationService.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar markerNavigationService_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar markerNavigationService_param = (undefined && undefined.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass MarkerCoordinate {\r\n    constructor(marker, index, total) {\r\n        this.marker = marker;\r\n        this.index = index;\r\n        this.total = total;\r\n    }\r\n}\r\nlet markerNavigationService_MarkerList = class MarkerList {\r\n    constructor(resourceFilter, _markerService) {\r\n        this._markerService = _markerService;\r\n        this._onDidChange = new common_event["Emitter"]();\r\n        this.onDidChange = this._onDidChange.event;\r\n        this._dispoables = new lifecycle["DisposableStore"]();\r\n        this._markers = [];\r\n        this._nextIdx = -1;\r\n        if (common_uri["URI"].isUri(resourceFilter)) {\r\n            this._resourceFilter = uri => uri.toString() === resourceFilter.toString();\r\n        }\r\n        else if (resourceFilter) {\r\n            this._resourceFilter = resourceFilter;\r\n        }\r\n        const updateMarker = () => {\r\n            this._markers = this._markerService.read({\r\n                resource: common_uri["URI"].isUri(resourceFilter) ? resourceFilter : undefined,\r\n                severities: markers["MarkerSeverity"].Error | markers["MarkerSeverity"].Warning | markers["MarkerSeverity"].Info\r\n            });\r\n            if (typeof resourceFilter === \'function\') {\r\n                this._markers = this._markers.filter(m => this._resourceFilter(m.resource));\r\n            }\r\n            this._markers.sort(MarkerList._compareMarker);\r\n        };\r\n        updateMarker();\r\n        this._dispoables.add(_markerService.onMarkerChanged(uris => {\r\n            if (!this._resourceFilter || uris.some(uri => this._resourceFilter(uri))) {\r\n                updateMarker();\r\n                this._nextIdx = -1;\r\n                this._onDidChange.fire();\r\n            }\r\n        }));\r\n    }\r\n    dispose() {\r\n        this._dispoables.dispose();\r\n        this._onDidChange.dispose();\r\n    }\r\n    matches(uri) {\r\n        if (!this._resourceFilter && !uri) {\r\n            return true;\r\n        }\r\n        if (!this._resourceFilter || !uri) {\r\n            return false;\r\n        }\r\n        return this._resourceFilter(uri);\r\n    }\r\n    get selected() {\r\n        const marker = this._markers[this._nextIdx];\r\n        return marker && new MarkerCoordinate(marker, this._nextIdx + 1, this._markers.length);\r\n    }\r\n    _initIdx(model, position, fwd) {\r\n        let found = false;\r\n        let idx = this._markers.findIndex(marker => marker.resource.toString() === model.uri.toString());\r\n        if (idx < 0) {\r\n            idx = Object(arrays["binarySearch"])(this._markers, { resource: model.uri }, (a, b) => Object(strings["compare"])(a.resource.toString(), b.resource.toString()));\r\n            if (idx < 0) {\r\n                idx = ~idx;\r\n            }\r\n        }\r\n        for (let i = idx; i < this._markers.length; i++) {\r\n            let range = core_range["Range"].lift(this._markers[i]);\r\n            if (range.isEmpty()) {\r\n                const word = model.getWordAtPosition(range.getStartPosition());\r\n                if (word) {\r\n                    range = new core_range["Range"](range.startLineNumber, word.startColumn, range.startLineNumber, word.endColumn);\r\n                }\r\n            }\r\n            if (position && (range.containsPosition(position) || position.isBeforeOrEqual(range.getStartPosition()))) {\r\n                this._nextIdx = i;\r\n                found = true;\r\n                break;\r\n            }\r\n            if (this._markers[i].resource.toString() !== model.uri.toString()) {\r\n                break;\r\n            }\r\n        }\r\n        if (!found) {\r\n            // after the last change\r\n            this._nextIdx = fwd ? 0 : this._markers.length - 1;\r\n        }\r\n        if (this._nextIdx < 0) {\r\n            this._nextIdx = this._markers.length - 1;\r\n        }\r\n    }\r\n    resetIndex() {\r\n        this._nextIdx = -1;\r\n    }\r\n    move(fwd, model, position) {\r\n        if (this._markers.length === 0) {\r\n            return false;\r\n        }\r\n        let oldIdx = this._nextIdx;\r\n        if (this._nextIdx === -1) {\r\n            this._initIdx(model, position, fwd);\r\n        }\r\n        else if (fwd) {\r\n            this._nextIdx = (this._nextIdx + 1) % this._markers.length;\r\n        }\r\n        else if (!fwd) {\r\n            this._nextIdx = (this._nextIdx - 1 + this._markers.length) % this._markers.length;\r\n        }\r\n        if (oldIdx !== this._nextIdx) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    find(uri, position) {\r\n        let idx = this._markers.findIndex(marker => marker.resource.toString() === uri.toString());\r\n        if (idx < 0) {\r\n            return undefined;\r\n        }\r\n        for (; idx < this._markers.length; idx++) {\r\n            if (core_range["Range"].containsPosition(this._markers[idx], position)) {\r\n                return new MarkerCoordinate(this._markers[idx], idx + 1, this._markers.length);\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    static _compareMarker(a, b) {\r\n        let res = Object(strings["compare"])(a.resource.toString(), b.resource.toString());\r\n        if (res === 0) {\r\n            res = markers["MarkerSeverity"].compare(a.severity, b.severity);\r\n        }\r\n        if (res === 0) {\r\n            res = core_range["Range"].compareRangesUsingStarts(a, b);\r\n        }\r\n        return res;\r\n    }\r\n};\r\nmarkerNavigationService_MarkerList = markerNavigationService_decorate([\r\n    markerNavigationService_param(1, markers["IMarkerService"])\r\n], markerNavigationService_MarkerList);\r\n\r\nconst IMarkerNavigationService = Object(instantiation["createDecorator"])(\'IMarkerNavigationService\');\r\nlet markerNavigationService_MarkerNavigationService = class MarkerNavigationService {\r\n    constructor(_markerService) {\r\n        this._markerService = _markerService;\r\n        this._provider = new linkedList["LinkedList"]();\r\n    }\r\n    getMarkerList(resource) {\r\n        for (let provider of this._provider) {\r\n            const result = provider.getMarkerList(resource);\r\n            if (result) {\r\n                return result;\r\n            }\r\n        }\r\n        // default\r\n        return new markerNavigationService_MarkerList(resource, this._markerService);\r\n    }\r\n};\r\nmarkerNavigationService_MarkerNavigationService = markerNavigationService_decorate([\r\n    markerNavigationService_param(0, markers["IMarkerService"])\r\n], markerNavigationService_MarkerNavigationService);\r\nObject(extensions["registerSingleton"])(IMarkerNavigationService, markerNavigationService_MarkerNavigationService, true);\r\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/platform/theme/common/iconRegistry.js\nvar iconRegistry = __webpack_require__("./node_modules/monaco-editor/esm/vs/platform/theme/common/iconRegistry.js");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/gotoError.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar gotoError_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar gotoError_param = (undefined && undefined.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nvar gotoError_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nlet gotoError_MarkerController = class MarkerController {\r\n    constructor(editor, _markerNavigationService, _contextKeyService, _editorService, _instantiationService) {\r\n        this._markerNavigationService = _markerNavigationService;\r\n        this._contextKeyService = _contextKeyService;\r\n        this._editorService = _editorService;\r\n        this._instantiationService = _instantiationService;\r\n        this._sessionDispoables = new lifecycle["DisposableStore"]();\r\n        this._editor = editor;\r\n        this._widgetVisible = CONTEXT_MARKERS_NAVIGATION_VISIBLE.bindTo(this._contextKeyService);\r\n    }\r\n    static get(editor) {\r\n        return editor.getContribution(MarkerController.ID);\r\n    }\r\n    dispose() {\r\n        this._cleanUp();\r\n        this._sessionDispoables.dispose();\r\n    }\r\n    _cleanUp() {\r\n        this._widgetVisible.reset();\r\n        this._sessionDispoables.clear();\r\n        this._widget = undefined;\r\n        this._model = undefined;\r\n    }\r\n    _getOrCreateModel(uri) {\r\n        if (this._model && this._model.matches(uri)) {\r\n            return this._model;\r\n        }\r\n        let reusePosition = false;\r\n        if (this._model) {\r\n            reusePosition = true;\r\n            this._cleanUp();\r\n        }\r\n        this._model = this._markerNavigationService.getMarkerList(uri);\r\n        if (reusePosition) {\r\n            this._model.move(true, this._editor.getModel(), this._editor.getPosition());\r\n        }\r\n        this._widget = this._instantiationService.createInstance(gotoErrorWidget_MarkerNavigationWidget, this._editor);\r\n        this._widget.onDidClose(() => this.close(), this, this._sessionDispoables);\r\n        this._widgetVisible.set(true);\r\n        this._sessionDispoables.add(this._model);\r\n        this._sessionDispoables.add(this._widget);\r\n        // follow cursor\r\n        this._sessionDispoables.add(this._editor.onDidChangeCursorPosition(e => {\r\n            var _a, _b, _c;\r\n            if (!((_a = this._model) === null || _a === void 0 ? void 0 : _a.selected) || !core_range["Range"].containsPosition((_b = this._model) === null || _b === void 0 ? void 0 : _b.selected.marker, e.position)) {\r\n                (_c = this._model) === null || _c === void 0 ? void 0 : _c.resetIndex();\r\n            }\r\n        }));\r\n        // update markers\r\n        this._sessionDispoables.add(this._model.onDidChange(() => {\r\n            if (!this._widget || !this._widget.position || !this._model) {\r\n                return;\r\n            }\r\n            const info = this._model.find(this._editor.getModel().uri, this._widget.position);\r\n            if (info) {\r\n                this._widget.updateMarker(info.marker);\r\n            }\r\n            else {\r\n                this._widget.showStale();\r\n            }\r\n        }));\r\n        // open related\r\n        this._sessionDispoables.add(this._widget.onDidSelectRelatedInformation(related => {\r\n            this._editorService.openCodeEditor({\r\n                resource: related.resource,\r\n                options: { pinned: true, revealIfOpened: true, selection: core_range["Range"].lift(related).collapseToStart() }\r\n            }, this._editor);\r\n            this.close(false);\r\n        }));\r\n        this._sessionDispoables.add(this._editor.onDidChangeModel(() => this._cleanUp()));\r\n        return this._model;\r\n    }\r\n    close(focusEditor = true) {\r\n        this._cleanUp();\r\n        if (focusEditor) {\r\n            this._editor.focus();\r\n        }\r\n    }\r\n    showAtMarker(marker) {\r\n        if (this._editor.hasModel()) {\r\n            const model = this._getOrCreateModel(this._editor.getModel().uri);\r\n            model.resetIndex();\r\n            model.move(true, this._editor.getModel(), new core_position["Position"](marker.startLineNumber, marker.startColumn));\r\n            if (model.selected) {\r\n                this._widget.showAtMarker(model.selected.marker, model.selected.index, model.selected.total);\r\n            }\r\n        }\r\n    }\r\n    nagivate(next, multiFile) {\r\n        return gotoError_awaiter(this, void 0, void 0, function* () {\r\n            if (this._editor.hasModel()) {\r\n                const model = this._getOrCreateModel(multiFile ? undefined : this._editor.getModel().uri);\r\n                model.move(next, this._editor.getModel(), this._editor.getPosition());\r\n                if (!model.selected) {\r\n                    return;\r\n                }\r\n                if (model.selected.marker.resource.toString() !== this._editor.getModel().uri.toString()) {\r\n                    // show in different editor\r\n                    this._cleanUp();\r\n                    const otherEditor = yield this._editorService.openCodeEditor({\r\n                        resource: model.selected.marker.resource,\r\n                        options: { pinned: false, revealIfOpened: true, selectionRevealType: 2 /* NearTop */, selection: model.selected.marker }\r\n                    }, this._editor);\r\n                    if (otherEditor) {\r\n                        MarkerController.get(otherEditor).close();\r\n                        MarkerController.get(otherEditor).nagivate(next, multiFile);\r\n                    }\r\n                }\r\n                else {\r\n                    // show in this editor\r\n                    this._widget.showAtMarker(model.selected.marker, model.selected.index, model.selected.total);\r\n                }\r\n            }\r\n        });\r\n    }\r\n};\r\ngotoError_MarkerController.ID = \'editor.contrib.markerController\';\r\ngotoError_MarkerController = gotoError_decorate([\r\n    gotoError_param(1, IMarkerNavigationService),\r\n    gotoError_param(2, contextkey["IContextKeyService"]),\r\n    gotoError_param(3, services_codeEditorService["ICodeEditorService"]),\r\n    gotoError_param(4, instantiation["IInstantiationService"])\r\n], gotoError_MarkerController);\r\n\r\nclass gotoError_MarkerNavigationAction extends editorExtensions["EditorAction"] {\r\n    constructor(_next, _multiFile, opts) {\r\n        super(opts);\r\n        this._next = _next;\r\n        this._multiFile = _multiFile;\r\n    }\r\n    run(_accessor, editor) {\r\n        return gotoError_awaiter(this, void 0, void 0, function* () {\r\n            if (editor.hasModel()) {\r\n                gotoError_MarkerController.get(editor).nagivate(this._next, this._multiFile);\r\n            }\r\n        });\r\n    }\r\n}\r\nclass gotoError_NextMarkerAction extends gotoError_MarkerNavigationAction {\r\n    constructor() {\r\n        super(true, false, {\r\n            id: gotoError_NextMarkerAction.ID,\r\n            label: gotoError_NextMarkerAction.LABEL,\r\n            alias: \'Go to Next Problem (Error, Warning, Info)\',\r\n            precondition: undefined,\r\n            kbOpts: {\r\n                kbExpr: editorContextKeys["EditorContextKeys"].focus,\r\n                primary: 512 /* Alt */ | 66 /* F8 */,\r\n                weight: 100 /* EditorContrib */\r\n            },\r\n            menuOpts: {\r\n                menuId: gotoErrorWidget_MarkerNavigationWidget.TitleMenu,\r\n                title: gotoError_NextMarkerAction.LABEL,\r\n                icon: Object(iconRegistry["registerIcon"])(\'marker-navigation-next\', codicons["Codicon"].arrowDown, nls["localize"](\'nextMarkerIcon\', \'Icon for goto next marker.\')),\r\n                group: \'navigation\',\r\n                order: 1\r\n            }\r\n        });\r\n    }\r\n}\r\ngotoError_NextMarkerAction.ID = \'editor.action.marker.next\';\r\ngotoError_NextMarkerAction.LABEL = nls["localize"](\'markerAction.next.label\', "Go to Next Problem (Error, Warning, Info)");\r\nclass gotoError_PrevMarkerAction extends gotoError_MarkerNavigationAction {\r\n    constructor() {\r\n        super(false, false, {\r\n            id: gotoError_PrevMarkerAction.ID,\r\n            label: gotoError_PrevMarkerAction.LABEL,\r\n            alias: \'Go to Previous Problem (Error, Warning, Info)\',\r\n            precondition: undefined,\r\n            kbOpts: {\r\n                kbExpr: editorContextKeys["EditorContextKeys"].focus,\r\n                primary: 1024 /* Shift */ | 512 /* Alt */ | 66 /* F8 */,\r\n                weight: 100 /* EditorContrib */\r\n            },\r\n            menuOpts: {\r\n                menuId: gotoErrorWidget_MarkerNavigationWidget.TitleMenu,\r\n                title: gotoError_NextMarkerAction.LABEL,\r\n                icon: Object(iconRegistry["registerIcon"])(\'marker-navigation-previous\', codicons["Codicon"].arrowUp, nls["localize"](\'previousMarkerIcon\', \'Icon for goto previous marker.\')),\r\n                group: \'navigation\',\r\n                order: 2\r\n            }\r\n        });\r\n    }\r\n}\r\ngotoError_PrevMarkerAction.ID = \'editor.action.marker.prev\';\r\ngotoError_PrevMarkerAction.LABEL = nls["localize"](\'markerAction.previous.label\', "Go to Previous Problem (Error, Warning, Info)");\r\nclass gotoError_NextMarkerInFilesAction extends gotoError_MarkerNavigationAction {\r\n    constructor() {\r\n        super(true, true, {\r\n            id: \'editor.action.marker.nextInFiles\',\r\n            label: nls["localize"](\'markerAction.nextInFiles.label\', "Go to Next Problem in Files (Error, Warning, Info)"),\r\n            alias: \'Go to Next Problem in Files (Error, Warning, Info)\',\r\n            precondition: undefined,\r\n            kbOpts: {\r\n                kbExpr: editorContextKeys["EditorContextKeys"].focus,\r\n                primary: 66 /* F8 */,\r\n                weight: 100 /* EditorContrib */\r\n            },\r\n            menuOpts: {\r\n                menuId: actions_common_actions["MenuId"].MenubarGoMenu,\r\n                title: nls["localize"]({ key: \'miGotoNextProblem\', comment: [\'&& denotes a mnemonic\'] }, "Next &&Problem"),\r\n                group: \'6_problem_nav\',\r\n                order: 1\r\n            }\r\n        });\r\n    }\r\n}\r\nclass gotoError_PrevMarkerInFilesAction extends gotoError_MarkerNavigationAction {\r\n    constructor() {\r\n        super(false, true, {\r\n            id: \'editor.action.marker.prevInFiles\',\r\n            label: nls["localize"](\'markerAction.previousInFiles.label\', "Go to Previous Problem in Files (Error, Warning, Info)"),\r\n            alias: \'Go to Previous Problem in Files (Error, Warning, Info)\',\r\n            precondition: undefined,\r\n            kbOpts: {\r\n                kbExpr: editorContextKeys["EditorContextKeys"].focus,\r\n                primary: 1024 /* Shift */ | 66 /* F8 */,\r\n                weight: 100 /* EditorContrib */\r\n            },\r\n            menuOpts: {\r\n                menuId: actions_common_actions["MenuId"].MenubarGoMenu,\r\n                title: nls["localize"]({ key: \'miGotoPreviousProblem\', comment: [\'&& denotes a mnemonic\'] }, "Previous &&Problem"),\r\n                group: \'6_problem_nav\',\r\n                order: 2\r\n            }\r\n        });\r\n    }\r\n}\r\nObject(editorExtensions["registerEditorContribution"])(gotoError_MarkerController.ID, gotoError_MarkerController);\r\nObject(editorExtensions["registerEditorAction"])(gotoError_NextMarkerAction);\r\nObject(editorExtensions["registerEditorAction"])(gotoError_PrevMarkerAction);\r\nObject(editorExtensions["registerEditorAction"])(gotoError_NextMarkerInFilesAction);\r\nObject(editorExtensions["registerEditorAction"])(gotoError_PrevMarkerInFilesAction);\r\nconst CONTEXT_MARKERS_NAVIGATION_VISIBLE = new contextkey["RawContextKey"](\'markersNavigationVisible\', false);\r\nconst MarkerCommand = editorExtensions["EditorCommand"].bindToContribution(gotoError_MarkerController.get);\r\nObject(editorExtensions["registerEditorCommand"])(new MarkerCommand({\r\n    id: \'closeMarkersNavigation\',\r\n    precondition: CONTEXT_MARKERS_NAVIGATION_VISIBLE,\r\n    handler: x => x.close(),\r\n    kbOpts: {\r\n        weight: 100 /* EditorContrib */ + 50,\r\n        kbExpr: editorContextKeys["EditorContextKeys"].focus,\r\n        primary: 9 /* Escape */,\r\n        secondary: [1024 /* Shift */ | 9 /* Escape */]\r\n    }\r\n}));\r\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/common/cancellation.js\nvar cancellation = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/common/cancellation.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/browser/core/editorState.js + 1 modules\nvar core_editorState = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/browser/core/editorState.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/core/selection.js\nvar core_selection = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/common/core/selection.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/services/modelService.js\nvar services_modelService = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/common/services/modelService.js");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/types.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nclass CodeActionKind {\r\n    constructor(value) {\r\n        this.value = value;\r\n    }\r\n    equals(other) {\r\n        return this.value === other.value;\r\n    }\r\n    contains(other) {\r\n        return this.equals(other) || this.value === \'\' || other.value.startsWith(this.value + CodeActionKind.sep);\r\n    }\r\n    intersects(other) {\r\n        return this.contains(other) || other.contains(this);\r\n    }\r\n    append(part) {\r\n        return new CodeActionKind(this.value + CodeActionKind.sep + part);\r\n    }\r\n}\r\nCodeActionKind.sep = \'.\';\r\nCodeActionKind.None = new CodeActionKind(\'@@none@@\'); // Special code action that contains nothing\r\nCodeActionKind.Empty = new CodeActionKind(\'\');\r\nCodeActionKind.QuickFix = new CodeActionKind(\'quickfix\');\r\nCodeActionKind.Refactor = new CodeActionKind(\'refactor\');\r\nCodeActionKind.Source = new CodeActionKind(\'source\');\r\nCodeActionKind.SourceOrganizeImports = CodeActionKind.Source.append(\'organizeImports\');\r\nCodeActionKind.SourceFixAll = CodeActionKind.Source.append(\'fixAll\');\r\nfunction mayIncludeActionsOfKind(filter, providedKind) {\r\n    // A provided kind may be a subset or superset of our filtered kind.\r\n    if (filter.include && !filter.include.intersects(providedKind)) {\r\n        return false;\r\n    }\r\n    if (filter.excludes) {\r\n        if (filter.excludes.some(exclude => excludesAction(providedKind, exclude, filter.include))) {\r\n            return false;\r\n        }\r\n    }\r\n    // Don\'t return source actions unless they are explicitly requested\r\n    if (!filter.includeSourceActions && CodeActionKind.Source.contains(providedKind)) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\nfunction filtersAction(filter, action) {\r\n    const actionKind = action.kind ? new CodeActionKind(action.kind) : undefined;\r\n    // Filter out actions by kind\r\n    if (filter.include) {\r\n        if (!actionKind || !filter.include.contains(actionKind)) {\r\n            return false;\r\n        }\r\n    }\r\n    if (filter.excludes) {\r\n        if (actionKind && filter.excludes.some(exclude => excludesAction(actionKind, exclude, filter.include))) {\r\n            return false;\r\n        }\r\n    }\r\n    // Don\'t return source actions unless they are explicitly requested\r\n    if (!filter.includeSourceActions) {\r\n        if (actionKind && CodeActionKind.Source.contains(actionKind)) {\r\n            return false;\r\n        }\r\n    }\r\n    if (filter.onlyIncludePreferredActions) {\r\n        if (!action.isPreferred) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction excludesAction(providedKind, exclude, include) {\r\n    if (!exclude.contains(providedKind)) {\r\n        return false;\r\n    }\r\n    if (include && exclude.contains(include)) {\r\n        // The include is more specific, don\'t filter out\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\nclass CodeActionCommandArgs {\r\n    constructor(kind, apply, preferred) {\r\n        this.kind = kind;\r\n        this.apply = apply;\r\n        this.preferred = preferred;\r\n    }\r\n    static fromUser(arg, defaults) {\r\n        if (!arg || typeof arg !== \'object\') {\r\n            return new CodeActionCommandArgs(defaults.kind, defaults.apply, false);\r\n        }\r\n        return new CodeActionCommandArgs(CodeActionCommandArgs.getKindFromUser(arg, defaults.kind), CodeActionCommandArgs.getApplyFromUser(arg, defaults.apply), CodeActionCommandArgs.getPreferredUser(arg));\r\n    }\r\n    static getApplyFromUser(arg, defaultAutoApply) {\r\n        switch (typeof arg.apply === \'string\' ? arg.apply.toLowerCase() : \'\') {\r\n            case \'first\': return "first" /* First */;\r\n            case \'never\': return "never" /* Never */;\r\n            case \'ifsingle\': return "ifSingle" /* IfSingle */;\r\n            default: return defaultAutoApply;\r\n        }\r\n    }\r\n    static getKindFromUser(arg, defaultKind) {\r\n        return typeof arg.kind === \'string\'\r\n            ? new CodeActionKind(arg.kind)\r\n            : defaultKind;\r\n    }\r\n    static getPreferredUser(arg) {\r\n        return typeof arg.preferred === \'boolean\'\r\n            ? arg.preferred\r\n            : false;\r\n    }\r\n}\r\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/platform/progress/common/progress.js\nvar common_progress = __webpack_require__("./node_modules/monaco-editor/esm/vs/platform/progress/common/progress.js");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/codeAction.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar codeAction_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst codeActionCommandId = \'editor.action.codeAction\';\r\nconst refactorCommandId = \'editor.action.refactor\';\r\nconst sourceActionCommandId = \'editor.action.sourceAction\';\r\nconst organizeImportsCommandId = \'editor.action.organizeImports\';\r\nconst fixAllCommandId = \'editor.action.fixAll\';\r\nclass codeAction_CodeActionItem {\r\n    constructor(action, provider) {\r\n        this.action = action;\r\n        this.provider = provider;\r\n    }\r\n    resolve(token) {\r\n        var _a;\r\n        return codeAction_awaiter(this, void 0, void 0, function* () {\r\n            if (((_a = this.provider) === null || _a === void 0 ? void 0 : _a.resolveCodeAction) && !this.action.edit) {\r\n                let action;\r\n                try {\r\n                    action = yield this.provider.resolveCodeAction(this.action, token);\r\n                }\r\n                catch (err) {\r\n                    Object(errors["onUnexpectedExternalError"])(err);\r\n                }\r\n                if (action) {\r\n                    this.action.edit = action.edit;\r\n                }\r\n            }\r\n            return this;\r\n        });\r\n    }\r\n}\r\nclass codeAction_ManagedCodeActionSet extends lifecycle["Disposable"] {\r\n    constructor(actions, documentation, disposables) {\r\n        super();\r\n        this.documentation = documentation;\r\n        this._register(disposables);\r\n        this.allActions = [...actions].sort(codeAction_ManagedCodeActionSet.codeActionsComparator);\r\n        this.validActions = this.allActions.filter(({ action }) => !action.disabled);\r\n    }\r\n    static codeActionsComparator({ action: a }, { action: b }) {\r\n        if (a.isPreferred && !b.isPreferred) {\r\n            return -1;\r\n        }\r\n        else if (!a.isPreferred && b.isPreferred) {\r\n            return 1;\r\n        }\r\n        if (Object(arrays["isNonEmptyArray"])(a.diagnostics)) {\r\n            if (Object(arrays["isNonEmptyArray"])(b.diagnostics)) {\r\n                return a.diagnostics[0].message.localeCompare(b.diagnostics[0].message);\r\n            }\r\n            else {\r\n                return -1;\r\n            }\r\n        }\r\n        else if (Object(arrays["isNonEmptyArray"])(b.diagnostics)) {\r\n            return 1;\r\n        }\r\n        else {\r\n            return 0; // both have no diagnostics\r\n        }\r\n    }\r\n    get hasAutoFix() {\r\n        return this.validActions.some(({ action: fix }) => !!fix.kind && CodeActionKind.QuickFix.contains(new CodeActionKind(fix.kind)) && !!fix.isPreferred);\r\n    }\r\n}\r\nconst emptyCodeActionsResponse = { actions: [], documentation: undefined };\r\nfunction getCodeActions(model, rangeOrSelection, trigger, progress, token) {\r\n    var _a;\r\n    const filter = trigger.filter || {};\r\n    const codeActionContext = {\r\n        only: (_a = filter.include) === null || _a === void 0 ? void 0 : _a.value,\r\n        trigger: trigger.type,\r\n    };\r\n    const cts = new core_editorState["TextModelCancellationTokenSource"](model, token);\r\n    const providers = getCodeActionProviders(model, filter);\r\n    const disposables = new lifecycle["DisposableStore"]();\r\n    const promises = providers.map((provider) => codeAction_awaiter(this, void 0, void 0, function* () {\r\n        try {\r\n            progress.report(provider);\r\n            const providedCodeActions = yield provider.provideCodeActions(model, rangeOrSelection, codeActionContext, cts.token);\r\n            if (providedCodeActions) {\r\n                disposables.add(providedCodeActions);\r\n            }\r\n            if (cts.token.isCancellationRequested) {\r\n                return emptyCodeActionsResponse;\r\n            }\r\n            const filteredActions = ((providedCodeActions === null || providedCodeActions === void 0 ? void 0 : providedCodeActions.actions) || []).filter(action => action && filtersAction(filter, action));\r\n            const documentation = getDocumentation(provider, filteredActions, filter.include);\r\n            return {\r\n                actions: filteredActions.map(action => new codeAction_CodeActionItem(action, provider)),\r\n                documentation\r\n            };\r\n        }\r\n        catch (err) {\r\n            if (Object(errors["isPromiseCanceledError"])(err)) {\r\n                throw err;\r\n            }\r\n            Object(errors["onUnexpectedExternalError"])(err);\r\n            return emptyCodeActionsResponse;\r\n        }\r\n    }));\r\n    const listener = modes["CodeActionProviderRegistry"].onDidChange(() => {\r\n        const newProviders = modes["CodeActionProviderRegistry"].all(model);\r\n        if (!Object(arrays["equals"])(newProviders, providers)) {\r\n            cts.cancel();\r\n        }\r\n    });\r\n    return Promise.all(promises).then(actions => {\r\n        const allActions = Object(arrays["flatten"])(actions.map(x => x.actions));\r\n        const allDocumentation = Object(arrays["coalesce"])(actions.map(x => x.documentation));\r\n        return new codeAction_ManagedCodeActionSet(allActions, allDocumentation, disposables);\r\n    })\r\n        .finally(() => {\r\n        listener.dispose();\r\n        cts.dispose();\r\n    });\r\n}\r\nfunction getCodeActionProviders(model, filter) {\r\n    return modes["CodeActionProviderRegistry"].all(model)\r\n        // Don\'t include providers that we know will not return code actions of interest\r\n        .filter(provider => {\r\n        if (!provider.providedCodeActionKinds) {\r\n            // We don\'t know what type of actions this provider will return.\r\n            return true;\r\n        }\r\n        return provider.providedCodeActionKinds.some(kind => mayIncludeActionsOfKind(filter, new CodeActionKind(kind)));\r\n    });\r\n}\r\nfunction getDocumentation(provider, providedCodeActions, only) {\r\n    if (!provider.documentation) {\r\n        return undefined;\r\n    }\r\n    const documentation = provider.documentation.map(entry => ({ kind: new CodeActionKind(entry.kind), command: entry.command }));\r\n    if (only) {\r\n        let currentBest;\r\n        for (const entry of documentation) {\r\n            if (entry.kind.contains(only)) {\r\n                if (!currentBest) {\r\n                    currentBest = entry;\r\n                }\r\n                else {\r\n                    // Take best match\r\n                    if (currentBest.kind.contains(entry.kind)) {\r\n                        currentBest = entry;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (currentBest) {\r\n            return currentBest === null || currentBest === void 0 ? void 0 : currentBest.command;\r\n        }\r\n    }\r\n    // Otherwise, check to see if any of the provided actions match.\r\n    for (const action of providedCodeActions) {\r\n        if (!action.kind) {\r\n            continue;\r\n        }\r\n        for (const entry of documentation) {\r\n            if (entry.kind.contains(new CodeActionKind(action.kind))) {\r\n                return entry.command;\r\n            }\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\ncommon_commands["CommandsRegistry"].registerCommand(\'_executeCodeActionProvider\', function (accessor, resource, rangeOrSelection, kind, itemResolveCount) {\r\n    return codeAction_awaiter(this, void 0, void 0, function* () {\r\n        if (!(resource instanceof common_uri["URI"])) {\r\n            throw Object(errors["illegalArgument"])();\r\n        }\r\n        const model = accessor.get(services_modelService["IModelService"]).getModel(resource);\r\n        if (!model) {\r\n            throw Object(errors["illegalArgument"])();\r\n        }\r\n        const validatedRangeOrSelection = core_selection["Selection"].isISelection(rangeOrSelection)\r\n            ? core_selection["Selection"].liftSelection(rangeOrSelection)\r\n            : core_range["Range"].isIRange(rangeOrSelection)\r\n                ? model.validateRange(rangeOrSelection)\r\n                : undefined;\r\n        if (!validatedRangeOrSelection) {\r\n            throw Object(errors["illegalArgument"])();\r\n        }\r\n        const include = typeof kind === \'string\' ? new CodeActionKind(kind) : undefined;\r\n        const codeActionSet = yield getCodeActions(model, validatedRangeOrSelection, { type: 1 /* Invoke */, filter: { includeSourceActions: true, include } }, common_progress["Progress"].None, cancellation["CancellationToken"].None);\r\n        const resolving = [];\r\n        const resolveCount = Math.min(codeActionSet.validActions.length, typeof itemResolveCount === \'number\' ? itemResolveCount : 0);\r\n        for (let i = 0; i < resolveCount; i++) {\r\n            resolving.push(codeActionSet.validActions[i].resolve(cancellation["CancellationToken"].None));\r\n        }\r\n        try {\r\n            yield Promise.all(resolving);\r\n            return codeActionSet.validActions.map(item => item.action);\r\n        }\r\n        finally {\r\n            setTimeout(() => codeActionSet.dispose(), 100);\r\n        }\r\n    });\r\n});\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/lazy.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nclass Lazy {\r\n    constructor(executor) {\r\n        this.executor = executor;\r\n        this._didRun = false;\r\n    }\r\n    /**\r\n     * Get the wrapped value.\r\n     *\r\n     * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only\r\n     * resolved once. `getValue` will re-throw exceptions that are hit while resolving the value\r\n     */\r\n    getValue() {\r\n        if (!this._didRun) {\r\n            try {\r\n                this._value = this.executor();\r\n            }\r\n            catch (err) {\r\n                this._error = err;\r\n            }\r\n            finally {\r\n                this._didRun = true;\r\n            }\r\n        }\r\n        if (this._error) {\r\n            throw this._error;\r\n        }\r\n        return this._value;\r\n    }\r\n    /**\r\n     * Get the wrapped value without forcing evaluation.\r\n     */\r\n    get rawValue() { return this._value; }\r\n}\r\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/browser/services/bulkEditService.js\nvar services_bulkEditService = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/browser/services/bulkEditService.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/message/messageController.css\nvar messageController = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/contrib/message/messageController.css");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/browser/ui/aria/aria.js\nvar aria = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/browser/ui/aria/aria.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/platform/theme/common/theme.js\nvar common_theme = __webpack_require__("./node_modules/monaco-editor/esm/vs/platform/theme/common/theme.js");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/message/messageController.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar messageController_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar messageController_param = (undefined && undefined.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nlet messageController_MessageController = class MessageController {\r\n    constructor(editor, contextKeyService) {\r\n        this._messageWidget = new lifecycle["MutableDisposable"]();\r\n        this._messageListeners = new lifecycle["DisposableStore"]();\r\n        this._editor = editor;\r\n        this._visible = MessageController.MESSAGE_VISIBLE.bindTo(contextKeyService);\r\n        this._editorListener = this._editor.onDidAttemptReadOnlyEdit(() => this._onDidAttemptReadOnlyEdit());\r\n    }\r\n    static get(editor) {\r\n        return editor.getContribution(MessageController.ID);\r\n    }\r\n    dispose() {\r\n        this._editorListener.dispose();\r\n        this._messageListeners.dispose();\r\n        this._messageWidget.dispose();\r\n        this._visible.reset();\r\n    }\r\n    showMessage(message, position) {\r\n        Object(aria["alert"])(message);\r\n        this._visible.set(true);\r\n        this._messageWidget.clear();\r\n        this._messageListeners.clear();\r\n        this._messageWidget.value = new messageController_MessageWidget(this._editor, position, message);\r\n        // close on blur, cursor, model change, dispose\r\n        this._messageListeners.add(this._editor.onDidBlurEditorText(() => this.closeMessage()));\r\n        this._messageListeners.add(this._editor.onDidChangeCursorPosition(() => this.closeMessage()));\r\n        this._messageListeners.add(this._editor.onDidDispose(() => this.closeMessage()));\r\n        this._messageListeners.add(this._editor.onDidChangeModel(() => this.closeMessage()));\r\n        // 3sec\r\n        this._messageListeners.add(new common_async["TimeoutTimer"](() => this.closeMessage(), 3000));\r\n        // close on mouse move\r\n        let bounds;\r\n        this._messageListeners.add(this._editor.onMouseMove(e => {\r\n            // outside the text area\r\n            if (!e.target.position) {\r\n                return;\r\n            }\r\n            if (!bounds) {\r\n                // define bounding box around position and first mouse occurance\r\n                bounds = new core_range["Range"](position.lineNumber - 3, 1, e.target.position.lineNumber + 3, 1);\r\n            }\r\n            else if (!bounds.containsPosition(e.target.position)) {\r\n                // check if position is still in bounds\r\n                this.closeMessage();\r\n            }\r\n        }));\r\n    }\r\n    closeMessage() {\r\n        this._visible.reset();\r\n        this._messageListeners.clear();\r\n        if (this._messageWidget.value) {\r\n            this._messageListeners.add(messageController_MessageWidget.fadeOut(this._messageWidget.value));\r\n        }\r\n    }\r\n    _onDidAttemptReadOnlyEdit() {\r\n        if (this._editor.hasModel()) {\r\n            this.showMessage(nls["localize"](\'editor.readonly\', "Cannot edit in read-only editor"), this._editor.getPosition());\r\n        }\r\n    }\r\n};\r\nmessageController_MessageController.ID = \'editor.contrib.messageController\';\r\nmessageController_MessageController.MESSAGE_VISIBLE = new contextkey["RawContextKey"](\'messageVisible\', false, nls["localize"](\'messageVisible\', \'Whether the editor is currently showing an inline message\'));\r\nmessageController_MessageController = messageController_decorate([\r\n    messageController_param(1, contextkey["IContextKeyService"])\r\n], messageController_MessageController);\r\n\r\nconst MessageCommand = editorExtensions["EditorCommand"].bindToContribution(messageController_MessageController.get);\r\nObject(editorExtensions["registerEditorCommand"])(new MessageCommand({\r\n    id: \'leaveEditorMessage\',\r\n    precondition: messageController_MessageController.MESSAGE_VISIBLE,\r\n    handler: c => c.closeMessage(),\r\n    kbOpts: {\r\n        weight: 100 /* EditorContrib */ + 30,\r\n        primary: 9 /* Escape */\r\n    }\r\n}));\r\nclass messageController_MessageWidget {\r\n    constructor(editor, { lineNumber, column }, text) {\r\n        // Editor.IContentWidget.allowEditorOverflow\r\n        this.allowEditorOverflow = true;\r\n        this.suppressMouseDown = false;\r\n        this._editor = editor;\r\n        this._editor.revealLinesInCenterIfOutsideViewport(lineNumber, lineNumber, 0 /* Smooth */);\r\n        this._position = { lineNumber, column: column - 1 };\r\n        this._domNode = document.createElement(\'div\');\r\n        this._domNode.classList.add(\'monaco-editor-overlaymessage\');\r\n        const anchorTop = document.createElement(\'div\');\r\n        anchorTop.classList.add(\'anchor\', \'top\');\r\n        this._domNode.appendChild(anchorTop);\r\n        const message = document.createElement(\'div\');\r\n        message.classList.add(\'message\');\r\n        message.textContent = text;\r\n        this._domNode.appendChild(message);\r\n        const anchorBottom = document.createElement(\'div\');\r\n        anchorBottom.classList.add(\'anchor\', \'below\');\r\n        this._domNode.appendChild(anchorBottom);\r\n        this._editor.addContentWidget(this);\r\n        this._domNode.classList.add(\'fadeIn\');\r\n    }\r\n    static fadeOut(messageWidget) {\r\n        let handle;\r\n        const dispose = () => {\r\n            messageWidget.dispose();\r\n            clearTimeout(handle);\r\n            messageWidget.getDomNode().removeEventListener(\'animationend\', dispose);\r\n        };\r\n        handle = setTimeout(dispose, 110);\r\n        messageWidget.getDomNode().addEventListener(\'animationend\', dispose);\r\n        messageWidget.getDomNode().classList.add(\'fadeOut\');\r\n        return { dispose };\r\n    }\r\n    dispose() {\r\n        this._editor.removeContentWidget(this);\r\n    }\r\n    getId() {\r\n        return \'messageoverlay\';\r\n    }\r\n    getDomNode() {\r\n        return this._domNode;\r\n    }\r\n    getPosition() {\r\n        return { position: this._position, preference: [1 /* ABOVE */, 2 /* BELOW */] };\r\n    }\r\n    afterRender(position) {\r\n        this._domNode.classList.toggle(\'below\', position === 2 /* BELOW */);\r\n    }\r\n}\r\nObject(editorExtensions["registerEditorContribution"])(messageController_MessageController.ID, messageController_MessageController);\r\nObject(common_themeService["registerThemingParticipant"])((theme, collector) => {\r\n    const border = theme.getColor(colorRegistry["inputValidationInfoBorder"]);\r\n    if (border) {\r\n        let borderWidth = theme.type === common_theme["ColorScheme"].HIGH_CONTRAST ? 2 : 1;\r\n        collector.addRule(`.monaco-editor .monaco-editor-overlaymessage .anchor.below { border-top-color: ${border}; }`);\r\n        collector.addRule(`.monaco-editor .monaco-editor-overlaymessage .anchor.top { border-bottom-color: ${border}; }`);\r\n        collector.addRule(`.monaco-editor .monaco-editor-overlaymessage .message { border: ${borderWidth}px solid ${border}; }`);\r\n    }\r\n    const background = theme.getColor(colorRegistry["inputValidationInfoBackground"]);\r\n    if (background) {\r\n        collector.addRule(`.monaco-editor .monaco-editor-overlaymessage .message { background-color: ${background}; }`);\r\n    }\r\n    const foreground = theme.getColor(colorRegistry["inputValidationInfoForeground"]);\r\n    if (foreground) {\r\n        collector.addRule(`.monaco-editor .monaco-editor-overlaymessage .message { color: ${foreground}; }`);\r\n    }\r\n});\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/codeActionMenu.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar codeActionMenu_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar codeActionMenu_param = (undefined && undefined.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nvar codeActionMenu_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass codeActionMenu_CodeActionAction extends common_actions["Action"] {\r\n    constructor(action, callback) {\r\n        super(action.command ? action.command.id : action.title, stripNewlines(action.title), undefined, !action.disabled, callback);\r\n        this.action = action;\r\n    }\r\n}\r\nfunction stripNewlines(str) {\r\n    return str.replace(/\\r\\n|\\r|\\n/g, \' \');\r\n}\r\nlet codeActionMenu_CodeActionMenu = class CodeActionMenu extends lifecycle["Disposable"] {\r\n    constructor(_editor, _delegate, _contextMenuService, keybindingService) {\r\n        super();\r\n        this._editor = _editor;\r\n        this._delegate = _delegate;\r\n        this._contextMenuService = _contextMenuService;\r\n        this._visible = false;\r\n        this._showingActions = this._register(new lifecycle["MutableDisposable"]());\r\n        this._keybindingResolver = new codeActionMenu_CodeActionKeybindingResolver({\r\n            getKeybindings: () => keybindingService.getKeybindings()\r\n        });\r\n    }\r\n    get isVisible() {\r\n        return this._visible;\r\n    }\r\n    show(trigger, codeActions, at, options) {\r\n        return codeActionMenu_awaiter(this, void 0, void 0, function* () {\r\n            const actionsToShow = options.includeDisabledActions ? codeActions.allActions : codeActions.validActions;\r\n            if (!actionsToShow.length) {\r\n                this._visible = false;\r\n                return;\r\n            }\r\n            if (!this._editor.getDomNode()) {\r\n                // cancel when editor went off-dom\r\n                this._visible = false;\r\n                throw Object(errors["canceled"])();\r\n            }\r\n            this._visible = true;\r\n            this._showingActions.value = codeActions;\r\n            const menuActions = this.getMenuActions(trigger, actionsToShow, codeActions.documentation);\r\n            const anchor = core_position["Position"].isIPosition(at) ? this._toCoords(at) : at || { x: 0, y: 0 };\r\n            const resolver = this._keybindingResolver.getResolver();\r\n            const useShadowDOM = this._editor.getOption(114 /* useShadowDOM */);\r\n            this._contextMenuService.showContextMenu({\r\n                domForShadowRoot: useShadowDOM ? this._editor.getDomNode() : undefined,\r\n                getAnchor: () => anchor,\r\n                getActions: () => menuActions,\r\n                onHide: () => {\r\n                    this._visible = false;\r\n                    this._editor.focus();\r\n                },\r\n                autoSelectFirstItem: true,\r\n                getKeyBinding: action => action instanceof codeActionMenu_CodeActionAction ? resolver(action.action) : undefined,\r\n            });\r\n        });\r\n    }\r\n    getMenuActions(trigger, actionsToShow, documentation) {\r\n        var _a, _b;\r\n        const toCodeActionAction = (item) => new codeActionMenu_CodeActionAction(item.action, () => this._delegate.onSelectCodeAction(item));\r\n        const result = actionsToShow\r\n            .map(toCodeActionAction);\r\n        const allDocumentation = [...documentation];\r\n        const model = this._editor.getModel();\r\n        if (model && result.length) {\r\n            for (const provider of modes["CodeActionProviderRegistry"].all(model)) {\r\n                if (provider._getAdditionalMenuItems) {\r\n                    allDocumentation.push(...provider._getAdditionalMenuItems({ trigger: trigger.type, only: (_b = (_a = trigger.filter) === null || _a === void 0 ? void 0 : _a.include) === null || _b === void 0 ? void 0 : _b.value }, actionsToShow.map(item => item.action)));\r\n                }\r\n            }\r\n        }\r\n        if (allDocumentation.length) {\r\n            result.push(new common_actions["Separator"](), ...allDocumentation.map(command => toCodeActionAction(new codeAction_CodeActionItem({\r\n                title: command.title,\r\n                command: command,\r\n            }, undefined))));\r\n        }\r\n        return result;\r\n    }\r\n    _toCoords(position) {\r\n        if (!this._editor.hasModel()) {\r\n            return { x: 0, y: 0 };\r\n        }\r\n        this._editor.revealPosition(position, 1 /* Immediate */);\r\n        this._editor.render();\r\n        // Translate to absolute editor position\r\n        const cursorCoords = this._editor.getScrolledVisiblePosition(position);\r\n        const editorCoords = Object(dom["getDomNodePagePosition"])(this._editor.getDomNode());\r\n        const x = editorCoords.left + cursorCoords.left;\r\n        const y = editorCoords.top + cursorCoords.top + cursorCoords.height;\r\n        return { x, y };\r\n    }\r\n};\r\ncodeActionMenu_CodeActionMenu = codeActionMenu_decorate([\r\n    codeActionMenu_param(2, contextView["IContextMenuService"]),\r\n    codeActionMenu_param(3, common_keybinding["IKeybindingService"])\r\n], codeActionMenu_CodeActionMenu);\r\n\r\nclass codeActionMenu_CodeActionKeybindingResolver {\r\n    constructor(_keybindingProvider) {\r\n        this._keybindingProvider = _keybindingProvider;\r\n    }\r\n    getResolver() {\r\n        // Lazy since we may not actually ever read the value\r\n        const allCodeActionBindings = new Lazy(() => this._keybindingProvider.getKeybindings()\r\n            .filter(item => codeActionMenu_CodeActionKeybindingResolver.codeActionCommands.indexOf(item.command) >= 0)\r\n            .filter(item => item.resolvedKeybinding)\r\n            .map((item) => {\r\n            // Special case these commands since they come built-in with VS Code and don\'t use \'commandArgs\'\r\n            let commandArgs = item.commandArgs;\r\n            if (item.command === organizeImportsCommandId) {\r\n                commandArgs = { kind: CodeActionKind.SourceOrganizeImports.value };\r\n            }\r\n            else if (item.command === fixAllCommandId) {\r\n                commandArgs = { kind: CodeActionKind.SourceFixAll.value };\r\n            }\r\n            return Object.assign({ resolvedKeybinding: item.resolvedKeybinding }, CodeActionCommandArgs.fromUser(commandArgs, {\r\n                kind: CodeActionKind.None,\r\n                apply: "never" /* Never */\r\n            }));\r\n        }));\r\n        return (action) => {\r\n            if (action.kind) {\r\n                const binding = this.bestKeybindingForCodeAction(action, allCodeActionBindings.getValue());\r\n                return binding === null || binding === void 0 ? void 0 : binding.resolvedKeybinding;\r\n            }\r\n            return undefined;\r\n        };\r\n    }\r\n    bestKeybindingForCodeAction(action, candidates) {\r\n        if (!action.kind) {\r\n            return undefined;\r\n        }\r\n        const kind = new CodeActionKind(action.kind);\r\n        return candidates\r\n            .filter(candidate => candidate.kind.contains(kind))\r\n            .filter(candidate => {\r\n            if (candidate.preferred) {\r\n                // If the candidate keybinding only applies to preferred actions, the this action must also be preferred\r\n                return action.isPreferred;\r\n            }\r\n            return true;\r\n        })\r\n            .reduceRight((currentBest, candidate) => {\r\n            if (!currentBest) {\r\n                return candidate;\r\n            }\r\n            // Select the more specific binding\r\n            return currentBest.kind.contains(candidate.kind) ? candidate : currentBest;\r\n        }, undefined);\r\n    }\r\n}\r\ncodeActionMenu_CodeActionKeybindingResolver.codeActionCommands = [\r\n    refactorCommandId,\r\n    codeActionCommandId,\r\n    sourceActionCommandId,\r\n    organizeImportsCommandId,\r\n    fixAllCommandId\r\n];\r\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/browser/globalMouseMoveMonitor.js\nvar globalMouseMoveMonitor = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/browser/globalMouseMoveMonitor.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/lightBulbWidget.css\nvar lightBulbWidget = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/lightBulbWidget.css");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/lightBulbWidget.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar lightBulbWidget_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar lightBulbWidget_param = (undefined && undefined.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar LightBulbState;\r\n(function (LightBulbState) {\r\n    LightBulbState.Hidden = { type: 0 /* Hidden */ };\r\n    class Showing {\r\n        constructor(actions, trigger, editorPosition, widgetPosition) {\r\n            this.actions = actions;\r\n            this.trigger = trigger;\r\n            this.editorPosition = editorPosition;\r\n            this.widgetPosition = widgetPosition;\r\n            this.type = 1 /* Showing */;\r\n        }\r\n    }\r\n    LightBulbState.Showing = Showing;\r\n})(LightBulbState || (LightBulbState = {}));\r\nlet lightBulbWidget_LightBulbWidget = class LightBulbWidget extends lifecycle["Disposable"] {\r\n    constructor(_editor, _quickFixActionId, _preferredFixActionId, _keybindingService) {\r\n        super();\r\n        this._editor = _editor;\r\n        this._quickFixActionId = _quickFixActionId;\r\n        this._preferredFixActionId = _preferredFixActionId;\r\n        this._keybindingService = _keybindingService;\r\n        this._onClick = this._register(new common_event["Emitter"]());\r\n        this.onClick = this._onClick.event;\r\n        this._state = LightBulbState.Hidden;\r\n        this._domNode = document.createElement(\'div\');\r\n        this._domNode.className = codicons["Codicon"].lightBulb.classNames;\r\n        this._editor.addContentWidget(this);\r\n        this._register(this._editor.onDidChangeModelContent(_ => {\r\n            // cancel when the line in question has been removed\r\n            const editorModel = this._editor.getModel();\r\n            if (this.state.type !== 1 /* Showing */ || !editorModel || this.state.editorPosition.lineNumber >= editorModel.getLineCount()) {\r\n                this.hide();\r\n            }\r\n        }));\r\n        touch["Gesture"].ignoreTarget(this._domNode);\r\n        this._register(dom["addStandardDisposableGenericMouseDownListner"](this._domNode, e => {\r\n            if (this.state.type !== 1 /* Showing */) {\r\n                return;\r\n            }\r\n            // Make sure that focus / cursor location is not lost when clicking widget icon\r\n            this._editor.focus();\r\n            e.preventDefault();\r\n            // a bit of extra work to make sure the menu\r\n            // doesn\'t cover the line-text\r\n            const { top, height } = dom["getDomNodePagePosition"](this._domNode);\r\n            const lineHeight = this._editor.getOption(58 /* lineHeight */);\r\n            let pad = Math.floor(lineHeight / 3);\r\n            if (this.state.widgetPosition.position !== null && this.state.widgetPosition.position.lineNumber < this.state.editorPosition.lineNumber) {\r\n                pad += lineHeight;\r\n            }\r\n            this._onClick.fire({\r\n                x: e.posx,\r\n                y: top + height + pad,\r\n                actions: this.state.actions,\r\n                trigger: this.state.trigger,\r\n            });\r\n        }));\r\n        this._register(dom["addDisposableListener"](this._domNode, \'mouseenter\', (e) => {\r\n            if ((e.buttons & 1) !== 1) {\r\n                return;\r\n            }\r\n            // mouse enters lightbulb while the primary/left button\r\n            // is being pressed -> hide the lightbulb and block future\r\n            // showings until mouse is released\r\n            this.hide();\r\n            const monitor = new globalMouseMoveMonitor["GlobalMouseMoveMonitor"]();\r\n            monitor.startMonitoring(e.target, e.buttons, globalMouseMoveMonitor["standardMouseMoveMerger"], () => { }, () => {\r\n                monitor.dispose();\r\n            });\r\n        }));\r\n        this._register(this._editor.onDidChangeConfiguration(e => {\r\n            // hide when told to do so\r\n            if (e.hasChanged(56 /* lightbulb */) && !this._editor.getOption(56 /* lightbulb */).enabled) {\r\n                this.hide();\r\n            }\r\n        }));\r\n        this._updateLightBulbTitleAndIcon();\r\n        this._register(this._keybindingService.onDidUpdateKeybindings(this._updateLightBulbTitleAndIcon, this));\r\n    }\r\n    dispose() {\r\n        super.dispose();\r\n        this._editor.removeContentWidget(this);\r\n    }\r\n    getId() {\r\n        return \'LightBulbWidget\';\r\n    }\r\n    getDomNode() {\r\n        return this._domNode;\r\n    }\r\n    getPosition() {\r\n        return this._state.type === 1 /* Showing */ ? this._state.widgetPosition : null;\r\n    }\r\n    update(actions, trigger, atPosition) {\r\n        if (actions.validActions.length <= 0) {\r\n            return this.hide();\r\n        }\r\n        const options = this._editor.getOptions();\r\n        if (!options.get(56 /* lightbulb */).enabled) {\r\n            return this.hide();\r\n        }\r\n        const model = this._editor.getModel();\r\n        if (!model) {\r\n            return this.hide();\r\n        }\r\n        const { lineNumber, column } = model.validatePosition(atPosition);\r\n        const tabSize = model.getOptions().tabSize;\r\n        const fontInfo = options.get(42 /* fontInfo */);\r\n        const lineContent = model.getLineContent(lineNumber);\r\n        const indent = model_textModel["TextModel"].computeIndentLevel(lineContent, tabSize);\r\n        const lineHasSpace = fontInfo.spaceWidth * indent > 22;\r\n        const isFolded = (lineNumber) => {\r\n            return lineNumber > 2 && this._editor.getTopForLineNumber(lineNumber) === this._editor.getTopForLineNumber(lineNumber - 1);\r\n        };\r\n        let effectiveLineNumber = lineNumber;\r\n        if (!lineHasSpace) {\r\n            if (lineNumber > 1 && !isFolded(lineNumber - 1)) {\r\n                effectiveLineNumber -= 1;\r\n            }\r\n            else if (!isFolded(lineNumber + 1)) {\r\n                effectiveLineNumber += 1;\r\n            }\r\n            else if (column * fontInfo.spaceWidth < 22) {\r\n                // cannot show lightbulb above/below and showing\r\n                // it inline would overlay the cursor...\r\n                return this.hide();\r\n            }\r\n        }\r\n        this.state = new LightBulbState.Showing(actions, trigger, atPosition, {\r\n            position: { lineNumber: effectiveLineNumber, column: 1 },\r\n            preference: LightBulbWidget._posPref\r\n        });\r\n        this._editor.layoutContentWidget(this);\r\n    }\r\n    hide() {\r\n        this.state = LightBulbState.Hidden;\r\n        this._editor.layoutContentWidget(this);\r\n    }\r\n    get state() { return this._state; }\r\n    set state(value) {\r\n        this._state = value;\r\n        this._updateLightBulbTitleAndIcon();\r\n    }\r\n    _updateLightBulbTitleAndIcon() {\r\n        if (this.state.type === 1 /* Showing */ && this.state.actions.hasAutoFix) {\r\n            // update icon\r\n            this._domNode.classList.remove(...codicons["Codicon"].lightBulb.classNamesArray);\r\n            this._domNode.classList.add(...codicons["Codicon"].lightbulbAutofix.classNamesArray);\r\n            const preferredKb = this._keybindingService.lookupKeybinding(this._preferredFixActionId);\r\n            if (preferredKb) {\r\n                this.title = nls["localize"](\'preferredcodeActionWithKb\', "Show Code Actions. Preferred Quick Fix Available ({0})", preferredKb.getLabel());\r\n                return;\r\n            }\r\n        }\r\n        // update icon\r\n        this._domNode.classList.remove(...codicons["Codicon"].lightbulbAutofix.classNamesArray);\r\n        this._domNode.classList.add(...codicons["Codicon"].lightBulb.classNamesArray);\r\n        const kb = this._keybindingService.lookupKeybinding(this._quickFixActionId);\r\n        if (kb) {\r\n            this.title = nls["localize"](\'codeActionWithKb\', "Show Code Actions ({0})", kb.getLabel());\r\n        }\r\n        else {\r\n            this.title = nls["localize"](\'codeAction\', "Show Code Actions");\r\n        }\r\n    }\r\n    set title(value) {\r\n        this._domNode.title = value;\r\n    }\r\n};\r\nlightBulbWidget_LightBulbWidget._posPref = [0 /* EXACT */];\r\nlightBulbWidget_LightBulbWidget = lightBulbWidget_decorate([\r\n    lightBulbWidget_param(3, common_keybinding["IKeybindingService"])\r\n], lightBulbWidget_LightBulbWidget);\r\n\r\nObject(common_themeService["registerThemingParticipant"])((theme, collector) => {\r\n    var _a;\r\n    const editorBackgroundColor = (_a = theme.getColor(colorRegistry["editorBackground"])) === null || _a === void 0 ? void 0 : _a.transparent(0.7);\r\n    // Lightbulb Icon\r\n    const editorLightBulbForegroundColor = theme.getColor(colorRegistry["editorLightBulbForeground"]);\r\n    if (editorLightBulbForegroundColor) {\r\n        collector.addRule(`\n\t\t.monaco-editor .contentWidgets ${codicons["Codicon"].lightBulb.cssSelector} {\n\t\t\tcolor: ${editorLightBulbForegroundColor};\n\t\t\tbackground-color: ${editorBackgroundColor};\n\t\t}`);\r\n    }\r\n    // Lightbulb Auto Fix Icon\r\n    const editorLightBulbAutoFixForegroundColor = theme.getColor(colorRegistry["editorLightBulbAutoFixForeground"]);\r\n    if (editorLightBulbAutoFixForegroundColor) {\r\n        collector.addRule(`\n\t\t.monaco-editor .contentWidgets ${codicons["Codicon"].lightbulbAutofix.cssSelector} {\n\t\t\tcolor: ${editorLightBulbAutoFixForegroundColor};\n\t\t\tbackground-color: ${editorBackgroundColor};\n\t\t}`);\r\n    }\r\n});\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/codeActionUi.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar codeActionUi_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar codeActionUi_param = (undefined && undefined.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nvar codeActionUi_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\r\n    if (kind === "m") throw new TypeError("Private method is not writable");\r\n    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");\r\n    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");\r\n    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n};\r\nvar __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\r\n    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");\r\n    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");\r\n    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n};\r\nvar _CodeActionUi_disposed;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nlet codeActionUi_CodeActionUi = class CodeActionUi extends lifecycle["Disposable"] {\r\n    constructor(_editor, quickFixActionId, preferredFixActionId, delegate, instantiationService) {\r\n        super();\r\n        this._editor = _editor;\r\n        this.delegate = delegate;\r\n        this._activeCodeActions = this._register(new lifecycle["MutableDisposable"]());\r\n        _CodeActionUi_disposed.set(this, false);\r\n        this._codeActionWidget = new Lazy(() => {\r\n            return this._register(instantiationService.createInstance(codeActionMenu_CodeActionMenu, this._editor, {\r\n                onSelectCodeAction: (action) => codeActionUi_awaiter(this, void 0, void 0, function* () {\r\n                    this.delegate.applyCodeAction(action, /* retrigger */ true);\r\n                })\r\n            }));\r\n        });\r\n        this._lightBulbWidget = new Lazy(() => {\r\n            const widget = this._register(instantiationService.createInstance(lightBulbWidget_LightBulbWidget, this._editor, quickFixActionId, preferredFixActionId));\r\n            this._register(widget.onClick(e => this.showCodeActionList(e.trigger, e.actions, e, { includeDisabledActions: false })));\r\n            return widget;\r\n        });\r\n    }\r\n    dispose() {\r\n        __classPrivateFieldSet(this, _CodeActionUi_disposed, true, "f");\r\n        super.dispose();\r\n    }\r\n    update(newState) {\r\n        var _a, _b, _c;\r\n        return codeActionUi_awaiter(this, void 0, void 0, function* () {\r\n            if (newState.type !== 1 /* Triggered */) {\r\n                (_a = this._lightBulbWidget.rawValue) === null || _a === void 0 ? void 0 : _a.hide();\r\n                return;\r\n            }\r\n            let actions;\r\n            try {\r\n                actions = yield newState.actions;\r\n            }\r\n            catch (e) {\r\n                Object(errors["onUnexpectedError"])(e);\r\n                return;\r\n            }\r\n            if (__classPrivateFieldGet(this, _CodeActionUi_disposed, "f")) {\r\n                return;\r\n            }\r\n            this._lightBulbWidget.getValue().update(actions, newState.trigger, newState.position);\r\n            if (newState.trigger.type === 1 /* Invoke */) {\r\n                if ((_b = newState.trigger.filter) === null || _b === void 0 ? void 0 : _b.include) { // Triggered for specific scope\r\n                    // Check to see if we want to auto apply.\r\n                    const validActionToApply = this.tryGetValidActionToApply(newState.trigger, actions);\r\n                    if (validActionToApply) {\r\n                        try {\r\n                            yield this.delegate.applyCodeAction(validActionToApply, false);\r\n                        }\r\n                        finally {\r\n                            actions.dispose();\r\n                        }\r\n                        return;\r\n                    }\r\n                    // Check to see if there is an action that we would have applied were it not invalid\r\n                    if (newState.trigger.context) {\r\n                        const invalidAction = this.getInvalidActionThatWouldHaveBeenApplied(newState.trigger, actions);\r\n                        if (invalidAction && invalidAction.action.disabled) {\r\n                            messageController_MessageController.get(this._editor).showMessage(invalidAction.action.disabled, newState.trigger.context.position);\r\n                            actions.dispose();\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n                const includeDisabledActions = !!((_c = newState.trigger.filter) === null || _c === void 0 ? void 0 : _c.include);\r\n                if (newState.trigger.context) {\r\n                    if (!actions.allActions.length || !includeDisabledActions && !actions.validActions.length) {\r\n                        messageController_MessageController.get(this._editor).showMessage(newState.trigger.context.notAvailableMessage, newState.trigger.context.position);\r\n                        this._activeCodeActions.value = actions;\r\n                        actions.dispose();\r\n                        return;\r\n                    }\r\n                }\r\n                this._activeCodeActions.value = actions;\r\n                this._codeActionWidget.getValue().show(newState.trigger, actions, newState.position, { includeDisabledActions });\r\n            }\r\n            else {\r\n                // auto magically triggered\r\n                if (this._codeActionWidget.getValue().isVisible) {\r\n                    // TODO: Figure out if we should update the showing menu?\r\n                    actions.dispose();\r\n                }\r\n                else {\r\n                    this._activeCodeActions.value = actions;\r\n                }\r\n            }\r\n        });\r\n    }\r\n    getInvalidActionThatWouldHaveBeenApplied(trigger, actions) {\r\n        if (!actions.allActions.length) {\r\n            return undefined;\r\n        }\r\n        if ((trigger.autoApply === "first" /* First */ && actions.validActions.length === 0)\r\n            || (trigger.autoApply === "ifSingle" /* IfSingle */ && actions.allActions.length === 1)) {\r\n            return actions.allActions.find(({ action }) => action.disabled);\r\n        }\r\n        return undefined;\r\n    }\r\n    tryGetValidActionToApply(trigger, actions) {\r\n        if (!actions.validActions.length) {\r\n            return undefined;\r\n        }\r\n        if ((trigger.autoApply === "first" /* First */ && actions.validActions.length > 0)\r\n            || (trigger.autoApply === "ifSingle" /* IfSingle */ && actions.validActions.length === 1)) {\r\n            return actions.validActions[0];\r\n        }\r\n        return undefined;\r\n    }\r\n    showCodeActionList(trigger, actions, at, options) {\r\n        return codeActionUi_awaiter(this, void 0, void 0, function* () {\r\n            this._codeActionWidget.getValue().show(trigger, actions, at, options);\r\n        });\r\n    }\r\n};\r\n_CodeActionUi_disposed = new WeakMap();\r\ncodeActionUi_CodeActionUi = codeActionUi_decorate([\r\n    codeActionUi_param(4, instantiation["IInstantiationService"])\r\n], codeActionUi_CodeActionUi);\r\n\r\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/platform/telemetry/common/telemetry.js\nvar telemetry = __webpack_require__("./node_modules/monaco-editor/esm/vs/platform/telemetry/common/telemetry.js");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/codeActionModel.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar codeActionModel_classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\r\n    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");\r\n    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");\r\n    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n};\r\nvar codeActionModel_classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\r\n    if (kind === "m") throw new TypeError("Private method is not writable");\r\n    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");\r\n    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");\r\n    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n};\r\nvar _CodeActionModel_isDisposed;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst SUPPORTED_CODE_ACTIONS = new contextkey["RawContextKey"](\'supportedCodeAction\', \'\');\r\nclass codeActionModel_CodeActionOracle extends lifecycle["Disposable"] {\r\n    constructor(_editor, _markerService, _signalChange, _delay = 250) {\r\n        super();\r\n        this._editor = _editor;\r\n        this._markerService = _markerService;\r\n        this._signalChange = _signalChange;\r\n        this._delay = _delay;\r\n        this._autoTriggerTimer = this._register(new common_async["TimeoutTimer"]());\r\n        this._register(this._markerService.onMarkerChanged(e => this._onMarkerChanges(e)));\r\n        this._register(this._editor.onDidChangeCursorPosition(() => this._onCursorChange()));\r\n    }\r\n    trigger(trigger) {\r\n        const selection = this._getRangeOfSelectionUnlessWhitespaceEnclosed(trigger);\r\n        return this._createEventAndSignalChange(trigger, selection);\r\n    }\r\n    _onMarkerChanges(resources) {\r\n        const model = this._editor.getModel();\r\n        if (!model) {\r\n            return;\r\n        }\r\n        if (resources.some(resource => Object(common_resources["isEqual"])(resource, model.uri))) {\r\n            this._autoTriggerTimer.cancelAndSet(() => {\r\n                this.trigger({ type: 2 /* Auto */ });\r\n            }, this._delay);\r\n        }\r\n    }\r\n    _onCursorChange() {\r\n        this._autoTriggerTimer.cancelAndSet(() => {\r\n            this.trigger({ type: 2 /* Auto */ });\r\n        }, this._delay);\r\n    }\r\n    _getRangeOfMarker(selection) {\r\n        const model = this._editor.getModel();\r\n        if (!model) {\r\n            return undefined;\r\n        }\r\n        for (const marker of this._markerService.read({ resource: model.uri })) {\r\n            const markerRange = model.validateRange(marker);\r\n            if (core_range["Range"].intersectRanges(markerRange, selection)) {\r\n                return core_range["Range"].lift(markerRange);\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    _getRangeOfSelectionUnlessWhitespaceEnclosed(trigger) {\r\n        if (!this._editor.hasModel()) {\r\n            return undefined;\r\n        }\r\n        const model = this._editor.getModel();\r\n        const selection = this._editor.getSelection();\r\n        if (selection.isEmpty() && trigger.type === 2 /* Auto */) {\r\n            const { lineNumber, column } = selection.getPosition();\r\n            const line = model.getLineContent(lineNumber);\r\n            if (line.length === 0) {\r\n                // empty line\r\n                return undefined;\r\n            }\r\n            else if (column === 1) {\r\n                // look only right\r\n                if (/\\s/.test(line[0])) {\r\n                    return undefined;\r\n                }\r\n            }\r\n            else if (column === model.getLineMaxColumn(lineNumber)) {\r\n                // look only left\r\n                if (/\\s/.test(line[line.length - 1])) {\r\n                    return undefined;\r\n                }\r\n            }\r\n            else {\r\n                // look left and right\r\n                if (/\\s/.test(line[column - 2]) && /\\s/.test(line[column - 1])) {\r\n                    return undefined;\r\n                }\r\n            }\r\n        }\r\n        return selection;\r\n    }\r\n    _createEventAndSignalChange(trigger, selection) {\r\n        const model = this._editor.getModel();\r\n        if (!selection || !model) {\r\n            // cancel\r\n            this._signalChange(undefined);\r\n            return undefined;\r\n        }\r\n        const markerRange = this._getRangeOfMarker(selection);\r\n        const position = markerRange ? markerRange.getStartPosition() : selection.getStartPosition();\r\n        const e = {\r\n            trigger,\r\n            selection,\r\n            position\r\n        };\r\n        this._signalChange(e);\r\n        return e;\r\n    }\r\n}\r\nvar codeActionModel_CodeActionsState;\r\n(function (CodeActionsState) {\r\n    CodeActionsState.Empty = { type: 0 /* Empty */ };\r\n    class Triggered {\r\n        constructor(trigger, rangeOrSelection, position, _cancellablePromise) {\r\n            this.trigger = trigger;\r\n            this.rangeOrSelection = rangeOrSelection;\r\n            this.position = position;\r\n            this._cancellablePromise = _cancellablePromise;\r\n            this.type = 1 /* Triggered */;\r\n            this.actions = _cancellablePromise.catch((e) => {\r\n                if (Object(errors["isPromiseCanceledError"])(e)) {\r\n                    return emptyCodeActionSet;\r\n                }\r\n                throw e;\r\n            });\r\n        }\r\n        cancel() {\r\n            this._cancellablePromise.cancel();\r\n        }\r\n    }\r\n    CodeActionsState.Triggered = Triggered;\r\n})(codeActionModel_CodeActionsState || (codeActionModel_CodeActionsState = {}));\r\nconst emptyCodeActionSet = {\r\n    allActions: [],\r\n    validActions: [],\r\n    dispose: () => { },\r\n    documentation: [],\r\n    hasAutoFix: false\r\n};\r\nclass codeActionModel_CodeActionModel extends lifecycle["Disposable"] {\r\n    constructor(_editor, _markerService, contextKeyService, _progressService) {\r\n        super();\r\n        this._editor = _editor;\r\n        this._markerService = _markerService;\r\n        this._progressService = _progressService;\r\n        this._codeActionOracle = this._register(new lifecycle["MutableDisposable"]());\r\n        this._state = codeActionModel_CodeActionsState.Empty;\r\n        this._onDidChangeState = this._register(new common_event["Emitter"]());\r\n        this.onDidChangeState = this._onDidChangeState.event;\r\n        _CodeActionModel_isDisposed.set(this, false);\r\n        this._supportedCodeActions = SUPPORTED_CODE_ACTIONS.bindTo(contextKeyService);\r\n        this._register(this._editor.onDidChangeModel(() => this._update()));\r\n        this._register(this._editor.onDidChangeModelLanguage(() => this._update()));\r\n        this._register(modes["CodeActionProviderRegistry"].onDidChange(() => this._update()));\r\n        this._update();\r\n    }\r\n    dispose() {\r\n        if (codeActionModel_classPrivateFieldGet(this, _CodeActionModel_isDisposed, "f")) {\r\n            return;\r\n        }\r\n        codeActionModel_classPrivateFieldSet(this, _CodeActionModel_isDisposed, true, "f");\r\n        super.dispose();\r\n        this.setState(codeActionModel_CodeActionsState.Empty, true);\r\n    }\r\n    _update() {\r\n        if (codeActionModel_classPrivateFieldGet(this, _CodeActionModel_isDisposed, "f")) {\r\n            return;\r\n        }\r\n        this._codeActionOracle.value = undefined;\r\n        this.setState(codeActionModel_CodeActionsState.Empty);\r\n        const model = this._editor.getModel();\r\n        if (model\r\n            && modes["CodeActionProviderRegistry"].has(model)\r\n            && !this._editor.getOption(80 /* readOnly */)) {\r\n            const supportedActions = [];\r\n            for (const provider of modes["CodeActionProviderRegistry"].all(model)) {\r\n                if (Array.isArray(provider.providedCodeActionKinds)) {\r\n                    supportedActions.push(...provider.providedCodeActionKinds);\r\n                }\r\n            }\r\n            this._supportedCodeActions.set(supportedActions.join(\' \'));\r\n            this._codeActionOracle.value = new codeActionModel_CodeActionOracle(this._editor, this._markerService, trigger => {\r\n                var _a;\r\n                if (!trigger) {\r\n                    this.setState(codeActionModel_CodeActionsState.Empty);\r\n                    return;\r\n                }\r\n                const actions = Object(common_async["createCancelablePromise"])(token => getCodeActions(model, trigger.selection, trigger.trigger, common_progress["Progress"].None, token));\r\n                if (trigger.trigger.type === 1 /* Invoke */) {\r\n                    (_a = this._progressService) === null || _a === void 0 ? void 0 : _a.showWhile(actions, 250);\r\n                }\r\n                this.setState(new codeActionModel_CodeActionsState.Triggered(trigger.trigger, trigger.selection, trigger.position, actions));\r\n            }, undefined);\r\n            this._codeActionOracle.value.trigger({ type: 2 /* Auto */ });\r\n        }\r\n        else {\r\n            this._supportedCodeActions.reset();\r\n        }\r\n    }\r\n    trigger(trigger) {\r\n        if (this._codeActionOracle.value) {\r\n            this._codeActionOracle.value.trigger(trigger);\r\n        }\r\n    }\r\n    setState(newState, skipNotify) {\r\n        if (newState === this._state) {\r\n            return;\r\n        }\r\n        // Cancel old request\r\n        if (this._state.type === 1 /* Triggered */) {\r\n            this._state.cancel();\r\n        }\r\n        this._state = newState;\r\n        if (!skipNotify && !codeActionModel_classPrivateFieldGet(this, _CodeActionModel_isDisposed, "f")) {\r\n            this._onDidChangeState.fire(newState);\r\n        }\r\n    }\r\n}\r\n_CodeActionModel_isDisposed = new WeakMap();\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/codeActionCommands.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar codeActionCommands_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar codeActionCommands_param = (undefined && undefined.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nvar codeActionCommands_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction contextKeyForSupportedActions(kind) {\r\n    return contextkey["ContextKeyExpr"].regex(SUPPORTED_CODE_ACTIONS.keys()[0], new RegExp(\'(\\\\s|^)\' + Object(strings["escapeRegExpCharacters"])(kind.value) + \'\\\\b\'));\r\n}\r\nconst argsSchema = {\r\n    type: \'object\',\r\n    defaultSnippets: [{ body: { kind: \'\' } }],\r\n    properties: {\r\n        \'kind\': {\r\n            type: \'string\',\r\n            description: nls["localize"](\'args.schema.kind\', "Kind of the code action to run."),\r\n        },\r\n        \'apply\': {\r\n            type: \'string\',\r\n            description: nls["localize"](\'args.schema.apply\', "Controls when the returned actions are applied."),\r\n            default: "ifSingle" /* IfSingle */,\r\n            enum: ["first" /* First */, "ifSingle" /* IfSingle */, "never" /* Never */],\r\n            enumDescriptions: [\r\n                nls["localize"](\'args.schema.apply.first\', "Always apply the first returned code action."),\r\n                nls["localize"](\'args.schema.apply.ifSingle\', "Apply the first returned code action if it is the only one."),\r\n                nls["localize"](\'args.schema.apply.never\', "Do not apply the returned code actions."),\r\n            ]\r\n        },\r\n        \'preferred\': {\r\n            type: \'boolean\',\r\n            default: false,\r\n            description: nls["localize"](\'args.schema.preferred\', "Controls if only preferred code actions should be returned."),\r\n        }\r\n    }\r\n};\r\nlet codeActionCommands_QuickFixController = class QuickFixController extends lifecycle["Disposable"] {\r\n    constructor(editor, markerService, contextKeyService, progressService, _instantiationService) {\r\n        super();\r\n        this._instantiationService = _instantiationService;\r\n        this._editor = editor;\r\n        this._model = this._register(new codeActionModel_CodeActionModel(this._editor, markerService, contextKeyService, progressService));\r\n        this._register(this._model.onDidChangeState(newState => this.update(newState)));\r\n        this._ui = new Lazy(() => this._register(new codeActionUi_CodeActionUi(editor, codeActionCommands_QuickFixAction.Id, codeActionCommands_AutoFixAction.Id, {\r\n            applyCodeAction: (action, retrigger) => codeActionCommands_awaiter(this, void 0, void 0, function* () {\r\n                try {\r\n                    yield this._applyCodeAction(action);\r\n                }\r\n                finally {\r\n                    if (retrigger) {\r\n                        this._trigger({ type: 2 /* Auto */, filter: {} });\r\n                    }\r\n                }\r\n            })\r\n        }, this._instantiationService)));\r\n    }\r\n    static get(editor) {\r\n        return editor.getContribution(QuickFixController.ID);\r\n    }\r\n    update(newState) {\r\n        this._ui.getValue().update(newState);\r\n    }\r\n    showCodeActions(trigger, actions, at) {\r\n        return this._ui.getValue().showCodeActionList(trigger, actions, at, { includeDisabledActions: false });\r\n    }\r\n    manualTriggerAtCurrentPosition(notAvailableMessage, filter, autoApply) {\r\n        if (!this._editor.hasModel()) {\r\n            return;\r\n        }\r\n        messageController_MessageController.get(this._editor).closeMessage();\r\n        const triggerPosition = this._editor.getPosition();\r\n        this._trigger({ type: 1 /* Invoke */, filter, autoApply, context: { notAvailableMessage, position: triggerPosition } });\r\n    }\r\n    _trigger(trigger) {\r\n        return this._model.trigger(trigger);\r\n    }\r\n    _applyCodeAction(action) {\r\n        return this._instantiationService.invokeFunction(applyCodeAction, action, this._editor);\r\n    }\r\n};\r\ncodeActionCommands_QuickFixController.ID = \'editor.contrib.quickFixController\';\r\ncodeActionCommands_QuickFixController = codeActionCommands_decorate([\r\n    codeActionCommands_param(1, markers["IMarkerService"]),\r\n    codeActionCommands_param(2, contextkey["IContextKeyService"]),\r\n    codeActionCommands_param(3, common_progress["IEditorProgressService"]),\r\n    codeActionCommands_param(4, instantiation["IInstantiationService"])\r\n], codeActionCommands_QuickFixController);\r\n\r\nfunction applyCodeAction(accessor, item, editor) {\r\n    return codeActionCommands_awaiter(this, void 0, void 0, function* () {\r\n        const bulkEditService = accessor.get(services_bulkEditService["IBulkEditService"]);\r\n        const commandService = accessor.get(common_commands["ICommandService"]);\r\n        const telemetryService = accessor.get(telemetry["ITelemetryService"]);\r\n        const notificationService = accessor.get(notification["INotificationService"]);\r\n        telemetryService.publicLog2(\'codeAction.applyCodeAction\', {\r\n            codeActionTitle: item.action.title,\r\n            codeActionKind: item.action.kind,\r\n            codeActionIsPreferred: !!item.action.isPreferred,\r\n        });\r\n        yield item.resolve(cancellation["CancellationToken"].None);\r\n        if (item.action.edit) {\r\n            yield bulkEditService.apply(services_bulkEditService["ResourceEdit"].convert(item.action.edit), { editor, label: item.action.title });\r\n        }\r\n        if (item.action.command) {\r\n            try {\r\n                yield commandService.executeCommand(item.action.command.id, ...(item.action.command.arguments || []));\r\n            }\r\n            catch (err) {\r\n                const message = asMessage(err);\r\n                notificationService.error(typeof message === \'string\'\r\n                    ? message\r\n                    : nls["localize"](\'applyCodeActionFailed\', "An unknown error occurred while applying the code action"));\r\n            }\r\n        }\r\n    });\r\n}\r\nfunction asMessage(err) {\r\n    if (typeof err === \'string\') {\r\n        return err;\r\n    }\r\n    else if (err instanceof Error && typeof err.message === \'string\') {\r\n        return err.message;\r\n    }\r\n    else {\r\n        return undefined;\r\n    }\r\n}\r\nfunction triggerCodeActionsForEditorSelection(editor, notAvailableMessage, filter, autoApply) {\r\n    if (editor.hasModel()) {\r\n        const controller = codeActionCommands_QuickFixController.get(editor);\r\n        if (controller) {\r\n            controller.manualTriggerAtCurrentPosition(notAvailableMessage, filter, autoApply);\r\n        }\r\n    }\r\n}\r\nclass codeActionCommands_QuickFixAction extends editorExtensions["EditorAction"] {\r\n    constructor() {\r\n        super({\r\n            id: codeActionCommands_QuickFixAction.Id,\r\n            label: nls["localize"](\'quickfix.trigger.label\', "Quick Fix..."),\r\n            alias: \'Quick Fix...\',\r\n            precondition: contextkey["ContextKeyExpr"].and(editorContextKeys["EditorContextKeys"].writable, editorContextKeys["EditorContextKeys"].hasCodeActionsProvider),\r\n            kbOpts: {\r\n                kbExpr: editorContextKeys["EditorContextKeys"].editorTextFocus,\r\n                primary: 2048 /* CtrlCmd */ | 84 /* US_DOT */,\r\n                weight: 100 /* EditorContrib */\r\n            }\r\n        });\r\n    }\r\n    run(_accessor, editor) {\r\n        return triggerCodeActionsForEditorSelection(editor, nls["localize"](\'editor.action.quickFix.noneMessage\', "No code actions available"), undefined, undefined);\r\n    }\r\n}\r\ncodeActionCommands_QuickFixAction.Id = \'editor.action.quickFix\';\r\nclass codeActionCommands_CodeActionCommand extends editorExtensions["EditorCommand"] {\r\n    constructor() {\r\n        super({\r\n            id: codeActionCommandId,\r\n            precondition: contextkey["ContextKeyExpr"].and(editorContextKeys["EditorContextKeys"].writable, editorContextKeys["EditorContextKeys"].hasCodeActionsProvider),\r\n            description: {\r\n                description: \'Trigger a code action\',\r\n                args: [{ name: \'args\', schema: argsSchema, }]\r\n            }\r\n        });\r\n    }\r\n    runEditorCommand(_accessor, editor, userArgs) {\r\n        const args = CodeActionCommandArgs.fromUser(userArgs, {\r\n            kind: CodeActionKind.Empty,\r\n            apply: "ifSingle" /* IfSingle */,\r\n        });\r\n        return triggerCodeActionsForEditorSelection(editor, typeof (userArgs === null || userArgs === void 0 ? void 0 : userArgs.kind) === \'string\'\r\n            ? args.preferred\r\n                ? nls["localize"](\'editor.action.codeAction.noneMessage.preferred.kind\', "No preferred code actions for \'{0}\' available", userArgs.kind)\r\n                : nls["localize"](\'editor.action.codeAction.noneMessage.kind\', "No code actions for \'{0}\' available", userArgs.kind)\r\n            : args.preferred\r\n                ? nls["localize"](\'editor.action.codeAction.noneMessage.preferred\', "No preferred code actions available")\r\n                : nls["localize"](\'editor.action.codeAction.noneMessage\', "No code actions available"), {\r\n            include: args.kind,\r\n            includeSourceActions: true,\r\n            onlyIncludePreferredActions: args.preferred,\r\n        }, args.apply);\r\n    }\r\n}\r\nclass codeActionCommands_RefactorAction extends editorExtensions["EditorAction"] {\r\n    constructor() {\r\n        super({\r\n            id: refactorCommandId,\r\n            label: nls["localize"](\'refactor.label\', "Refactor..."),\r\n            alias: \'Refactor...\',\r\n            precondition: contextkey["ContextKeyExpr"].and(editorContextKeys["EditorContextKeys"].writable, editorContextKeys["EditorContextKeys"].hasCodeActionsProvider),\r\n            kbOpts: {\r\n                kbExpr: editorContextKeys["EditorContextKeys"].editorTextFocus,\r\n                primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 48 /* KEY_R */,\r\n                mac: {\r\n                    primary: 256 /* WinCtrl */ | 1024 /* Shift */ | 48 /* KEY_R */\r\n                },\r\n                weight: 100 /* EditorContrib */\r\n            },\r\n            contextMenuOpts: {\r\n                group: \'1_modification\',\r\n                order: 2,\r\n                when: contextkey["ContextKeyExpr"].and(editorContextKeys["EditorContextKeys"].writable, contextKeyForSupportedActions(CodeActionKind.Refactor)),\r\n            },\r\n            description: {\r\n                description: \'Refactor...\',\r\n                args: [{ name: \'args\', schema: argsSchema }]\r\n            }\r\n        });\r\n    }\r\n    run(_accessor, editor, userArgs) {\r\n        const args = CodeActionCommandArgs.fromUser(userArgs, {\r\n            kind: CodeActionKind.Refactor,\r\n            apply: "never" /* Never */\r\n        });\r\n        return triggerCodeActionsForEditorSelection(editor, typeof (userArgs === null || userArgs === void 0 ? void 0 : userArgs.kind) === \'string\'\r\n            ? args.preferred\r\n                ? nls["localize"](\'editor.action.refactor.noneMessage.preferred.kind\', "No preferred refactorings for \'{0}\' available", userArgs.kind)\r\n                : nls["localize"](\'editor.action.refactor.noneMessage.kind\', "No refactorings for \'{0}\' available", userArgs.kind)\r\n            : args.preferred\r\n                ? nls["localize"](\'editor.action.refactor.noneMessage.preferred\', "No preferred refactorings available")\r\n                : nls["localize"](\'editor.action.refactor.noneMessage\', "No refactorings available"), {\r\n            include: CodeActionKind.Refactor.contains(args.kind) ? args.kind : CodeActionKind.None,\r\n            onlyIncludePreferredActions: args.preferred,\r\n        }, args.apply);\r\n    }\r\n}\r\nclass codeActionCommands_SourceAction extends editorExtensions["EditorAction"] {\r\n    constructor() {\r\n        super({\r\n            id: sourceActionCommandId,\r\n            label: nls["localize"](\'source.label\', "Source Action..."),\r\n            alias: \'Source Action...\',\r\n            precondition: contextkey["ContextKeyExpr"].and(editorContextKeys["EditorContextKeys"].writable, editorContextKeys["EditorContextKeys"].hasCodeActionsProvider),\r\n            contextMenuOpts: {\r\n                group: \'1_modification\',\r\n                order: 2.1,\r\n                when: contextkey["ContextKeyExpr"].and(editorContextKeys["EditorContextKeys"].writable, contextKeyForSupportedActions(CodeActionKind.Source)),\r\n            },\r\n            description: {\r\n                description: \'Source Action...\',\r\n                args: [{ name: \'args\', schema: argsSchema }]\r\n            }\r\n        });\r\n    }\r\n    run(_accessor, editor, userArgs) {\r\n        const args = CodeActionCommandArgs.fromUser(userArgs, {\r\n            kind: CodeActionKind.Source,\r\n            apply: "never" /* Never */\r\n        });\r\n        return triggerCodeActionsForEditorSelection(editor, typeof (userArgs === null || userArgs === void 0 ? void 0 : userArgs.kind) === \'string\'\r\n            ? args.preferred\r\n                ? nls["localize"](\'editor.action.source.noneMessage.preferred.kind\', "No preferred source actions for \'{0}\' available", userArgs.kind)\r\n                : nls["localize"](\'editor.action.source.noneMessage.kind\', "No source actions for \'{0}\' available", userArgs.kind)\r\n            : args.preferred\r\n                ? nls["localize"](\'editor.action.source.noneMessage.preferred\', "No preferred source actions available")\r\n                : nls["localize"](\'editor.action.source.noneMessage\', "No source actions available"), {\r\n            include: CodeActionKind.Source.contains(args.kind) ? args.kind : CodeActionKind.None,\r\n            includeSourceActions: true,\r\n            onlyIncludePreferredActions: args.preferred,\r\n        }, args.apply);\r\n    }\r\n}\r\nclass codeActionCommands_OrganizeImportsAction extends editorExtensions["EditorAction"] {\r\n    constructor() {\r\n        super({\r\n            id: organizeImportsCommandId,\r\n            label: nls["localize"](\'organizeImports.label\', "Organize Imports"),\r\n            alias: \'Organize Imports\',\r\n            precondition: contextkey["ContextKeyExpr"].and(editorContextKeys["EditorContextKeys"].writable, contextKeyForSupportedActions(CodeActionKind.SourceOrganizeImports)),\r\n            kbOpts: {\r\n                kbExpr: editorContextKeys["EditorContextKeys"].editorTextFocus,\r\n                primary: 1024 /* Shift */ | 512 /* Alt */ | 45 /* KEY_O */,\r\n                weight: 100 /* EditorContrib */\r\n            },\r\n        });\r\n    }\r\n    run(_accessor, editor) {\r\n        return triggerCodeActionsForEditorSelection(editor, nls["localize"](\'editor.action.organize.noneMessage\', "No organize imports action available"), { include: CodeActionKind.SourceOrganizeImports, includeSourceActions: true }, "ifSingle" /* IfSingle */);\r\n    }\r\n}\r\nclass codeActionCommands_FixAllAction extends editorExtensions["EditorAction"] {\r\n    constructor() {\r\n        super({\r\n            id: fixAllCommandId,\r\n            label: nls["localize"](\'fixAll.label\', "Fix All"),\r\n            alias: \'Fix All\',\r\n            precondition: contextkey["ContextKeyExpr"].and(editorContextKeys["EditorContextKeys"].writable, contextKeyForSupportedActions(CodeActionKind.SourceFixAll))\r\n        });\r\n    }\r\n    run(_accessor, editor) {\r\n        return triggerCodeActionsForEditorSelection(editor, nls["localize"](\'fixAll.noneMessage\', "No fix all action available"), { include: CodeActionKind.SourceFixAll, includeSourceActions: true }, "ifSingle" /* IfSingle */);\r\n    }\r\n}\r\nclass codeActionCommands_AutoFixAction extends editorExtensions["EditorAction"] {\r\n    constructor() {\r\n        super({\r\n            id: codeActionCommands_AutoFixAction.Id,\r\n            label: nls["localize"](\'autoFix.label\', "Auto Fix..."),\r\n            alias: \'Auto Fix...\',\r\n            precondition: contextkey["ContextKeyExpr"].and(editorContextKeys["EditorContextKeys"].writable, contextKeyForSupportedActions(CodeActionKind.QuickFix)),\r\n            kbOpts: {\r\n                kbExpr: editorContextKeys["EditorContextKeys"].editorTextFocus,\r\n                primary: 512 /* Alt */ | 1024 /* Shift */ | 84 /* US_DOT */,\r\n                mac: {\r\n                    primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 84 /* US_DOT */\r\n                },\r\n                weight: 100 /* EditorContrib */\r\n            }\r\n        });\r\n    }\r\n    run(_accessor, editor) {\r\n        return triggerCodeActionsForEditorSelection(editor, nls["localize"](\'editor.action.autoFix.noneMessage\', "No auto fixes available"), {\r\n            include: CodeActionKind.QuickFix,\r\n            onlyIncludePreferredActions: true\r\n        }, "ifSingle" /* IfSingle */);\r\n    }\r\n}\r\ncodeActionCommands_AutoFixAction.Id = \'editor.action.autoFix\';\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/hover/markerHoverParticipant.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar markerHoverParticipant_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar markerHoverParticipant_param = (undefined && undefined.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst markerHoverParticipant_$ = dom["$"];\r\nclass MarkerHover {\r\n    constructor(owner, range, marker) {\r\n        this.owner = owner;\r\n        this.range = range;\r\n        this.marker = marker;\r\n    }\r\n    isValidForHoverAnchor(anchor) {\r\n        return (anchor.type === 1 /* Range */\r\n            && this.range.startColumn <= anchor.range.startColumn\r\n            && this.range.endColumn >= anchor.range.endColumn);\r\n    }\r\n}\r\nconst markerCodeActionTrigger = {\r\n    type: 1 /* Invoke */,\r\n    filter: { include: CodeActionKind.QuickFix }\r\n};\r\nlet markerHoverParticipant_MarkerHoverParticipant = class MarkerHoverParticipant {\r\n    constructor(_editor, _hover, _markerDecorationsService, _openerService) {\r\n        this._editor = _editor;\r\n        this._hover = _hover;\r\n        this._markerDecorationsService = _markerDecorationsService;\r\n        this._openerService = _openerService;\r\n        this.recentMarkerCodeActionsInfo = undefined;\r\n    }\r\n    computeSync(anchor, lineDecorations) {\r\n        if (!this._editor.hasModel() || anchor.type !== 1 /* Range */) {\r\n            return [];\r\n        }\r\n        const model = this._editor.getModel();\r\n        const lineNumber = anchor.range.startLineNumber;\r\n        const maxColumn = model.getLineMaxColumn(lineNumber);\r\n        const result = [];\r\n        for (const d of lineDecorations) {\r\n            const startColumn = (d.range.startLineNumber === lineNumber) ? d.range.startColumn : 1;\r\n            const endColumn = (d.range.endLineNumber === lineNumber) ? d.range.endColumn : maxColumn;\r\n            const marker = this._markerDecorationsService.getMarker(model.uri, d);\r\n            if (!marker) {\r\n                continue;\r\n            }\r\n            const range = new core_range["Range"](anchor.range.startLineNumber, startColumn, anchor.range.startLineNumber, endColumn);\r\n            result.push(new MarkerHover(this, range, marker));\r\n        }\r\n        return result;\r\n    }\r\n    renderHoverParts(hoverParts, fragment, statusBar) {\r\n        if (!hoverParts.length) {\r\n            return lifecycle["Disposable"].None;\r\n        }\r\n        const disposables = new lifecycle["DisposableStore"]();\r\n        hoverParts.forEach(msg => fragment.appendChild(this.renderMarkerHover(msg, disposables)));\r\n        const markerHoverForStatusbar = hoverParts.length === 1 ? hoverParts[0] : hoverParts.sort((a, b) => markers["MarkerSeverity"].compare(a.marker.severity, b.marker.severity))[0];\r\n        this.renderMarkerStatusbar(markerHoverForStatusbar, statusBar, disposables);\r\n        return disposables;\r\n    }\r\n    renderMarkerHover(markerHover, disposables) {\r\n        const hoverElement = markerHoverParticipant_$(\'div.hover-row\');\r\n        const markerElement = dom["append"](hoverElement, markerHoverParticipant_$(\'div.marker.hover-contents\'));\r\n        const { source, message, code, relatedInformation } = markerHover.marker;\r\n        this._editor.applyFontInfo(markerElement);\r\n        const messageElement = dom["append"](markerElement, markerHoverParticipant_$(\'span\'));\r\n        messageElement.style.whiteSpace = \'pre-wrap\';\r\n        messageElement.innerText = message;\r\n        if (source || code) {\r\n            // Code has link\r\n            if (code && typeof code !== \'string\') {\r\n                const sourceAndCodeElement = markerHoverParticipant_$(\'span\');\r\n                if (source) {\r\n                    const sourceElement = dom["append"](sourceAndCodeElement, markerHoverParticipant_$(\'span\'));\r\n                    sourceElement.innerText = source;\r\n                }\r\n                const codeLink = dom["append"](sourceAndCodeElement, markerHoverParticipant_$(\'a.code-link\'));\r\n                codeLink.setAttribute(\'href\', code.target.toString());\r\n                disposables.add(dom["addDisposableListener"](codeLink, \'click\', (e) => {\r\n                    this._openerService.open(code.target, { allowCommands: true });\r\n                    e.preventDefault();\r\n                    e.stopPropagation();\r\n                }));\r\n                const codeElement = dom["append"](codeLink, markerHoverParticipant_$(\'span\'));\r\n                codeElement.innerText = code.value;\r\n                const detailsElement = dom["append"](markerElement, sourceAndCodeElement);\r\n                detailsElement.style.opacity = \'0.6\';\r\n                detailsElement.style.paddingLeft = \'6px\';\r\n            }\r\n            else {\r\n                const detailsElement = dom["append"](markerElement, markerHoverParticipant_$(\'span\'));\r\n                detailsElement.style.opacity = \'0.6\';\r\n                detailsElement.style.paddingLeft = \'6px\';\r\n                detailsElement.innerText = source && code ? `${source}(${code})` : source ? source : `(${code})`;\r\n            }\r\n        }\r\n        if (Object(arrays["isNonEmptyArray"])(relatedInformation)) {\r\n            for (const { message, resource, startLineNumber, startColumn } of relatedInformation) {\r\n                const relatedInfoContainer = dom["append"](markerElement, markerHoverParticipant_$(\'div\'));\r\n                relatedInfoContainer.style.marginTop = \'8px\';\r\n                const a = dom["append"](relatedInfoContainer, markerHoverParticipant_$(\'a\'));\r\n                a.innerText = `${Object(common_resources["basename"])(resource)}(${startLineNumber}, ${startColumn}): `;\r\n                a.style.cursor = \'pointer\';\r\n                disposables.add(dom["addDisposableListener"](a, \'click\', (e) => {\r\n                    e.stopPropagation();\r\n                    e.preventDefault();\r\n                    if (this._openerService) {\r\n                        this._openerService.open(resource, {\r\n                            fromUserGesture: true,\r\n                            editorOptions: { selection: { startLineNumber, startColumn } }\r\n                        }).catch(errors["onUnexpectedError"]);\r\n                    }\r\n                }));\r\n                const messageElement = dom["append"](relatedInfoContainer, markerHoverParticipant_$(\'span\'));\r\n                messageElement.innerText = message;\r\n                this._editor.applyFontInfo(messageElement);\r\n            }\r\n        }\r\n        return hoverElement;\r\n    }\r\n    renderMarkerStatusbar(markerHover, statusBar, disposables) {\r\n        if (markerHover.marker.severity === markers["MarkerSeverity"].Error || markerHover.marker.severity === markers["MarkerSeverity"].Warning || markerHover.marker.severity === markers["MarkerSeverity"].Info) {\r\n            statusBar.addAction({\r\n                label: nls["localize"](\'view problem\', "View Problem"),\r\n                commandId: gotoError_NextMarkerAction.ID,\r\n                run: () => {\r\n                    this._hover.hide();\r\n                    gotoError_MarkerController.get(this._editor).showAtMarker(markerHover.marker);\r\n                    this._editor.focus();\r\n                }\r\n            });\r\n        }\r\n        if (!this._editor.getOption(80 /* readOnly */)) {\r\n            const quickfixPlaceholderElement = statusBar.append(markerHoverParticipant_$(\'div\'));\r\n            if (this.recentMarkerCodeActionsInfo) {\r\n                if (markers["IMarkerData"].makeKey(this.recentMarkerCodeActionsInfo.marker) === markers["IMarkerData"].makeKey(markerHover.marker)) {\r\n                    if (!this.recentMarkerCodeActionsInfo.hasCodeActions) {\r\n                        quickfixPlaceholderElement.textContent = nls["localize"](\'noQuickFixes\', "No quick fixes available");\r\n                    }\r\n                }\r\n                else {\r\n                    this.recentMarkerCodeActionsInfo = undefined;\r\n                }\r\n            }\r\n            const updatePlaceholderDisposable = this.recentMarkerCodeActionsInfo && !this.recentMarkerCodeActionsInfo.hasCodeActions ? lifecycle["Disposable"].None : disposables.add(Object(common_async["disposableTimeout"])(() => quickfixPlaceholderElement.textContent = nls["localize"](\'checkingForQuickFixes\', "Checking for quick fixes..."), 200));\r\n            if (!quickfixPlaceholderElement.textContent) {\r\n                // Have some content in here to avoid flickering\r\n                quickfixPlaceholderElement.textContent = String.fromCharCode(0xA0); // &nbsp;\r\n            }\r\n            const codeActionsPromise = this.getCodeActions(markerHover.marker);\r\n            disposables.add(Object(lifecycle["toDisposable"])(() => codeActionsPromise.cancel()));\r\n            codeActionsPromise.then(actions => {\r\n                updatePlaceholderDisposable.dispose();\r\n                this.recentMarkerCodeActionsInfo = { marker: markerHover.marker, hasCodeActions: actions.validActions.length > 0 };\r\n                if (!this.recentMarkerCodeActionsInfo.hasCodeActions) {\r\n                    actions.dispose();\r\n                    quickfixPlaceholderElement.textContent = nls["localize"](\'noQuickFixes\', "No quick fixes available");\r\n                    return;\r\n                }\r\n                quickfixPlaceholderElement.style.display = \'none\';\r\n                let showing = false;\r\n                disposables.add(Object(lifecycle["toDisposable"])(() => {\r\n                    if (!showing) {\r\n                        actions.dispose();\r\n                    }\r\n                }));\r\n                statusBar.addAction({\r\n                    label: nls["localize"](\'quick fixes\', "Quick Fix..."),\r\n                    commandId: codeActionCommands_QuickFixAction.Id,\r\n                    run: (target) => {\r\n                        showing = true;\r\n                        const controller = codeActionCommands_QuickFixController.get(this._editor);\r\n                        const elementPosition = dom["getDomNodePagePosition"](target);\r\n                        // Hide the hover pre-emptively, otherwise the editor can close the code actions\r\n                        // context menu as well when using keyboard navigation\r\n                        this._hover.hide();\r\n                        controller.showCodeActions(markerCodeActionTrigger, actions, {\r\n                            x: elementPosition.left + 6,\r\n                            y: elementPosition.top + elementPosition.height + 6\r\n                        });\r\n                    }\r\n                });\r\n            }, errors["onUnexpectedError"]);\r\n        }\r\n    }\r\n    getCodeActions(marker) {\r\n        return Object(common_async["createCancelablePromise"])(cancellationToken => {\r\n            return getCodeActions(this._editor.getModel(), new core_range["Range"](marker.startLineNumber, marker.startColumn, marker.endLineNumber, marker.endColumn), markerCodeActionTrigger, common_progress["Progress"].None, cancellationToken);\r\n        });\r\n    }\r\n};\r\nmarkerHoverParticipant_MarkerHoverParticipant = markerHoverParticipant_decorate([\r\n    markerHoverParticipant_param(2, markersDecorationService["IMarkerDecorationsService"]),\r\n    markerHoverParticipant_param(3, common_opener["IOpenerService"])\r\n], markerHoverParticipant_MarkerHoverParticipant);\r\n\r\nObject(common_themeService["registerThemingParticipant"])((theme, collector) => {\r\n    const linkFg = theme.getColor(colorRegistry["textLinkForeground"]);\r\n    if (linkFg) {\r\n        collector.addRule(`.monaco-hover .hover-contents a.code-link span { color: ${linkFg}; }`);\r\n    }\r\n    const activeLinkFg = theme.getColor(colorRegistry["textLinkActiveForeground"]);\r\n    if (activeLinkFg) {\r\n        collector.addRule(`.monaco-hover .hover-contents a.code-link span:hover { color: ${activeLinkFg}; }`);\r\n    }\r\n});\r\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/common/iconLabels.js\nvar iconLabels = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/common/iconLabels.js");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/htmlContent.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\nclass htmlContent_MarkdownString {\r\n    constructor(value = \'\', isTrustedOrOptions = false) {\r\n        var _a, _b;\r\n        this.value = value;\r\n        if (typeof this.value !== \'string\') {\r\n            throw Object(errors["illegalArgument"])(\'value\');\r\n        }\r\n        if (typeof isTrustedOrOptions === \'boolean\') {\r\n            this.isTrusted = isTrustedOrOptions;\r\n            this.supportThemeIcons = false;\r\n        }\r\n        else {\r\n            this.isTrusted = (_a = isTrustedOrOptions.isTrusted) !== null && _a !== void 0 ? _a : undefined;\r\n            this.supportThemeIcons = (_b = isTrustedOrOptions.supportThemeIcons) !== null && _b !== void 0 ? _b : false;\r\n        }\r\n    }\r\n    appendText(value, newlineStyle = 0 /* Paragraph */) {\r\n        this.value += escapeMarkdownSyntaxTokens(this.supportThemeIcons ? Object(iconLabels["escapeIcons"])(value) : value)\r\n            .replace(/([ \\t]+)/g, (_match, g1) => \'&nbsp;\'.repeat(g1.length))\r\n            .replace(/^>/gm, \'\\\\>\')\r\n            .replace(/\\n/g, newlineStyle === 1 /* Break */ ? \'\\\\\\n\' : \'\\n\\n\');\r\n        return this;\r\n    }\r\n    appendMarkdown(value) {\r\n        this.value += value;\r\n        return this;\r\n    }\r\n    appendCodeblock(langId, code) {\r\n        this.value += \'\\n```\';\r\n        this.value += langId;\r\n        this.value += \'\\n\';\r\n        this.value += code;\r\n        this.value += \'\\n```\\n\';\r\n        return this;\r\n    }\r\n}\r\nfunction isEmptyMarkdownString(oneOrMany) {\r\n    if (isMarkdownString(oneOrMany)) {\r\n        return !oneOrMany.value;\r\n    }\r\n    else if (Array.isArray(oneOrMany)) {\r\n        return oneOrMany.every(isEmptyMarkdownString);\r\n    }\r\n    else {\r\n        return true;\r\n    }\r\n}\r\nfunction isMarkdownString(thing) {\r\n    if (thing instanceof htmlContent_MarkdownString) {\r\n        return true;\r\n    }\r\n    else if (thing && typeof thing === \'object\') {\r\n        return typeof thing.value === \'string\'\r\n            && (typeof thing.isTrusted === \'boolean\' || thing.isTrusted === undefined)\r\n            && (typeof thing.supportThemeIcons === \'boolean\' || thing.supportThemeIcons === undefined);\r\n    }\r\n    return false;\r\n}\r\nfunction escapeMarkdownSyntaxTokens(text) {\r\n    // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash\r\n    return text.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, \'\\\\$&\');\r\n}\r\nfunction removeMarkdownEscapes(text) {\r\n    if (!text) {\r\n        return text;\r\n    }\r\n    return text.replace(/\\\\([\\\\`*_{}[\\]()#+\\-.!])/g, \'$1\');\r\n}\r\nfunction parseHrefAndDimensions(href) {\r\n    const dimensions = [];\r\n    const splitted = href.split(\'|\').map(s => s.trim());\r\n    href = splitted[0];\r\n    const parameters = splitted[1];\r\n    if (parameters) {\r\n        const heightFromParams = /height=(\\d+)/.exec(parameters);\r\n        const widthFromParams = /width=(\\d+)/.exec(parameters);\r\n        const height = heightFromParams ? heightFromParams[1] : \'\';\r\n        const width = widthFromParams ? widthFromParams[1] : \'\';\r\n        const widthIsFinite = isFinite(parseInt(width));\r\n        const heightIsFinite = isFinite(parseInt(height));\r\n        if (widthIsFinite) {\r\n            dimensions.push(`width="${width}"`);\r\n        }\r\n        if (heightIsFinite) {\r\n            dimensions.push(`height="${height}"`);\r\n        }\r\n    }\r\n    return { href, dimensions };\r\n}\r\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/browser/event.js\nvar browser_event = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/browser/event.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/browser/formattedTextRenderer.js\nvar formattedTextRenderer = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/browser/formattedTextRenderer.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/browser/mouseEvent.js\nvar browser_mouseEvent = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/browser/mouseEvent.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/browser/ui/iconLabel/iconLabels.js\nvar iconLabel_iconLabels = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/browser/ui/iconLabel/iconLabels.js");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/insane/insane.js\nvar require;var require;/*\nThe MIT License (MIT)\n\nCopyright  2015 Nicolas Bevacqua\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the "Software"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nlet __insane_func;\n\n(function () { function r(e, n, t) { function o(i, f) { if (!n[i]) { if (!e[i]) { var c = "function" == typeof require && require; if (!f && c) return require(i, !0); if (u) return u(i, !0); var a = new Error("Cannot find module \'" + i + "\'"); throw a.code = "MODULE_NOT_FOUND", a } var p = n[i] = { exports: {} }; e[i][0].call(p.exports, function (r) { var n = e[i][1][r]; return o(n || r) }, p, p.exports, r, e, n, t) } return n[i].exports } for (var u = "function" == typeof require && require, i = 0; i < t.length; i++)o(t[i]); return o } return r })()({\n\t1: [function (require, module, exports) {\n\t\t\'use strict\';\n\n\t\tvar toMap = require(\'./toMap\');\n\t\tvar uris = [\'background\', \'base\', \'cite\', \'href\', \'longdesc\', \'src\', \'usemap\'];\n\n\t\tmodule.exports = {\n\t\t\turis: toMap(uris) // attributes that have an href and hence need to be sanitized\n\t\t};\n\n\t}, { "./toMap": 10 }], 2: [function (require, module, exports) {\n\t\t\'use strict\';\n\n\t\tvar defaults = {\n\t\t\tallowedAttributes: {\n\t\t\t\t\'*\': [\'title\', \'accesskey\'],\n\t\t\t\ta: [\'href\', \'name\', \'target\', \'aria-label\'],\n\t\t\t\tiframe: [\'allowfullscreen\', \'frameborder\', \'src\'],\n\t\t\t\timg: [\'src\', \'alt\', \'title\', \'aria-label\']\n\t\t\t},\n\t\t\tallowedClasses: {},\n\t\t\tallowedSchemes: [\'http\', \'https\', \'mailto\'],\n\t\t\tallowedTags: [\n\t\t\t\t\'a\', \'abbr\', \'article\', \'b\', \'blockquote\', \'br\', \'caption\', \'code\', \'del\', \'details\', \'div\', \'em\',\n\t\t\t\t\'h1\', \'h2\', \'h3\', \'h4\', \'h5\', \'h6\', \'hr\', \'i\', \'img\', \'ins\', \'kbd\', \'li\', \'main\', \'mark\',\n\t\t\t\t\'ol\', \'p\', \'pre\', \'section\', \'span\', \'strike\', \'strong\', \'sub\', \'summary\', \'sup\', \'table\',\n\t\t\t\t\'tbody\', \'td\', \'th\', \'thead\', \'tr\', \'u\', \'ul\'\n\t\t\t],\n\t\t\tfilter: null\n\t\t};\n\n\t\tmodule.exports = defaults;\n\n\t}, {}], 3: [function (require, module, exports) {\n\t\t\'use strict\';\n\n\t\tvar toMap = require(\'./toMap\');\n\t\tvar voids = [\'area\', \'br\', \'col\', \'hr\', \'img\', \'wbr\', \'input\', \'base\', \'basefont\', \'link\', \'meta\'];\n\n\t\tmodule.exports = {\n\t\t\tvoids: toMap(voids)\n\t\t};\n\n\t}, { "./toMap": 10 }], 4: [function (require, module, exports) {\n\t\t\'use strict\';\n\n\t\tvar he = require(\'he\');\n\t\tvar assign = require(\'assignment\');\n\t\tvar parser = require(\'./parser\');\n\t\tvar sanitizer = require(\'./sanitizer\');\n\t\tvar defaults = require(\'./defaults\');\n\n\t\tfunction insane(html, options, strict) {\n\t\t\tvar buffer = [];\n\t\t\tvar configuration = strict === true ? options : assign({}, defaults, options);\n\t\t\tvar handler = sanitizer(buffer, configuration);\n\n\t\t\tparser(html, handler);\n\n\t\t\treturn buffer.join(\'\');\n\t\t}\n\n\t\tinsane.defaults = defaults;\n\t\tmodule.exports = insane;\n\t\t__insane_func = insane;\n\n\t}, { "./defaults": 2, "./parser": 7, "./sanitizer": 8, "assignment": 6, "he": 9 }], 5: [function (require, module, exports) {\n\t\t\'use strict\';\n\n\t\tmodule.exports = function lowercase(string) {\n\t\t\treturn typeof string === \'string\' ? string.toLowerCase() : string;\n\t\t};\n\n\t}, {}], 6: [function (require, module, exports) {\n\t\t\'use strict\';\n\n\t\tfunction assignment(result) {\n\t\t\tvar stack = Array.prototype.slice.call(arguments, 1);\n\t\t\tvar item;\n\t\t\tvar key;\n\t\t\twhile (stack.length) {\n\t\t\t\titem = stack.shift();\n\t\t\t\tfor (key in item) {\n\t\t\t\t\tif (item.hasOwnProperty(key)) {\n\t\t\t\t\t\tif (Object.prototype.toString.call(result[key]) === \'[object Object]\') {\n\t\t\t\t\t\t\tresult[key] = assignment(result[key], item[key]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult[key] = item[key];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tmodule.exports = assignment;\n\n\t}, {}], 7: [function (require, module, exports) {\n\t\t\'use strict\';\n\n\t\tvar he = require(\'he\');\n\t\tvar lowercase = require(\'./lowercase\');\n\t\tvar attributes = require(\'./attributes\');\n\t\tvar elements = require(\'./elements\');\n\t\tvar rstart = /^<\\s*([\\w:-]+)((?:\\s+[\\w:-]+(?:\\s*=\\s*(?:(?:"[^"]*")|(?:\'[^\']*\')|[^>\\s]+))?)*)\\s*(\\/?)\\s*>/;\n\t\tvar rend = /^<\\s*\\/\\s*([\\w:-]+)[^>]*>/;\n\t\tvar rattrs = /([\\w:-]+)(?:\\s*=\\s*(?:(?:"((?:[^"])*)")|(?:\'((?:[^\'])*)\')|([^>\\s]+)))?/g;\n\t\tvar rtag = /^</;\n\t\tvar rtagend = /^<\\s*\\//;\n\n\t\tfunction createStack() {\n\t\t\tvar stack = [];\n\t\t\tstack.lastItem = function lastItem() {\n\t\t\t\treturn stack[stack.length - 1];\n\t\t\t};\n\t\t\treturn stack;\n\t\t}\n\n\t\tfunction parser(html, handler) {\n\t\t\tvar stack = createStack();\n\t\t\tvar last = html;\n\t\t\tvar chars;\n\n\t\t\twhile (html) {\n\t\t\t\tparsePart();\n\t\t\t}\n\t\t\tparseEndTag(); // clean up any remaining tags\n\n\t\t\tfunction parsePart() {\n\t\t\t\tchars = true;\n\t\t\t\tparseTag();\n\n\t\t\t\tvar same = html === last;\n\t\t\t\tlast = html;\n\n\t\t\t\tif (same) { // discard, because it\'s invalid\n\t\t\t\t\thtml = \'\';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction parseTag() {\n\t\t\t\tif (html.substr(0, 4) === \'\x3c!--\') { // comments\n\t\t\t\t\tparseComment();\n\t\t\t\t} else if (rtagend.test(html)) {\n\t\t\t\t\tparseEdge(rend, parseEndTag);\n\t\t\t\t} else if (rtag.test(html)) {\n\t\t\t\t\tparseEdge(rstart, parseStartTag);\n\t\t\t\t}\n\t\t\t\tparseTagDecode();\n\t\t\t}\n\n\t\t\tfunction parseEdge(regex, parser) {\n\t\t\t\tvar match = html.match(regex);\n\t\t\t\tif (match) {\n\t\t\t\t\thtml = html.substring(match[0].length);\n\t\t\t\t\tmatch[0].replace(regex, parser);\n\t\t\t\t\tchars = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction parseComment() {\n\t\t\t\tvar index = html.indexOf(\'--\x3e\');\n\t\t\t\tif (index >= 0) {\n\t\t\t\t\tif (handler.comment) {\n\t\t\t\t\t\thandler.comment(html.substring(4, index));\n\t\t\t\t\t}\n\t\t\t\t\thtml = html.substring(index + 3);\n\t\t\t\t\tchars = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction parseTagDecode() {\n\t\t\t\tif (!chars) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar text;\n\t\t\t\tvar index = html.indexOf(\'<\');\n\t\t\t\tif (index >= 0) {\n\t\t\t\t\ttext = html.substring(0, index);\n\t\t\t\t\thtml = html.substring(index);\n\t\t\t\t} else {\n\t\t\t\t\ttext = html;\n\t\t\t\t\thtml = \'\';\n\t\t\t\t}\n\t\t\t\tif (handler.chars) {\n\t\t\t\t\thandler.chars(text);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction parseStartTag(tag, tagName, rest, unary) {\n\t\t\t\tvar attrs = {};\n\t\t\t\tvar low = lowercase(tagName);\n\t\t\t\tvar u = elements.voids[low] || !!unary;\n\n\t\t\t\trest.replace(rattrs, attrReplacer);\n\n\t\t\t\tif (!u) {\n\t\t\t\t\tstack.push(low);\n\t\t\t\t}\n\t\t\t\tif (handler.start) {\n\t\t\t\t\thandler.start(low, attrs, u);\n\t\t\t\t}\n\n\t\t\t\tfunction attrReplacer(match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {\n\t\t\t\t\tif (doubleQuotedValue === void 0 && singleQuotedValue === void 0 && unquotedValue === void 0) {\n\t\t\t\t\t\tattrs[name] = void 0; // attribute is like <button disabled></button>\n\t\t\t\t\t} else {\n\t\t\t\t\t\tattrs[name] = he.decode(doubleQuotedValue || singleQuotedValue || unquotedValue || \'\');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction parseEndTag(tag, tagName) {\n\t\t\t\tvar i;\n\t\t\t\tvar pos = 0;\n\t\t\t\tvar low = lowercase(tagName);\n\t\t\t\tif (low) {\n\t\t\t\t\tfor (pos = stack.length - 1; pos >= 0; pos--) {\n\t\t\t\t\t\tif (stack[pos] === low) {\n\t\t\t\t\t\t\tbreak; // find the closest opened tag of the same type\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pos >= 0) {\n\t\t\t\t\tfor (i = stack.length - 1; i >= pos; i--) {\n\t\t\t\t\t\tif (handler.end) { // close all the open elements, up the stack\n\t\t\t\t\t\t\thandler.end(stack[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstack.length = pos;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmodule.exports = parser;\n\n\t}, { "./attributes": 1, "./elements": 3, "./lowercase": 5, "he": 9 }], 8: [function (require, module, exports) {\n\t\t\'use strict\';\n\n\t\tvar he = require(\'he\');\n\t\tvar lowercase = require(\'./lowercase\');\n\t\tvar attributes = require(\'./attributes\');\n\t\tvar elements = require(\'./elements\');\n\n\t\tfunction sanitizer(buffer, options) {\n\t\t\tvar last;\n\t\t\tvar context;\n\t\t\tvar o = options || {};\n\n\t\t\treset();\n\n\t\t\treturn {\n\t\t\t\tstart: start,\n\t\t\t\tend: end,\n\t\t\t\tchars: chars\n\t\t\t};\n\n\t\t\tfunction out(value) {\n\t\t\t\tbuffer.push(value);\n\t\t\t}\n\n\t\t\tfunction start(tag, attrs, unary) {\n\t\t\t\tvar low = lowercase(tag);\n\n\t\t\t\tif (context.ignoring) {\n\t\t\t\t\tignore(low); return;\n\t\t\t\t}\n\t\t\t\tif ((o.allowedTags || []).indexOf(low) === -1) {\n\t\t\t\t\tignore(low); return;\n\t\t\t\t}\n\t\t\t\tif (o.filter && !o.filter({ tag: low, attrs: attrs })) {\n\t\t\t\t\tignore(low); return;\n\t\t\t\t}\n\n\t\t\t\tout(\'<\');\n\t\t\t\tout(low);\n\t\t\t\tObject.keys(attrs).forEach(parse);\n\t\t\t\tout(unary ? \'/>\' : \'>\');\n\n\t\t\t\tfunction parse(key) {\n\t\t\t\t\tvar value = attrs[key];\n\t\t\t\t\tvar classesOk = (o.allowedClasses || {})[low] || [];\n\t\t\t\t\tvar attrsOk = (o.allowedAttributes || {})[low] || [];\n\t\t\t\t\tattrsOk = attrsOk.concat((o.allowedAttributes || {})[\'*\'] || []);\n\t\t\t\t\tvar valid;\n\t\t\t\t\tvar lkey = lowercase(key);\n\t\t\t\t\tif (lkey === \'class\' && attrsOk.indexOf(lkey) === -1) {\n\t\t\t\t\t\tvalue = value.split(\' \').filter(isValidClass).join(\' \').trim();\n\t\t\t\t\t\tvalid = value.length;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalid = attrsOk.indexOf(lkey) !== -1 && (attributes.uris[lkey] !== true || testUrl(value));\n\t\t\t\t\t}\n\t\t\t\t\tif (valid) {\n\t\t\t\t\t\tout(\' \');\n\t\t\t\t\t\tout(key);\n\t\t\t\t\t\tif (typeof value === \'string\') {\n\t\t\t\t\t\t\tout(\'="\');\n\t\t\t\t\t\t\tout(he.encode(value));\n\t\t\t\t\t\t\tout(\'"\');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfunction isValidClass(className) {\n\t\t\t\t\t\treturn classesOk && classesOk.indexOf(className) !== -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction end(tag) {\n\t\t\t\tvar low = lowercase(tag);\n\t\t\t\tvar allowed = (o.allowedTags || []).indexOf(low) !== -1;\n\t\t\t\tif (allowed) {\n\t\t\t\t\tif (context.ignoring === false) {\n\t\t\t\t\t\tout(\'</\');\n\t\t\t\t\t\tout(low);\n\t\t\t\t\t\tout(\'>\');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tunignore(low);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tunignore(low);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction testUrl(text) {\n\t\t\t\tvar start = text[0];\n\t\t\t\tif (start === \'#\' || start === \'/\') {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tvar colon = text.indexOf(\':\');\n\t\t\t\tif (colon === -1) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tvar questionmark = text.indexOf(\'?\');\n\t\t\t\tif (questionmark !== -1 && colon > questionmark) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tvar hash = text.indexOf(\'#\');\n\t\t\t\tif (hash !== -1 && colon > hash) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn o.allowedSchemes.some(matches);\n\n\t\t\t\tfunction matches(scheme) {\n\t\t\t\t\treturn text.indexOf(scheme + \':\') === 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction chars(text) {\n\t\t\t\tif (context.ignoring === false) {\n\t\t\t\t\tout(o.transformText ? o.transformText(text) : text);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction ignore(tag) {\n\t\t\t\tif (elements.voids[tag]) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (context.ignoring === false) {\n\t\t\t\t\tcontext = { ignoring: tag, depth: 1 };\n\t\t\t\t} else if (context.ignoring === tag) {\n\t\t\t\t\tcontext.depth++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction unignore(tag) {\n\t\t\t\tif (context.ignoring === tag) {\n\t\t\t\t\tif (--context.depth <= 0) {\n\t\t\t\t\t\treset();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction reset() {\n\t\t\t\tcontext = { ignoring: false, depth: 0 };\n\t\t\t}\n\t\t}\n\n\t\tmodule.exports = sanitizer;\n\n\t}, { "./attributes": 1, "./elements": 3, "./lowercase": 5, "he": 9 }], 9: [function (require, module, exports) {\n\t\t\'use strict\';\n\n\t\tvar escapes = {\n\t\t\t\'&\': \'&amp;\',\n\t\t\t\'<\': \'&lt;\',\n\t\t\t\'>\': \'&gt;\',\n\t\t\t\'"\': \'&quot;\',\n\t\t\t"\'": \'&#39;\'\n\t\t};\n\t\tvar unescapes = {\n\t\t\t\'&amp;\': \'&\',\n\t\t\t\'&lt;\': \'<\',\n\t\t\t\'&gt;\': \'>\',\n\t\t\t\'&quot;\': \'"\',\n\t\t\t\'&#39;\': "\'"\n\t\t};\n\t\tvar rescaped = /(&amp;|&lt;|&gt;|&quot;|&#39;)/g;\n\t\tvar runescaped = /[&<>"\']/g;\n\n\t\tfunction escapeHtmlChar(match) {\n\t\t\treturn escapes[match];\n\t\t}\n\t\tfunction unescapeHtmlChar(match) {\n\t\t\treturn unescapes[match];\n\t\t}\n\n\t\tfunction escapeHtml(text) {\n\t\t\treturn text == null ? \'\' : String(text).replace(runescaped, escapeHtmlChar);\n\t\t}\n\n\t\tfunction unescapeHtml(html) {\n\t\t\treturn html == null ? \'\' : String(html).replace(rescaped, unescapeHtmlChar);\n\t\t}\n\n\t\tescapeHtml.options = unescapeHtml.options = {};\n\n\t\tmodule.exports = {\n\t\t\tencode: escapeHtml,\n\t\t\tescape: escapeHtml,\n\t\t\tdecode: unescapeHtml,\n\t\t\tunescape: unescapeHtml,\n\t\t\tversion: \'1.0.0-browser\'\n\t\t};\n\n\t}, {}], 10: [function (require, module, exports) {\n\t\t\'use strict\';\n\n\t\tfunction toMap(list) {\n\t\t\treturn list.reduce(asKey, {});\n\t\t}\n\n\t\tfunction asKey(accumulator, item) {\n\t\t\taccumulator[item] = true;\n\t\t\treturn accumulator;\n\t\t}\n\n\t\tmodule.exports = toMap;\n\n\t}, {}]\n}, {}, [4]);\n\n// ESM-comment-begin\n// define(function() { return { insane: __insane_func }; });\n// ESM-comment-end\n\n// ESM-uncomment-begin\nvar insane = __insane_func;\n// ESM-uncomment-end\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/common/marked/marked.js\nvar marked = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/common/marked/marked.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/common/marshalling.js\nvar marshalling = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/common/marshalling.js");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/browser/markdownRenderer.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar markdownRenderer_a;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst _ttpInsane = (markdownRenderer_a = window.trustedTypes) === null || markdownRenderer_a === void 0 ? void 0 : markdownRenderer_a.createPolicy(\'insane\', {\r\n    createHTML(value, options) {\r\n        return insane(value, options);\r\n    }\r\n});\r\n/**\r\n * Low-level way create a html element from a markdown string.\r\n *\r\n * **Note** that for most cases you should be using [`MarkdownRenderer`](./src/vs/editor/browser/core/markdownRenderer.ts)\r\n * which comes with support for pretty code block rendering and which uses the default way of handling links.\r\n */\r\nfunction renderMarkdown(markdown, options = {}, markedOptions = {}) {\r\n    var _a;\r\n    const element = Object(formattedTextRenderer["createElement"])(options);\r\n    const _uriMassage = function (part) {\r\n        let data;\r\n        try {\r\n            data = Object(marshalling["parse"])(decodeURIComponent(part));\r\n        }\r\n        catch (e) {\r\n            // ignore\r\n        }\r\n        if (!data) {\r\n            return part;\r\n        }\r\n        data = Object(objects["cloneAndChange"])(data, value => {\r\n            if (markdown.uris && markdown.uris[value]) {\r\n                return common_uri["URI"].revive(markdown.uris[value]);\r\n            }\r\n            else {\r\n                return undefined;\r\n            }\r\n        });\r\n        return encodeURIComponent(JSON.stringify(data));\r\n    };\r\n    const _href = function (href, isDomUri) {\r\n        const data = markdown.uris && markdown.uris[href];\r\n        if (!data) {\r\n            return href; // no uri exists\r\n        }\r\n        let uri = common_uri["URI"].revive(data);\r\n        if (isDomUri) {\r\n            if (href.startsWith(network["Schemas"].data + \':\')) {\r\n                return href;\r\n            }\r\n            // this URI will end up as "src"-attribute of a dom node\r\n            // and because of that special rewriting needs to be done\r\n            // so that the URI uses a protocol that\'s understood by\r\n            // browsers (like http or https)\r\n            return network["FileAccess"].asBrowserUri(uri).toString(true);\r\n        }\r\n        if (common_uri["URI"].parse(href).toString() === uri.toString()) {\r\n            return href; // no transformation performed\r\n        }\r\n        if (uri.query) {\r\n            uri = uri.with({ query: _uriMassage(uri.query) });\r\n        }\r\n        return uri.toString();\r\n    };\r\n    // signal to code-block render that the\r\n    // element has been created\r\n    let signalInnerHTML;\r\n    const withInnerHTML = new Promise(c => signalInnerHTML = c);\r\n    const renderer = new marked["Renderer"]();\r\n    renderer.image = (href, title, text) => {\r\n        let dimensions = [];\r\n        let attributes = [];\r\n        if (href) {\r\n            ({ href, dimensions } = parseHrefAndDimensions(href));\r\n            href = _href(href, true);\r\n            try {\r\n                const hrefAsUri = common_uri["URI"].parse(href);\r\n                if (options.baseUrl && hrefAsUri.scheme === network["Schemas"].file) { // absolute or relative local path, or file: uri\r\n                    href = Object(common_resources["resolvePath"])(options.baseUrl, href).toString();\r\n                }\r\n            }\r\n            catch (err) { }\r\n            attributes.push(`src="${href}"`);\r\n        }\r\n        if (text) {\r\n            attributes.push(`alt="${text}"`);\r\n        }\r\n        if (title) {\r\n            attributes.push(`title="${title}"`);\r\n        }\r\n        if (dimensions.length) {\r\n            attributes = attributes.concat(dimensions);\r\n        }\r\n        return \'<img \' + attributes.join(\' \') + \'>\';\r\n    };\r\n    renderer.link = (href, title, text) => {\r\n        // Remove markdown escapes. Workaround for https://github.com/chjj/marked/issues/829\r\n        if (href === text) { // raw link case\r\n            text = removeMarkdownEscapes(text);\r\n        }\r\n        href = _href(href, false);\r\n        if (options.baseUrl) {\r\n            const hasScheme = /^\\w[\\w\\d+.-]*:/.test(href);\r\n            if (!hasScheme) {\r\n                href = Object(common_resources["resolvePath"])(options.baseUrl, href).toString();\r\n            }\r\n        }\r\n        title = removeMarkdownEscapes(title);\r\n        href = removeMarkdownEscapes(href);\r\n        if (!href\r\n            || href.match(/^data:|javascript:/i)\r\n            || (href.match(/^command:/i) && !markdown.isTrusted)\r\n            || href.match(/^command:(\\/\\/\\/)?_workbench\\.downloadResource/i)) {\r\n            // drop the link\r\n            return text;\r\n        }\r\n        else {\r\n            // HTML Encode href\r\n            href = href.replace(/&/g, \'&amp;\')\r\n                .replace(/</g, \'&lt;\')\r\n                .replace(/>/g, \'&gt;\')\r\n                .replace(/"/g, \'&quot;\')\r\n                .replace(/\'/g, \'&#39;\');\r\n            return `<a href="#" data-href="${href}" title="${title || href}">${text}</a>`;\r\n        }\r\n    };\r\n    renderer.paragraph = (text) => {\r\n        if (markdown.supportThemeIcons) {\r\n            const elements = Object(iconLabel_iconLabels["renderLabelWithIcons"])(text);\r\n            text = elements.map(e => typeof e === \'string\' ? e : e.outerHTML).join(\'\');\r\n        }\r\n        return `<p>${text}</p>`;\r\n    };\r\n    if (options.codeBlockRenderer) {\r\n        renderer.code = (code, lang) => {\r\n            const value = options.codeBlockRenderer(lang, code);\r\n            // when code-block rendering is async we return sync\r\n            // but update the node with the real result later.\r\n            const id = idGenerator["defaultGenerator"].nextId();\r\n            const promise = Promise.all([value, withInnerHTML]).then(values => {\r\n                const span = element.querySelector(`div[data-code="${id}"]`);\r\n                if (span) {\r\n                    dom["reset"](span, values[0]);\r\n                }\r\n            }).catch(_err => {\r\n                // ignore\r\n            });\r\n            if (options.asyncRenderCallback) {\r\n                promise.then(options.asyncRenderCallback);\r\n            }\r\n            return `<div class="code" data-code="${id}">${Object(strings["escape"])(code)}</div>`;\r\n        };\r\n    }\r\n    if (options.actionHandler) {\r\n        const onClick = options.actionHandler.disposables.add(new browser_event["DomEmitter"](element, \'click\'));\r\n        const onAuxClick = options.actionHandler.disposables.add(new browser_event["DomEmitter"](element, \'auxclick\'));\r\n        options.actionHandler.disposables.add(common_event["Event"].any(onClick.event, onAuxClick.event)(e => {\r\n            const mouseEvent = new browser_mouseEvent["StandardMouseEvent"](e);\r\n            if (!mouseEvent.leftButton && !mouseEvent.middleButton) {\r\n                return;\r\n            }\r\n            let target = mouseEvent.target;\r\n            if (target.tagName !== \'A\') {\r\n                target = target.parentElement;\r\n                if (!target || target.tagName !== \'A\') {\r\n                    return;\r\n                }\r\n            }\r\n            try {\r\n                const href = target.dataset[\'href\'];\r\n                if (href) {\r\n                    options.actionHandler.callback(href, mouseEvent);\r\n                }\r\n            }\r\n            catch (err) {\r\n                Object(errors["onUnexpectedError"])(err);\r\n            }\r\n            finally {\r\n                mouseEvent.preventDefault();\r\n            }\r\n        }));\r\n    }\r\n    // Use our own sanitizer so that we can let through only spans.\r\n    // Otherwise, we\'d be letting all html be rendered.\r\n    // If we want to allow markdown permitted tags, then we can delete sanitizer and sanitize.\r\n    // We always pass the output through insane after this so that we don\'t rely on\r\n    // marked for sanitization.\r\n    markedOptions.sanitizer = (html) => {\r\n        const match = markdown.isTrusted ? html.match(/^(<span[^>]+>)|(<\\/\\s*span>)$/) : undefined;\r\n        return match ? html : \'\';\r\n    };\r\n    markedOptions.sanitize = true;\r\n    markedOptions.silent = true;\r\n    markedOptions.renderer = renderer;\r\n    // values that are too long will freeze the UI\r\n    let value = (_a = markdown.value) !== null && _a !== void 0 ? _a : \'\';\r\n    if (value.length > 100000) {\r\n        value = `${value.substr(0, 100000)}`;\r\n    }\r\n    // escape theme icons\r\n    if (markdown.supportThemeIcons) {\r\n        value = Object(iconLabels["markdownEscapeEscapedIcons"])(value);\r\n    }\r\n    const renderedMarkdown = marked["parse"](value, markedOptions);\r\n    // sanitize with insane\r\n    element.innerHTML = sanitizeRenderedMarkdown(markdown, renderedMarkdown);\r\n    // signal that async code blocks can be now be inserted\r\n    signalInnerHTML();\r\n    // signal size changes for image tags\r\n    if (options.asyncRenderCallback) {\r\n        for (const img of element.getElementsByTagName(\'img\')) {\r\n            const listener = dom["addDisposableListener"](img, \'load\', () => {\r\n                listener.dispose();\r\n                options.asyncRenderCallback();\r\n            });\r\n        }\r\n    }\r\n    return element;\r\n}\r\nfunction sanitizeRenderedMarkdown(options, renderedMarkdown) {\r\n    var _a;\r\n    const insaneOptions = getInsaneOptions(options);\r\n    return (_a = _ttpInsane === null || _ttpInsane === void 0 ? void 0 : _ttpInsane.createHTML(renderedMarkdown, insaneOptions)) !== null && _a !== void 0 ? _a : insane(renderedMarkdown, insaneOptions);\r\n}\r\nfunction getInsaneOptions(options) {\r\n    const allowedSchemes = [\r\n        network["Schemas"].http,\r\n        network["Schemas"].https,\r\n        network["Schemas"].mailto,\r\n        network["Schemas"].data,\r\n        network["Schemas"].file,\r\n        network["Schemas"].vscodeFileResource,\r\n        network["Schemas"].vscodeRemote,\r\n        network["Schemas"].vscodeRemoteResource,\r\n    ];\r\n    if (options.isTrusted) {\r\n        allowedSchemes.push(network["Schemas"].command);\r\n    }\r\n    return {\r\n        allowedSchemes,\r\n        // allowedTags should included everything that markdown renders to.\r\n        // Since we have our own sanitize function for marked, it\'s possible we missed some tag so let insane make sure.\r\n        // HTML tags that can result from markdown are from reading https://spec.commonmark.org/0.29/\r\n        // HTML table tags that can result from markdown are from https://github.github.com/gfm/#tables-extension-\r\n        allowedTags: [\'ul\', \'li\', \'p\', \'code\', \'blockquote\', \'ol\', \'h1\', \'h2\', \'h3\', \'h4\', \'h5\', \'h6\', \'hr\', \'em\', \'pre\', \'table\', \'thead\', \'tbody\', \'tr\', \'th\', \'td\', \'div\', \'del\', \'a\', \'strong\', \'br\', \'img\', \'span\'],\r\n        allowedAttributes: {\r\n            \'a\': [\'href\', \'name\', \'target\', \'data-href\'],\r\n            \'img\': [\'src\', \'title\', \'alt\', \'width\', \'height\'],\r\n            \'div\': [\'class\', \'data-code\'],\r\n            \'span\': [\'class\', \'style\'],\r\n            // https://github.com/microsoft/vscode/issues/95937\r\n            \'th\': [\'align\'],\r\n            \'td\': [\'align\']\r\n        },\r\n        filter(token) {\r\n            if (token.tag === \'span\' && options.isTrusted) {\r\n                if (token.attrs[\'style\'] && (Object.keys(token.attrs).length === 1)) {\r\n                    return !!token.attrs[\'style\'].match(/^(color\\:#[0-9a-fA-F]+;)?(background-color\\:#[0-9a-fA-F]+;)?$/);\r\n                }\r\n                else if (token.attrs[\'class\']) {\r\n                    // The class should match codicon rendering in src\\vs\\base\\common\\codicons.ts\r\n                    return !!token.attrs[\'class\'].match(/^codicon codicon-[a-z\\-]+( codicon-modifier-[a-z\\-]+)?$/);\r\n                }\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n    };\r\n}\r\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/modes/textToHtmlTokenizer.js\nvar textToHtmlTokenizer = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/common/modes/textToHtmlTokenizer.js");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/browser/core/markdownRenderer.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar markdownRenderer_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar markdownRenderer_param = (undefined && undefined.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nvar markdownRenderer_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar core_markdownRenderer_a;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Markdown renderer that can render codeblocks with the editor mechanics. This\r\n * renderer should always be preferred.\r\n */\r\nlet markdownRenderer_MarkdownRenderer = class MarkdownRenderer {\r\n    constructor(_options, _modeService, _openerService) {\r\n        this._options = _options;\r\n        this._modeService = _modeService;\r\n        this._openerService = _openerService;\r\n        this._onDidRenderAsync = new common_event["Emitter"]();\r\n        this.onDidRenderAsync = this._onDidRenderAsync.event;\r\n    }\r\n    dispose() {\r\n        this._onDidRenderAsync.dispose();\r\n    }\r\n    render(markdown, options, markedOptions) {\r\n        const disposables = new lifecycle["DisposableStore"]();\r\n        let element;\r\n        if (!markdown) {\r\n            element = document.createElement(\'span\');\r\n        }\r\n        else {\r\n            element = renderMarkdown(markdown, Object.assign(Object.assign({}, this._getRenderOptions(markdown, disposables)), options), markedOptions);\r\n        }\r\n        return {\r\n            element,\r\n            dispose: () => disposables.dispose()\r\n        };\r\n    }\r\n    _getRenderOptions(markdown, disposeables) {\r\n        return {\r\n            baseUrl: this._options.baseUrl,\r\n            codeBlockRenderer: (languageAlias, value) => markdownRenderer_awaiter(this, void 0, void 0, function* () {\r\n                var _a, _b, _c, _d;\r\n                // In markdown,\r\n                // it is possible that we stumble upon language aliases (e.g.js instead of javascript)\r\n                // it is possible no alias is given in which case we fall back to the current editor lang\r\n                let modeId;\r\n                if (languageAlias) {\r\n                    modeId = this._modeService.getModeIdForLanguageName(languageAlias);\r\n                }\r\n                else if (this._options.editor) {\r\n                    modeId = (_a = this._options.editor.getModel()) === null || _a === void 0 ? void 0 : _a.getLanguageIdentifier().language;\r\n                }\r\n                if (!modeId) {\r\n                    modeId = \'plaintext\';\r\n                }\r\n                this._modeService.triggerMode(modeId);\r\n                const tokenization = (_b = yield modes["TokenizationRegistry"].getPromise(modeId)) !== null && _b !== void 0 ? _b : undefined;\r\n                const element = document.createElement(\'span\');\r\n                element.innerHTML = ((_d = (_c = MarkdownRenderer._ttpTokenizer) === null || _c === void 0 ? void 0 : _c.createHTML(value, tokenization)) !== null && _d !== void 0 ? _d : Object(textToHtmlTokenizer["tokenizeToString"])(value, tokenization));\r\n                // use "good" font\r\n                let fontFamily = this._options.codeBlockFontFamily;\r\n                if (this._options.editor) {\r\n                    fontFamily = this._options.editor.getOption(42 /* fontInfo */).fontFamily;\r\n                }\r\n                if (fontFamily) {\r\n                    element.style.fontFamily = fontFamily;\r\n                }\r\n                return element;\r\n            }),\r\n            asyncRenderCallback: () => this._onDidRenderAsync.fire(),\r\n            actionHandler: {\r\n                callback: (content) => this._openerService.open(content, { fromUserGesture: true, allowContributedOpeners: true, allowCommands: markdown.isTrusted }).catch(errors["onUnexpectedError"]),\r\n                disposables: disposeables\r\n            }\r\n        };\r\n    }\r\n};\r\nmarkdownRenderer_MarkdownRenderer._ttpTokenizer = (core_markdownRenderer_a = window.trustedTypes) === null || core_markdownRenderer_a === void 0 ? void 0 : core_markdownRenderer_a.createPolicy(\'tokenizeToString\', {\r\n    createHTML(value, tokenizer) {\r\n        return Object(textToHtmlTokenizer["tokenizeToString"])(value, tokenizer);\r\n    }\r\n});\r\nmarkdownRenderer_MarkdownRenderer = markdownRenderer_decorate([\r\n    markdownRenderer_param(1, services_modeService["IModeService"]),\r\n    markdownRenderer_param(2, common_opener["IOpenerService"])\r\n], markdownRenderer_MarkdownRenderer);\r\n\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/hover/getHover.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\n\r\n\r\nfunction getHover(model, position, token) {\r\n    const supports = modes["HoverProviderRegistry"].ordered(model);\r\n    const promises = supports.map(support => {\r\n        return Promise.resolve(support.provideHover(model, position, token)).then(hover => {\r\n            return hover && isValid(hover) ? hover : undefined;\r\n        }, err => {\r\n            Object(errors["onUnexpectedExternalError"])(err);\r\n            return undefined;\r\n        });\r\n    });\r\n    return Promise.all(promises).then(arrays["coalesce"]);\r\n}\r\nObject(editorExtensions["registerModelAndPositionCommand"])(\'_executeHoverProvider\', (model, position) => getHover(model, position, cancellation["CancellationToken"].None));\r\nfunction isValid(result) {\r\n    const hasRange = (typeof result.range !== \'undefined\');\r\n    const hasHtmlContent = typeof result.contents !== \'undefined\' && result.contents && result.contents.length > 0;\r\n    return hasRange && hasHtmlContent;\r\n}\r\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/platform/configuration/common/configuration.js\nvar configuration = __webpack_require__("./node_modules/monaco-editor/esm/vs/platform/configuration/common/configuration.js");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/hover/markdownHoverParticipant.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar markdownHoverParticipant_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar markdownHoverParticipant_param = (undefined && undefined.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nvar markdownHoverParticipant_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst markdownHoverParticipant_$ = dom["$"];\r\nclass MarkdownHover {\r\n    constructor(owner, range, contents) {\r\n        this.owner = owner;\r\n        this.range = range;\r\n        this.contents = contents;\r\n    }\r\n    isValidForHoverAnchor(anchor) {\r\n        return (anchor.type === 1 /* Range */\r\n            && this.range.startColumn <= anchor.range.startColumn\r\n            && this.range.endColumn >= anchor.range.endColumn);\r\n    }\r\n}\r\nlet markdownHoverParticipant_MarkdownHoverParticipant = class MarkdownHoverParticipant {\r\n    constructor(_editor, _hover, _modeService, _openerService, _configurationService) {\r\n        this._editor = _editor;\r\n        this._hover = _hover;\r\n        this._modeService = _modeService;\r\n        this._openerService = _openerService;\r\n        this._configurationService = _configurationService;\r\n    }\r\n    createLoadingMessage(anchor) {\r\n        return new MarkdownHover(this, anchor.range, [new htmlContent_MarkdownString().appendText(nls["localize"](\'modesContentHover.loading\', "Loading..."))]);\r\n    }\r\n    computeSync(anchor, lineDecorations) {\r\n        if (!this._editor.hasModel() || anchor.type !== 1 /* Range */) {\r\n            return [];\r\n        }\r\n        const model = this._editor.getModel();\r\n        const lineNumber = anchor.range.startLineNumber;\r\n        const maxColumn = model.getLineMaxColumn(lineNumber);\r\n        const result = [];\r\n        for (const d of lineDecorations) {\r\n            const startColumn = (d.range.startLineNumber === lineNumber) ? d.range.startColumn : 1;\r\n            const endColumn = (d.range.endLineNumber === lineNumber) ? d.range.endColumn : maxColumn;\r\n            const hoverMessage = d.options.hoverMessage;\r\n            if (!hoverMessage || isEmptyMarkdownString(hoverMessage)) {\r\n                continue;\r\n            }\r\n            const range = new core_range["Range"](anchor.range.startLineNumber, startColumn, anchor.range.startLineNumber, endColumn);\r\n            result.push(new MarkdownHover(this, range, Object(arrays["asArray"])(hoverMessage)));\r\n        }\r\n        const lineLength = this._editor.getModel().getLineLength(lineNumber);\r\n        const maxTokenizationLineLength = this._configurationService.getValue(\'editor.maxTokenizationLineLength\');\r\n        if (typeof maxTokenizationLineLength === \'number\' && lineLength >= maxTokenizationLineLength) {\r\n            result.push(new MarkdownHover(this, new core_range["Range"](lineNumber, 1, lineNumber, lineLength + 1), [{\r\n                    value: nls["localize"](\'too many characters\', "Tokenization is skipped for long lines for performance reasons. This can be configured via `editor.maxTokenizationLineLength`.")\r\n                }]));\r\n        }\r\n        return result;\r\n    }\r\n    computeAsync(anchor, lineDecorations, token) {\r\n        return markdownHoverParticipant_awaiter(this, void 0, void 0, function* () {\r\n            if (!this._editor.hasModel() || anchor.type !== 1 /* Range */) {\r\n                return Promise.resolve([]);\r\n            }\r\n            const model = this._editor.getModel();\r\n            if (!modes["HoverProviderRegistry"].has(model)) {\r\n                return Promise.resolve([]);\r\n            }\r\n            const hovers = yield getHover(model, new core_position["Position"](anchor.range.startLineNumber, anchor.range.startColumn), token);\r\n            const result = [];\r\n            for (const hover of hovers) {\r\n                if (isEmptyMarkdownString(hover.contents)) {\r\n                    continue;\r\n                }\r\n                const rng = hover.range ? core_range["Range"].lift(hover.range) : anchor.range;\r\n                result.push(new MarkdownHover(this, rng, hover.contents));\r\n            }\r\n            return result;\r\n        });\r\n    }\r\n    renderHoverParts(hoverParts, fragment, statusBar) {\r\n        const disposables = new lifecycle["DisposableStore"]();\r\n        for (const hoverPart of hoverParts) {\r\n            for (const contents of hoverPart.contents) {\r\n                if (isEmptyMarkdownString(contents)) {\r\n                    continue;\r\n                }\r\n                const markdownHoverElement = markdownHoverParticipant_$(\'div.hover-row.markdown-hover\');\r\n                const hoverContentsElement = dom["append"](markdownHoverElement, markdownHoverParticipant_$(\'div.hover-contents\'));\r\n                const renderer = disposables.add(new markdownRenderer_MarkdownRenderer({ editor: this._editor }, this._modeService, this._openerService));\r\n                disposables.add(renderer.onDidRenderAsync(() => {\r\n                    hoverContentsElement.className = \'hover-contents code-hover-contents\';\r\n                    this._hover.onContentsChanged();\r\n                }));\r\n                const renderedContents = disposables.add(renderer.render(contents));\r\n                hoverContentsElement.appendChild(renderedContents.element);\r\n                fragment.appendChild(markdownHoverElement);\r\n            }\r\n        }\r\n        return disposables;\r\n    }\r\n};\r\nmarkdownHoverParticipant_MarkdownHoverParticipant = markdownHoverParticipant_decorate([\r\n    markdownHoverParticipant_param(2, services_modeService["IModeService"]),\r\n    markdownHoverParticipant_param(3, common_opener["IOpenerService"]),\r\n    markdownHoverParticipant_param(4, configuration["IConfigurationService"])\r\n], markdownHoverParticipant_MarkdownHoverParticipant);\r\n\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/hover/hoverTypes.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nclass HoverRangeAnchor {\r\n    constructor(priority, range) {\r\n        this.priority = priority;\r\n        this.range = range;\r\n        this.type = 1 /* Range */;\r\n    }\r\n    equals(other) {\r\n        return (other.type === 1 /* Range */ && this.range.equalsRange(other.range));\r\n    }\r\n    canAdoptVisibleHover(lastAnchor, showAtPosition) {\r\n        return (lastAnchor.type === 1 /* Range */ && showAtPosition.lineNumber === this.range.startLineNumber);\r\n    }\r\n}\r\nclass HoverForeignElementAnchor {\r\n    constructor(priority, owner, range) {\r\n        this.priority = priority;\r\n        this.owner = owner;\r\n        this.range = range;\r\n        this.type = 2 /* ForeignElement */;\r\n    }\r\n    equals(other) {\r\n        return (other.type === 2 /* ForeignElement */ && this.owner === other.owner);\r\n    }\r\n    canAdoptVisibleHover(lastAnchor, showAtPosition) {\r\n        return (lastAnchor.type === 2 /* ForeignElement */ && this.owner === lastAnchor.owner);\r\n    }\r\n}\r\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/ghostText.css\nvar inlineCompletions_ghostText = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/ghostText.css");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLineRenderer.js\nvar viewLineRenderer = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/common/viewLayout/viewLineRenderer.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/config/editorOptions.js\nvar editorOptions = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/common/config/editorOptions.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/core/stringBuilder.js\nvar stringBuilder = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/common/core/stringBuilder.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/browser/config/configuration.js + 1 modules\nvar config_configuration = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/browser/config/configuration.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/core/lineTokens.js\nvar core_lineTokens = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/common/core/lineTokens.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/view/editorColorRegistry.js\nvar editorColorRegistry = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/common/view/editorColorRegistry.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/controller/cursorCommon.js\nvar cursorCommon = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/common/controller/cursorCommon.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/viewLayout/lineDecorations.js\nvar viewLayout_lineDecorations = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/common/viewLayout/lineDecorations.js");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/ghostTextWidget.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar ghostTextWidget_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar ghostTextWidget_param = (undefined && undefined.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nvar ghostTextWidget_a;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst ttPolicy = (ghostTextWidget_a = window.trustedTypes) === null || ghostTextWidget_a === void 0 ? void 0 : ghostTextWidget_a.createPolicy(\'editorGhostText\', { createHTML: value => value });\r\nlet ghostTextWidget_GhostTextWidget = class GhostTextWidget extends lifecycle["Disposable"] {\r\n    constructor(editor, model, instantiationService) {\r\n        super();\r\n        this.editor = editor;\r\n        this.model = model;\r\n        this.instantiationService = instantiationService;\r\n        this.disposed = false;\r\n        this.partsWidget = this._register(this.instantiationService.createInstance(ghostTextWidget_DecorationsWidget, this.editor));\r\n        this.additionalLinesWidget = this._register(new AdditionalLinesWidget(this.editor));\r\n        this.viewMoreContentWidget = undefined;\r\n        this._register(this.editor.onDidChangeConfiguration((e) => {\r\n            if (e.hasChanged(28 /* disableMonospaceOptimizations */)\r\n                || e.hasChanged(105 /* stopRenderingLineAfter */)\r\n                || e.hasChanged(88 /* renderWhitespace */)\r\n                || e.hasChanged(82 /* renderControlCharacters */)\r\n                || e.hasChanged(43 /* fontLigatures */)\r\n                || e.hasChanged(42 /* fontInfo */)\r\n                || e.hasChanged(58 /* lineHeight */)) {\r\n                this.update();\r\n            }\r\n        }));\r\n        this._register(Object(lifecycle["toDisposable"])(() => {\r\n            var _a;\r\n            this.disposed = true;\r\n            this.update();\r\n            (_a = this.viewMoreContentWidget) === null || _a === void 0 ? void 0 : _a.dispose();\r\n            this.viewMoreContentWidget = undefined;\r\n        }));\r\n        this._register(model.onDidChange(() => {\r\n            this.update();\r\n        }));\r\n        this.update();\r\n    }\r\n    shouldShowHoverAtViewZone(viewZoneId) {\r\n        return (this.additionalLinesWidget.viewZoneId === viewZoneId);\r\n    }\r\n    update() {\r\n        var _a;\r\n        const ghostText = this.model.ghostText;\r\n        if (!this.editor.hasModel() || !ghostText || this.disposed) {\r\n            this.partsWidget.clear();\r\n            this.additionalLinesWidget.clear();\r\n            return;\r\n        }\r\n        const inlineTexts = new Array();\r\n        const additionalLines = new Array();\r\n        function addToAdditionalLines(lines, className) {\r\n            if (additionalLines.length > 0) {\r\n                const lastLine = additionalLines[additionalLines.length - 1];\r\n                if (className) {\r\n                    lastLine.decorations.push(new viewLayout_lineDecorations["LineDecoration"](lastLine.content.length + 1, lastLine.content.length + 1 + lines[0].length, className, 0 /* Regular */));\r\n                }\r\n                lastLine.content += lines[0];\r\n                lines = lines.slice(1);\r\n            }\r\n            for (const line of lines) {\r\n                additionalLines.push({\r\n                    content: line,\r\n                    decorations: className ? [new viewLayout_lineDecorations["LineDecoration"](1, line.length + 1, className, 0 /* Regular */)] : []\r\n                });\r\n            }\r\n        }\r\n        const textBufferLine = this.editor.getModel().getLineContent(ghostText.lineNumber);\r\n        this.editor.getModel().getLineTokens(ghostText.lineNumber);\r\n        let hiddenTextStartColumn = undefined;\r\n        let lastIdx = 0;\r\n        for (const part of ghostText.parts) {\r\n            let lines = part.lines;\r\n            if (hiddenTextStartColumn === undefined) {\r\n                inlineTexts.push({\r\n                    column: part.column,\r\n                    text: lines[0],\r\n                    preview: part.preview,\r\n                });\r\n                lines = lines.slice(1);\r\n            }\r\n            else {\r\n                addToAdditionalLines([textBufferLine.substring(lastIdx, part.column - 1)], undefined);\r\n            }\r\n            if (lines.length > 0) {\r\n                addToAdditionalLines(lines, \'ghost-text\');\r\n                if (hiddenTextStartColumn === undefined && part.column <= textBufferLine.length) {\r\n                    hiddenTextStartColumn = part.column;\r\n                }\r\n            }\r\n            lastIdx = part.column - 1;\r\n        }\r\n        if (hiddenTextStartColumn !== undefined) {\r\n            addToAdditionalLines([textBufferLine.substring(lastIdx)], undefined);\r\n        }\r\n        this.partsWidget.setParts(ghostText.lineNumber, inlineTexts, hiddenTextStartColumn !== undefined ? { column: hiddenTextStartColumn, length: textBufferLine.length + 1 - hiddenTextStartColumn } : undefined);\r\n        this.additionalLinesWidget.updateLines(ghostText.lineNumber, additionalLines, ghostText.additionalReservedLineCount);\r\n        if (ghostText.parts.some(p => p.lines.length < 0)) {\r\n            // Not supported at the moment, condition is always false.\r\n            this.viewMoreContentWidget = this.renderViewMoreLines(new core_position["Position"](ghostText.lineNumber, this.editor.getModel().getLineMaxColumn(ghostText.lineNumber)), \'\', 0);\r\n        }\r\n        else {\r\n            (_a = this.viewMoreContentWidget) === null || _a === void 0 ? void 0 : _a.dispose();\r\n            this.viewMoreContentWidget = undefined;\r\n        }\r\n    }\r\n    renderViewMoreLines(position, firstLineText, remainingLinesLength) {\r\n        const fontInfo = this.editor.getOption(42 /* fontInfo */);\r\n        const domNode = document.createElement(\'div\');\r\n        domNode.className = \'suggest-preview-additional-widget\';\r\n        config_configuration["Configuration"].applyFontInfoSlow(domNode, fontInfo);\r\n        const spacer = document.createElement(\'span\');\r\n        spacer.className = \'content-spacer\';\r\n        spacer.append(firstLineText);\r\n        domNode.append(spacer);\r\n        const newline = document.createElement(\'span\');\r\n        newline.className = \'content-newline suggest-preview-text\';\r\n        newline.append(\'  \');\r\n        domNode.append(newline);\r\n        const disposableStore = new lifecycle["DisposableStore"]();\r\n        const button = document.createElement(\'div\');\r\n        button.className = \'button suggest-preview-text\';\r\n        button.append(`+${remainingLinesLength} lines`);\r\n        disposableStore.add(dom["addStandardDisposableListener"](button, \'mousedown\', (e) => {\r\n            var _a;\r\n            (_a = this.model) === null || _a === void 0 ? void 0 : _a.setExpanded(true);\r\n            e.preventDefault();\r\n            this.editor.focus();\r\n        }));\r\n        domNode.append(button);\r\n        return new ghostTextWidget_ViewMoreLinesContentWidget(this.editor, position, domNode, disposableStore);\r\n    }\r\n};\r\nghostTextWidget_GhostTextWidget = ghostTextWidget_decorate([\r\n    ghostTextWidget_param(2, instantiation["IInstantiationService"])\r\n], ghostTextWidget_GhostTextWidget);\r\n\r\nlet ghostTextWidget_DecorationsWidget = class DecorationsWidget {\r\n    constructor(editor, codeEditorService, themeService, contextKeyService) {\r\n        this.editor = editor;\r\n        this.codeEditorService = codeEditorService;\r\n        this.themeService = themeService;\r\n        this.contextKeyService = contextKeyService;\r\n        this.decorationIds = [];\r\n        this.disposableStore = new lifecycle["DisposableStore"]();\r\n    }\r\n    dispose() {\r\n        this.clear();\r\n        this.disposableStore.dispose();\r\n    }\r\n    clear() {\r\n        this.editor.deltaDecorations(this.decorationIds, []);\r\n        this.disposableStore.clear();\r\n    }\r\n    setParts(lineNumber, parts, hiddenText) {\r\n        this.disposableStore.clear();\r\n        const colorTheme = this.themeService.getColorTheme();\r\n        const foreground = colorTheme.getColor(editorColorRegistry["ghostTextForeground"]);\r\n        let opacity = undefined;\r\n        let color = undefined;\r\n        if (foreground) {\r\n            opacity = String(foreground.rgba.a);\r\n            color = common_color["Color"].Format.CSS.format(ghostTextWidget_opaque(foreground));\r\n        }\r\n        const borderColor = colorTheme.getColor(editorColorRegistry["ghostTextBorder"]);\r\n        let border = undefined;\r\n        if (borderColor) {\r\n            border = `2px dashed ${borderColor}`;\r\n        }\r\n        const textModel = this.editor.getModel();\r\n        if (!textModel) {\r\n            return;\r\n        }\r\n        const { tabSize } = textModel.getOptions();\r\n        const line = textModel.getLineContent(lineNumber) || \'\';\r\n        let lastIndex = 0;\r\n        let currentLinePrefix = \'\';\r\n        const hiddenTextDecorations = new Array();\r\n        if (hiddenText) {\r\n            hiddenTextDecorations.push({\r\n                range: core_range["Range"].fromPositions(new core_position["Position"](lineNumber, hiddenText.column), new core_position["Position"](lineNumber, hiddenText.column + hiddenText.length)),\r\n                options: {\r\n                    inlineClassName: \'ghost-text-hidden\',\r\n                    description: \'ghost-text-hidden\'\r\n                }\r\n            });\r\n        }\r\n        const key = this.contextKeyService.getContextKeyValue(\'config.editor.useInjectedText\');\r\n        const shouldUseInjectedText = key === undefined ? true : !!key;\r\n        this.decorationIds = this.editor.deltaDecorations(this.decorationIds, parts.map(p => {\r\n            currentLinePrefix += line.substring(lastIndex, p.column - 1);\r\n            lastIndex = p.column - 1;\r\n            // To avoid visual confusion, we don\'t want to render visible whitespace\r\n            const contentText = shouldUseInjectedText ? p.text : this.renderSingleLineText(p.text, currentLinePrefix, tabSize, false);\r\n            const decorationType = this.disposableStore.add(registerDecorationType(this.codeEditorService, \'ghost-text\', \'0-ghost-text-\', {\r\n                after: {\r\n                    // TODO: escape?\r\n                    contentText,\r\n                    opacity,\r\n                    color,\r\n                    border,\r\n                    fontWeight: p.preview ? \'bold\' : \'normal\',\r\n                },\r\n            }));\r\n            return ({\r\n                range: core_range["Range"].fromPositions(new core_position["Position"](lineNumber, p.column)),\r\n                options: shouldUseInjectedText ? {\r\n                    description: \'ghost-text\',\r\n                    after: { content: contentText, inlineClassName: p.preview ? \'ghost-text-decoration-preview\' : \'ghost-text-decoration\' }\r\n                } : Object.assign({}, decorationType.resolve())\r\n            });\r\n        }).concat(hiddenTextDecorations));\r\n    }\r\n    renderSingleLineText(text, lineStart, tabSize, renderWhitespace) {\r\n        const newLine = lineStart + text;\r\n        const visibleColumnsByColumns = cursorCommon["CursorColumns"].visibleColumnsByColumns(newLine, tabSize);\r\n        let contentText = \'\';\r\n        let curCol = lineStart.length + 1;\r\n        for (const c of text) {\r\n            if (c === \'\\t\') {\r\n                const width = visibleColumnsByColumns[curCol + 1] - visibleColumnsByColumns[curCol];\r\n                if (renderWhitespace) {\r\n                    contentText += \'\';\r\n                    for (let i = 1; i < width; i++) {\r\n                        contentText += \'\\xa0\';\r\n                    }\r\n                }\r\n                else {\r\n                    for (let i = 0; i < width; i++) {\r\n                        contentText += \'\\xa0\';\r\n                    }\r\n                }\r\n            }\r\n            else if (c === \' \') {\r\n                if (renderWhitespace) {\r\n                    contentText += \'\';\r\n                }\r\n                else {\r\n                    contentText += \'\\xa0\';\r\n                }\r\n            }\r\n            else {\r\n                contentText += c;\r\n            }\r\n            curCol += 1;\r\n        }\r\n        return contentText;\r\n    }\r\n};\r\nghostTextWidget_DecorationsWidget = ghostTextWidget_decorate([\r\n    ghostTextWidget_param(1, services_codeEditorService["ICodeEditorService"]),\r\n    ghostTextWidget_param(2, common_themeService["IThemeService"]),\r\n    ghostTextWidget_param(3, contextkey["IContextKeyService"])\r\n], ghostTextWidget_DecorationsWidget);\r\nfunction ghostTextWidget_opaque(color) {\r\n    const { r, b, g } = color.rgba;\r\n    return new common_color["Color"](new common_color["RGBA"](r, g, b, 255));\r\n}\r\nclass AdditionalLinesWidget {\r\n    constructor(editor) {\r\n        this.editor = editor;\r\n        this._viewZoneId = undefined;\r\n    }\r\n    get viewZoneId() { return this._viewZoneId; }\r\n    dispose() {\r\n        this.clear();\r\n    }\r\n    clear() {\r\n        this.editor.changeViewZones((changeAccessor) => {\r\n            if (this._viewZoneId) {\r\n                changeAccessor.removeZone(this._viewZoneId);\r\n                this._viewZoneId = undefined;\r\n            }\r\n        });\r\n    }\r\n    updateLines(lineNumber, additionalLines, minReservedLineCount) {\r\n        const textModel = this.editor.getModel();\r\n        if (!textModel) {\r\n            return;\r\n        }\r\n        const { tabSize } = textModel.getOptions();\r\n        this.editor.changeViewZones((changeAccessor) => {\r\n            if (this._viewZoneId) {\r\n                changeAccessor.removeZone(this._viewZoneId);\r\n                this._viewZoneId = undefined;\r\n            }\r\n            const heightInLines = Math.max(additionalLines.length, minReservedLineCount);\r\n            if (heightInLines > 0) {\r\n                const domNode = document.createElement(\'div\');\r\n                renderLines(domNode, tabSize, additionalLines, this.editor.getOptions());\r\n                this._viewZoneId = changeAccessor.addZone({\r\n                    afterLineNumber: lineNumber,\r\n                    heightInLines: heightInLines,\r\n                    domNode,\r\n                });\r\n            }\r\n        });\r\n    }\r\n}\r\nfunction renderLines(domNode, tabSize, lines, opts) {\r\n    const disableMonospaceOptimizations = opts.get(28 /* disableMonospaceOptimizations */);\r\n    const stopRenderingLineAfter = opts.get(105 /* stopRenderingLineAfter */);\r\n    // To avoid visual confusion, we don\'t want to render visible whitespace\r\n    const renderWhitespace = \'none\';\r\n    const renderControlCharacters = opts.get(82 /* renderControlCharacters */);\r\n    const fontLigatures = opts.get(43 /* fontLigatures */);\r\n    const fontInfo = opts.get(42 /* fontInfo */);\r\n    const lineHeight = opts.get(58 /* lineHeight */);\r\n    const sb = Object(stringBuilder["createStringBuilder"])(10000);\r\n    sb.appendASCIIString(\'<div class="suggest-preview-text">\');\r\n    for (let i = 0, len = lines.length; i < len; i++) {\r\n        const lineData = lines[i];\r\n        const line = lineData.content;\r\n        sb.appendASCIIString(\'<div class="view-line\');\r\n        sb.appendASCIIString(\'" style="top:\');\r\n        sb.appendASCIIString(String(i * lineHeight));\r\n        sb.appendASCIIString(\'px;width:1000000px;">\');\r\n        const isBasicASCII = strings["isBasicASCII"](line);\r\n        const containsRTL = strings["containsRTL"](line);\r\n        const lineTokens = core_lineTokens["LineTokens"].createEmpty(line);\r\n        Object(viewLineRenderer["renderViewLine"])(new viewLineRenderer["RenderLineInput"]((fontInfo.isMonospace && !disableMonospaceOptimizations), fontInfo.canUseHalfwidthRightwardsArrow, line, false, isBasicASCII, containsRTL, 0, lineTokens, lineData.decorations, tabSize, 0, fontInfo.spaceWidth, fontInfo.middotWidth, fontInfo.wsmiddotWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures !== editorOptions["EditorFontLigatures"].OFF, null), sb);\r\n        sb.appendASCIIString(\'</div>\');\r\n    }\r\n    sb.appendASCIIString(\'</div>\');\r\n    config_configuration["Configuration"].applyFontInfoSlow(domNode, fontInfo);\r\n    const html = sb.build();\r\n    const trustedhtml = ttPolicy ? ttPolicy.createHTML(html) : html;\r\n    domNode.innerHTML = trustedhtml;\r\n}\r\nlet keyCounter = 0;\r\nfunction registerDecorationType(service, description, keyPrefix, options) {\r\n    const key = keyPrefix + (keyCounter++);\r\n    service.registerDecorationType(description, key, options);\r\n    return {\r\n        dispose() {\r\n            service.removeDecorationType(key);\r\n        },\r\n        resolve() {\r\n            return service.resolveDecorationOptions(key, true);\r\n        }\r\n    };\r\n}\r\nclass ghostTextWidget_ViewMoreLinesContentWidget extends lifecycle["Disposable"] {\r\n    constructor(editor, position, domNode, disposableStore) {\r\n        super();\r\n        this.editor = editor;\r\n        this.position = position;\r\n        this.domNode = domNode;\r\n        this.allowEditorOverflow = false;\r\n        this.suppressMouseDown = false;\r\n        this._register(disposableStore);\r\n        this._register(Object(lifecycle["toDisposable"])(() => {\r\n            this.editor.removeContentWidget(this);\r\n        }));\r\n        this.editor.addContentWidget(this);\r\n    }\r\n    getId() {\r\n        return \'editor.widget.viewMoreLinesWidget\';\r\n    }\r\n    getDomNode() {\r\n        return this.domNode;\r\n    }\r\n    getPosition() {\r\n        return {\r\n            position: this.position,\r\n            preference: [0 /* EXACT */]\r\n        };\r\n    }\r\n}\r\nObject(common_themeService["registerThemingParticipant"])((theme, collector) => {\r\n    const foreground = theme.getColor(editorColorRegistry["ghostTextForeground"]);\r\n    if (foreground) {\r\n        const opacity = String(foreground.rgba.a);\r\n        const color = common_color["Color"].Format.CSS.format(ghostTextWidget_opaque(foreground));\r\n        collector.addRule(`.monaco-editor .ghost-text-decoration { opacity: ${opacity}; color: ${color}; }`);\r\n        collector.addRule(`.monaco-editor .ghost-text-decoration-preview { color: ${foreground.toString()}; }`);\r\n        collector.addRule(`.monaco-editor .suggest-preview-text .ghost-text { opacity: ${opacity}; color: ${color}; }`);\r\n    }\r\n    const border = theme.getColor(editorColorRegistry["ghostTextBorder"]);\r\n    if (border) {\r\n        collector.addRule(`.monaco-editor .suggest-preview-text .ghost-text { border: 2px dashed ${border}; }`);\r\n    }\r\n});\r\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/core/editOperation.js\nvar editOperation = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/common/core/editOperation.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/browser/controller/coreCommands.js + 2 modules\nvar coreCommands = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/browser/controller/coreCommands.js");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/ghostText.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\nclass GhostText {\r\n    constructor(lineNumber, parts, additionalReservedLineCount = 0) {\r\n        this.lineNumber = lineNumber;\r\n        this.parts = parts;\r\n        this.additionalReservedLineCount = additionalReservedLineCount;\r\n    }\r\n    renderForScreenReader(lineText) {\r\n        if (this.parts.length === 0) {\r\n            return \'\';\r\n        }\r\n        const lastPart = this.parts[this.parts.length - 1];\r\n        const cappedLineText = lineText.substr(0, lastPart.column - 1);\r\n        const text = applyEdits(cappedLineText, this.parts.map(p => ({\r\n            range: { startLineNumber: 1, endLineNumber: 1, startColumn: p.column, endColumn: p.column },\r\n            text: p.lines.join(\'\\n\')\r\n        })));\r\n        return text.substring(this.parts[0].column - 1);\r\n    }\r\n}\r\nclass PositionOffsetTransformer {\r\n    constructor(text) {\r\n        this.lineStartOffsetByLineIdx = [];\r\n        this.lineStartOffsetByLineIdx.push(0);\r\n        for (let i = 0; i < text.length; i++) {\r\n            if (text.charAt(i) === \'\\n\') {\r\n                this.lineStartOffsetByLineIdx.push(i + 1);\r\n            }\r\n        }\r\n    }\r\n    getOffset(position) {\r\n        return this.lineStartOffsetByLineIdx[position.lineNumber - 1] + position.column - 1;\r\n    }\r\n}\r\nfunction applyEdits(text, edits) {\r\n    const transformer = new PositionOffsetTransformer(text);\r\n    const offsetEdits = edits.map(e => {\r\n        const range = core_range["Range"].lift(e.range);\r\n        return ({\r\n            startOffset: transformer.getOffset(range.getStartPosition()),\r\n            endOffset: transformer.getOffset(range.getEndPosition()),\r\n            text: e.text\r\n        });\r\n    });\r\n    offsetEdits.sort((a, b) => b.startOffset - a.startOffset);\r\n    for (const edit of offsetEdits) {\r\n        text = text.substring(0, edit.startOffset) + edit.text + text.substring(edit.endOffset);\r\n    }\r\n    return text;\r\n}\r\nclass GhostTextPart {\r\n    constructor(column, lines, \r\n    /**\r\n     * Indicates if this part is a preview of an inline suggestion when a suggestion is previewed.\r\n    */\r\n    preview) {\r\n        this.column = column;\r\n        this.lines = lines;\r\n        this.preview = preview;\r\n    }\r\n}\r\nclass ghostText_BaseGhostTextWidgetModel extends lifecycle["Disposable"] {\r\n    constructor(editor) {\r\n        super();\r\n        this.editor = editor;\r\n        this._expanded = undefined;\r\n        this.onDidChangeEmitter = new common_event["Emitter"]();\r\n        this.onDidChange = this.onDidChangeEmitter.event;\r\n        this._register(editor.onDidChangeConfiguration((e) => {\r\n            if (e.hasChanged(106 /* suggest */) && this._expanded === undefined) {\r\n                this.onDidChangeEmitter.fire();\r\n            }\r\n        }));\r\n    }\r\n    setExpanded(expanded) {\r\n        this._expanded = true;\r\n        this.onDidChangeEmitter.fire();\r\n    }\r\n}\r\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/common/diff/diff.js + 1 modules\nvar diff = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/common/diff/diff.js");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/inlineCompletionToGhostText.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\nfunction inlineCompletionToGhostText(inlineCompletion, textModel, mode, cursorPosition, previewSuffixLength = 0) {\r\n    if (inlineCompletion.range.startLineNumber !== inlineCompletion.range.endLineNumber) {\r\n        // Only single line replacements are supported.\r\n        return undefined;\r\n    }\r\n    const modifiedLength = inlineCompletion.text.length;\r\n    const previewStartInModified = modifiedLength - previewSuffixLength;\r\n    // This is a single line string\r\n    const valueToBeReplaced = textModel.getValueInRange(inlineCompletion.range);\r\n    const changes = cachingDiff(valueToBeReplaced, inlineCompletion.text);\r\n    const lineNumber = inlineCompletion.range.startLineNumber;\r\n    const parts = new Array();\r\n    if (mode === \'prefix\') {\r\n        const filteredChanges = changes.filter(c => c.originalLength === 0);\r\n        if (filteredChanges.length > 1 || filteredChanges.length === 1 && filteredChanges[0].originalStart !== valueToBeReplaced.length) {\r\n            // Prefixes only have a single change.\r\n            return undefined;\r\n        }\r\n    }\r\n    for (const c of changes) {\r\n        const insertColumn = inlineCompletion.range.startColumn + c.originalStart + c.originalLength;\r\n        if (mode === \'subwordSmart\' && cursorPosition && cursorPosition.lineNumber === inlineCompletion.range.startLineNumber && insertColumn < cursorPosition.column) {\r\n            // No ghost text before cursor\r\n            return undefined;\r\n        }\r\n        if (c.originalLength > 0) {\r\n            const originalText = valueToBeReplaced.substr(c.originalStart, c.originalLength);\r\n            const firstNonWsCol = textModel.getLineFirstNonWhitespaceColumn(lineNumber);\r\n            if (!(/^(\\t| )*$/.test(originalText) && (firstNonWsCol === 0 || insertColumn <= firstNonWsCol))) {\r\n                return undefined;\r\n            }\r\n        }\r\n        if (c.modifiedLength === 0) {\r\n            continue;\r\n        }\r\n        const modifiedEnd = c.modifiedStart + c.modifiedLength;\r\n        const nonPreviewTextEnd = Math.max(c.modifiedStart, Math.min(modifiedEnd, previewStartInModified));\r\n        const nonPreviewText = inlineCompletion.text.substring(c.modifiedStart, nonPreviewTextEnd);\r\n        const italicText = inlineCompletion.text.substring(nonPreviewTextEnd, Math.max(c.modifiedStart, modifiedEnd));\r\n        if (nonPreviewText.length > 0) {\r\n            const lines = strings["splitLines"](nonPreviewText);\r\n            parts.push(new GhostTextPart(insertColumn, lines, false));\r\n        }\r\n        if (italicText.length > 0) {\r\n            const lines = strings["splitLines"](italicText);\r\n            parts.push(new GhostTextPart(insertColumn, lines, true));\r\n        }\r\n    }\r\n    return new GhostText(lineNumber, parts, 0);\r\n}\r\nlet lastRequest = undefined;\r\nfunction cachingDiff(originalValue, newValue) {\r\n    if ((lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.originalValue) === originalValue && (lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.newValue) === newValue) {\r\n        return lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.changes;\r\n    }\r\n    else {\r\n        const changes = smartDiff(originalValue, newValue);\r\n        lastRequest = {\r\n            originalValue,\r\n            newValue,\r\n            changes\r\n        };\r\n        return changes;\r\n    }\r\n}\r\n/**\r\n * When matching `if ()` with `if (f() = 1) { g(); }`,\r\n * align it like this:        `if (       )`\r\n * Not like this:\t\t\t  `if (  )`\r\n * Also not like this:\t\t  `if (             )`.\r\n *\r\n * The parenthesis are preprocessed to ensure that they match correctly.\r\n */\r\nfunction smartDiff(originalValue, newValue) {\r\n    function getMaxCharCode(val) {\r\n        let maxCharCode = 0;\r\n        for (let i = 0, len = val.length; i < len; i++) {\r\n            const charCode = val.charCodeAt(i);\r\n            if (charCode > maxCharCode) {\r\n                maxCharCode = charCode;\r\n            }\r\n        }\r\n        return maxCharCode;\r\n    }\r\n    const maxCharCode = Math.max(getMaxCharCode(originalValue), getMaxCharCode(newValue));\r\n    function getUniqueCharCode(id) {\r\n        if (id < 0) {\r\n            throw new Error(\'unexpected\');\r\n        }\r\n        return maxCharCode + id + 1;\r\n    }\r\n    function getElements(source) {\r\n        let level = 0;\r\n        let group = 0;\r\n        const characters = new Int32Array(source.length);\r\n        for (let i = 0, len = source.length; i < len; i++) {\r\n            const id = group * 100 + level;\r\n            // TODO support more brackets\r\n            if (source[i] === \'(\') {\r\n                characters[i] = getUniqueCharCode(2 * id);\r\n                level++;\r\n            }\r\n            else if (source[i] === \')\') {\r\n                characters[i] = getUniqueCharCode(2 * id + 1);\r\n                if (level === 1) {\r\n                    group++;\r\n                }\r\n                level = Math.max(level - 1, 0);\r\n            }\r\n            else {\r\n                characters[i] = source.charCodeAt(i);\r\n            }\r\n        }\r\n        return characters;\r\n    }\r\n    const elements1 = getElements(originalValue);\r\n    const elements2 = getElements(newValue);\r\n    return new diff["LcsDiff"]({ getElements: () => elements1 }, { getElements: () => elements2 }).ComputeDiff(false).changes;\r\n}\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/consts.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nconst inlineSuggestCommitId = \'editor.action.inlineSuggest.commit\';\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/inlineCompletionsModel.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar inlineCompletionsModel_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar inlineCompletionsModel_param = (undefined && undefined.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nvar inlineCompletionsModel_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nlet inlineCompletionsModel_InlineCompletionsModel = class InlineCompletionsModel extends lifecycle["Disposable"] {\r\n    constructor(editor, cache, commandService) {\r\n        super();\r\n        this.editor = editor;\r\n        this.cache = cache;\r\n        this.commandService = commandService;\r\n        this.onDidChangeEmitter = new common_event["Emitter"]();\r\n        this.onDidChange = this.onDidChangeEmitter.event;\r\n        this.completionSession = this._register(new lifecycle["MutableDisposable"]());\r\n        this.active = false;\r\n        this.disposed = false;\r\n        this._register(commandService.onDidExecuteCommand(e => {\r\n            // These commands don\'t trigger onDidType.\r\n            const commands = new Set([\r\n                editorExtensions["UndoCommand"].id,\r\n                editorExtensions["RedoCommand"].id,\r\n                coreCommands["CoreEditingCommands"].Tab.id,\r\n                coreCommands["CoreEditingCommands"].DeleteLeft.id,\r\n                coreCommands["CoreEditingCommands"].DeleteRight.id,\r\n                inlineSuggestCommitId,\r\n                \'acceptSelectedSuggestion\'\r\n            ]);\r\n            if (commands.has(e.commandId) && editor.hasTextFocus()) {\r\n                this.handleUserInput();\r\n            }\r\n        }));\r\n        this._register(this.editor.onDidType((e) => {\r\n            this.handleUserInput();\r\n        }));\r\n        this._register(this.editor.onDidChangeCursorPosition((e) => {\r\n            if (this.session && !this.session.isValid) {\r\n                this.hide();\r\n            }\r\n        }));\r\n        this._register(Object(lifecycle["toDisposable"])(() => {\r\n            this.disposed = true;\r\n        }));\r\n    }\r\n    handleUserInput() {\r\n        if (this.session && !this.session.isValid) {\r\n            this.hide();\r\n        }\r\n        setTimeout(() => {\r\n            if (this.disposed) {\r\n                return;\r\n            }\r\n            // Wait for the cursor update that happens in the same iteration loop iteration\r\n            this.startSessionIfTriggered();\r\n        }, 0);\r\n    }\r\n    get session() {\r\n        return this.completionSession.value;\r\n    }\r\n    get ghostText() {\r\n        var _a;\r\n        return (_a = this.session) === null || _a === void 0 ? void 0 : _a.ghostText;\r\n    }\r\n    get minReservedLineCount() {\r\n        return this.session ? this.session.minReservedLineCount : 0;\r\n    }\r\n    setExpanded(expanded) {\r\n        var _a;\r\n        (_a = this.session) === null || _a === void 0 ? void 0 : _a.setExpanded(expanded);\r\n    }\r\n    setActive(active) {\r\n        var _a;\r\n        this.active = active;\r\n        if (active) {\r\n            (_a = this.session) === null || _a === void 0 ? void 0 : _a.scheduleAutomaticUpdate();\r\n        }\r\n    }\r\n    startSessionIfTriggered() {\r\n        const suggestOptions = this.editor.getOption(54 /* inlineSuggest */);\r\n        if (!suggestOptions.enabled) {\r\n            return;\r\n        }\r\n        if (this.session && this.session.isValid) {\r\n            return;\r\n        }\r\n        this.trigger(modes["InlineCompletionTriggerKind"].Automatic);\r\n    }\r\n    trigger(triggerKind) {\r\n        if (this.completionSession.value) {\r\n            if (triggerKind === modes["InlineCompletionTriggerKind"].Explicit) {\r\n                void this.completionSession.value.ensureUpdateWithExplicitContext();\r\n            }\r\n            return;\r\n        }\r\n        this.completionSession.value = new inlineCompletionsModel_InlineCompletionsSession(this.editor, this.editor.getPosition(), () => this.active, this.commandService, this.cache, triggerKind);\r\n        this.completionSession.value.takeOwnership(this.completionSession.value.onDidChange(() => {\r\n            this.onDidChangeEmitter.fire();\r\n        }));\r\n    }\r\n    hide() {\r\n        this.completionSession.clear();\r\n        this.onDidChangeEmitter.fire();\r\n    }\r\n    commitCurrentSuggestion() {\r\n        var _a;\r\n        // Don\'t dispose the session, so that after committing, more suggestions are shown.\r\n        (_a = this.session) === null || _a === void 0 ? void 0 : _a.commitCurrentCompletion();\r\n    }\r\n    showNext() {\r\n        var _a;\r\n        (_a = this.session) === null || _a === void 0 ? void 0 : _a.showNextInlineCompletion();\r\n    }\r\n    showPrevious() {\r\n        var _a;\r\n        (_a = this.session) === null || _a === void 0 ? void 0 : _a.showPreviousInlineCompletion();\r\n    }\r\n    hasMultipleInlineCompletions() {\r\n        var _a;\r\n        return inlineCompletionsModel_awaiter(this, void 0, void 0, function* () {\r\n            const result = yield ((_a = this.session) === null || _a === void 0 ? void 0 : _a.hasMultipleInlineCompletions());\r\n            return result !== undefined ? result : false;\r\n        });\r\n    }\r\n};\r\ninlineCompletionsModel_InlineCompletionsModel = inlineCompletionsModel_decorate([\r\n    inlineCompletionsModel_param(2, common_commands["ICommandService"])\r\n], inlineCompletionsModel_InlineCompletionsModel);\r\n\r\nclass inlineCompletionsModel_InlineCompletionsSession extends ghostText_BaseGhostTextWidgetModel {\r\n    constructor(editor, triggerPosition, shouldUpdate, commandService, cache, initialTriggerKind) {\r\n        super(editor);\r\n        this.triggerPosition = triggerPosition;\r\n        this.shouldUpdate = shouldUpdate;\r\n        this.commandService = commandService;\r\n        this.cache = cache;\r\n        this.initialTriggerKind = initialTriggerKind;\r\n        this.minReservedLineCount = 0;\r\n        this.updateOperation = this._register(new lifecycle["MutableDisposable"]());\r\n        this.updateSoon = this._register(new common_async["RunOnceScheduler"](() => {\r\n            let triggerKind = this.initialTriggerKind;\r\n            // All subsequent triggers are automatic.\r\n            this.initialTriggerKind = modes["InlineCompletionTriggerKind"].Automatic;\r\n            return this.update(triggerKind);\r\n        }, 50));\r\n        //#region Selection\r\n        // We use a semantic id to track the selection even if the cache changes.\r\n        this.currentlySelectedCompletionId = undefined;\r\n        let lastCompletionItem = undefined;\r\n        this._register(this.onDidChange(() => {\r\n            const currentCompletion = this.currentCompletion;\r\n            if (currentCompletion && currentCompletion.sourceInlineCompletion !== lastCompletionItem) {\r\n                lastCompletionItem = currentCompletion.sourceInlineCompletion;\r\n                const provider = currentCompletion.sourceProvider;\r\n                if (provider.handleItemDidShow) {\r\n                    provider.handleItemDidShow(currentCompletion.sourceInlineCompletions, lastCompletionItem);\r\n                }\r\n            }\r\n        }));\r\n        this._register(Object(lifecycle["toDisposable"])(() => {\r\n            this.cache.clear();\r\n        }));\r\n        this._register(this.editor.onDidChangeCursorPosition((e) => {\r\n            if (this.cache.value) {\r\n                this.onDidChangeEmitter.fire();\r\n            }\r\n        }));\r\n        this._register(this.editor.onDidChangeModelContent((e) => {\r\n            this.scheduleAutomaticUpdate();\r\n        }));\r\n        this._register(modes["InlineCompletionsProviderRegistry"].onDidChange(() => {\r\n            this.updateSoon.schedule();\r\n        }));\r\n        this.scheduleAutomaticUpdate();\r\n    }\r\n    fixAndGetIndexOfCurrentSelection() {\r\n        if (!this.currentlySelectedCompletionId || !this.cache.value) {\r\n            return 0;\r\n        }\r\n        if (this.cache.value.completions.length === 0) {\r\n            // don\'t reset the selection in this case\r\n            return 0;\r\n        }\r\n        const idx = this.cache.value.completions.findIndex(v => v.semanticId === this.currentlySelectedCompletionId);\r\n        if (idx === -1) {\r\n            // Reset the selection so that the selection does not jump back when it appears again\r\n            this.currentlySelectedCompletionId = undefined;\r\n            return 0;\r\n        }\r\n        return idx;\r\n    }\r\n    get currentCachedCompletion() {\r\n        if (!this.cache.value) {\r\n            return undefined;\r\n        }\r\n        return this.cache.value.completions[this.fixAndGetIndexOfCurrentSelection()];\r\n    }\r\n    showNextInlineCompletion() {\r\n        var _a;\r\n        return inlineCompletionsModel_awaiter(this, void 0, void 0, function* () {\r\n            yield this.ensureUpdateWithExplicitContext();\r\n            const completions = ((_a = this.cache.value) === null || _a === void 0 ? void 0 : _a.completions) || [];\r\n            if (completions.length > 0) {\r\n                const newIdx = (this.fixAndGetIndexOfCurrentSelection() + 1) % completions.length;\r\n                this.currentlySelectedCompletionId = completions[newIdx].semanticId;\r\n            }\r\n            else {\r\n                this.currentlySelectedCompletionId = undefined;\r\n            }\r\n            this.onDidChangeEmitter.fire();\r\n        });\r\n    }\r\n    showPreviousInlineCompletion() {\r\n        var _a;\r\n        return inlineCompletionsModel_awaiter(this, void 0, void 0, function* () {\r\n            yield this.ensureUpdateWithExplicitContext();\r\n            const completions = ((_a = this.cache.value) === null || _a === void 0 ? void 0 : _a.completions) || [];\r\n            if (completions.length > 0) {\r\n                const newIdx = (this.fixAndGetIndexOfCurrentSelection() + completions.length - 1) % completions.length;\r\n                this.currentlySelectedCompletionId = completions[newIdx].semanticId;\r\n            }\r\n            else {\r\n                this.currentlySelectedCompletionId = undefined;\r\n            }\r\n            this.onDidChangeEmitter.fire();\r\n        });\r\n    }\r\n    ensureUpdateWithExplicitContext() {\r\n        var _a;\r\n        return inlineCompletionsModel_awaiter(this, void 0, void 0, function* () {\r\n            if (this.updateOperation.value) {\r\n                // Restart or wait for current update operation\r\n                if (this.updateOperation.value.triggerKind === modes["InlineCompletionTriggerKind"].Explicit) {\r\n                    yield this.updateOperation.value.promise;\r\n                }\r\n                else {\r\n                    yield this.update(modes["InlineCompletionTriggerKind"].Explicit);\r\n                }\r\n            }\r\n            else if (((_a = this.cache.value) === null || _a === void 0 ? void 0 : _a.triggerKind) !== modes["InlineCompletionTriggerKind"].Explicit) {\r\n                // Refresh cache\r\n                yield this.update(modes["InlineCompletionTriggerKind"].Explicit);\r\n            }\r\n        });\r\n    }\r\n    hasMultipleInlineCompletions() {\r\n        var _a;\r\n        return inlineCompletionsModel_awaiter(this, void 0, void 0, function* () {\r\n            yield this.ensureUpdateWithExplicitContext();\r\n            return (((_a = this.cache.value) === null || _a === void 0 ? void 0 : _a.completions.length) || 0) > 1;\r\n        });\r\n    }\r\n    //#endregion\r\n    get ghostText() {\r\n        const currentCompletion = this.currentCompletion;\r\n        const mode = this.editor.getOptions().get(54 /* inlineSuggest */).mode;\r\n        return currentCompletion ? inlineCompletionToGhostText(currentCompletion, this.editor.getModel(), mode, this.editor.getPosition()) : undefined;\r\n    }\r\n    get currentCompletion() {\r\n        const completion = this.currentCachedCompletion;\r\n        if (!completion) {\r\n            return undefined;\r\n        }\r\n        return completion.toLiveInlineCompletion();\r\n    }\r\n    get isValid() {\r\n        return this.editor.getPosition().lineNumber === this.triggerPosition.lineNumber;\r\n    }\r\n    scheduleAutomaticUpdate() {\r\n        // Since updateSoon debounces, starvation can happen.\r\n        // To prevent stale cache, we clear the current update operation.\r\n        this.updateOperation.clear();\r\n        this.updateSoon.schedule();\r\n    }\r\n    update(triggerKind) {\r\n        return inlineCompletionsModel_awaiter(this, void 0, void 0, function* () {\r\n            if (!this.shouldUpdate()) {\r\n                return;\r\n            }\r\n            const position = this.editor.getPosition();\r\n            const promise = Object(common_async["createCancelablePromise"])((token) => inlineCompletionsModel_awaiter(this, void 0, void 0, function* () {\r\n                let result;\r\n                try {\r\n                    result = yield provideInlineCompletions(position, this.editor.getModel(), { triggerKind, selectedSuggestionInfo: undefined }, token);\r\n                }\r\n                catch (e) {\r\n                    Object(errors["onUnexpectedError"])(e);\r\n                    return;\r\n                }\r\n                if (token.isCancellationRequested) {\r\n                    return;\r\n                }\r\n                this.cache.setValue(this.editor, result, triggerKind);\r\n                this.onDidChangeEmitter.fire();\r\n            }));\r\n            const operation = new UpdateOperation(promise, triggerKind);\r\n            this.updateOperation.value = operation;\r\n            yield promise;\r\n            if (this.updateOperation.value === operation) {\r\n                this.updateOperation.clear();\r\n            }\r\n        });\r\n    }\r\n    takeOwnership(disposable) {\r\n        this._register(disposable);\r\n    }\r\n    commitCurrentCompletion() {\r\n        if (!this.ghostText) {\r\n            // No ghost text was shown for this completion.\r\n            // Thus, we don\'t want to commit anything.\r\n            return;\r\n        }\r\n        const completion = this.currentCompletion;\r\n        if (completion) {\r\n            this.commit(completion);\r\n        }\r\n    }\r\n    commit(completion) {\r\n        // Mark the cache as stale, but don\'t dispose it yet,\r\n        // otherwise command args might get disposed.\r\n        const cache = this.cache.clearAndLeak();\r\n        this.editor.executeEdits(\'inlineSuggestion.accept\', [\r\n            editOperation["EditOperation"].replaceMove(completion.range, completion.text)\r\n        ]);\r\n        if (completion.command) {\r\n            this.commandService\r\n                .executeCommand(completion.command.id, ...(completion.command.arguments || []))\r\n                .finally(() => {\r\n                cache === null || cache === void 0 ? void 0 : cache.dispose();\r\n            })\r\n                .then(undefined, errors["onUnexpectedExternalError"]);\r\n        }\r\n        else {\r\n            cache === null || cache === void 0 ? void 0 : cache.dispose();\r\n        }\r\n        this.onDidChangeEmitter.fire();\r\n    }\r\n}\r\nclass UpdateOperation {\r\n    constructor(promise, triggerKind) {\r\n        this.promise = promise;\r\n        this.triggerKind = triggerKind;\r\n    }\r\n    dispose() {\r\n        this.promise.cancel();\r\n    }\r\n}\r\n/**\r\n * The cache keeps itself in sync with the editor.\r\n * It also owns the completions result and disposes it when the cache is diposed.\r\n*/\r\nclass inlineCompletionsModel_SynchronizedInlineCompletionsCache extends lifecycle["Disposable"] {\r\n    constructor(editor, completionsSource, onChange, triggerKind) {\r\n        super();\r\n        this.triggerKind = triggerKind;\r\n        const decorationIds = editor.deltaDecorations([], completionsSource.items.map(i => ({\r\n            range: i.range,\r\n            options: {\r\n                description: \'inline-completion-tracking-range\'\r\n            },\r\n        })));\r\n        this._register(Object(lifecycle["toDisposable"])(() => {\r\n            editor.deltaDecorations(decorationIds, []);\r\n        }));\r\n        this.completions = completionsSource.items.map((c, idx) => new CachedInlineCompletion(c, decorationIds[idx]));\r\n        this._register(editor.onDidChangeModelContent(() => {\r\n            let hasChanged = false;\r\n            const model = editor.getModel();\r\n            for (const c of this.completions) {\r\n                const newRange = model.getDecorationRange(c.decorationId);\r\n                if (!newRange) {\r\n                    Object(errors["onUnexpectedError"])(new Error(\'Decoration has no range\'));\r\n                    continue;\r\n                }\r\n                if (!c.synchronizedRange.equalsRange(newRange)) {\r\n                    hasChanged = true;\r\n                    c.synchronizedRange = newRange;\r\n                }\r\n            }\r\n            if (hasChanged) {\r\n                onChange();\r\n            }\r\n        }));\r\n        this._register(completionsSource);\r\n    }\r\n}\r\nclass CachedInlineCompletion {\r\n    constructor(inlineCompletion, decorationId) {\r\n        this.inlineCompletion = inlineCompletion;\r\n        this.decorationId = decorationId;\r\n        this.semanticId = JSON.stringify({\r\n            text: this.inlineCompletion.text,\r\n            startLine: this.inlineCompletion.range.startLineNumber,\r\n            startColumn: this.inlineCompletion.range.startColumn,\r\n            command: this.inlineCompletion.command\r\n        });\r\n        this.synchronizedRange = inlineCompletion.range;\r\n    }\r\n    toLiveInlineCompletion() {\r\n        return {\r\n            text: this.inlineCompletion.text,\r\n            range: this.synchronizedRange,\r\n            command: this.inlineCompletion.command,\r\n            sourceProvider: this.inlineCompletion.sourceProvider,\r\n            sourceInlineCompletions: this.inlineCompletion.sourceInlineCompletions,\r\n            sourceInlineCompletion: this.inlineCompletion.sourceInlineCompletion,\r\n        };\r\n    }\r\n}\r\nfunction getDefaultRange(position, model) {\r\n    const word = model.getWordAtPosition(position);\r\n    const maxColumn = model.getLineMaxColumn(position.lineNumber);\r\n    // By default, always replace up until the end of the current line.\r\n    // This default might be subject to change!\r\n    return word\r\n        ? new core_range["Range"](position.lineNumber, word.startColumn, position.lineNumber, maxColumn)\r\n        : core_range["Range"].fromPositions(position, position.with(undefined, maxColumn));\r\n}\r\nfunction provideInlineCompletions(position, model, context, token = cancellation["CancellationToken"].None) {\r\n    return inlineCompletionsModel_awaiter(this, void 0, void 0, function* () {\r\n        const defaultReplaceRange = getDefaultRange(position, model);\r\n        const providers = modes["InlineCompletionsProviderRegistry"].all(model);\r\n        const results = yield Promise.all(providers.map((provider) => inlineCompletionsModel_awaiter(this, void 0, void 0, function* () {\r\n            const completions = yield provider.provideInlineCompletions(model, position, context, token);\r\n            return ({\r\n                completions,\r\n                provider,\r\n                dispose: () => {\r\n                    if (completions) {\r\n                        provider.freeInlineCompletions(completions);\r\n                    }\r\n                }\r\n            });\r\n        })));\r\n        const itemsByHash = new Map();\r\n        for (const result of results) {\r\n            const completions = result.completions;\r\n            if (completions) {\r\n                for (const item of completions.items.map(item => ({\r\n                    text: item.text,\r\n                    range: item.range ? core_range["Range"].lift(item.range) : defaultReplaceRange,\r\n                    command: item.command,\r\n                    sourceProvider: result.provider,\r\n                    sourceInlineCompletions: completions,\r\n                    sourceInlineCompletion: item\r\n                }))) {\r\n                    if (item.range.startLineNumber !== item.range.endLineNumber) {\r\n                        // Ignore invalid ranges.\r\n                        continue;\r\n                    }\r\n                    itemsByHash.set(JSON.stringify({ text: item.text, range: item.range }), item);\r\n                }\r\n            }\r\n        }\r\n        return {\r\n            items: [...itemsByHash.values()],\r\n            dispose: () => {\r\n                for (const result of results) {\r\n                    result.dispose();\r\n                }\r\n            },\r\n        };\r\n    });\r\n}\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/snippet/snippetParser.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nclass Scanner {\r\n    constructor() {\r\n        this.value = \'\';\r\n        this.pos = 0;\r\n    }\r\n    static isDigitCharacter(ch) {\r\n        return ch >= 48 /* Digit0 */ && ch <= 57 /* Digit9 */;\r\n    }\r\n    static isVariableCharacter(ch) {\r\n        return ch === 95 /* Underline */\r\n            || (ch >= 97 /* a */ && ch <= 122 /* z */)\r\n            || (ch >= 65 /* A */ && ch <= 90 /* Z */);\r\n    }\r\n    text(value) {\r\n        this.value = value;\r\n        this.pos = 0;\r\n    }\r\n    tokenText(token) {\r\n        return this.value.substr(token.pos, token.len);\r\n    }\r\n    next() {\r\n        if (this.pos >= this.value.length) {\r\n            return { type: 14 /* EOF */, pos: this.pos, len: 0 };\r\n        }\r\n        let pos = this.pos;\r\n        let len = 0;\r\n        let ch = this.value.charCodeAt(pos);\r\n        let type;\r\n        // static types\r\n        type = Scanner._table[ch];\r\n        if (typeof type === \'number\') {\r\n            this.pos += 1;\r\n            return { type, pos, len: 1 };\r\n        }\r\n        // number\r\n        if (Scanner.isDigitCharacter(ch)) {\r\n            type = 8 /* Int */;\r\n            do {\r\n                len += 1;\r\n                ch = this.value.charCodeAt(pos + len);\r\n            } while (Scanner.isDigitCharacter(ch));\r\n            this.pos += len;\r\n            return { type, pos, len };\r\n        }\r\n        // variable name\r\n        if (Scanner.isVariableCharacter(ch)) {\r\n            type = 9 /* VariableName */;\r\n            do {\r\n                ch = this.value.charCodeAt(pos + (++len));\r\n            } while (Scanner.isVariableCharacter(ch) || Scanner.isDigitCharacter(ch));\r\n            this.pos += len;\r\n            return { type, pos, len };\r\n        }\r\n        // format\r\n        type = 10 /* Format */;\r\n        do {\r\n            len += 1;\r\n            ch = this.value.charCodeAt(pos + len);\r\n        } while (!isNaN(ch)\r\n            && typeof Scanner._table[ch] === \'undefined\' // not static token\r\n            && !Scanner.isDigitCharacter(ch) // not number\r\n            && !Scanner.isVariableCharacter(ch) // not variable\r\n        );\r\n        this.pos += len;\r\n        return { type, pos, len };\r\n    }\r\n}\r\nScanner._table = {\r\n    [36 /* DollarSign */]: 0 /* Dollar */,\r\n    [58 /* Colon */]: 1 /* Colon */,\r\n    [44 /* Comma */]: 2 /* Comma */,\r\n    [123 /* OpenCurlyBrace */]: 3 /* CurlyOpen */,\r\n    [125 /* CloseCurlyBrace */]: 4 /* CurlyClose */,\r\n    [92 /* Backslash */]: 5 /* Backslash */,\r\n    [47 /* Slash */]: 6 /* Forwardslash */,\r\n    [124 /* Pipe */]: 7 /* Pipe */,\r\n    [43 /* Plus */]: 11 /* Plus */,\r\n    [45 /* Dash */]: 12 /* Dash */,\r\n    [63 /* QuestionMark */]: 13 /* QuestionMark */,\r\n};\r\nclass Marker {\r\n    constructor() {\r\n        this._children = [];\r\n    }\r\n    appendChild(child) {\r\n        if (child instanceof Text && this._children[this._children.length - 1] instanceof Text) {\r\n            // this and previous child are text -> merge them\r\n            this._children[this._children.length - 1].value += child.value;\r\n        }\r\n        else {\r\n            // normal adoption of child\r\n            child.parent = this;\r\n            this._children.push(child);\r\n        }\r\n        return this;\r\n    }\r\n    replace(child, others) {\r\n        const { parent } = child;\r\n        const idx = parent.children.indexOf(child);\r\n        const newChildren = parent.children.slice(0);\r\n        newChildren.splice(idx, 1, ...others);\r\n        parent._children = newChildren;\r\n        (function _fixParent(children, parent) {\r\n            for (const child of children) {\r\n                child.parent = parent;\r\n                _fixParent(child.children, child);\r\n            }\r\n        })(others, parent);\r\n    }\r\n    get children() {\r\n        return this._children;\r\n    }\r\n    get snippet() {\r\n        let candidate = this;\r\n        while (true) {\r\n            if (!candidate) {\r\n                return undefined;\r\n            }\r\n            if (candidate instanceof TextmateSnippet) {\r\n                return candidate;\r\n            }\r\n            candidate = candidate.parent;\r\n        }\r\n    }\r\n    toString() {\r\n        return this.children.reduce((prev, cur) => prev + cur.toString(), \'\');\r\n    }\r\n    len() {\r\n        return 0;\r\n    }\r\n}\r\nclass Text extends Marker {\r\n    constructor(value) {\r\n        super();\r\n        this.value = value;\r\n    }\r\n    toString() {\r\n        return this.value;\r\n    }\r\n    len() {\r\n        return this.value.length;\r\n    }\r\n    clone() {\r\n        return new Text(this.value);\r\n    }\r\n}\r\nclass TransformableMarker extends Marker {\r\n}\r\nclass Placeholder extends TransformableMarker {\r\n    constructor(index) {\r\n        super();\r\n        this.index = index;\r\n    }\r\n    static compareByIndex(a, b) {\r\n        if (a.index === b.index) {\r\n            return 0;\r\n        }\r\n        else if (a.isFinalTabstop) {\r\n            return 1;\r\n        }\r\n        else if (b.isFinalTabstop) {\r\n            return -1;\r\n        }\r\n        else if (a.index < b.index) {\r\n            return -1;\r\n        }\r\n        else if (a.index > b.index) {\r\n            return 1;\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n    get isFinalTabstop() {\r\n        return this.index === 0;\r\n    }\r\n    get choice() {\r\n        return this._children.length === 1 && this._children[0] instanceof Choice\r\n            ? this._children[0]\r\n            : undefined;\r\n    }\r\n    clone() {\r\n        let ret = new Placeholder(this.index);\r\n        if (this.transform) {\r\n            ret.transform = this.transform.clone();\r\n        }\r\n        ret._children = this.children.map(child => child.clone());\r\n        return ret;\r\n    }\r\n}\r\nclass Choice extends Marker {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.options = [];\r\n    }\r\n    appendChild(marker) {\r\n        if (marker instanceof Text) {\r\n            marker.parent = this;\r\n            this.options.push(marker);\r\n        }\r\n        return this;\r\n    }\r\n    toString() {\r\n        return this.options[0].value;\r\n    }\r\n    len() {\r\n        return this.options[0].len();\r\n    }\r\n    clone() {\r\n        let ret = new Choice();\r\n        this.options.forEach(ret.appendChild, ret);\r\n        return ret;\r\n    }\r\n}\r\nclass Transform extends Marker {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.regexp = new RegExp(\'\');\r\n    }\r\n    resolve(value) {\r\n        const _this = this;\r\n        let didMatch = false;\r\n        let ret = value.replace(this.regexp, function () {\r\n            didMatch = true;\r\n            return _this._replace(Array.prototype.slice.call(arguments, 0, -2));\r\n        });\r\n        // when the regex didn\'t match and when the transform has\r\n        // else branches, then run those\r\n        if (!didMatch && this._children.some(child => child instanceof FormatString && Boolean(child.elseValue))) {\r\n            ret = this._replace([]);\r\n        }\r\n        return ret;\r\n    }\r\n    _replace(groups) {\r\n        let ret = \'\';\r\n        for (const marker of this._children) {\r\n            if (marker instanceof FormatString) {\r\n                let value = groups[marker.index] || \'\';\r\n                value = marker.resolve(value);\r\n                ret += value;\r\n            }\r\n            else {\r\n                ret += marker.toString();\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n    toString() {\r\n        return \'\';\r\n    }\r\n    clone() {\r\n        let ret = new Transform();\r\n        ret.regexp = new RegExp(this.regexp.source, \'\' + (this.regexp.ignoreCase ? \'i\' : \'\') + (this.regexp.global ? \'g\' : \'\'));\r\n        ret._children = this.children.map(child => child.clone());\r\n        return ret;\r\n    }\r\n}\r\nclass FormatString extends Marker {\r\n    constructor(index, shorthandName, ifValue, elseValue) {\r\n        super();\r\n        this.index = index;\r\n        this.shorthandName = shorthandName;\r\n        this.ifValue = ifValue;\r\n        this.elseValue = elseValue;\r\n    }\r\n    resolve(value) {\r\n        if (this.shorthandName === \'upcase\') {\r\n            return !value ? \'\' : value.toLocaleUpperCase();\r\n        }\r\n        else if (this.shorthandName === \'downcase\') {\r\n            return !value ? \'\' : value.toLocaleLowerCase();\r\n        }\r\n        else if (this.shorthandName === \'capitalize\') {\r\n            return !value ? \'\' : (value[0].toLocaleUpperCase() + value.substr(1));\r\n        }\r\n        else if (this.shorthandName === \'pascalcase\') {\r\n            return !value ? \'\' : this._toPascalCase(value);\r\n        }\r\n        else if (this.shorthandName === \'camelcase\') {\r\n            return !value ? \'\' : this._toCamelCase(value);\r\n        }\r\n        else if (Boolean(value) && typeof this.ifValue === \'string\') {\r\n            return this.ifValue;\r\n        }\r\n        else if (!Boolean(value) && typeof this.elseValue === \'string\') {\r\n            return this.elseValue;\r\n        }\r\n        else {\r\n            return value || \'\';\r\n        }\r\n    }\r\n    _toPascalCase(value) {\r\n        const match = value.match(/[a-z0-9]+/gi);\r\n        if (!match) {\r\n            return value;\r\n        }\r\n        return match.map(word => {\r\n            return word.charAt(0).toUpperCase()\r\n                + word.substr(1).toLowerCase();\r\n        })\r\n            .join(\'\');\r\n    }\r\n    _toCamelCase(value) {\r\n        const match = value.match(/[a-z0-9]+/gi);\r\n        if (!match) {\r\n            return value;\r\n        }\r\n        return match.map((word, index) => {\r\n            if (index === 0) {\r\n                return word.toLowerCase();\r\n            }\r\n            else {\r\n                return word.charAt(0).toUpperCase()\r\n                    + word.substr(1).toLowerCase();\r\n            }\r\n        })\r\n            .join(\'\');\r\n    }\r\n    clone() {\r\n        let ret = new FormatString(this.index, this.shorthandName, this.ifValue, this.elseValue);\r\n        return ret;\r\n    }\r\n}\r\nclass Variable extends TransformableMarker {\r\n    constructor(name) {\r\n        super();\r\n        this.name = name;\r\n    }\r\n    resolve(resolver) {\r\n        let value = resolver.resolve(this);\r\n        if (this.transform) {\r\n            value = this.transform.resolve(value || \'\');\r\n        }\r\n        if (value !== undefined) {\r\n            this._children = [new Text(value)];\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    clone() {\r\n        const ret = new Variable(this.name);\r\n        if (this.transform) {\r\n            ret.transform = this.transform.clone();\r\n        }\r\n        ret._children = this.children.map(child => child.clone());\r\n        return ret;\r\n    }\r\n}\r\nfunction walk(marker, visitor) {\r\n    const stack = [...marker];\r\n    while (stack.length > 0) {\r\n        const marker = stack.shift();\r\n        const recurse = visitor(marker);\r\n        if (!recurse) {\r\n            break;\r\n        }\r\n        stack.unshift(...marker.children);\r\n    }\r\n}\r\nclass TextmateSnippet extends Marker {\r\n    get placeholderInfo() {\r\n        if (!this._placeholders) {\r\n            // fill in placeholders\r\n            let all = [];\r\n            let last;\r\n            this.walk(function (candidate) {\r\n                if (candidate instanceof Placeholder) {\r\n                    all.push(candidate);\r\n                    last = !last || last.index < candidate.index ? candidate : last;\r\n                }\r\n                return true;\r\n            });\r\n            this._placeholders = { all, last };\r\n        }\r\n        return this._placeholders;\r\n    }\r\n    get placeholders() {\r\n        const { all } = this.placeholderInfo;\r\n        return all;\r\n    }\r\n    offset(marker) {\r\n        let pos = 0;\r\n        let found = false;\r\n        this.walk(candidate => {\r\n            if (candidate === marker) {\r\n                found = true;\r\n                return false;\r\n            }\r\n            pos += candidate.len();\r\n            return true;\r\n        });\r\n        if (!found) {\r\n            return -1;\r\n        }\r\n        return pos;\r\n    }\r\n    fullLen(marker) {\r\n        let ret = 0;\r\n        walk([marker], marker => {\r\n            ret += marker.len();\r\n            return true;\r\n        });\r\n        return ret;\r\n    }\r\n    enclosingPlaceholders(placeholder) {\r\n        let ret = [];\r\n        let { parent } = placeholder;\r\n        while (parent) {\r\n            if (parent instanceof Placeholder) {\r\n                ret.push(parent);\r\n            }\r\n            parent = parent.parent;\r\n        }\r\n        return ret;\r\n    }\r\n    resolveVariables(resolver) {\r\n        this.walk(candidate => {\r\n            if (candidate instanceof Variable) {\r\n                if (candidate.resolve(resolver)) {\r\n                    this._placeholders = undefined;\r\n                }\r\n            }\r\n            return true;\r\n        });\r\n        return this;\r\n    }\r\n    appendChild(child) {\r\n        this._placeholders = undefined;\r\n        return super.appendChild(child);\r\n    }\r\n    replace(child, others) {\r\n        this._placeholders = undefined;\r\n        return super.replace(child, others);\r\n    }\r\n    clone() {\r\n        let ret = new TextmateSnippet();\r\n        this._children = this.children.map(child => child.clone());\r\n        return ret;\r\n    }\r\n    walk(visitor) {\r\n        walk(this.children, visitor);\r\n    }\r\n}\r\nclass SnippetParser {\r\n    constructor() {\r\n        this._scanner = new Scanner();\r\n        this._token = { type: 14 /* EOF */, pos: 0, len: 0 };\r\n    }\r\n    static escape(value) {\r\n        return value.replace(/\\$|}|\\\\/g, \'\\\\$&\');\r\n    }\r\n    static guessNeedsClipboard(template) {\r\n        return /\\${?CLIPBOARD/.test(template);\r\n    }\r\n    parse(value, insertFinalTabstop, enforceFinalTabstop) {\r\n        this._scanner.text(value);\r\n        this._token = this._scanner.next();\r\n        const snippet = new TextmateSnippet();\r\n        while (this._parse(snippet)) {\r\n            // nothing\r\n        }\r\n        // fill in values for placeholders. the first placeholder of an index\r\n        // that has a value defines the value for all placeholders with that index\r\n        const placeholderDefaultValues = new Map();\r\n        const incompletePlaceholders = [];\r\n        let placeholderCount = 0;\r\n        snippet.walk(marker => {\r\n            if (marker instanceof Placeholder) {\r\n                placeholderCount += 1;\r\n                if (marker.isFinalTabstop) {\r\n                    placeholderDefaultValues.set(0, undefined);\r\n                }\r\n                else if (!placeholderDefaultValues.has(marker.index) && marker.children.length > 0) {\r\n                    placeholderDefaultValues.set(marker.index, marker.children);\r\n                }\r\n                else {\r\n                    incompletePlaceholders.push(marker);\r\n                }\r\n            }\r\n            return true;\r\n        });\r\n        for (const placeholder of incompletePlaceholders) {\r\n            const defaultValues = placeholderDefaultValues.get(placeholder.index);\r\n            if (defaultValues) {\r\n                const clone = new Placeholder(placeholder.index);\r\n                clone.transform = placeholder.transform;\r\n                for (const child of defaultValues) {\r\n                    clone.appendChild(child.clone());\r\n                }\r\n                snippet.replace(placeholder, [clone]);\r\n            }\r\n        }\r\n        if (!enforceFinalTabstop) {\r\n            enforceFinalTabstop = placeholderCount > 0 && insertFinalTabstop;\r\n        }\r\n        if (!placeholderDefaultValues.has(0) && enforceFinalTabstop) {\r\n            // the snippet uses placeholders but has no\r\n            // final tabstop defined -> insert at the end\r\n            snippet.appendChild(new Placeholder(0));\r\n        }\r\n        return snippet;\r\n    }\r\n    _accept(type, value) {\r\n        if (type === undefined || this._token.type === type) {\r\n            let ret = !value ? true : this._scanner.tokenText(this._token);\r\n            this._token = this._scanner.next();\r\n            return ret;\r\n        }\r\n        return false;\r\n    }\r\n    _backTo(token) {\r\n        this._scanner.pos = token.pos + token.len;\r\n        this._token = token;\r\n        return false;\r\n    }\r\n    _until(type) {\r\n        const start = this._token;\r\n        while (this._token.type !== type) {\r\n            if (this._token.type === 14 /* EOF */) {\r\n                return false;\r\n            }\r\n            else if (this._token.type === 5 /* Backslash */) {\r\n                const nextToken = this._scanner.next();\r\n                if (nextToken.type !== 0 /* Dollar */\r\n                    && nextToken.type !== 4 /* CurlyClose */\r\n                    && nextToken.type !== 5 /* Backslash */) {\r\n                    return false;\r\n                }\r\n            }\r\n            this._token = this._scanner.next();\r\n        }\r\n        const value = this._scanner.value.substring(start.pos, this._token.pos).replace(/\\\\(\\$|}|\\\\)/g, \'$1\');\r\n        this._token = this._scanner.next();\r\n        return value;\r\n    }\r\n    _parse(marker) {\r\n        return this._parseEscaped(marker)\r\n            || this._parseTabstopOrVariableName(marker)\r\n            || this._parseComplexPlaceholder(marker)\r\n            || this._parseComplexVariable(marker)\r\n            || this._parseAnything(marker);\r\n    }\r\n    // \\$, \\\\, \\} -> just text\r\n    _parseEscaped(marker) {\r\n        let value;\r\n        if (value = this._accept(5 /* Backslash */, true)) {\r\n            // saw a backslash, append escaped token or that backslash\r\n            value = this._accept(0 /* Dollar */, true)\r\n                || this._accept(4 /* CurlyClose */, true)\r\n                || this._accept(5 /* Backslash */, true)\r\n                || value;\r\n            marker.appendChild(new Text(value));\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // $foo -> variable, $1 -> tabstop\r\n    _parseTabstopOrVariableName(parent) {\r\n        let value;\r\n        const token = this._token;\r\n        const match = this._accept(0 /* Dollar */)\r\n            && (value = this._accept(9 /* VariableName */, true) || this._accept(8 /* Int */, true));\r\n        if (!match) {\r\n            return this._backTo(token);\r\n        }\r\n        parent.appendChild(/^\\d+$/.test(value)\r\n            ? new Placeholder(Number(value))\r\n            : new Variable(value));\r\n        return true;\r\n    }\r\n    // ${1:<children>}, ${1} -> placeholder\r\n    _parseComplexPlaceholder(parent) {\r\n        let index;\r\n        const token = this._token;\r\n        const match = this._accept(0 /* Dollar */)\r\n            && this._accept(3 /* CurlyOpen */)\r\n            && (index = this._accept(8 /* Int */, true));\r\n        if (!match) {\r\n            return this._backTo(token);\r\n        }\r\n        const placeholder = new Placeholder(Number(index));\r\n        if (this._accept(1 /* Colon */)) {\r\n            // ${1:<children>}\r\n            while (true) {\r\n                // ...} -> done\r\n                if (this._accept(4 /* CurlyClose */)) {\r\n                    parent.appendChild(placeholder);\r\n                    return true;\r\n                }\r\n                if (this._parse(placeholder)) {\r\n                    continue;\r\n                }\r\n                // fallback\r\n                parent.appendChild(new Text(\'${\' + index + \':\'));\r\n                placeholder.children.forEach(parent.appendChild, parent);\r\n                return true;\r\n            }\r\n        }\r\n        else if (placeholder.index > 0 && this._accept(7 /* Pipe */)) {\r\n            // ${1|one,two,three|}\r\n            const choice = new Choice();\r\n            while (true) {\r\n                if (this._parseChoiceElement(choice)) {\r\n                    if (this._accept(2 /* Comma */)) {\r\n                        // opt, -> more\r\n                        continue;\r\n                    }\r\n                    if (this._accept(7 /* Pipe */)) {\r\n                        placeholder.appendChild(choice);\r\n                        if (this._accept(4 /* CurlyClose */)) {\r\n                            // ..|} -> done\r\n                            parent.appendChild(placeholder);\r\n                            return true;\r\n                        }\r\n                    }\r\n                }\r\n                this._backTo(token);\r\n                return false;\r\n            }\r\n        }\r\n        else if (this._accept(6 /* Forwardslash */)) {\r\n            // ${1/<regex>/<format>/<options>}\r\n            if (this._parseTransform(placeholder)) {\r\n                parent.appendChild(placeholder);\r\n                return true;\r\n            }\r\n            this._backTo(token);\r\n            return false;\r\n        }\r\n        else if (this._accept(4 /* CurlyClose */)) {\r\n            // ${1}\r\n            parent.appendChild(placeholder);\r\n            return true;\r\n        }\r\n        else {\r\n            // ${1 <- missing curly or colon\r\n            return this._backTo(token);\r\n        }\r\n    }\r\n    _parseChoiceElement(parent) {\r\n        const token = this._token;\r\n        const values = [];\r\n        while (true) {\r\n            if (this._token.type === 2 /* Comma */ || this._token.type === 7 /* Pipe */) {\r\n                break;\r\n            }\r\n            let value;\r\n            if (value = this._accept(5 /* Backslash */, true)) {\r\n                // \\, \\|, or \\\\\r\n                value = this._accept(2 /* Comma */, true)\r\n                    || this._accept(7 /* Pipe */, true)\r\n                    || this._accept(5 /* Backslash */, true)\r\n                    || value;\r\n            }\r\n            else {\r\n                value = this._accept(undefined, true);\r\n            }\r\n            if (!value) {\r\n                // EOF\r\n                this._backTo(token);\r\n                return false;\r\n            }\r\n            values.push(value);\r\n        }\r\n        if (values.length === 0) {\r\n            this._backTo(token);\r\n            return false;\r\n        }\r\n        parent.appendChild(new Text(values.join(\'\')));\r\n        return true;\r\n    }\r\n    // ${foo:<children>}, ${foo} -> variable\r\n    _parseComplexVariable(parent) {\r\n        let name;\r\n        const token = this._token;\r\n        const match = this._accept(0 /* Dollar */)\r\n            && this._accept(3 /* CurlyOpen */)\r\n            && (name = this._accept(9 /* VariableName */, true));\r\n        if (!match) {\r\n            return this._backTo(token);\r\n        }\r\n        const variable = new Variable(name);\r\n        if (this._accept(1 /* Colon */)) {\r\n            // ${foo:<children>}\r\n            while (true) {\r\n                // ...} -> done\r\n                if (this._accept(4 /* CurlyClose */)) {\r\n                    parent.appendChild(variable);\r\n                    return true;\r\n                }\r\n                if (this._parse(variable)) {\r\n                    continue;\r\n                }\r\n                // fallback\r\n                parent.appendChild(new Text(\'${\' + name + \':\'));\r\n                variable.children.forEach(parent.appendChild, parent);\r\n                return true;\r\n            }\r\n        }\r\n        else if (this._accept(6 /* Forwardslash */)) {\r\n            // ${foo/<regex>/<format>/<options>}\r\n            if (this._parseTransform(variable)) {\r\n                parent.appendChild(variable);\r\n                return true;\r\n            }\r\n            this._backTo(token);\r\n            return false;\r\n        }\r\n        else if (this._accept(4 /* CurlyClose */)) {\r\n            // ${foo}\r\n            parent.appendChild(variable);\r\n            return true;\r\n        }\r\n        else {\r\n            // ${foo <- missing curly or colon\r\n            return this._backTo(token);\r\n        }\r\n    }\r\n    _parseTransform(parent) {\r\n        // ...<regex>/<format>/<options>}\r\n        let transform = new Transform();\r\n        let regexValue = \'\';\r\n        let regexOptions = \'\';\r\n        // (1) /regex\r\n        while (true) {\r\n            if (this._accept(6 /* Forwardslash */)) {\r\n                break;\r\n            }\r\n            let escaped;\r\n            if (escaped = this._accept(5 /* Backslash */, true)) {\r\n                escaped = this._accept(6 /* Forwardslash */, true) || escaped;\r\n                regexValue += escaped;\r\n                continue;\r\n            }\r\n            if (this._token.type !== 14 /* EOF */) {\r\n                regexValue += this._accept(undefined, true);\r\n                continue;\r\n            }\r\n            return false;\r\n        }\r\n        // (2) /format\r\n        while (true) {\r\n            if (this._accept(6 /* Forwardslash */)) {\r\n                break;\r\n            }\r\n            let escaped;\r\n            if (escaped = this._accept(5 /* Backslash */, true)) {\r\n                escaped = this._accept(5 /* Backslash */, true) || this._accept(6 /* Forwardslash */, true) || escaped;\r\n                transform.appendChild(new Text(escaped));\r\n                continue;\r\n            }\r\n            if (this._parseFormatString(transform) || this._parseAnything(transform)) {\r\n                continue;\r\n            }\r\n            return false;\r\n        }\r\n        // (3) /option\r\n        while (true) {\r\n            if (this._accept(4 /* CurlyClose */)) {\r\n                break;\r\n            }\r\n            if (this._token.type !== 14 /* EOF */) {\r\n                regexOptions += this._accept(undefined, true);\r\n                continue;\r\n            }\r\n            return false;\r\n        }\r\n        try {\r\n            transform.regexp = new RegExp(regexValue, regexOptions);\r\n        }\r\n        catch (e) {\r\n            // invalid regexp\r\n            return false;\r\n        }\r\n        parent.transform = transform;\r\n        return true;\r\n    }\r\n    _parseFormatString(parent) {\r\n        const token = this._token;\r\n        if (!this._accept(0 /* Dollar */)) {\r\n            return false;\r\n        }\r\n        let complex = false;\r\n        if (this._accept(3 /* CurlyOpen */)) {\r\n            complex = true;\r\n        }\r\n        let index = this._accept(8 /* Int */, true);\r\n        if (!index) {\r\n            this._backTo(token);\r\n            return false;\r\n        }\r\n        else if (!complex) {\r\n            // $1\r\n            parent.appendChild(new FormatString(Number(index)));\r\n            return true;\r\n        }\r\n        else if (this._accept(4 /* CurlyClose */)) {\r\n            // ${1}\r\n            parent.appendChild(new FormatString(Number(index)));\r\n            return true;\r\n        }\r\n        else if (!this._accept(1 /* Colon */)) {\r\n            this._backTo(token);\r\n            return false;\r\n        }\r\n        if (this._accept(6 /* Forwardslash */)) {\r\n            // ${1:/upcase}\r\n            let shorthand = this._accept(9 /* VariableName */, true);\r\n            if (!shorthand || !this._accept(4 /* CurlyClose */)) {\r\n                this._backTo(token);\r\n                return false;\r\n            }\r\n            else {\r\n                parent.appendChild(new FormatString(Number(index), shorthand));\r\n                return true;\r\n            }\r\n        }\r\n        else if (this._accept(11 /* Plus */)) {\r\n            // ${1:+<if>}\r\n            let ifValue = this._until(4 /* CurlyClose */);\r\n            if (ifValue) {\r\n                parent.appendChild(new FormatString(Number(index), undefined, ifValue, undefined));\r\n                return true;\r\n            }\r\n        }\r\n        else if (this._accept(12 /* Dash */)) {\r\n            // ${2:-<else>}\r\n            let elseValue = this._until(4 /* CurlyClose */);\r\n            if (elseValue) {\r\n                parent.appendChild(new FormatString(Number(index), undefined, undefined, elseValue));\r\n                return true;\r\n            }\r\n        }\r\n        else if (this._accept(13 /* QuestionMark */)) {\r\n            // ${2:?<if>:<else>}\r\n            let ifValue = this._until(1 /* Colon */);\r\n            if (ifValue) {\r\n                let elseValue = this._until(4 /* CurlyClose */);\r\n                if (elseValue) {\r\n                    parent.appendChild(new FormatString(Number(index), undefined, ifValue, elseValue));\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // ${1:<else>}\r\n            let elseValue = this._until(4 /* CurlyClose */);\r\n            if (elseValue) {\r\n                parent.appendChild(new FormatString(Number(index), undefined, undefined, elseValue));\r\n                return true;\r\n            }\r\n        }\r\n        this._backTo(token);\r\n        return false;\r\n    }\r\n    _parseAnything(marker) {\r\n        if (this._token.type !== 14 /* EOF */) {\r\n            marker.appendChild(new Text(this._scanner.tokenText(this._token)));\r\n            this._accept(undefined);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/snippet/snippetSession.css\nvar snippetSession = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/contrib/snippet/snippetSession.css");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/platform/workspace/common/workspace.js\nvar workspace = __webpack_require__("./node_modules/monaco-editor/esm/vs/platform/workspace/common/workspace.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/common/path.js\nvar common_path = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/common/path.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/modes/languageConfigurationRegistry.js + 4 modules\nvar languageConfigurationRegistry = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/common/modes/languageConfigurationRegistry.js");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/platform/workspaces/common/workspaces.js\n\r\nconst WORKSPACE_EXTENSION = \'code-workspace\';\r\nfunction isSingleFolderWorkspaceIdentifier(obj) {\r\n    const singleFolderIdentifier = obj;\r\n    return typeof (singleFolderIdentifier === null || singleFolderIdentifier === void 0 ? void 0 : singleFolderIdentifier.id) === \'string\' && common_uri["URI"].isUri(singleFolderIdentifier.uri);\r\n}\r\nfunction toWorkspaceIdentifier(workspace) {\r\n    // Multi root\r\n    if (workspace.configuration) {\r\n        return {\r\n            id: workspace.id,\r\n            configPath: workspace.configuration\r\n        };\r\n    }\r\n    // Single folder\r\n    if (workspace.folders.length === 1) {\r\n        return {\r\n            id: workspace.id,\r\n            uri: workspace.folders[0].uri\r\n        };\r\n    }\r\n    // Empty workspace\r\n    return undefined;\r\n}\r\n//#endregion\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/uuid.js\n// prep-work\r\nconst _data = new Uint8Array(16);\r\nconst _hex = [];\r\nfor (let i = 0; i < 256; i++) {\r\n    _hex.push(i.toString(16).padStart(2, \'0\'));\r\n}\r\n// todo@jrieken - with node@15 crypto#getRandomBytes is available everywhere, https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues#browser_compatibility\r\nlet _fillRandomValues;\r\nif (typeof crypto === \'object\' && typeof crypto.getRandomValues === \'function\') {\r\n    // browser\r\n    _fillRandomValues = crypto.getRandomValues.bind(crypto);\r\n}\r\nelse {\r\n    _fillRandomValues = function (bucket) {\r\n        for (let i = 0; i < bucket.length; i++) {\r\n            bucket[i] = Math.floor(Math.random() * 256);\r\n        }\r\n        return bucket;\r\n    };\r\n}\r\nfunction generateUuid() {\r\n    // get data\r\n    _fillRandomValues(_data);\r\n    // set version bits\r\n    _data[6] = (_data[6] & 0x0f) | 0x40;\r\n    _data[8] = (_data[8] & 0x3f) | 0x80;\r\n    // print as string\r\n    let i = 0;\r\n    let result = \'\';\r\n    result += _hex[_data[i++]];\r\n    result += _hex[_data[i++]];\r\n    result += _hex[_data[i++]];\r\n    result += _hex[_data[i++]];\r\n    result += \'-\';\r\n    result += _hex[_data[i++]];\r\n    result += _hex[_data[i++]];\r\n    result += \'-\';\r\n    result += _hex[_data[i++]];\r\n    result += _hex[_data[i++]];\r\n    result += \'-\';\r\n    result += _hex[_data[i++]];\r\n    result += _hex[_data[i++]];\r\n    result += \'-\';\r\n    result += _hex[_data[i++]];\r\n    result += _hex[_data[i++]];\r\n    result += _hex[_data[i++]];\r\n    result += _hex[_data[i++]];\r\n    result += _hex[_data[i++]];\r\n    result += _hex[_data[i++]];\r\n    return result;\r\n}\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/snippet/snippetVariables.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass CompositeSnippetVariableResolver {\r\n    constructor(_delegates) {\r\n        this._delegates = _delegates;\r\n        //\r\n    }\r\n    resolve(variable) {\r\n        for (const delegate of this._delegates) {\r\n            let value = delegate.resolve(variable);\r\n            if (value !== undefined) {\r\n                return value;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n}\r\nclass snippetVariables_SelectionBasedVariableResolver {\r\n    constructor(_model, _selection, _selectionIdx, _overtypingCapturer) {\r\n        this._model = _model;\r\n        this._selection = _selection;\r\n        this._selectionIdx = _selectionIdx;\r\n        this._overtypingCapturer = _overtypingCapturer;\r\n        //\r\n    }\r\n    resolve(variable) {\r\n        const { name } = variable;\r\n        if (name === \'SELECTION\' || name === \'TM_SELECTED_TEXT\') {\r\n            let value = this._model.getValueInRange(this._selection) || undefined;\r\n            let isMultiline = this._selection.startLineNumber !== this._selection.endLineNumber;\r\n            // If there was no selected text, try to get last overtyped text\r\n            if (!value && this._overtypingCapturer) {\r\n                const info = this._overtypingCapturer.getLastOvertypedInfo(this._selectionIdx);\r\n                if (info) {\r\n                    value = info.value;\r\n                    isMultiline = info.multiline;\r\n                }\r\n            }\r\n            if (value && isMultiline && variable.snippet) {\r\n                // Selection is a multiline string which we indentation we now\r\n                // need to adjust. We compare the indentation of this variable\r\n                // with the indentation at the editor position and add potential\r\n                // extra indentation to the value\r\n                const line = this._model.getLineContent(this._selection.startLineNumber);\r\n                const lineLeadingWhitespace = Object(strings["getLeadingWhitespace"])(line, 0, this._selection.startColumn - 1);\r\n                let varLeadingWhitespace = lineLeadingWhitespace;\r\n                variable.snippet.walk(marker => {\r\n                    if (marker === variable) {\r\n                        return false;\r\n                    }\r\n                    if (marker instanceof Text) {\r\n                        varLeadingWhitespace = Object(strings["getLeadingWhitespace"])(Object(strings["splitLines"])(marker.value).pop());\r\n                    }\r\n                    return true;\r\n                });\r\n                const whitespaceCommonLength = Object(strings["commonPrefixLength"])(varLeadingWhitespace, lineLeadingWhitespace);\r\n                value = value.replace(/(\\r\\n|\\r|\\n)(.*)/g, (m, newline, rest) => `${newline}${varLeadingWhitespace.substr(whitespaceCommonLength)}${rest}`);\r\n            }\r\n            return value;\r\n        }\r\n        else if (name === \'TM_CURRENT_LINE\') {\r\n            return this._model.getLineContent(this._selection.positionLineNumber);\r\n        }\r\n        else if (name === \'TM_CURRENT_WORD\') {\r\n            const info = this._model.getWordAtPosition({\r\n                lineNumber: this._selection.positionLineNumber,\r\n                column: this._selection.positionColumn\r\n            });\r\n            return info && info.word || undefined;\r\n        }\r\n        else if (name === \'TM_LINE_INDEX\') {\r\n            return String(this._selection.positionLineNumber - 1);\r\n        }\r\n        else if (name === \'TM_LINE_NUMBER\') {\r\n            return String(this._selection.positionLineNumber);\r\n        }\r\n        return undefined;\r\n    }\r\n}\r\nclass snippetVariables_ModelBasedVariableResolver {\r\n    constructor(_labelService, _model) {\r\n        this._labelService = _labelService;\r\n        this._model = _model;\r\n        //\r\n    }\r\n    resolve(variable) {\r\n        const { name } = variable;\r\n        if (name === \'TM_FILENAME\') {\r\n            return common_path["basename"](this._model.uri.fsPath);\r\n        }\r\n        else if (name === \'TM_FILENAME_BASE\') {\r\n            const name = common_path["basename"](this._model.uri.fsPath);\r\n            const idx = name.lastIndexOf(\'.\');\r\n            if (idx <= 0) {\r\n                return name;\r\n            }\r\n            else {\r\n                return name.slice(0, idx);\r\n            }\r\n        }\r\n        else if (name === \'TM_DIRECTORY\' && this._labelService) {\r\n            if (common_path["dirname"](this._model.uri.fsPath) === \'.\') {\r\n                return \'\';\r\n            }\r\n            return this._labelService.getUriLabel(Object(common_resources["dirname"])(this._model.uri));\r\n        }\r\n        else if (name === \'TM_FILEPATH\' && this._labelService) {\r\n            return this._labelService.getUriLabel(this._model.uri);\r\n        }\r\n        else if (name === \'RELATIVE_FILEPATH\' && this._labelService) {\r\n            return this._labelService.getUriLabel(this._model.uri, { relative: true, noPrefix: true });\r\n        }\r\n        return undefined;\r\n    }\r\n}\r\nclass snippetVariables_ClipboardBasedVariableResolver {\r\n    constructor(_readClipboardText, _selectionIdx, _selectionCount, _spread) {\r\n        this._readClipboardText = _readClipboardText;\r\n        this._selectionIdx = _selectionIdx;\r\n        this._selectionCount = _selectionCount;\r\n        this._spread = _spread;\r\n        //\r\n    }\r\n    resolve(variable) {\r\n        if (variable.name !== \'CLIPBOARD\') {\r\n            return undefined;\r\n        }\r\n        const clipboardText = this._readClipboardText();\r\n        if (!clipboardText) {\r\n            return undefined;\r\n        }\r\n        // `spread` is assigning each cursor a line of the clipboard\r\n        // text whenever there the line count equals the cursor count\r\n        // and when enabled\r\n        if (this._spread) {\r\n            const lines = clipboardText.split(/\\r\\n|\\n|\\r/).filter(s => !Object(strings["isFalsyOrWhitespace"])(s));\r\n            if (lines.length === this._selectionCount) {\r\n                return lines[this._selectionIdx];\r\n            }\r\n        }\r\n        return clipboardText;\r\n    }\r\n}\r\nclass snippetVariables_CommentBasedVariableResolver {\r\n    constructor(_model, _selection) {\r\n        this._model = _model;\r\n        this._selection = _selection;\r\n        //\r\n    }\r\n    resolve(variable) {\r\n        const { name } = variable;\r\n        const langId = this._model.getLanguageIdAtPosition(this._selection.selectionStartLineNumber, this._selection.selectionStartColumn);\r\n        const config = languageConfigurationRegistry["LanguageConfigurationRegistry"].getComments(langId);\r\n        if (!config) {\r\n            return undefined;\r\n        }\r\n        if (name === \'LINE_COMMENT\') {\r\n            return config.lineCommentToken || undefined;\r\n        }\r\n        else if (name === \'BLOCK_COMMENT_START\') {\r\n            return config.blockCommentStartToken || undefined;\r\n        }\r\n        else if (name === \'BLOCK_COMMENT_END\') {\r\n            return config.blockCommentEndToken || undefined;\r\n        }\r\n        return undefined;\r\n    }\r\n}\r\nclass TimeBasedVariableResolver {\r\n    constructor() {\r\n        this._date = new Date();\r\n    }\r\n    resolve(variable) {\r\n        const { name } = variable;\r\n        if (name === \'CURRENT_YEAR\') {\r\n            return String(this._date.getFullYear());\r\n        }\r\n        else if (name === \'CURRENT_YEAR_SHORT\') {\r\n            return String(this._date.getFullYear()).slice(-2);\r\n        }\r\n        else if (name === \'CURRENT_MONTH\') {\r\n            return String(this._date.getMonth().valueOf() + 1).padStart(2, \'0\');\r\n        }\r\n        else if (name === \'CURRENT_DATE\') {\r\n            return String(this._date.getDate().valueOf()).padStart(2, \'0\');\r\n        }\r\n        else if (name === \'CURRENT_HOUR\') {\r\n            return String(this._date.getHours().valueOf()).padStart(2, \'0\');\r\n        }\r\n        else if (name === \'CURRENT_MINUTE\') {\r\n            return String(this._date.getMinutes().valueOf()).padStart(2, \'0\');\r\n        }\r\n        else if (name === \'CURRENT_SECOND\') {\r\n            return String(this._date.getSeconds().valueOf()).padStart(2, \'0\');\r\n        }\r\n        else if (name === \'CURRENT_DAY_NAME\') {\r\n            return TimeBasedVariableResolver.dayNames[this._date.getDay()];\r\n        }\r\n        else if (name === \'CURRENT_DAY_NAME_SHORT\') {\r\n            return TimeBasedVariableResolver.dayNamesShort[this._date.getDay()];\r\n        }\r\n        else if (name === \'CURRENT_MONTH_NAME\') {\r\n            return TimeBasedVariableResolver.monthNames[this._date.getMonth()];\r\n        }\r\n        else if (name === \'CURRENT_MONTH_NAME_SHORT\') {\r\n            return TimeBasedVariableResolver.monthNamesShort[this._date.getMonth()];\r\n        }\r\n        else if (name === \'CURRENT_SECONDS_UNIX\') {\r\n            return String(Math.floor(this._date.getTime() / 1000));\r\n        }\r\n        return undefined;\r\n    }\r\n}\r\nTimeBasedVariableResolver.dayNames = [nls["localize"](\'Sunday\', "Sunday"), nls["localize"](\'Monday\', "Monday"), nls["localize"](\'Tuesday\', "Tuesday"), nls["localize"](\'Wednesday\', "Wednesday"), nls["localize"](\'Thursday\', "Thursday"), nls["localize"](\'Friday\', "Friday"), nls["localize"](\'Saturday\', "Saturday")];\r\nTimeBasedVariableResolver.dayNamesShort = [nls["localize"](\'SundayShort\', "Sun"), nls["localize"](\'MondayShort\', "Mon"), nls["localize"](\'TuesdayShort\', "Tue"), nls["localize"](\'WednesdayShort\', "Wed"), nls["localize"](\'ThursdayShort\', "Thu"), nls["localize"](\'FridayShort\', "Fri"), nls["localize"](\'SaturdayShort\', "Sat")];\r\nTimeBasedVariableResolver.monthNames = [nls["localize"](\'January\', "January"), nls["localize"](\'February\', "February"), nls["localize"](\'March\', "March"), nls["localize"](\'April\', "April"), nls["localize"](\'May\', "May"), nls["localize"](\'June\', "June"), nls["localize"](\'July\', "July"), nls["localize"](\'August\', "August"), nls["localize"](\'September\', "September"), nls["localize"](\'October\', "October"), nls["localize"](\'November\', "November"), nls["localize"](\'December\', "December")];\r\nTimeBasedVariableResolver.monthNamesShort = [nls["localize"](\'JanuaryShort\', "Jan"), nls["localize"](\'FebruaryShort\', "Feb"), nls["localize"](\'MarchShort\', "Mar"), nls["localize"](\'AprilShort\', "Apr"), nls["localize"](\'MayShort\', "May"), nls["localize"](\'JuneShort\', "Jun"), nls["localize"](\'JulyShort\', "Jul"), nls["localize"](\'AugustShort\', "Aug"), nls["localize"](\'SeptemberShort\', "Sep"), nls["localize"](\'OctoberShort\', "Oct"), nls["localize"](\'NovemberShort\', "Nov"), nls["localize"](\'DecemberShort\', "Dec")];\r\nclass snippetVariables_WorkspaceBasedVariableResolver {\r\n    constructor(_workspaceService) {\r\n        this._workspaceService = _workspaceService;\r\n        //\r\n    }\r\n    resolve(variable) {\r\n        if (!this._workspaceService) {\r\n            return undefined;\r\n        }\r\n        const workspaceIdentifier = toWorkspaceIdentifier(this._workspaceService.getWorkspace());\r\n        if (!workspaceIdentifier) {\r\n            return undefined;\r\n        }\r\n        if (variable.name === \'WORKSPACE_NAME\') {\r\n            return this._resolveWorkspaceName(workspaceIdentifier);\r\n        }\r\n        else if (variable.name === \'WORKSPACE_FOLDER\') {\r\n            return this._resoveWorkspacePath(workspaceIdentifier);\r\n        }\r\n        return undefined;\r\n    }\r\n    _resolveWorkspaceName(workspaceIdentifier) {\r\n        if (isSingleFolderWorkspaceIdentifier(workspaceIdentifier)) {\r\n            return common_path["basename"](workspaceIdentifier.uri.path);\r\n        }\r\n        let filename = common_path["basename"](workspaceIdentifier.configPath.path);\r\n        if (filename.endsWith(WORKSPACE_EXTENSION)) {\r\n            filename = filename.substr(0, filename.length - WORKSPACE_EXTENSION.length - 1);\r\n        }\r\n        return filename;\r\n    }\r\n    _resoveWorkspacePath(workspaceIdentifier) {\r\n        if (isSingleFolderWorkspaceIdentifier(workspaceIdentifier)) {\r\n            return normalizeDriveLetter(workspaceIdentifier.uri.fsPath);\r\n        }\r\n        let filename = common_path["basename"](workspaceIdentifier.configPath.path);\r\n        let folderpath = workspaceIdentifier.configPath.fsPath;\r\n        if (folderpath.endsWith(filename)) {\r\n            folderpath = folderpath.substr(0, folderpath.length - filename.length - 1);\r\n        }\r\n        return (folderpath ? normalizeDriveLetter(folderpath) : \'/\');\r\n    }\r\n}\r\nclass snippetVariables_RandomBasedVariableResolver {\r\n    resolve(variable) {\r\n        const { name } = variable;\r\n        if (name === \'RANDOM\') {\r\n            return Math.random().toString().slice(-6);\r\n        }\r\n        else if (name === \'RANDOM_HEX\') {\r\n            return Math.random().toString(16).slice(-6);\r\n        }\r\n        else if (name === \'UUID\') {\r\n            return generateUuid();\r\n        }\r\n        return undefined;\r\n    }\r\n}\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/snippet/snippetSession.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nObject(common_themeService["registerThemingParticipant"])((theme, collector) => {\r\n    function getColorGraceful(name) {\r\n        const color = theme.getColor(name);\r\n        return color ? color.toString() : \'transparent\';\r\n    }\r\n    collector.addRule(`.monaco-editor .snippet-placeholder { background-color: ${getColorGraceful(colorRegistry["snippetTabstopHighlightBackground"])}; outline-color: ${getColorGraceful(colorRegistry["snippetTabstopHighlightBorder"])}; }`);\r\n    collector.addRule(`.monaco-editor .finish-snippet-placeholder { background-color: ${getColorGraceful(colorRegistry["snippetFinalTabstopHighlightBackground"])}; outline-color: ${getColorGraceful(colorRegistry["snippetFinalTabstopHighlightBorder"])}; }`);\r\n});\r\nclass snippetSession_OneSnippet {\r\n    constructor(_editor, _snippet, _offset, _snippetLineLeadingWhitespace) {\r\n        this._editor = _editor;\r\n        this._snippet = _snippet;\r\n        this._offset = _offset;\r\n        this._snippetLineLeadingWhitespace = _snippetLineLeadingWhitespace;\r\n        this._nestingLevel = 1;\r\n        this._placeholderGroups = Object(arrays["groupBy"])(_snippet.placeholders, Placeholder.compareByIndex);\r\n        this._placeholderGroupsIdx = -1;\r\n    }\r\n    dispose() {\r\n        if (this._placeholderDecorations) {\r\n            this._editor.deltaDecorations([...this._placeholderDecorations.values()], []);\r\n        }\r\n        this._placeholderGroups.length = 0;\r\n    }\r\n    _initDecorations() {\r\n        if (this._placeholderDecorations) {\r\n            // already initialized\r\n            return;\r\n        }\r\n        this._placeholderDecorations = new Map();\r\n        const model = this._editor.getModel();\r\n        this._editor.changeDecorations(accessor => {\r\n            // create a decoration for each placeholder\r\n            for (const placeholder of this._snippet.placeholders) {\r\n                const placeholderOffset = this._snippet.offset(placeholder);\r\n                const placeholderLen = this._snippet.fullLen(placeholder);\r\n                const range = core_range["Range"].fromPositions(model.getPositionAt(this._offset + placeholderOffset), model.getPositionAt(this._offset + placeholderOffset + placeholderLen));\r\n                const options = placeholder.isFinalTabstop ? snippetSession_OneSnippet._decor.inactiveFinal : snippetSession_OneSnippet._decor.inactive;\r\n                const handle = accessor.addDecoration(range, options);\r\n                this._placeholderDecorations.set(placeholder, handle);\r\n            }\r\n        });\r\n    }\r\n    move(fwd) {\r\n        if (!this._editor.hasModel()) {\r\n            return [];\r\n        }\r\n        this._initDecorations();\r\n        // Transform placeholder text if necessary\r\n        if (this._placeholderGroupsIdx >= 0) {\r\n            let operations = [];\r\n            for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {\r\n                // Check if the placeholder has a transformation\r\n                if (placeholder.transform) {\r\n                    const id = this._placeholderDecorations.get(placeholder);\r\n                    const range = this._editor.getModel().getDecorationRange(id);\r\n                    const currentValue = this._editor.getModel().getValueInRange(range);\r\n                    const transformedValueLines = placeholder.transform.resolve(currentValue).split(/\\r\\n|\\r|\\n/);\r\n                    // fix indentation for transformed lines\r\n                    for (let i = 1; i < transformedValueLines.length; i++) {\r\n                        transformedValueLines[i] = this._editor.getModel().normalizeIndentation(this._snippetLineLeadingWhitespace + transformedValueLines[i]);\r\n                    }\r\n                    operations.push(editOperation["EditOperation"].replace(range, transformedValueLines.join(this._editor.getModel().getEOL())));\r\n                }\r\n            }\r\n            if (operations.length > 0) {\r\n                this._editor.executeEdits(\'snippet.placeholderTransform\', operations);\r\n            }\r\n        }\r\n        let couldSkipThisPlaceholder = false;\r\n        if (fwd === true && this._placeholderGroupsIdx < this._placeholderGroups.length - 1) {\r\n            this._placeholderGroupsIdx += 1;\r\n            couldSkipThisPlaceholder = true;\r\n        }\r\n        else if (fwd === false && this._placeholderGroupsIdx > 0) {\r\n            this._placeholderGroupsIdx -= 1;\r\n            couldSkipThisPlaceholder = true;\r\n        }\r\n        else {\r\n            // the selection of the current placeholder might\r\n            // not acurate any more -> simply restore it\r\n        }\r\n        const newSelections = this._editor.getModel().changeDecorations(accessor => {\r\n            const activePlaceholders = new Set();\r\n            // change stickiness to always grow when typing at its edges\r\n            // because these decorations represent the currently active\r\n            // tabstop.\r\n            // Special case #1: reaching the final tabstop\r\n            // Special case #2: placeholders enclosing active placeholders\r\n            const selections = [];\r\n            for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {\r\n                const id = this._placeholderDecorations.get(placeholder);\r\n                const range = this._editor.getModel().getDecorationRange(id);\r\n                selections.push(new core_selection["Selection"](range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn));\r\n                // consider to skip this placeholder index when the decoration\r\n                // range is empty but when the placeholder wasn\'t. that\'s a strong\r\n                // hint that the placeholder has been deleted. (all placeholder must match this)\r\n                couldSkipThisPlaceholder = couldSkipThisPlaceholder && this._hasPlaceholderBeenCollapsed(placeholder);\r\n                accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? snippetSession_OneSnippet._decor.activeFinal : snippetSession_OneSnippet._decor.active);\r\n                activePlaceholders.add(placeholder);\r\n                for (const enclosingPlaceholder of this._snippet.enclosingPlaceholders(placeholder)) {\r\n                    const id = this._placeholderDecorations.get(enclosingPlaceholder);\r\n                    accessor.changeDecorationOptions(id, enclosingPlaceholder.isFinalTabstop ? snippetSession_OneSnippet._decor.activeFinal : snippetSession_OneSnippet._decor.active);\r\n                    activePlaceholders.add(enclosingPlaceholder);\r\n                }\r\n            }\r\n            // change stickness to never grow when typing at its edges\r\n            // so that in-active tabstops never grow\r\n            for (const [placeholder, id] of this._placeholderDecorations) {\r\n                if (!activePlaceholders.has(placeholder)) {\r\n                    accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? snippetSession_OneSnippet._decor.inactiveFinal : snippetSession_OneSnippet._decor.inactive);\r\n                }\r\n            }\r\n            return selections;\r\n        });\r\n        return !couldSkipThisPlaceholder ? newSelections !== null && newSelections !== void 0 ? newSelections : [] : this.move(fwd);\r\n    }\r\n    _hasPlaceholderBeenCollapsed(placeholder) {\r\n        // A placeholder is empty when it wasn\'t empty when authored but\r\n        // when its tracking decoration is empty. This also applies to all\r\n        // potential parent placeholders\r\n        let marker = placeholder;\r\n        while (marker) {\r\n            if (marker instanceof Placeholder) {\r\n                const id = this._placeholderDecorations.get(marker);\r\n                const range = this._editor.getModel().getDecorationRange(id);\r\n                if (range.isEmpty() && marker.toString().length > 0) {\r\n                    return true;\r\n                }\r\n            }\r\n            marker = marker.parent;\r\n        }\r\n        return false;\r\n    }\r\n    get isAtFirstPlaceholder() {\r\n        return this._placeholderGroupsIdx <= 0 || this._placeholderGroups.length === 0;\r\n    }\r\n    get isAtLastPlaceholder() {\r\n        return this._placeholderGroupsIdx === this._placeholderGroups.length - 1;\r\n    }\r\n    get hasPlaceholder() {\r\n        return this._snippet.placeholders.length > 0;\r\n    }\r\n    computePossibleSelections() {\r\n        const result = new Map();\r\n        for (const placeholdersWithEqualIndex of this._placeholderGroups) {\r\n            let ranges;\r\n            for (const placeholder of placeholdersWithEqualIndex) {\r\n                if (placeholder.isFinalTabstop) {\r\n                    // ignore those\r\n                    break;\r\n                }\r\n                if (!ranges) {\r\n                    ranges = [];\r\n                    result.set(placeholder.index, ranges);\r\n                }\r\n                const id = this._placeholderDecorations.get(placeholder);\r\n                const range = this._editor.getModel().getDecorationRange(id);\r\n                if (!range) {\r\n                    // one of the placeholder lost its decoration and\r\n                    // therefore we bail out and pretend the placeholder\r\n                    // (with its mirrors) doesn\'t exist anymore.\r\n                    result.delete(placeholder.index);\r\n                    break;\r\n                }\r\n                ranges.push(range);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    get choice() {\r\n        return this._placeholderGroups[this._placeholderGroupsIdx][0].choice;\r\n    }\r\n    merge(others) {\r\n        const model = this._editor.getModel();\r\n        this._nestingLevel *= 10;\r\n        this._editor.changeDecorations(accessor => {\r\n            // For each active placeholder take one snippet and merge it\r\n            // in that the placeholder (can be many for `$1foo$1foo`). Because\r\n            // everything is sorted by editor selection we can simply remove\r\n            // elements from the beginning of the array\r\n            for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {\r\n                const nested = others.shift();\r\n                console.assert(!nested._placeholderDecorations);\r\n                // Massage placeholder-indicies of the nested snippet to be\r\n                // sorted right after the insertion point. This ensures we move\r\n                // through the placeholders in the correct order\r\n                const indexLastPlaceholder = nested._snippet.placeholderInfo.last.index;\r\n                for (const nestedPlaceholder of nested._snippet.placeholderInfo.all) {\r\n                    if (nestedPlaceholder.isFinalTabstop) {\r\n                        nestedPlaceholder.index = placeholder.index + ((indexLastPlaceholder + 1) / this._nestingLevel);\r\n                    }\r\n                    else {\r\n                        nestedPlaceholder.index = placeholder.index + (nestedPlaceholder.index / this._nestingLevel);\r\n                    }\r\n                }\r\n                this._snippet.replace(placeholder, nested._snippet.children);\r\n                // Remove the placeholder at which position are inserting\r\n                // the snippet and also remove its decoration.\r\n                const id = this._placeholderDecorations.get(placeholder);\r\n                accessor.removeDecoration(id);\r\n                this._placeholderDecorations.delete(placeholder);\r\n                // For each *new* placeholder we create decoration to monitor\r\n                // how and if it grows/shrinks.\r\n                for (const placeholder of nested._snippet.placeholders) {\r\n                    const placeholderOffset = nested._snippet.offset(placeholder);\r\n                    const placeholderLen = nested._snippet.fullLen(placeholder);\r\n                    const range = core_range["Range"].fromPositions(model.getPositionAt(nested._offset + placeholderOffset), model.getPositionAt(nested._offset + placeholderOffset + placeholderLen));\r\n                    const handle = accessor.addDecoration(range, snippetSession_OneSnippet._decor.inactive);\r\n                    this._placeholderDecorations.set(placeholder, handle);\r\n                }\r\n            }\r\n            // Last, re-create the placeholder groups by sorting placeholders by their index.\r\n            this._placeholderGroups = Object(arrays["groupBy"])(this._snippet.placeholders, Placeholder.compareByIndex);\r\n        });\r\n    }\r\n}\r\nsnippetSession_OneSnippet._decor = {\r\n    active: model_textModel["ModelDecorationOptions"].register({ description: \'snippet-placeholder-1\', stickiness: 0 /* AlwaysGrowsWhenTypingAtEdges */, className: \'snippet-placeholder\' }),\r\n    inactive: model_textModel["ModelDecorationOptions"].register({ description: \'snippet-placeholder-2\', stickiness: 1 /* NeverGrowsWhenTypingAtEdges */, className: \'snippet-placeholder\' }),\r\n    activeFinal: model_textModel["ModelDecorationOptions"].register({ description: \'snippet-placeholder-3\', stickiness: 1 /* NeverGrowsWhenTypingAtEdges */, className: \'finish-snippet-placeholder\' }),\r\n    inactiveFinal: model_textModel["ModelDecorationOptions"].register({ description: \'snippet-placeholder-4\', stickiness: 1 /* NeverGrowsWhenTypingAtEdges */, className: \'finish-snippet-placeholder\' }),\r\n};\r\nconst _defaultOptions = {\r\n    overwriteBefore: 0,\r\n    overwriteAfter: 0,\r\n    adjustWhitespace: true,\r\n    clipboardText: undefined,\r\n    overtypingCapturer: undefined\r\n};\r\nclass snippetSession_SnippetSession {\r\n    constructor(editor, template, options = _defaultOptions) {\r\n        this._templateMerges = [];\r\n        this._snippets = [];\r\n        this._editor = editor;\r\n        this._template = template;\r\n        this._options = options;\r\n    }\r\n    static adjustWhitespace(model, position, snippet, adjustIndentation, adjustNewlines) {\r\n        const line = model.getLineContent(position.lineNumber);\r\n        const lineLeadingWhitespace = Object(strings["getLeadingWhitespace"])(line, 0, position.column - 1);\r\n        // the snippet as inserted\r\n        let snippetTextString;\r\n        snippet.walk(marker => {\r\n            // all text elements that are not inside choice\r\n            if (!(marker instanceof Text) || marker.parent instanceof Choice) {\r\n                return true;\r\n            }\r\n            const lines = marker.value.split(/\\r\\n|\\r|\\n/);\r\n            if (adjustIndentation) {\r\n                // adjust indentation of snippet test\r\n                // -the snippet-start doesn\'t get extra-indented (lineLeadingWhitespace), only normalized\r\n                // -all N+1 lines get extra-indented and normalized\r\n                // -the text start get extra-indented and normalized when following a linebreak\r\n                const offset = snippet.offset(marker);\r\n                if (offset === 0) {\r\n                    // snippet start\r\n                    lines[0] = model.normalizeIndentation(lines[0]);\r\n                }\r\n                else {\r\n                    // check if text start is after a linebreak\r\n                    snippetTextString = snippetTextString !== null && snippetTextString !== void 0 ? snippetTextString : snippet.toString();\r\n                    let prevChar = snippetTextString.charCodeAt(offset - 1);\r\n                    if (prevChar === 10 /* LineFeed */ || prevChar === 13 /* CarriageReturn */) {\r\n                        lines[0] = model.normalizeIndentation(lineLeadingWhitespace + lines[0]);\r\n                    }\r\n                }\r\n                for (let i = 1; i < lines.length; i++) {\r\n                    lines[i] = model.normalizeIndentation(lineLeadingWhitespace + lines[i]);\r\n                }\r\n            }\r\n            const newValue = lines.join(model.getEOL());\r\n            if (newValue !== marker.value) {\r\n                marker.parent.replace(marker, [new Text(newValue)]);\r\n                snippetTextString = undefined;\r\n            }\r\n            return true;\r\n        });\r\n        return lineLeadingWhitespace;\r\n    }\r\n    static adjustSelection(model, selection, overwriteBefore, overwriteAfter) {\r\n        if (overwriteBefore !== 0 || overwriteAfter !== 0) {\r\n            // overwrite[Before|After] is compute using the position, not the whole\r\n            // selection. therefore we adjust the selection around that position\r\n            const { positionLineNumber, positionColumn } = selection;\r\n            const positionColumnBefore = positionColumn - overwriteBefore;\r\n            const positionColumnAfter = positionColumn + overwriteAfter;\r\n            const range = model.validateRange({\r\n                startLineNumber: positionLineNumber,\r\n                startColumn: positionColumnBefore,\r\n                endLineNumber: positionLineNumber,\r\n                endColumn: positionColumnAfter\r\n            });\r\n            selection = core_selection["Selection"].createWithDirection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn, selection.getDirection());\r\n        }\r\n        return selection;\r\n    }\r\n    static createEditsAndSnippets(editor, template, overwriteBefore, overwriteAfter, enforceFinalTabstop, adjustWhitespace, clipboardText, overtypingCapturer) {\r\n        const edits = [];\r\n        const snippets = [];\r\n        if (!editor.hasModel()) {\r\n            return { edits, snippets };\r\n        }\r\n        const model = editor.getModel();\r\n        const workspaceService = editor.invokeWithinContext(accessor => accessor.get(workspace["IWorkspaceContextService"], instantiation["optional"]));\r\n        const modelBasedVariableResolver = editor.invokeWithinContext(accessor => new snippetVariables_ModelBasedVariableResolver(accessor.get(common_label["ILabelService"], instantiation["optional"]), model));\r\n        const readClipboardText = () => clipboardText;\r\n        let delta = 0;\r\n        // know what text the overwrite[Before|After] extensions\r\n        // of the primary curser have selected because only when\r\n        // secondary selections extend to the same text we can grow them\r\n        let firstBeforeText = model.getValueInRange(snippetSession_SnippetSession.adjustSelection(model, editor.getSelection(), overwriteBefore, 0));\r\n        let firstAfterText = model.getValueInRange(snippetSession_SnippetSession.adjustSelection(model, editor.getSelection(), 0, overwriteAfter));\r\n        // remember the first non-whitespace column to decide if\r\n        // `keepWhitespace` should be overruled for secondary selections\r\n        let firstLineFirstNonWhitespace = model.getLineFirstNonWhitespaceColumn(editor.getSelection().positionLineNumber);\r\n        // sort selections by their start position but remeber\r\n        // the original index. that allows you to create correct\r\n        // offset-based selection logic without changing the\r\n        // primary selection\r\n        const indexedSelections = editor.getSelections()\r\n            .map((selection, idx) => ({ selection, idx }))\r\n            .sort((a, b) => core_range["Range"].compareRangesUsingStarts(a.selection, b.selection));\r\n        for (const { selection, idx } of indexedSelections) {\r\n            // extend selection with the `overwriteBefore` and `overwriteAfter` and then\r\n            // compare if this matches the extensions of the primary selection\r\n            let extensionBefore = snippetSession_SnippetSession.adjustSelection(model, selection, overwriteBefore, 0);\r\n            let extensionAfter = snippetSession_SnippetSession.adjustSelection(model, selection, 0, overwriteAfter);\r\n            if (firstBeforeText !== model.getValueInRange(extensionBefore)) {\r\n                extensionBefore = selection;\r\n            }\r\n            if (firstAfterText !== model.getValueInRange(extensionAfter)) {\r\n                extensionAfter = selection;\r\n            }\r\n            // merge the before and after selection into one\r\n            const snippetSelection = selection\r\n                .setStartPosition(extensionBefore.startLineNumber, extensionBefore.startColumn)\r\n                .setEndPosition(extensionAfter.endLineNumber, extensionAfter.endColumn);\r\n            const snippet = new SnippetParser().parse(template, true, enforceFinalTabstop);\r\n            // adjust the template string to match the indentation and\r\n            // whitespace rules of this insert location (can be different for each cursor)\r\n            // happens when being asked for (default) or when this is a secondary\r\n            // cursor and the leading whitespace is different\r\n            const start = snippetSelection.getStartPosition();\r\n            const snippetLineLeadingWhitespace = snippetSession_SnippetSession.adjustWhitespace(model, start, snippet, adjustWhitespace || (idx > 0 && firstLineFirstNonWhitespace !== model.getLineFirstNonWhitespaceColumn(selection.positionLineNumber)), true);\r\n            snippet.resolveVariables(new CompositeSnippetVariableResolver([\r\n                modelBasedVariableResolver,\r\n                new snippetVariables_ClipboardBasedVariableResolver(readClipboardText, idx, indexedSelections.length, editor.getOption(70 /* multiCursorPaste */) === \'spread\'),\r\n                new snippetVariables_SelectionBasedVariableResolver(model, selection, idx, overtypingCapturer),\r\n                new snippetVariables_CommentBasedVariableResolver(model, selection),\r\n                new TimeBasedVariableResolver,\r\n                new snippetVariables_WorkspaceBasedVariableResolver(workspaceService),\r\n                new snippetVariables_RandomBasedVariableResolver,\r\n            ]));\r\n            const offset = model.getOffsetAt(start) + delta;\r\n            delta += snippet.toString().length - model.getValueLengthInRange(snippetSelection);\r\n            // store snippets with the index of their originating selection.\r\n            // that ensures the primiary cursor stays primary despite not being\r\n            // the one with lowest start position\r\n            edits[idx] = editOperation["EditOperation"].replace(snippetSelection, snippet.toString());\r\n            edits[idx].identifier = { major: idx, minor: 0 }; // mark the edit so only our undo edits will be used to generate end cursors\r\n            snippets[idx] = new snippetSession_OneSnippet(editor, snippet, offset, snippetLineLeadingWhitespace);\r\n        }\r\n        return { edits, snippets };\r\n    }\r\n    dispose() {\r\n        Object(lifecycle["dispose"])(this._snippets);\r\n    }\r\n    _logInfo() {\r\n        return `template="${this._template}", merged_templates="${this._templateMerges.join(\' -> \')}"`;\r\n    }\r\n    insert() {\r\n        if (!this._editor.hasModel()) {\r\n            return;\r\n        }\r\n        // make insert edit and start with first selections\r\n        const { edits, snippets } = snippetSession_SnippetSession.createEditsAndSnippets(this._editor, this._template, this._options.overwriteBefore, this._options.overwriteAfter, false, this._options.adjustWhitespace, this._options.clipboardText, this._options.overtypingCapturer);\r\n        this._snippets = snippets;\r\n        this._editor.executeEdits(\'snippet\', edits, undoEdits => {\r\n            if (this._snippets[0].hasPlaceholder) {\r\n                return this._move(true);\r\n            }\r\n            else {\r\n                return undoEdits\r\n                    .filter(edit => !!edit.identifier) // only use our undo edits\r\n                    .map(edit => core_selection["Selection"].fromPositions(edit.range.getEndPosition()));\r\n            }\r\n        });\r\n        this._editor.revealRange(this._editor.getSelections()[0]);\r\n    }\r\n    merge(template, options = _defaultOptions) {\r\n        if (!this._editor.hasModel()) {\r\n            return;\r\n        }\r\n        this._templateMerges.push([this._snippets[0]._nestingLevel, this._snippets[0]._placeholderGroupsIdx, template]);\r\n        const { edits, snippets } = snippetSession_SnippetSession.createEditsAndSnippets(this._editor, template, options.overwriteBefore, options.overwriteAfter, true, options.adjustWhitespace, options.clipboardText, options.overtypingCapturer);\r\n        this._editor.executeEdits(\'snippet\', edits, undoEdits => {\r\n            for (const snippet of this._snippets) {\r\n                snippet.merge(snippets);\r\n            }\r\n            console.assert(snippets.length === 0);\r\n            if (this._snippets[0].hasPlaceholder) {\r\n                return this._move(undefined);\r\n            }\r\n            else {\r\n                return (undoEdits\r\n                    .filter(edit => !!edit.identifier) // only use our undo edits\r\n                    .map(edit => core_selection["Selection"].fromPositions(edit.range.getEndPosition())));\r\n            }\r\n        });\r\n    }\r\n    next() {\r\n        const newSelections = this._move(true);\r\n        this._editor.setSelections(newSelections);\r\n        this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());\r\n    }\r\n    prev() {\r\n        const newSelections = this._move(false);\r\n        this._editor.setSelections(newSelections);\r\n        this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());\r\n    }\r\n    _move(fwd) {\r\n        const selections = [];\r\n        for (const snippet of this._snippets) {\r\n            const oneSelection = snippet.move(fwd);\r\n            selections.push(...oneSelection);\r\n        }\r\n        return selections;\r\n    }\r\n    get isAtFirstPlaceholder() {\r\n        return this._snippets[0].isAtFirstPlaceholder;\r\n    }\r\n    get isAtLastPlaceholder() {\r\n        return this._snippets[0].isAtLastPlaceholder;\r\n    }\r\n    get hasPlaceholder() {\r\n        return this._snippets[0].hasPlaceholder;\r\n    }\r\n    get choice() {\r\n        return this._snippets[0].choice;\r\n    }\r\n    isSelectionWithinPlaceholders() {\r\n        if (!this.hasPlaceholder) {\r\n            return false;\r\n        }\r\n        const selections = this._editor.getSelections();\r\n        if (selections.length < this._snippets.length) {\r\n            // this means we started snippet mode with N\r\n            // selections and have M (N > M) selections.\r\n            // So one snippet is without selection -> cancel\r\n            return false;\r\n        }\r\n        let allPossibleSelections = new Map();\r\n        for (const snippet of this._snippets) {\r\n            const possibleSelections = snippet.computePossibleSelections();\r\n            // for the first snippet find the placeholder (and its ranges)\r\n            // that contain at least one selection. for all remaining snippets\r\n            // the same placeholder (and their ranges) must be used.\r\n            if (allPossibleSelections.size === 0) {\r\n                for (const [index, ranges] of possibleSelections) {\r\n                    ranges.sort(core_range["Range"].compareRangesUsingStarts);\r\n                    for (const selection of selections) {\r\n                        if (ranges[0].containsRange(selection)) {\r\n                            allPossibleSelections.set(index, []);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (allPossibleSelections.size === 0) {\r\n                // return false if we couldn\'t associate a selection to\r\n                // this (the first) snippet\r\n                return false;\r\n            }\r\n            // add selections from \'this\' snippet so that we know all\r\n            // selections for this placeholder\r\n            allPossibleSelections.forEach((array, index) => {\r\n                array.push(...possibleSelections.get(index));\r\n            });\r\n        }\r\n        // sort selections (and later placeholder-ranges). then walk both\r\n        // arrays and make sure the placeholder-ranges contain the corresponding\r\n        // selection\r\n        selections.sort(core_range["Range"].compareRangesUsingStarts);\r\n        for (let [index, ranges] of allPossibleSelections) {\r\n            if (ranges.length !== selections.length) {\r\n                allPossibleSelections.delete(index);\r\n                continue;\r\n            }\r\n            ranges.sort(core_range["Range"].compareRangesUsingStarts);\r\n            for (let i = 0; i < ranges.length; i++) {\r\n                if (!ranges[i].containsRange(selections[i])) {\r\n                    allPossibleSelections.delete(index);\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n        // from all possible selections we have deleted those\r\n        // that don\'t match with the current selection. if we don\'t\r\n        // have any left, we don\'t have a selection anymore\r\n        return allPossibleSelections.size > 0;\r\n    }\r\n}\r\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/common/filters.js\nvar filters = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/common/filters.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/common/stopwatch.js\nvar stopwatch = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/common/stopwatch.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/common/types.js\nvar types = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/common/types.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/services/resolverService.js\nvar resolverService = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/common/services/resolverService.js");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggest.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar suggest_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst Context = {\r\n    Visible: new contextkey["RawContextKey"](\'suggestWidgetVisible\', false, Object(nls["localize"])(\'suggestWidgetVisible\', "Whether suggestion are visible")),\r\n    DetailsVisible: new contextkey["RawContextKey"](\'suggestWidgetDetailsVisible\', false, Object(nls["localize"])(\'suggestWidgetDetailsVisible\', "Whether suggestion details are visible")),\r\n    MultipleSuggestions: new contextkey["RawContextKey"](\'suggestWidgetMultipleSuggestions\', false, Object(nls["localize"])(\'suggestWidgetMultipleSuggestions\', "Whether there are multiple suggestions to pick from")),\r\n    MakesTextEdit: new contextkey["RawContextKey"](\'suggestionMakesTextEdit\', true, Object(nls["localize"])(\'suggestionMakesTextEdit\', "Whether inserting the current suggestion yields in a change or has everything already been typed")),\r\n    AcceptSuggestionsOnEnter: new contextkey["RawContextKey"](\'acceptSuggestionOnEnter\', true, Object(nls["localize"])(\'acceptSuggestionOnEnter\', "Whether suggestions are inserted when pressing Enter")),\r\n    HasInsertAndReplaceRange: new contextkey["RawContextKey"](\'suggestionHasInsertAndReplaceRange\', false, Object(nls["localize"])(\'suggestionHasInsertAndReplaceRange\', "Whether the current suggestion has insert and replace behaviour")),\r\n    InsertMode: new contextkey["RawContextKey"](\'suggestionInsertMode\', undefined, { type: \'string\', description: Object(nls["localize"])(\'suggestionInsertMode\', "Whether the default behaviour is to insert or replace") }),\r\n    CanResolve: new contextkey["RawContextKey"](\'suggestionCanResolve\', false, Object(nls["localize"])(\'suggestionCanResolve\', "Whether the current suggestion supports to resolve further details")),\r\n};\r\nconst suggestWidgetStatusbarMenu = new actions_common_actions["MenuId"](\'suggestWidgetStatusBar\');\r\nclass suggest_CompletionItem {\r\n    constructor(position, completion, container, provider) {\r\n        this.position = position;\r\n        this.completion = completion;\r\n        this.container = container;\r\n        this.provider = provider;\r\n        // validation\r\n        this.isInvalid = false;\r\n        // sorting, filtering\r\n        this.score = filters["FuzzyScore"].Default;\r\n        this.distance = 0;\r\n        this.textLabel = typeof completion.label === \'string\'\r\n            ? completion.label\r\n            : completion.label.label;\r\n        // ensure lower-variants (perf)\r\n        this.labelLow = this.textLabel.toLowerCase();\r\n        // validate label\r\n        this.isInvalid = !this.textLabel;\r\n        this.sortTextLow = completion.sortText && completion.sortText.toLowerCase();\r\n        this.filterTextLow = completion.filterText && completion.filterText.toLowerCase();\r\n        // normalize ranges\r\n        if (core_range["Range"].isIRange(completion.range)) {\r\n            this.editStart = new core_position["Position"](completion.range.startLineNumber, completion.range.startColumn);\r\n            this.editInsertEnd = new core_position["Position"](completion.range.endLineNumber, completion.range.endColumn);\r\n            this.editReplaceEnd = new core_position["Position"](completion.range.endLineNumber, completion.range.endColumn);\r\n            // validate range\r\n            this.isInvalid = this.isInvalid\r\n                || core_range["Range"].spansMultipleLines(completion.range) || completion.range.startLineNumber !== position.lineNumber;\r\n        }\r\n        else {\r\n            this.editStart = new core_position["Position"](completion.range.insert.startLineNumber, completion.range.insert.startColumn);\r\n            this.editInsertEnd = new core_position["Position"](completion.range.insert.endLineNumber, completion.range.insert.endColumn);\r\n            this.editReplaceEnd = new core_position["Position"](completion.range.replace.endLineNumber, completion.range.replace.endColumn);\r\n            // validate ranges\r\n            this.isInvalid = this.isInvalid\r\n                || core_range["Range"].spansMultipleLines(completion.range.insert) || core_range["Range"].spansMultipleLines(completion.range.replace)\r\n                || completion.range.insert.startLineNumber !== position.lineNumber || completion.range.replace.startLineNumber !== position.lineNumber\r\n                || completion.range.insert.startColumn !== completion.range.replace.startColumn;\r\n        }\r\n        // create the suggestion resolver\r\n        if (typeof provider.resolveCompletionItem !== \'function\') {\r\n            this._resolveCache = Promise.resolve();\r\n            this._isResolved = true;\r\n        }\r\n    }\r\n    // ---- resolving\r\n    get isResolved() {\r\n        return !!this._isResolved;\r\n    }\r\n    resolve(token) {\r\n        return suggest_awaiter(this, void 0, void 0, function* () {\r\n            if (!this._resolveCache) {\r\n                const sub = token.onCancellationRequested(() => {\r\n                    this._resolveCache = undefined;\r\n                    this._isResolved = false;\r\n                });\r\n                this._resolveCache = Promise.resolve(this.provider.resolveCompletionItem(this.completion, token)).then(value => {\r\n                    Object.assign(this.completion, value);\r\n                    this._isResolved = true;\r\n                    sub.dispose();\r\n                }, err => {\r\n                    if (Object(errors["isPromiseCanceledError"])(err)) {\r\n                        // the IPC queue will reject the request with the\r\n                        // cancellation error -> reset cached\r\n                        this._resolveCache = undefined;\r\n                        this._isResolved = false;\r\n                    }\r\n                });\r\n            }\r\n            return this._resolveCache;\r\n        });\r\n    }\r\n}\r\nclass CompletionOptions {\r\n    constructor(snippetSortOrder = 2 /* Bottom */, kindFilter = new Set(), providerFilter = new Set(), showDeprecated = true) {\r\n        this.snippetSortOrder = snippetSortOrder;\r\n        this.kindFilter = kindFilter;\r\n        this.providerFilter = providerFilter;\r\n        this.showDeprecated = showDeprecated;\r\n    }\r\n}\r\nCompletionOptions.default = new CompletionOptions();\r\nlet _snippetSuggestSupport;\r\nfunction getSnippetSuggestSupport() {\r\n    return _snippetSuggestSupport;\r\n}\r\nclass CompletionItemModel {\r\n    constructor(items, needsClipboard, durations, disposable) {\r\n        this.items = items;\r\n        this.needsClipboard = needsClipboard;\r\n        this.durations = durations;\r\n        this.disposable = disposable;\r\n    }\r\n}\r\nfunction provideSuggestionItems(model, position, options = CompletionOptions.default, context = { triggerKind: 0 /* Invoke */ }, token = cancellation["CancellationToken"].None) {\r\n    return suggest_awaiter(this, void 0, void 0, function* () {\r\n        const sw = new stopwatch["StopWatch"](true);\r\n        position = position.clone();\r\n        const word = model.getWordAtPosition(position);\r\n        const defaultReplaceRange = word ? new core_range["Range"](position.lineNumber, word.startColumn, position.lineNumber, word.endColumn) : core_range["Range"].fromPositions(position);\r\n        const defaultRange = { replace: defaultReplaceRange, insert: defaultReplaceRange.setEndPosition(position.lineNumber, position.column) };\r\n        const result = [];\r\n        const disposables = new lifecycle["DisposableStore"]();\r\n        const durations = [];\r\n        let needsClipboard = false;\r\n        const onCompletionList = (provider, container, sw) => {\r\n            var _a, _b, _c;\r\n            if (!container) {\r\n                return;\r\n            }\r\n            for (let suggestion of container.suggestions) {\r\n                if (!options.kindFilter.has(suggestion.kind)) {\r\n                    // skip if not showing deprecated suggestions\r\n                    if (!options.showDeprecated && ((_a = suggestion === null || suggestion === void 0 ? void 0 : suggestion.tags) === null || _a === void 0 ? void 0 : _a.includes(1 /* Deprecated */))) {\r\n                        continue;\r\n                    }\r\n                    // fill in default range when missing\r\n                    if (!suggestion.range) {\r\n                        suggestion.range = defaultRange;\r\n                    }\r\n                    // fill in default sortText when missing\r\n                    if (!suggestion.sortText) {\r\n                        suggestion.sortText = typeof suggestion.label === \'string\' ? suggestion.label : suggestion.label.label;\r\n                    }\r\n                    if (!needsClipboard && suggestion.insertTextRules && suggestion.insertTextRules & 4 /* InsertAsSnippet */) {\r\n                        needsClipboard = SnippetParser.guessNeedsClipboard(suggestion.insertText);\r\n                    }\r\n                    result.push(new suggest_CompletionItem(position, suggestion, container, provider));\r\n                }\r\n            }\r\n            if (Object(lifecycle["isDisposable"])(container)) {\r\n                disposables.add(container);\r\n            }\r\n            durations.push({\r\n                providerName: (_b = provider._debugDisplayName) !== null && _b !== void 0 ? _b : \'unkown_provider\', elapsedProvider: (_c = container.duration) !== null && _c !== void 0 ? _c : -1, elapsedOverall: sw.elapsed()\r\n            });\r\n        };\r\n        // ask for snippets in parallel to asking "real" providers. Only do something if configured to\r\n        // do so - no snippet filter, no special-providers-only request\r\n        const snippetCompletions = (() => suggest_awaiter(this, void 0, void 0, function* () {\r\n            if (!_snippetSuggestSupport || options.kindFilter.has(27 /* Snippet */)) {\r\n                return;\r\n            }\r\n            if (options.providerFilter.size > 0 && !options.providerFilter.has(_snippetSuggestSupport)) {\r\n                return;\r\n            }\r\n            const sw = new stopwatch["StopWatch"](true);\r\n            const list = yield _snippetSuggestSupport.provideCompletionItems(model, position, context, token);\r\n            onCompletionList(_snippetSuggestSupport, list, sw);\r\n        }))();\r\n        // add suggestions from contributed providers - providers are ordered in groups of\r\n        // equal score and once a group produces a result the process stops\r\n        // get provider groups, always add snippet suggestion provider\r\n        for (let providerGroup of modes["CompletionProviderRegistry"].orderedGroups(model)) {\r\n            // for each support in the group ask for suggestions\r\n            let lenBefore = result.length;\r\n            yield Promise.all(providerGroup.map((provider) => suggest_awaiter(this, void 0, void 0, function* () {\r\n                if (options.providerFilter.size > 0 && !options.providerFilter.has(provider)) {\r\n                    return;\r\n                }\r\n                try {\r\n                    const sw = new stopwatch["StopWatch"](true);\r\n                    const list = yield provider.provideCompletionItems(model, position, context, token);\r\n                    onCompletionList(provider, list, sw);\r\n                }\r\n                catch (err) {\r\n                    Object(errors["onUnexpectedExternalError"])(err);\r\n                }\r\n            })));\r\n            if (lenBefore !== result.length || token.isCancellationRequested) {\r\n                break;\r\n            }\r\n        }\r\n        yield snippetCompletions;\r\n        if (token.isCancellationRequested) {\r\n            disposables.dispose();\r\n            return Promise.reject(Object(errors["canceled"])());\r\n        }\r\n        return new CompletionItemModel(result.sort(getSuggestionComparator(options.snippetSortOrder)), needsClipboard, { entries: durations, elapsed: sw.elapsed() }, disposables);\r\n    });\r\n}\r\nfunction defaultComparator(a, b) {\r\n    // check with \'sortText\'\r\n    if (a.sortTextLow && b.sortTextLow) {\r\n        if (a.sortTextLow < b.sortTextLow) {\r\n            return -1;\r\n        }\r\n        else if (a.sortTextLow > b.sortTextLow) {\r\n            return 1;\r\n        }\r\n    }\r\n    // check with \'label\'\r\n    if (a.completion.label < b.completion.label) {\r\n        return -1;\r\n    }\r\n    else if (a.completion.label > b.completion.label) {\r\n        return 1;\r\n    }\r\n    // check with \'type\'\r\n    return a.completion.kind - b.completion.kind;\r\n}\r\nfunction snippetUpComparator(a, b) {\r\n    if (a.completion.kind !== b.completion.kind) {\r\n        if (a.completion.kind === 27 /* Snippet */) {\r\n            return -1;\r\n        }\r\n        else if (b.completion.kind === 27 /* Snippet */) {\r\n            return 1;\r\n        }\r\n    }\r\n    return defaultComparator(a, b);\r\n}\r\nfunction snippetDownComparator(a, b) {\r\n    if (a.completion.kind !== b.completion.kind) {\r\n        if (a.completion.kind === 27 /* Snippet */) {\r\n            return 1;\r\n        }\r\n        else if (b.completion.kind === 27 /* Snippet */) {\r\n            return -1;\r\n        }\r\n    }\r\n    return defaultComparator(a, b);\r\n}\r\nconst _snippetComparators = new Map();\r\n_snippetComparators.set(0 /* Top */, snippetUpComparator);\r\n_snippetComparators.set(2 /* Bottom */, snippetDownComparator);\r\n_snippetComparators.set(1 /* Inline */, defaultComparator);\r\nfunction getSuggestionComparator(snippetConfig) {\r\n    return _snippetComparators.get(snippetConfig);\r\n}\r\ncommon_commands["CommandsRegistry"].registerCommand(\'_executeCompletionItemProvider\', (accessor, ...args) => suggest_awaiter(void 0, void 0, void 0, function* () {\r\n    const [uri, position, triggerCharacter, maxItemsToResolve] = args;\r\n    Object(types["assertType"])(common_uri["URI"].isUri(uri));\r\n    Object(types["assertType"])(core_position["Position"].isIPosition(position));\r\n    Object(types["assertType"])(typeof triggerCharacter === \'string\' || !triggerCharacter);\r\n    Object(types["assertType"])(typeof maxItemsToResolve === \'number\' || !maxItemsToResolve);\r\n    const ref = yield accessor.get(resolverService["ITextModelService"]).createModelReference(uri);\r\n    try {\r\n        const result = {\r\n            incomplete: false,\r\n            suggestions: []\r\n        };\r\n        const resolving = [];\r\n        const completions = yield provideSuggestionItems(ref.object.textEditorModel, core_position["Position"].lift(position), undefined, { triggerCharacter, triggerKind: triggerCharacter ? 1 /* TriggerCharacter */ : 0 /* Invoke */ });\r\n        for (const item of completions.items) {\r\n            if (resolving.length < (maxItemsToResolve !== null && maxItemsToResolve !== void 0 ? maxItemsToResolve : 0)) {\r\n                resolving.push(item.resolve(cancellation["CancellationToken"].None));\r\n            }\r\n            result.incomplete = result.incomplete || item.container.incomplete;\r\n            result.suggestions.push(item.completion);\r\n        }\r\n        try {\r\n            yield Promise.all(resolving);\r\n            return result;\r\n        }\r\n        finally {\r\n            setTimeout(() => completions.disposable.dispose(), 100);\r\n        }\r\n    }\r\n    finally {\r\n        ref.dispose();\r\n    }\r\n}));\r\nconst _provider = new class {\r\n    constructor() {\r\n        this.onlyOnceSuggestions = [];\r\n    }\r\n    provideCompletionItems() {\r\n        let suggestions = this.onlyOnceSuggestions.slice(0);\r\n        let result = { suggestions };\r\n        this.onlyOnceSuggestions.length = 0;\r\n        return result;\r\n    }\r\n};\r\nmodes["CompletionProviderRegistry"].register(\'*\', _provider);\r\nfunction showSimpleSuggestions(editor, suggestions) {\r\n    setTimeout(() => {\r\n        _provider.onlyOnceSuggestions.push(...suggestions);\r\n        editor.getContribution(\'editor.contrib.suggestController\').triggerSuggest(new Set().add(_provider));\r\n    }, 0);\r\n}\r\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/platform/log/common/log.js\nvar log = __webpack_require__("./node_modules/monaco-editor/esm/vs/platform/log/common/log.js");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/snippet/snippetController2.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar snippetController2_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar snippetController2_param = (undefined && undefined.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst snippetController2_defaultOptions = {\r\n    overwriteBefore: 0,\r\n    overwriteAfter: 0,\r\n    undoStopBefore: true,\r\n    undoStopAfter: true,\r\n    adjustWhitespace: true,\r\n    clipboardText: undefined,\r\n    overtypingCapturer: undefined\r\n};\r\nlet snippetController2_SnippetController2 = class SnippetController2 {\r\n    constructor(_editor, _logService, contextKeyService) {\r\n        this._editor = _editor;\r\n        this._logService = _logService;\r\n        this._snippetListener = new lifecycle["DisposableStore"]();\r\n        this._modelVersionId = -1;\r\n        this._inSnippet = SnippetController2.InSnippetMode.bindTo(contextKeyService);\r\n        this._hasNextTabstop = SnippetController2.HasNextTabstop.bindTo(contextKeyService);\r\n        this._hasPrevTabstop = SnippetController2.HasPrevTabstop.bindTo(contextKeyService);\r\n    }\r\n    static get(editor) {\r\n        return editor.getContribution(SnippetController2.ID);\r\n    }\r\n    dispose() {\r\n        var _a;\r\n        this._inSnippet.reset();\r\n        this._hasPrevTabstop.reset();\r\n        this._hasNextTabstop.reset();\r\n        (_a = this._session) === null || _a === void 0 ? void 0 : _a.dispose();\r\n        this._snippetListener.dispose();\r\n    }\r\n    insert(template, opts) {\r\n        // this is here to find out more about the yet-not-understood\r\n        // error that sometimes happens when we fail to inserted a nested\r\n        // snippet\r\n        try {\r\n            this._doInsert(template, typeof opts === \'undefined\' ? snippetController2_defaultOptions : Object.assign(Object.assign({}, snippetController2_defaultOptions), opts));\r\n        }\r\n        catch (e) {\r\n            this.cancel();\r\n            this._logService.error(e);\r\n            this._logService.error(\'snippet_error\');\r\n            this._logService.error(\'insert_template=\', template);\r\n            this._logService.error(\'existing_template=\', this._session ? this._session._logInfo() : \'<no_session>\');\r\n        }\r\n    }\r\n    _doInsert(template, opts) {\r\n        if (!this._editor.hasModel()) {\r\n            return;\r\n        }\r\n        // don\'t listen while inserting the snippet\r\n        // as that is the inflight state causing cancelation\r\n        this._snippetListener.clear();\r\n        if (opts.undoStopBefore) {\r\n            this._editor.getModel().pushStackElement();\r\n        }\r\n        if (!this._session) {\r\n            this._modelVersionId = this._editor.getModel().getAlternativeVersionId();\r\n            this._session = new snippetSession_SnippetSession(this._editor, template, opts);\r\n            this._session.insert();\r\n        }\r\n        else {\r\n            this._session.merge(template, opts);\r\n        }\r\n        if (opts.undoStopAfter) {\r\n            this._editor.getModel().pushStackElement();\r\n        }\r\n        this._updateState();\r\n        this._snippetListener.add(this._editor.onDidChangeModelContent(e => e.isFlush && this.cancel()));\r\n        this._snippetListener.add(this._editor.onDidChangeModel(() => this.cancel()));\r\n        this._snippetListener.add(this._editor.onDidChangeCursorSelection(() => this._updateState()));\r\n    }\r\n    _updateState() {\r\n        if (!this._session || !this._editor.hasModel()) {\r\n            // canceled in the meanwhile\r\n            return;\r\n        }\r\n        if (this._modelVersionId === this._editor.getModel().getAlternativeVersionId()) {\r\n            // undo until the \'before\' state happened\r\n            // and makes use cancel snippet mode\r\n            return this.cancel();\r\n        }\r\n        if (!this._session.hasPlaceholder) {\r\n            // don\'t listen for selection changes and don\'t\r\n            // update context keys when the snippet is plain text\r\n            return this.cancel();\r\n        }\r\n        if (this._session.isAtLastPlaceholder || !this._session.isSelectionWithinPlaceholders()) {\r\n            return this.cancel();\r\n        }\r\n        this._inSnippet.set(true);\r\n        this._hasPrevTabstop.set(!this._session.isAtFirstPlaceholder);\r\n        this._hasNextTabstop.set(!this._session.isAtLastPlaceholder);\r\n        this._handleChoice();\r\n    }\r\n    _handleChoice() {\r\n        if (!this._session || !this._editor.hasModel()) {\r\n            this._currentChoice = undefined;\r\n            return;\r\n        }\r\n        const { choice } = this._session;\r\n        if (!choice) {\r\n            this._currentChoice = undefined;\r\n            return;\r\n        }\r\n        if (this._currentChoice !== choice) {\r\n            this._currentChoice = choice;\r\n            this._editor.setSelections(this._editor.getSelections()\r\n                .map(s => core_selection["Selection"].fromPositions(s.getStartPosition())));\r\n            const [first] = choice.options;\r\n            showSimpleSuggestions(this._editor, choice.options.map((option, i) => {\r\n                // let before = choice.options.slice(0, i);\r\n                // let after = choice.options.slice(i);\r\n                return {\r\n                    kind: 13 /* Value */,\r\n                    label: option.value,\r\n                    insertText: option.value,\r\n                    // insertText: `\\${1|${after.concat(before).join(\',\')}|}$0`,\r\n                    // snippetType: \'textmate\',\r\n                    sortText: \'a\'.repeat(i + 1),\r\n                    range: core_range["Range"].fromPositions(this._editor.getPosition(), this._editor.getPosition().delta(0, first.value.length))\r\n                };\r\n            }));\r\n        }\r\n    }\r\n    finish() {\r\n        while (this._inSnippet.get()) {\r\n            this.next();\r\n        }\r\n    }\r\n    cancel(resetSelection = false) {\r\n        var _a;\r\n        this._inSnippet.reset();\r\n        this._hasPrevTabstop.reset();\r\n        this._hasNextTabstop.reset();\r\n        this._snippetListener.clear();\r\n        (_a = this._session) === null || _a === void 0 ? void 0 : _a.dispose();\r\n        this._session = undefined;\r\n        this._modelVersionId = -1;\r\n        if (resetSelection) {\r\n            // reset selection to the primary cursor when being asked\r\n            // for. this happens when explicitly cancelling snippet mode,\r\n            // e.g. when pressing ESC\r\n            this._editor.setSelections([this._editor.getSelection()]);\r\n        }\r\n    }\r\n    prev() {\r\n        if (this._session) {\r\n            this._session.prev();\r\n        }\r\n        this._updateState();\r\n    }\r\n    next() {\r\n        if (this._session) {\r\n            this._session.next();\r\n        }\r\n        this._updateState();\r\n    }\r\n    isInSnippet() {\r\n        return Boolean(this._inSnippet.get());\r\n    }\r\n};\r\nsnippetController2_SnippetController2.ID = \'snippetController2\';\r\nsnippetController2_SnippetController2.InSnippetMode = new contextkey["RawContextKey"](\'inSnippetMode\', false, Object(nls["localize"])(\'inSnippetMode\', "Whether the editor in current in snippet mode"));\r\nsnippetController2_SnippetController2.HasNextTabstop = new contextkey["RawContextKey"](\'hasNextTabstop\', false, Object(nls["localize"])(\'hasNextTabstop\', "Whether there is a next tab stop when in snippet mode"));\r\nsnippetController2_SnippetController2.HasPrevTabstop = new contextkey["RawContextKey"](\'hasPrevTabstop\', false, Object(nls["localize"])(\'hasPrevTabstop\', "Whether there is a previous tab stop when in snippet mode"));\r\nsnippetController2_SnippetController2 = snippetController2_decorate([\r\n    snippetController2_param(1, log["ILogService"]),\r\n    snippetController2_param(2, contextkey["IContextKeyService"])\r\n], snippetController2_SnippetController2);\r\n\r\nObject(editorExtensions["registerEditorContribution"])(snippetController2_SnippetController2.ID, snippetController2_SnippetController2);\r\nconst CommandCtor = editorExtensions["EditorCommand"].bindToContribution(snippetController2_SnippetController2.get);\r\nObject(editorExtensions["registerEditorCommand"])(new CommandCtor({\r\n    id: \'jumpToNextSnippetPlaceholder\',\r\n    precondition: contextkey["ContextKeyExpr"].and(snippetController2_SnippetController2.InSnippetMode, snippetController2_SnippetController2.HasNextTabstop),\r\n    handler: ctrl => ctrl.next(),\r\n    kbOpts: {\r\n        weight: 100 /* EditorContrib */ + 30,\r\n        kbExpr: editorContextKeys["EditorContextKeys"].editorTextFocus,\r\n        primary: 2 /* Tab */\r\n    }\r\n}));\r\nObject(editorExtensions["registerEditorCommand"])(new CommandCtor({\r\n    id: \'jumpToPrevSnippetPlaceholder\',\r\n    precondition: contextkey["ContextKeyExpr"].and(snippetController2_SnippetController2.InSnippetMode, snippetController2_SnippetController2.HasPrevTabstop),\r\n    handler: ctrl => ctrl.prev(),\r\n    kbOpts: {\r\n        weight: 100 /* EditorContrib */ + 30,\r\n        kbExpr: editorContextKeys["EditorContextKeys"].editorTextFocus,\r\n        primary: 1024 /* Shift */ | 2 /* Tab */\r\n    }\r\n}));\r\nObject(editorExtensions["registerEditorCommand"])(new CommandCtor({\r\n    id: \'leaveSnippet\',\r\n    precondition: snippetController2_SnippetController2.InSnippetMode,\r\n    handler: ctrl => ctrl.cancel(true),\r\n    kbOpts: {\r\n        weight: 100 /* EditorContrib */ + 30,\r\n        kbExpr: editorContextKeys["EditorContextKeys"].editorTextFocus,\r\n        primary: 9 /* Escape */,\r\n        secondary: [1024 /* Shift */ | 9 /* Escape */]\r\n    }\r\n}));\r\nObject(editorExtensions["registerEditorCommand"])(new CommandCtor({\r\n    id: \'acceptSnippet\',\r\n    precondition: snippetController2_SnippetController2.InSnippetMode,\r\n    handler: ctrl => ctrl.finish(),\r\n    // kbOpts: {\r\n    // \tweight: KeybindingWeight.EditorContrib + 30,\r\n    // \tkbExpr: EditorContextKeys.textFocus,\r\n    // \tprimary: KeyCode.Enter,\r\n    // }\r\n}));\r\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/common/map.js\nvar map = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/common/map.js");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestMemory.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar suggestMemory_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar suggestMemory_param = (undefined && undefined.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass Memory {\r\n    constructor(name) {\r\n        this.name = name;\r\n    }\r\n    select(model, pos, items) {\r\n        if (items.length === 0) {\r\n            return 0;\r\n        }\r\n        let topScore = items[0].score[0];\r\n        for (let i = 0; i < items.length; i++) {\r\n            const { score, completion: suggestion } = items[i];\r\n            if (score[0] !== topScore) {\r\n                // stop when leaving the group of top matches\r\n                break;\r\n            }\r\n            if (suggestion.preselect) {\r\n                // stop when seeing an auto-select-item\r\n                return i;\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n}\r\nclass NoMemory extends Memory {\r\n    constructor() {\r\n        super(\'first\');\r\n    }\r\n    memorize(model, pos, item) {\r\n        // no-op\r\n    }\r\n    toJSON() {\r\n        return undefined;\r\n    }\r\n    fromJSON() {\r\n        //\r\n    }\r\n}\r\nclass suggestMemory_LRUMemory extends Memory {\r\n    constructor() {\r\n        super(\'recentlyUsed\');\r\n        this._cache = new map["LRUCache"](300, 0.66);\r\n        this._seq = 0;\r\n    }\r\n    memorize(model, pos, item) {\r\n        const key = `${model.getLanguageIdentifier().language}/${item.textLabel}`;\r\n        this._cache.set(key, {\r\n            touch: this._seq++,\r\n            type: item.completion.kind,\r\n            insertText: item.completion.insertText\r\n        });\r\n    }\r\n    select(model, pos, items) {\r\n        if (items.length === 0) {\r\n            return 0;\r\n        }\r\n        const lineSuffix = model.getLineContent(pos.lineNumber).substr(pos.column - 10, pos.column - 1);\r\n        if (/\\s$/.test(lineSuffix)) {\r\n            return super.select(model, pos, items);\r\n        }\r\n        let topScore = items[0].score[0];\r\n        let indexPreselect = -1;\r\n        let indexRecency = -1;\r\n        let seq = -1;\r\n        for (let i = 0; i < items.length; i++) {\r\n            if (items[i].score[0] !== topScore) {\r\n                // consider only top items\r\n                break;\r\n            }\r\n            const key = `${model.getLanguageIdentifier().language}/${items[i].textLabel}`;\r\n            const item = this._cache.peek(key);\r\n            if (item && item.touch > seq && item.type === items[i].completion.kind && item.insertText === items[i].completion.insertText) {\r\n                seq = item.touch;\r\n                indexRecency = i;\r\n            }\r\n            if (items[i].completion.preselect && indexPreselect === -1) {\r\n                // stop when seeing an auto-select-item\r\n                return indexPreselect = i;\r\n            }\r\n        }\r\n        if (indexRecency !== -1) {\r\n            return indexRecency;\r\n        }\r\n        else if (indexPreselect !== -1) {\r\n            return indexPreselect;\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n    toJSON() {\r\n        return this._cache.toJSON();\r\n    }\r\n    fromJSON(data) {\r\n        this._cache.clear();\r\n        let seq = 0;\r\n        for (const [key, value] of data) {\r\n            value.touch = seq;\r\n            value.type = typeof value.type === \'number\' ? value.type : Object(modes["completionKindFromString"])(value.type);\r\n            this._cache.set(key, value);\r\n        }\r\n        this._seq = this._cache.size;\r\n    }\r\n}\r\nclass suggestMemory_PrefixMemory extends Memory {\r\n    constructor() {\r\n        super(\'recentlyUsedByPrefix\');\r\n        this._trie = map["TernarySearchTree"].forStrings();\r\n        this._seq = 0;\r\n    }\r\n    memorize(model, pos, item) {\r\n        const { word } = model.getWordUntilPosition(pos);\r\n        const key = `${model.getLanguageIdentifier().language}/${word}`;\r\n        this._trie.set(key, {\r\n            type: item.completion.kind,\r\n            insertText: item.completion.insertText,\r\n            touch: this._seq++\r\n        });\r\n    }\r\n    select(model, pos, items) {\r\n        let { word } = model.getWordUntilPosition(pos);\r\n        if (!word) {\r\n            return super.select(model, pos, items);\r\n        }\r\n        let key = `${model.getLanguageIdentifier().language}/${word}`;\r\n        let item = this._trie.get(key);\r\n        if (!item) {\r\n            item = this._trie.findSubstr(key);\r\n        }\r\n        if (item) {\r\n            for (let i = 0; i < items.length; i++) {\r\n                let { kind, insertText } = items[i].completion;\r\n                if (kind === item.type && insertText === item.insertText) {\r\n                    return i;\r\n                }\r\n            }\r\n        }\r\n        return super.select(model, pos, items);\r\n    }\r\n    toJSON() {\r\n        let entries = [];\r\n        this._trie.forEach((value, key) => entries.push([key, value]));\r\n        // sort by last recently used (touch), then\r\n        // take the top 200 item and normalize their\r\n        // touch\r\n        entries\r\n            .sort((a, b) => -(a[1].touch - b[1].touch))\r\n            .forEach((value, i) => value[1].touch = i);\r\n        return entries.slice(0, 200);\r\n    }\r\n    fromJSON(data) {\r\n        this._trie.clear();\r\n        if (data.length > 0) {\r\n            this._seq = data[0][1].touch + 1;\r\n            for (const [key, value] of data) {\r\n                value.type = typeof value.type === \'number\' ? value.type : Object(modes["completionKindFromString"])(value.type);\r\n                this._trie.set(key, value);\r\n            }\r\n        }\r\n    }\r\n}\r\nlet suggestMemory_SuggestMemoryService = class SuggestMemoryService {\r\n    constructor(_storageService, _modeService, _configService) {\r\n        this._storageService = _storageService;\r\n        this._modeService = _modeService;\r\n        this._configService = _configService;\r\n        this._disposables = new lifecycle["DisposableStore"]();\r\n        this._persistSoon = new common_async["RunOnceScheduler"](() => this._saveState(), 500);\r\n        this._disposables.add(_storageService.onWillSaveState(e => {\r\n            if (e.reason === storage["WillSaveStateReason"].SHUTDOWN) {\r\n                this._saveState();\r\n            }\r\n        }));\r\n    }\r\n    dispose() {\r\n        this._disposables.dispose();\r\n        this._persistSoon.dispose();\r\n    }\r\n    memorize(model, pos, item) {\r\n        this._withStrategy(model, pos).memorize(model, pos, item);\r\n        this._persistSoon.schedule();\r\n    }\r\n    select(model, pos, items) {\r\n        return this._withStrategy(model, pos).select(model, pos, items);\r\n    }\r\n    _withStrategy(model, pos) {\r\n        var _a, _b;\r\n        const mode = this._configService.getValue(\'editor.suggestSelection\', {\r\n            overrideIdentifier: (_a = this._modeService.getLanguageIdentifier(model.getLanguageIdAtPosition(pos.lineNumber, pos.column))) === null || _a === void 0 ? void 0 : _a.language,\r\n            resource: model.uri\r\n        });\r\n        if (((_b = this._strategy) === null || _b === void 0 ? void 0 : _b.name) !== mode) {\r\n            this._saveState();\r\n            const ctor = SuggestMemoryService._strategyCtors.get(mode) || NoMemory;\r\n            this._strategy = new ctor();\r\n            try {\r\n                const share = this._configService.getValue(\'editor.suggest.shareSuggestSelections\');\r\n                const scope = share ? 0 /* GLOBAL */ : 1 /* WORKSPACE */;\r\n                const raw = this._storageService.get(`${SuggestMemoryService._storagePrefix}/${mode}`, scope);\r\n                if (raw) {\r\n                    this._strategy.fromJSON(JSON.parse(raw));\r\n                }\r\n            }\r\n            catch (e) {\r\n                // things can go wrong with JSON...\r\n            }\r\n        }\r\n        return this._strategy;\r\n    }\r\n    _saveState() {\r\n        if (this._strategy) {\r\n            const share = this._configService.getValue(\'editor.suggest.shareSuggestSelections\');\r\n            const scope = share ? 0 /* GLOBAL */ : 1 /* WORKSPACE */;\r\n            const raw = JSON.stringify(this._strategy);\r\n            this._storageService.store(`${SuggestMemoryService._storagePrefix}/${this._strategy.name}`, raw, scope, 1 /* MACHINE */);\r\n        }\r\n    }\r\n};\r\nsuggestMemory_SuggestMemoryService._strategyCtors = new Map([\r\n    [\'recentlyUsedByPrefix\', suggestMemory_PrefixMemory],\r\n    [\'recentlyUsed\', suggestMemory_LRUMemory],\r\n    [\'first\', NoMemory]\r\n]);\r\nsuggestMemory_SuggestMemoryService._storagePrefix = \'suggest/memories\';\r\nsuggestMemory_SuggestMemoryService = suggestMemory_decorate([\r\n    suggestMemory_param(0, storage["IStorageService"]),\r\n    suggestMemory_param(1, services_modeService["IModeService"]),\r\n    suggestMemory_param(2, configuration["IConfigurationService"])\r\n], suggestMemory_SuggestMemoryService);\r\n\r\nconst ISuggestMemoryService = Object(instantiation["createDecorator"])(\'ISuggestMemories\');\r\nObject(extensions["registerSingleton"])(ISuggestMemoryService, suggestMemory_SuggestMemoryService, true);\r\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/platform/keybinding/common/keybindingsRegistry.js\nvar keybindingsRegistry = __webpack_require__("./node_modules/monaco-editor/esm/vs/platform/keybinding/common/keybindingsRegistry.js");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestAlternatives.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar suggestAlternatives_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar suggestAlternatives_param = (undefined && undefined.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\n\r\nlet SuggestAlternatives = class SuggestAlternatives {\r\n    constructor(_editor, contextKeyService) {\r\n        this._editor = _editor;\r\n        this._index = 0;\r\n        this._ckOtherSuggestions = SuggestAlternatives.OtherSuggestions.bindTo(contextKeyService);\r\n    }\r\n    dispose() {\r\n        this.reset();\r\n    }\r\n    reset() {\r\n        var _a;\r\n        this._ckOtherSuggestions.reset();\r\n        (_a = this._listener) === null || _a === void 0 ? void 0 : _a.dispose();\r\n        this._model = undefined;\r\n        this._acceptNext = undefined;\r\n        this._ignore = false;\r\n    }\r\n    set({ model, index }, acceptNext) {\r\n        // no suggestions -> nothing to do\r\n        if (model.items.length === 0) {\r\n            this.reset();\r\n            return;\r\n        }\r\n        // no alternative suggestions -> nothing to do\r\n        let nextIndex = SuggestAlternatives._moveIndex(true, model, index);\r\n        if (nextIndex === index) {\r\n            this.reset();\r\n            return;\r\n        }\r\n        this._acceptNext = acceptNext;\r\n        this._model = model;\r\n        this._index = index;\r\n        this._listener = this._editor.onDidChangeCursorPosition(() => {\r\n            if (!this._ignore) {\r\n                this.reset();\r\n            }\r\n        });\r\n        this._ckOtherSuggestions.set(true);\r\n    }\r\n    static _moveIndex(fwd, model, index) {\r\n        let newIndex = index;\r\n        while (true) {\r\n            newIndex = (newIndex + model.items.length + (fwd ? +1 : -1)) % model.items.length;\r\n            if (newIndex === index) {\r\n                break;\r\n            }\r\n            if (!model.items[newIndex].completion.additionalTextEdits) {\r\n                break;\r\n            }\r\n        }\r\n        return newIndex;\r\n    }\r\n    next() {\r\n        this._move(true);\r\n    }\r\n    prev() {\r\n        this._move(false);\r\n    }\r\n    _move(fwd) {\r\n        if (!this._model) {\r\n            // nothing to reason about\r\n            return;\r\n        }\r\n        try {\r\n            this._ignore = true;\r\n            this._index = SuggestAlternatives._moveIndex(fwd, this._model, this._index);\r\n            this._acceptNext({ index: this._index, item: this._model.items[this._index], model: this._model });\r\n        }\r\n        finally {\r\n            this._ignore = false;\r\n        }\r\n    }\r\n};\r\nSuggestAlternatives.OtherSuggestions = new contextkey["RawContextKey"](\'hasOtherSuggestions\', false);\r\nSuggestAlternatives = suggestAlternatives_decorate([\r\n    suggestAlternatives_param(1, contextkey["IContextKeyService"])\r\n], SuggestAlternatives);\r\n\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/suggest/completionModel.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\nclass LineContext {\r\n    constructor(leadingLineContent, characterCountDelta) {\r\n        this.leadingLineContent = leadingLineContent;\r\n        this.characterCountDelta = characterCountDelta;\r\n    }\r\n}\r\n/**\r\n * Sorted, filtered completion view model\r\n * */\r\nclass completionModel_CompletionModel {\r\n    constructor(items, column, lineContext, wordDistance, options, snippetSuggestions, clipboardText) {\r\n        this.clipboardText = clipboardText;\r\n        this._snippetCompareFn = completionModel_CompletionModel._compareCompletionItems;\r\n        this._items = items;\r\n        this._column = column;\r\n        this._wordDistance = wordDistance;\r\n        this._options = options;\r\n        this._refilterKind = 1 /* All */;\r\n        this._lineContext = lineContext;\r\n        if (snippetSuggestions === \'top\') {\r\n            this._snippetCompareFn = completionModel_CompletionModel._compareCompletionItemsSnippetsUp;\r\n        }\r\n        else if (snippetSuggestions === \'bottom\') {\r\n            this._snippetCompareFn = completionModel_CompletionModel._compareCompletionItemsSnippetsDown;\r\n        }\r\n    }\r\n    get lineContext() {\r\n        return this._lineContext;\r\n    }\r\n    set lineContext(value) {\r\n        if (this._lineContext.leadingLineContent !== value.leadingLineContent\r\n            || this._lineContext.characterCountDelta !== value.characterCountDelta) {\r\n            this._refilterKind = this._lineContext.characterCountDelta < value.characterCountDelta && this._filteredItems ? 2 /* Incr */ : 1 /* All */;\r\n            this._lineContext = value;\r\n        }\r\n    }\r\n    get items() {\r\n        this._ensureCachedState();\r\n        return this._filteredItems;\r\n    }\r\n    get allProvider() {\r\n        this._ensureCachedState();\r\n        return this._providerInfo.keys();\r\n    }\r\n    get incomplete() {\r\n        this._ensureCachedState();\r\n        const result = new Set();\r\n        for (let [provider, incomplete] of this._providerInfo) {\r\n            if (incomplete) {\r\n                result.add(provider);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    adopt(except) {\r\n        let res = [];\r\n        for (let i = 0; i < this._items.length;) {\r\n            if (!except.has(this._items[i].provider)) {\r\n                res.push(this._items[i]);\r\n                // unordered removed\r\n                this._items[i] = this._items[this._items.length - 1];\r\n                this._items.pop();\r\n            }\r\n            else {\r\n                // continue with next item\r\n                i++;\r\n            }\r\n        }\r\n        this._refilterKind = 1 /* All */;\r\n        return res;\r\n    }\r\n    get stats() {\r\n        this._ensureCachedState();\r\n        return this._stats;\r\n    }\r\n    _ensureCachedState() {\r\n        if (this._refilterKind !== 0 /* Nothing */) {\r\n            this._createCachedState();\r\n        }\r\n    }\r\n    _createCachedState() {\r\n        this._providerInfo = new Map();\r\n        const labelLengths = [];\r\n        const { leadingLineContent, characterCountDelta } = this._lineContext;\r\n        let word = \'\';\r\n        let wordLow = \'\';\r\n        // incrementally filter less\r\n        const source = this._refilterKind === 1 /* All */ ? this._items : this._filteredItems;\r\n        const target = [];\r\n        // picks a score function based on the number of\r\n        // items that we have to score/filter and based on the\r\n        // user-configuration\r\n        const scoreFn = (!this._options.filterGraceful || source.length > 2000) ? filters["fuzzyScore"] : filters["fuzzyScoreGracefulAggressive"];\r\n        for (let i = 0; i < source.length; i++) {\r\n            const item = source[i];\r\n            if (item.isInvalid) {\r\n                continue; // SKIP invalid items\r\n            }\r\n            // collect all support, know if their result is incomplete\r\n            this._providerInfo.set(item.provider, Boolean(item.container.incomplete));\r\n            // \'word\' is that remainder of the current line that we\r\n            // filter and score against. In theory each suggestion uses a\r\n            // different word, but in practice not - that\'s why we cache\r\n            const overwriteBefore = item.position.column - item.editStart.column;\r\n            const wordLen = overwriteBefore + characterCountDelta - (item.position.column - this._column);\r\n            if (word.length !== wordLen) {\r\n                word = wordLen === 0 ? \'\' : leadingLineContent.slice(-wordLen);\r\n                wordLow = word.toLowerCase();\r\n            }\r\n            // remember the word against which this item was\r\n            // scored\r\n            item.word = word;\r\n            if (wordLen === 0) {\r\n                // when there is nothing to score against, don\'t\r\n                // event try to do. Use a const rank and rely on\r\n                // the fallback-sort using the initial sort order.\r\n                // use a score of `-100` because that is out of the\r\n                // bound of values `fuzzyScore` will return\r\n                item.score = filters["FuzzyScore"].Default;\r\n            }\r\n            else {\r\n                // skip word characters that are whitespace until\r\n                // we have hit the replace range (overwriteBefore)\r\n                let wordPos = 0;\r\n                while (wordPos < overwriteBefore) {\r\n                    const ch = word.charCodeAt(wordPos);\r\n                    if (ch === 32 /* Space */ || ch === 9 /* Tab */) {\r\n                        wordPos += 1;\r\n                    }\r\n                    else {\r\n                        break;\r\n                    }\r\n                }\r\n                if (wordPos >= wordLen) {\r\n                    // the wordPos at which scoring starts is the whole word\r\n                    // and therefore the same rules as not having a word apply\r\n                    item.score = filters["FuzzyScore"].Default;\r\n                }\r\n                else if (typeof item.completion.filterText === \'string\') {\r\n                    // when there is a `filterText` it must match the `word`.\r\n                    // if it matches we check with the label to compute highlights\r\n                    // and if that doesn\'t yield a result we have no highlights,\r\n                    // despite having the match\r\n                    let match = scoreFn(word, wordLow, wordPos, item.completion.filterText, item.filterTextLow, 0, false);\r\n                    if (!match) {\r\n                        continue; // NO match\r\n                    }\r\n                    if (Object(strings["compareIgnoreCase"])(item.completion.filterText, item.textLabel) === 0) {\r\n                        // filterText and label are actually the same -> use good highlights\r\n                        item.score = match;\r\n                    }\r\n                    else {\r\n                        // re-run the scorer on the label in the hope of a result BUT use the rank\r\n                        // of the filterText-match\r\n                        item.score = Object(filters["anyScore"])(word, wordLow, wordPos, item.textLabel, item.labelLow, 0);\r\n                        item.score[0] = match[0]; // use score from filterText\r\n                    }\r\n                }\r\n                else {\r\n                    // by default match `word` against the `label`\r\n                    let match = scoreFn(word, wordLow, wordPos, item.textLabel, item.labelLow, 0, false);\r\n                    if (!match) {\r\n                        continue; // NO match\r\n                    }\r\n                    item.score = match;\r\n                }\r\n            }\r\n            item.idx = i;\r\n            item.distance = this._wordDistance.distance(item.position, item.completion);\r\n            target.push(item);\r\n            // update stats\r\n            labelLengths.push(item.textLabel.length);\r\n        }\r\n        this._filteredItems = target.sort(this._snippetCompareFn);\r\n        this._refilterKind = 0 /* Nothing */;\r\n        this._stats = {\r\n            pLabelLen: labelLengths.length ?\r\n                Object(arrays["quickSelect"])(labelLengths.length - .85, labelLengths, (a, b) => a - b)\r\n                : 0\r\n        };\r\n    }\r\n    static _compareCompletionItems(a, b) {\r\n        if (a.score[0] > b.score[0]) {\r\n            return -1;\r\n        }\r\n        else if (a.score[0] < b.score[0]) {\r\n            return 1;\r\n        }\r\n        else if (a.distance < b.distance) {\r\n            return -1;\r\n        }\r\n        else if (a.distance > b.distance) {\r\n            return 1;\r\n        }\r\n        else if (a.idx < b.idx) {\r\n            return -1;\r\n        }\r\n        else if (a.idx > b.idx) {\r\n            return 1;\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n    static _compareCompletionItemsSnippetsDown(a, b) {\r\n        if (a.completion.kind !== b.completion.kind) {\r\n            if (a.completion.kind === 27 /* Snippet */) {\r\n                return 1;\r\n            }\r\n            else if (b.completion.kind === 27 /* Snippet */) {\r\n                return -1;\r\n            }\r\n        }\r\n        return completionModel_CompletionModel._compareCompletionItems(a, b);\r\n    }\r\n    static _compareCompletionItemsSnippetsUp(a, b) {\r\n        if (a.completion.kind !== b.completion.kind) {\r\n            if (a.completion.kind === 27 /* Snippet */) {\r\n                return -1;\r\n            }\r\n            else if (b.completion.kind === 27 /* Snippet */) {\r\n                return 1;\r\n            }\r\n        }\r\n        return completionModel_CompletionModel._compareCompletionItems(a, b);\r\n    }\r\n}\r\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/services/editorWorkerService.js\nvar editorWorkerService = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/common/services/editorWorkerService.js");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/smartSelect/bracketSelections.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar bracketSelections_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\nclass bracketSelections_BracketSelectionRangeProvider {\r\n    provideSelectionRanges(model, positions) {\r\n        return bracketSelections_awaiter(this, void 0, void 0, function* () {\r\n            const result = [];\r\n            for (const position of positions) {\r\n                const bucket = [];\r\n                result.push(bucket);\r\n                const ranges = new Map();\r\n                yield new Promise(resolve => bracketSelections_BracketSelectionRangeProvider._bracketsRightYield(resolve, 0, model, position, ranges));\r\n                yield new Promise(resolve => bracketSelections_BracketSelectionRangeProvider._bracketsLeftYield(resolve, 0, model, position, ranges, bucket));\r\n            }\r\n            return result;\r\n        });\r\n    }\r\n    static _bracketsRightYield(resolve, round, model, pos, ranges) {\r\n        const counts = new Map();\r\n        const t1 = Date.now();\r\n        while (true) {\r\n            if (round >= bracketSelections_BracketSelectionRangeProvider._maxRounds) {\r\n                resolve();\r\n                break;\r\n            }\r\n            if (!pos) {\r\n                resolve();\r\n                break;\r\n            }\r\n            let bracket = model.findNextBracket(pos);\r\n            if (!bracket) {\r\n                resolve();\r\n                break;\r\n            }\r\n            let d = Date.now() - t1;\r\n            if (d > bracketSelections_BracketSelectionRangeProvider._maxDuration) {\r\n                setTimeout(() => bracketSelections_BracketSelectionRangeProvider._bracketsRightYield(resolve, round + 1, model, pos, ranges));\r\n                break;\r\n            }\r\n            const key = bracket.close[0];\r\n            if (bracket.isOpen) {\r\n                // wait for closing\r\n                let val = counts.has(key) ? counts.get(key) : 0;\r\n                counts.set(key, val + 1);\r\n            }\r\n            else {\r\n                // process closing\r\n                let val = counts.has(key) ? counts.get(key) : 0;\r\n                val -= 1;\r\n                counts.set(key, Math.max(0, val));\r\n                if (val < 0) {\r\n                    let list = ranges.get(key);\r\n                    if (!list) {\r\n                        list = new linkedList["LinkedList"]();\r\n                        ranges.set(key, list);\r\n                    }\r\n                    list.push(bracket.range);\r\n                }\r\n            }\r\n            pos = bracket.range.getEndPosition();\r\n        }\r\n    }\r\n    static _bracketsLeftYield(resolve, round, model, pos, ranges, bucket) {\r\n        const counts = new Map();\r\n        const t1 = Date.now();\r\n        while (true) {\r\n            if (round >= bracketSelections_BracketSelectionRangeProvider._maxRounds && ranges.size === 0) {\r\n                resolve();\r\n                break;\r\n            }\r\n            if (!pos) {\r\n                resolve();\r\n                break;\r\n            }\r\n            let bracket = model.findPrevBracket(pos);\r\n            if (!bracket) {\r\n                resolve();\r\n                break;\r\n            }\r\n            let d = Date.now() - t1;\r\n            if (d > bracketSelections_BracketSelectionRangeProvider._maxDuration) {\r\n                setTimeout(() => bracketSelections_BracketSelectionRangeProvider._bracketsLeftYield(resolve, round + 1, model, pos, ranges, bucket));\r\n                break;\r\n            }\r\n            const key = bracket.close[0];\r\n            if (!bracket.isOpen) {\r\n                // wait for opening\r\n                let val = counts.has(key) ? counts.get(key) : 0;\r\n                counts.set(key, val + 1);\r\n            }\r\n            else {\r\n                // opening\r\n                let val = counts.has(key) ? counts.get(key) : 0;\r\n                val -= 1;\r\n                counts.set(key, Math.max(0, val));\r\n                if (val < 0) {\r\n                    let list = ranges.get(key);\r\n                    if (list) {\r\n                        let closing = list.shift();\r\n                        if (list.size === 0) {\r\n                            ranges.delete(key);\r\n                        }\r\n                        const innerBracket = core_range["Range"].fromPositions(bracket.range.getEndPosition(), closing.getStartPosition());\r\n                        const outerBracket = core_range["Range"].fromPositions(bracket.range.getStartPosition(), closing.getEndPosition());\r\n                        bucket.push({ range: innerBracket });\r\n                        bucket.push({ range: outerBracket });\r\n                        bracketSelections_BracketSelectionRangeProvider._addBracketLeading(model, outerBracket, bucket);\r\n                    }\r\n                }\r\n            }\r\n            pos = bracket.range.getStartPosition();\r\n        }\r\n    }\r\n    static _addBracketLeading(model, bracket, bucket) {\r\n        if (bracket.startLineNumber === bracket.endLineNumber) {\r\n            return;\r\n        }\r\n        // xxxxxxxx {\r\n        //\r\n        // }\r\n        const startLine = bracket.startLineNumber;\r\n        const column = model.getLineFirstNonWhitespaceColumn(startLine);\r\n        if (column !== 0 && column !== bracket.startColumn) {\r\n            bucket.push({ range: core_range["Range"].fromPositions(new core_position["Position"](startLine, column), bracket.getEndPosition()) });\r\n            bucket.push({ range: core_range["Range"].fromPositions(new core_position["Position"](startLine, 1), bracket.getEndPosition()) });\r\n        }\r\n        // xxxxxxxx\r\n        // {\r\n        //\r\n        // }\r\n        const aboveLine = startLine - 1;\r\n        if (aboveLine > 0) {\r\n            const column = model.getLineFirstNonWhitespaceColumn(aboveLine);\r\n            if (column === bracket.startColumn && column !== model.getLineLastNonWhitespaceColumn(aboveLine)) {\r\n                bucket.push({ range: core_range["Range"].fromPositions(new core_position["Position"](aboveLine, column), bracket.getEndPosition()) });\r\n                bucket.push({ range: core_range["Range"].fromPositions(new core_position["Position"](aboveLine, 1), bracket.getEndPosition()) });\r\n            }\r\n        }\r\n    }\r\n}\r\nbracketSelections_BracketSelectionRangeProvider._maxDuration = 30;\r\nbracketSelections_BracketSelectionRangeProvider._maxRounds = 2;\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/suggest/wordDistance.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar wordDistance_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\nclass wordDistance_WordDistance {\r\n    static create(service, editor) {\r\n        return wordDistance_awaiter(this, void 0, void 0, function* () {\r\n            if (!editor.getOption(106 /* suggest */).localityBonus) {\r\n                return wordDistance_WordDistance.None;\r\n            }\r\n            if (!editor.hasModel()) {\r\n                return wordDistance_WordDistance.None;\r\n            }\r\n            const model = editor.getModel();\r\n            const position = editor.getPosition();\r\n            if (!service.canComputeWordRanges(model.uri)) {\r\n                return wordDistance_WordDistance.None;\r\n            }\r\n            const [ranges] = yield new bracketSelections_BracketSelectionRangeProvider().provideSelectionRanges(model, [position]);\r\n            if (ranges.length === 0) {\r\n                return wordDistance_WordDistance.None;\r\n            }\r\n            const wordRanges = yield service.computeWordRanges(model.uri, ranges[0].range);\r\n            if (!wordRanges) {\r\n                return wordDistance_WordDistance.None;\r\n            }\r\n            // remove current word\r\n            const wordUntilPos = model.getWordUntilPosition(position);\r\n            delete wordRanges[wordUntilPos.word];\r\n            return new class extends wordDistance_WordDistance {\r\n                distance(anchor, item) {\r\n                    if (!position.equals(editor.getPosition())) {\r\n                        return 0;\r\n                    }\r\n                    if (item.kind === 17 /* Keyword */) {\r\n                        return 2 << 20;\r\n                    }\r\n                    let word = typeof item.label === \'string\' ? item.label : item.label.label;\r\n                    let wordLines = wordRanges[word];\r\n                    if (Object(arrays["isFalsyOrEmpty"])(wordLines)) {\r\n                        return 2 << 20;\r\n                    }\r\n                    let idx = Object(arrays["binarySearch"])(wordLines, core_range["Range"].fromPositions(anchor), core_range["Range"].compareRangesUsingStarts);\r\n                    let bestWordRange = idx >= 0 ? wordLines[idx] : wordLines[Math.max(0, ~idx - 1)];\r\n                    let blockDistance = ranges.length;\r\n                    for (const range of ranges) {\r\n                        if (!core_range["Range"].containsRange(range.range, bestWordRange)) {\r\n                            break;\r\n                        }\r\n                        blockDistance -= 1;\r\n                    }\r\n                    return blockDistance;\r\n                }\r\n            };\r\n        });\r\n    }\r\n}\r\nwordDistance_WordDistance.None = new class extends wordDistance_WordDistance {\r\n    distance() { return 0; }\r\n};\r\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/platform/clipboard/common/clipboardService.js\nvar clipboardService = __webpack_require__("./node_modules/monaco-editor/esm/vs/platform/clipboard/common/clipboardService.js");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestModel.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar suggestModel_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar suggestModel_param = (undefined && undefined.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nvar suggestModel_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass suggestModel_LineContext {\r\n    constructor(model, position, auto, shy) {\r\n        this.leadingLineContent = model.getLineContent(position.lineNumber).substr(0, position.column - 1);\r\n        this.leadingWord = model.getWordUntilPosition(position);\r\n        this.lineNumber = position.lineNumber;\r\n        this.column = position.column;\r\n        this.auto = auto;\r\n        this.shy = shy;\r\n    }\r\n    static shouldAutoTrigger(editor) {\r\n        if (!editor.hasModel()) {\r\n            return false;\r\n        }\r\n        const model = editor.getModel();\r\n        const pos = editor.getPosition();\r\n        model.tokenizeIfCheap(pos.lineNumber);\r\n        const word = model.getWordAtPosition(pos);\r\n        if (!word) {\r\n            return false;\r\n        }\r\n        if (word.endColumn !== pos.column) {\r\n            return false;\r\n        }\r\n        if (!isNaN(Number(word.word))) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\nfunction shouldPreventQuickSuggest(contextKeyService, configurationService) {\r\n    return (Boolean(contextKeyService.getContextKeyValue(\'inlineSuggestionVisible\'))\r\n        && !Boolean(configurationService.getValue(\'editor.inlineSuggest.allowQuickSuggestions\')));\r\n}\r\nfunction shouldPreventSuggestOnTriggerCharacters(contextKeyService, configurationService) {\r\n    return (Boolean(contextKeyService.getContextKeyValue(\'inlineSuggestionVisible\'))\r\n        && !Boolean(configurationService.getValue(\'editor.inlineSuggest.allowSuggestOnTriggerCharacters\')));\r\n}\r\nlet suggestModel_SuggestModel = class SuggestModel {\r\n    constructor(_editor, _editorWorkerService, _clipboardService, _telemetryService, _logService, _contextKeyService, _configurationService) {\r\n        this._editor = _editor;\r\n        this._editorWorkerService = _editorWorkerService;\r\n        this._clipboardService = _clipboardService;\r\n        this._telemetryService = _telemetryService;\r\n        this._logService = _logService;\r\n        this._contextKeyService = _contextKeyService;\r\n        this._configurationService = _configurationService;\r\n        this._toDispose = new lifecycle["DisposableStore"]();\r\n        this._quickSuggestDelay = 10;\r\n        this._triggerCharacterListener = new lifecycle["DisposableStore"]();\r\n        this._triggerQuickSuggest = new common_async["TimeoutTimer"]();\r\n        this._state = 0 /* Idle */;\r\n        this._completionDisposables = new lifecycle["DisposableStore"]();\r\n        this._onDidCancel = new common_event["Emitter"]();\r\n        this._onDidTrigger = new common_event["Emitter"]();\r\n        this._onDidSuggest = new common_event["Emitter"]();\r\n        this.onDidCancel = this._onDidCancel.event;\r\n        this.onDidTrigger = this._onDidTrigger.event;\r\n        this.onDidSuggest = this._onDidSuggest.event;\r\n        this._telemetryGate = 0;\r\n        this._currentSelection = this._editor.getSelection() || new core_selection["Selection"](1, 1, 1, 1);\r\n        // wire up various listeners\r\n        this._toDispose.add(this._editor.onDidChangeModel(() => {\r\n            this._updateTriggerCharacters();\r\n            this.cancel();\r\n        }));\r\n        this._toDispose.add(this._editor.onDidChangeModelLanguage(() => {\r\n            this._updateTriggerCharacters();\r\n            this.cancel();\r\n        }));\r\n        this._toDispose.add(this._editor.onDidChangeConfiguration(() => {\r\n            this._updateTriggerCharacters();\r\n            this._updateQuickSuggest();\r\n        }));\r\n        this._toDispose.add(modes["CompletionProviderRegistry"].onDidChange(() => {\r\n            this._updateTriggerCharacters();\r\n            this._updateActiveSuggestSession();\r\n        }));\r\n        this._toDispose.add(this._editor.onDidChangeCursorSelection(e => {\r\n            this._onCursorChange(e);\r\n        }));\r\n        let editorIsComposing = false;\r\n        this._toDispose.add(this._editor.onDidCompositionStart(() => {\r\n            editorIsComposing = true;\r\n        }));\r\n        this._toDispose.add(this._editor.onDidCompositionEnd(() => {\r\n            // refilter when composition ends\r\n            editorIsComposing = false;\r\n            this._refilterCompletionItems();\r\n        }));\r\n        this._toDispose.add(this._editor.onDidChangeModelContent(() => {\r\n            // only filter completions when the editor isn\'t\r\n            // composing a character, e.g.  + u makes  but just\r\n            //  cannot be used for filtering\r\n            if (!editorIsComposing) {\r\n                this._refilterCompletionItems();\r\n            }\r\n        }));\r\n        this._updateTriggerCharacters();\r\n        this._updateQuickSuggest();\r\n    }\r\n    dispose() {\r\n        Object(lifecycle["dispose"])(this._triggerCharacterListener);\r\n        Object(lifecycle["dispose"])([this._onDidCancel, this._onDidSuggest, this._onDidTrigger, this._triggerQuickSuggest]);\r\n        this._toDispose.dispose();\r\n        this._completionDisposables.dispose();\r\n        this.cancel();\r\n    }\r\n    // --- handle configuration & precondition changes\r\n    _updateQuickSuggest() {\r\n        this._quickSuggestDelay = this._editor.getOption(79 /* quickSuggestionsDelay */);\r\n        if (isNaN(this._quickSuggestDelay) || (!this._quickSuggestDelay && this._quickSuggestDelay !== 0) || this._quickSuggestDelay < 0) {\r\n            this._quickSuggestDelay = 10;\r\n        }\r\n    }\r\n    _updateTriggerCharacters() {\r\n        this._triggerCharacterListener.clear();\r\n        if (this._editor.getOption(80 /* readOnly */)\r\n            || !this._editor.hasModel()\r\n            || !this._editor.getOption(109 /* suggestOnTriggerCharacters */)) {\r\n            return;\r\n        }\r\n        const supportsByTriggerCharacter = new Map();\r\n        for (const support of modes["CompletionProviderRegistry"].all(this._editor.getModel())) {\r\n            for (const ch of support.triggerCharacters || []) {\r\n                let set = supportsByTriggerCharacter.get(ch);\r\n                if (!set) {\r\n                    set = new Set();\r\n                    set.add(getSnippetSuggestSupport());\r\n                    supportsByTriggerCharacter.set(ch, set);\r\n                }\r\n                set.add(support);\r\n            }\r\n        }\r\n        const checkTriggerCharacter = (text) => {\r\n            if (shouldPreventSuggestOnTriggerCharacters(this._contextKeyService, this._configurationService)) {\r\n                return;\r\n            }\r\n            if (suggestModel_LineContext.shouldAutoTrigger(this._editor)) {\r\n                // don\'t trigger by trigger characters when this is a case for quick suggest\r\n                return;\r\n            }\r\n            if (!text) {\r\n                // came here from the compositionEnd-event\r\n                const position = this._editor.getPosition();\r\n                const model = this._editor.getModel();\r\n                text = model.getLineContent(position.lineNumber).substr(0, position.column - 1);\r\n            }\r\n            let lastChar = \'\';\r\n            if (Object(strings["isLowSurrogate"])(text.charCodeAt(text.length - 1))) {\r\n                if (Object(strings["isHighSurrogate"])(text.charCodeAt(text.length - 2))) {\r\n                    lastChar = text.substr(text.length - 2);\r\n                }\r\n            }\r\n            else {\r\n                lastChar = text.charAt(text.length - 1);\r\n            }\r\n            const supports = supportsByTriggerCharacter.get(lastChar);\r\n            if (supports) {\r\n                // keep existing items that where not computed by the\r\n                // supports/providers that want to trigger now\r\n                const existing = this._completionModel\r\n                    ? { items: this._completionModel.adopt(supports), clipboardText: this._completionModel.clipboardText }\r\n                    : undefined;\r\n                this.trigger({ auto: true, shy: false, triggerCharacter: lastChar }, Boolean(this._completionModel), supports, existing);\r\n            }\r\n        };\r\n        this._triggerCharacterListener.add(this._editor.onDidType(checkTriggerCharacter));\r\n        this._triggerCharacterListener.add(this._editor.onDidCompositionEnd(checkTriggerCharacter));\r\n    }\r\n    // --- trigger/retrigger/cancel suggest\r\n    get state() {\r\n        return this._state;\r\n    }\r\n    cancel(retrigger = false) {\r\n        var _a;\r\n        if (this._state !== 0 /* Idle */) {\r\n            this._triggerQuickSuggest.cancel();\r\n            (_a = this._requestToken) === null || _a === void 0 ? void 0 : _a.cancel();\r\n            this._requestToken = undefined;\r\n            this._state = 0 /* Idle */;\r\n            this._completionModel = undefined;\r\n            this._context = undefined;\r\n            this._onDidCancel.fire({ retrigger });\r\n        }\r\n    }\r\n    clear() {\r\n        this._completionDisposables.clear();\r\n    }\r\n    _updateActiveSuggestSession() {\r\n        if (this._state !== 0 /* Idle */) {\r\n            if (!this._editor.hasModel() || !modes["CompletionProviderRegistry"].has(this._editor.getModel())) {\r\n                this.cancel();\r\n            }\r\n            else {\r\n                this.trigger({ auto: this._state === 2 /* Auto */, shy: false }, true);\r\n            }\r\n        }\r\n    }\r\n    _onCursorChange(e) {\r\n        if (!this._editor.hasModel()) {\r\n            return;\r\n        }\r\n        const model = this._editor.getModel();\r\n        const prevSelection = this._currentSelection;\r\n        this._currentSelection = this._editor.getSelection();\r\n        if (!e.selection.isEmpty()\r\n            || (e.reason !== 0 /* NotSet */ && e.reason !== 3 /* Explicit */)\r\n            || (e.source !== \'keyboard\' && e.source !== \'deleteLeft\')) {\r\n            // Early exit if nothing needs to be done!\r\n            // Leave some form of early exit check here if you wish to continue being a cursor position change listener ;)\r\n            this.cancel();\r\n            return;\r\n        }\r\n        if (!modes["CompletionProviderRegistry"].has(model)) {\r\n            return;\r\n        }\r\n        if (this._state === 0 /* Idle */ && e.reason === 0 /* NotSet */) {\r\n            if (this._editor.getOption(78 /* quickSuggestions */) === false) {\r\n                // not enabled\r\n                return;\r\n            }\r\n            if (!prevSelection.containsRange(this._currentSelection) && !prevSelection.getEndPosition().isBeforeOrEqual(this._currentSelection.getPosition())) {\r\n                // cursor didn\'t move RIGHT\r\n                return;\r\n            }\r\n            if (this._editor.getOption(106 /* suggest */).snippetsPreventQuickSuggestions && snippetController2_SnippetController2.get(this._editor).isInSnippet()) {\r\n                // no quick suggestion when in snippet mode\r\n                return;\r\n            }\r\n            this.cancel();\r\n            this._triggerQuickSuggest.cancelAndSet(() => {\r\n                if (this._state !== 0 /* Idle */) {\r\n                    return;\r\n                }\r\n                if (!suggestModel_LineContext.shouldAutoTrigger(this._editor)) {\r\n                    return;\r\n                }\r\n                if (!this._editor.hasModel()) {\r\n                    return;\r\n                }\r\n                const model = this._editor.getModel();\r\n                const pos = this._editor.getPosition();\r\n                // validate enabled now\r\n                const quickSuggestions = this._editor.getOption(78 /* quickSuggestions */);\r\n                if (quickSuggestions === false) {\r\n                    return;\r\n                }\r\n                else if (quickSuggestions === true) {\r\n                    // all good\r\n                }\r\n                else {\r\n                    // Check the type of the token that triggered this\r\n                    model.tokenizeIfCheap(pos.lineNumber);\r\n                    const lineTokens = model.getLineTokens(pos.lineNumber);\r\n                    const tokenType = lineTokens.getStandardTokenType(lineTokens.findTokenIndexAtOffset(Math.max(pos.column - 1 - 1, 0)));\r\n                    const inValidScope = quickSuggestions.other && tokenType === 0 /* Other */\r\n                        || quickSuggestions.comments && tokenType === 1 /* Comment */\r\n                        || quickSuggestions.strings && tokenType === 2 /* String */;\r\n                    if (!inValidScope) {\r\n                        return;\r\n                    }\r\n                }\r\n                if (shouldPreventQuickSuggest(this._contextKeyService, this._configurationService)) {\r\n                    // do not trigger quick suggestions if inline suggestions are shown\r\n                    return;\r\n                }\r\n                // we made it till here -> trigger now\r\n                this.trigger({ auto: true, shy: false });\r\n            }, this._quickSuggestDelay);\r\n        }\r\n        else if (this._state !== 0 /* Idle */ && e.reason === 3 /* Explicit */) {\r\n            // suggest is active and something like cursor keys are used to move\r\n            // the cursor. this means we can refilter at the new position\r\n            this._refilterCompletionItems();\r\n        }\r\n    }\r\n    _refilterCompletionItems() {\r\n        // Re-filter suggestions. This MUST run async because filtering/scoring\r\n        // uses the model content AND the cursor position. The latter is NOT\r\n        // updated when the document has changed (the event which drives this method)\r\n        // and therefore a little pause (next mirco task) is needed. See:\r\n        // https://stackoverflow.com/questions/25915634/difference-between-microtask-and-macrotask-within-an-event-loop-context#25933985\r\n        Promise.resolve().then(() => {\r\n            if (this._state === 0 /* Idle */) {\r\n                return;\r\n            }\r\n            if (!this._editor.hasModel()) {\r\n                return;\r\n            }\r\n            const model = this._editor.getModel();\r\n            const position = this._editor.getPosition();\r\n            const ctx = new suggestModel_LineContext(model, position, this._state === 2 /* Auto */, false);\r\n            this._onNewContext(ctx);\r\n        });\r\n    }\r\n    trigger(context, retrigger = false, onlyFrom, existing) {\r\n        var _a;\r\n        if (!this._editor.hasModel()) {\r\n            return;\r\n        }\r\n        const model = this._editor.getModel();\r\n        const auto = context.auto;\r\n        const ctx = new suggestModel_LineContext(model, this._editor.getPosition(), auto, context.shy);\r\n        // Cancel previous requests, change state & update UI\r\n        this.cancel(retrigger);\r\n        this._state = auto ? 2 /* Auto */ : 1 /* Manual */;\r\n        this._onDidTrigger.fire({ auto, shy: context.shy, position: this._editor.getPosition() });\r\n        // Capture context when request was sent\r\n        this._context = ctx;\r\n        // Build context for request\r\n        let suggestCtx = { triggerKind: (_a = context.triggerKind) !== null && _a !== void 0 ? _a : 0 /* Invoke */ };\r\n        if (context.triggerCharacter) {\r\n            suggestCtx = {\r\n                triggerKind: 1 /* TriggerCharacter */,\r\n                triggerCharacter: context.triggerCharacter\r\n            };\r\n        }\r\n        this._requestToken = new cancellation["CancellationTokenSource"]();\r\n        // kind filter and snippet sort rules\r\n        const snippetSuggestions = this._editor.getOption(101 /* snippetSuggestions */);\r\n        let snippetSortOrder = 1 /* Inline */;\r\n        switch (snippetSuggestions) {\r\n            case \'top\':\r\n                snippetSortOrder = 0 /* Top */;\r\n                break;\r\n            // \t that\'s the default anyways...\r\n            // case \'inline\':\r\n            // \tsnippetSortOrder = SnippetSortOrder.Inline;\r\n            // \tbreak;\r\n            case \'bottom\':\r\n                snippetSortOrder = 2 /* Bottom */;\r\n                break;\r\n        }\r\n        const { itemKind: itemKindFilter, showDeprecated } = SuggestModel._createSuggestFilter(this._editor);\r\n        const wordDistance = wordDistance_WordDistance.create(this._editorWorkerService, this._editor);\r\n        const completions = provideSuggestionItems(model, this._editor.getPosition(), new CompletionOptions(snippetSortOrder, itemKindFilter, onlyFrom, showDeprecated), suggestCtx, this._requestToken.token);\r\n        Promise.all([completions, wordDistance]).then(([completions, wordDistance]) => suggestModel_awaiter(this, void 0, void 0, function* () {\r\n            var _b;\r\n            (_b = this._requestToken) === null || _b === void 0 ? void 0 : _b.dispose();\r\n            if (!this._editor.hasModel()) {\r\n                return;\r\n            }\r\n            let clipboardText = existing === null || existing === void 0 ? void 0 : existing.clipboardText;\r\n            if (!clipboardText && completions.needsClipboard) {\r\n                clipboardText = yield this._clipboardService.readText();\r\n            }\r\n            if (this._state === 0 /* Idle */) {\r\n                return;\r\n            }\r\n            const model = this._editor.getModel();\r\n            let items = completions.items;\r\n            if (existing) {\r\n                const cmpFn = getSuggestionComparator(snippetSortOrder);\r\n                items = items.concat(existing.items).sort(cmpFn);\r\n            }\r\n            const ctx = new suggestModel_LineContext(model, this._editor.getPosition(), auto, context.shy);\r\n            this._completionModel = new completionModel_CompletionModel(items, this._context.column, {\r\n                leadingLineContent: ctx.leadingLineContent,\r\n                characterCountDelta: ctx.column - this._context.column\r\n            }, wordDistance, this._editor.getOption(106 /* suggest */), this._editor.getOption(101 /* snippetSuggestions */), clipboardText);\r\n            // store containers so that they can be disposed later\r\n            this._completionDisposables.add(completions.disposable);\r\n            this._onNewContext(ctx);\r\n            // finally report telemetry about durations\r\n            this._reportDurationsTelemetry(completions.durations);\r\n        })).catch(errors["onUnexpectedError"]);\r\n    }\r\n    _reportDurationsTelemetry(durations) {\r\n        if (this._telemetryGate++ % 230 !== 0) {\r\n            return;\r\n        }\r\n        setTimeout(() => {\r\n            this._telemetryService.publicLog2(\'suggest.durations.json\', { data: JSON.stringify(durations) });\r\n            this._logService.debug(\'suggest.durations.json\', durations);\r\n        });\r\n    }\r\n    static _createSuggestFilter(editor) {\r\n        // kind filter and snippet sort rules\r\n        const result = new Set();\r\n        // snippet setting\r\n        const snippetSuggestions = editor.getOption(101 /* snippetSuggestions */);\r\n        if (snippetSuggestions === \'none\') {\r\n            result.add(27 /* Snippet */);\r\n        }\r\n        // type setting\r\n        const suggestOptions = editor.getOption(106 /* suggest */);\r\n        if (!suggestOptions.showMethods) {\r\n            result.add(0 /* Method */);\r\n        }\r\n        if (!suggestOptions.showFunctions) {\r\n            result.add(1 /* Function */);\r\n        }\r\n        if (!suggestOptions.showConstructors) {\r\n            result.add(2 /* Constructor */);\r\n        }\r\n        if (!suggestOptions.showFields) {\r\n            result.add(3 /* Field */);\r\n        }\r\n        if (!suggestOptions.showVariables) {\r\n            result.add(4 /* Variable */);\r\n        }\r\n        if (!suggestOptions.showClasses) {\r\n            result.add(5 /* Class */);\r\n        }\r\n        if (!suggestOptions.showStructs) {\r\n            result.add(6 /* Struct */);\r\n        }\r\n        if (!suggestOptions.showInterfaces) {\r\n            result.add(7 /* Interface */);\r\n        }\r\n        if (!suggestOptions.showModules) {\r\n            result.add(8 /* Module */);\r\n        }\r\n        if (!suggestOptions.showProperties) {\r\n            result.add(9 /* Property */);\r\n        }\r\n        if (!suggestOptions.showEvents) {\r\n            result.add(10 /* Event */);\r\n        }\r\n        if (!suggestOptions.showOperators) {\r\n            result.add(11 /* Operator */);\r\n        }\r\n        if (!suggestOptions.showUnits) {\r\n            result.add(12 /* Unit */);\r\n        }\r\n        if (!suggestOptions.showValues) {\r\n            result.add(13 /* Value */);\r\n        }\r\n        if (!suggestOptions.showConstants) {\r\n            result.add(14 /* Constant */);\r\n        }\r\n        if (!suggestOptions.showEnums) {\r\n            result.add(15 /* Enum */);\r\n        }\r\n        if (!suggestOptions.showEnumMembers) {\r\n            result.add(16 /* EnumMember */);\r\n        }\r\n        if (!suggestOptions.showKeywords) {\r\n            result.add(17 /* Keyword */);\r\n        }\r\n        if (!suggestOptions.showWords) {\r\n            result.add(18 /* Text */);\r\n        }\r\n        if (!suggestOptions.showColors) {\r\n            result.add(19 /* Color */);\r\n        }\r\n        if (!suggestOptions.showFiles) {\r\n            result.add(20 /* File */);\r\n        }\r\n        if (!suggestOptions.showReferences) {\r\n            result.add(21 /* Reference */);\r\n        }\r\n        if (!suggestOptions.showColors) {\r\n            result.add(22 /* Customcolor */);\r\n        }\r\n        if (!suggestOptions.showFolders) {\r\n            result.add(23 /* Folder */);\r\n        }\r\n        if (!suggestOptions.showTypeParameters) {\r\n            result.add(24 /* TypeParameter */);\r\n        }\r\n        if (!suggestOptions.showSnippets) {\r\n            result.add(27 /* Snippet */);\r\n        }\r\n        if (!suggestOptions.showUsers) {\r\n            result.add(25 /* User */);\r\n        }\r\n        if (!suggestOptions.showIssues) {\r\n            result.add(26 /* Issue */);\r\n        }\r\n        return { itemKind: result, showDeprecated: suggestOptions.showDeprecated };\r\n    }\r\n    _onNewContext(ctx) {\r\n        if (!this._context) {\r\n            // happens when 24x7 IntelliSense is enabled and still in its delay\r\n            return;\r\n        }\r\n        if (ctx.lineNumber !== this._context.lineNumber) {\r\n            // e.g. happens when pressing Enter while IntelliSense is computed\r\n            this.cancel();\r\n            return;\r\n        }\r\n        if (Object(strings["getLeadingWhitespace"])(ctx.leadingLineContent) !== Object(strings["getLeadingWhitespace"])(this._context.leadingLineContent)) {\r\n            // cancel IntelliSense when line start changes\r\n            // happens when the current word gets outdented\r\n            this.cancel();\r\n            return;\r\n        }\r\n        if (ctx.column < this._context.column) {\r\n            // typed -> moved cursor LEFT -> retrigger if still on a word\r\n            if (ctx.leadingWord.word) {\r\n                this.trigger({ auto: this._context.auto, shy: false }, true);\r\n            }\r\n            else {\r\n                this.cancel();\r\n            }\r\n            return;\r\n        }\r\n        if (!this._completionModel) {\r\n            // happens when IntelliSense is not yet computed\r\n            return;\r\n        }\r\n        if (ctx.leadingWord.word.length !== 0 && ctx.leadingWord.startColumn > this._context.leadingWord.startColumn) {\r\n            // started a new word while IntelliSense shows -> retrigger\r\n            // Select those providers have not contributed to this completion model and re-trigger completions for\r\n            // them. Also adopt the existing items and merge them into the new completion model\r\n            const inactiveProvider = new Set(modes["CompletionProviderRegistry"].all(this._editor.getModel()));\r\n            for (let provider of this._completionModel.allProvider) {\r\n                inactiveProvider.delete(provider);\r\n            }\r\n            const items = this._completionModel.adopt(new Set());\r\n            this.trigger({ auto: this._context.auto, shy: false }, true, inactiveProvider, { items, clipboardText: this._completionModel.clipboardText });\r\n            return;\r\n        }\r\n        if (ctx.column > this._context.column && this._completionModel.incomplete.size > 0 && ctx.leadingWord.word.length !== 0) {\r\n            // typed -> moved cursor RIGHT & incomple model & still on a word -> retrigger\r\n            const { incomplete } = this._completionModel;\r\n            const items = this._completionModel.adopt(incomplete);\r\n            this.trigger({ auto: this._state === 2 /* Auto */, shy: false, triggerKind: 2 /* TriggerForIncompleteCompletions */ }, true, incomplete, { items, clipboardText: this._completionModel.clipboardText });\r\n        }\r\n        else {\r\n            // typed -> moved cursor RIGHT -> update UI\r\n            let oldLineContext = this._completionModel.lineContext;\r\n            let isFrozen = false;\r\n            this._completionModel.lineContext = {\r\n                leadingLineContent: ctx.leadingLineContent,\r\n                characterCountDelta: ctx.column - this._context.column\r\n            };\r\n            if (this._completionModel.items.length === 0) {\r\n                if (suggestModel_LineContext.shouldAutoTrigger(this._editor) && this._context.leadingWord.endColumn < ctx.leadingWord.startColumn) {\r\n                    // retrigger when heading into a new word\r\n                    this.trigger({ auto: this._context.auto, shy: false }, true);\r\n                    return;\r\n                }\r\n                if (!this._context.auto) {\r\n                    // freeze when IntelliSense was manually requested\r\n                    this._completionModel.lineContext = oldLineContext;\r\n                    isFrozen = this._completionModel.items.length > 0;\r\n                    if (isFrozen && ctx.leadingWord.word.length === 0) {\r\n                        // there were results before but now there aren\'t\r\n                        // and also we are not on a word anymore -> cancel\r\n                        this.cancel();\r\n                        return;\r\n                    }\r\n                }\r\n                else {\r\n                    // nothing left\r\n                    this.cancel();\r\n                    return;\r\n                }\r\n            }\r\n            this._onDidSuggest.fire({\r\n                completionModel: this._completionModel,\r\n                auto: this._context.auto,\r\n                shy: this._context.shy,\r\n                isFrozen,\r\n            });\r\n        }\r\n    }\r\n};\r\nsuggestModel_SuggestModel = suggestModel_decorate([\r\n    suggestModel_param(1, editorWorkerService["IEditorWorkerService"]),\r\n    suggestModel_param(2, clipboardService["IClipboardService"]),\r\n    suggestModel_param(3, telemetry["ITelemetryService"]),\r\n    suggestModel_param(4, log["ILogService"]),\r\n    suggestModel_param(5, contextkey["IContextKeyService"]),\r\n    suggestModel_param(6, configuration["IConfigurationService"])\r\n], suggestModel_SuggestModel);\r\n\r\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/suggest/media/suggest.css\nvar suggest = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/contrib/suggest/media/suggest.css");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/browser/ui/codicons/codiconStyles.js\nvar codiconStyles = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/browser/ui/codicons/codiconStyles.js");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/symbolIcons/symbolIcons.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\n\r\nconst SYMBOL_ICON_ARRAY_FOREGROUND = Object(colorRegistry["registerColor"])(\'symbolIcon.arrayForeground\', {\r\n    dark: colorRegistry["foreground"],\r\n    light: colorRegistry["foreground"],\r\n    hc: colorRegistry["foreground"]\r\n}, Object(nls["localize"])(\'symbolIcon.arrayForeground\', \'The foreground color for array symbols. These symbols appear in the outline, breadcrumb, and suggest widget.\'));\r\nconst SYMBOL_ICON_BOOLEAN_FOREGROUND = Object(colorRegistry["registerColor"])(\'symbolIcon.booleanForeground\', {\r\n    dark: colorRegistry["foreground"],\r\n    light: colorRegistry["foreground"],\r\n    hc: colorRegistry["foreground"]\r\n}, Object(nls["localize"])(\'symbolIcon.booleanForeground\', \'The foreground color for boolean symbols. These symbols appear in the outline, breadcrumb, and suggest widget.\'));\r\nconst SYMBOL_ICON_CLASS_FOREGROUND = Object(colorRegistry["registerColor"])(\'symbolIcon.classForeground\', {\r\n    dark: \'#EE9D28\',\r\n    light: \'#D67E00\',\r\n    hc: \'#EE9D28\'\r\n}, Object(nls["localize"])(\'symbolIcon.classForeground\', \'The foreground color for class symbols. These symbols appear in the outline, breadcrumb, and suggest widget.\'));\r\nconst SYMBOL_ICON_COLOR_FOREGROUND = Object(colorRegistry["registerColor"])(\'symbolIcon.colorForeground\', {\r\n    dark: colorRegistry["foreground"],\r\n    light: colorRegistry["foreground"],\r\n    hc: colorRegistry["foreground"]\r\n}, Object(nls["localize"])(\'symbolIcon.colorForeground\', \'The foreground color for color symbols. These symbols appear in the outline, breadcrumb, and suggest widget.\'));\r\nconst SYMBOL_ICON_CONSTANT_FOREGROUND = Object(colorRegistry["registerColor"])(\'symbolIcon.constantForeground\', {\r\n    dark: colorRegistry["foreground"],\r\n    light: colorRegistry["foreground"],\r\n    hc: colorRegistry["foreground"]\r\n}, Object(nls["localize"])(\'symbolIcon.constantForeground\', \'The foreground color for constant symbols. These symbols appear in the outline, breadcrumb, and suggest widget.\'));\r\nconst SYMBOL_ICON_CONSTRUCTOR_FOREGROUND = Object(colorRegistry["registerColor"])(\'symbolIcon.constructorForeground\', {\r\n    dark: \'#B180D7\',\r\n    light: \'#652D90\',\r\n    hc: \'#B180D7\'\r\n}, Object(nls["localize"])(\'symbolIcon.constructorForeground\', \'The foreground color for constructor symbols. These symbols appear in the outline, breadcrumb, and suggest widget.\'));\r\nconst SYMBOL_ICON_ENUMERATOR_FOREGROUND = Object(colorRegistry["registerColor"])(\'symbolIcon.enumeratorForeground\', {\r\n    dark: \'#EE9D28\',\r\n    light: \'#D67E00\',\r\n    hc: \'#EE9D28\'\r\n}, Object(nls["localize"])(\'symbolIcon.enumeratorForeground\', \'The foreground color for enumerator symbols. These symbols appear in the outline, breadcrumb, and suggest widget.\'));\r\nconst SYMBOL_ICON_ENUMERATOR_MEMBER_FOREGROUND = Object(colorRegistry["registerColor"])(\'symbolIcon.enumeratorMemberForeground\', {\r\n    dark: \'#75BEFF\',\r\n    light: \'#007ACC\',\r\n    hc: \'#75BEFF\'\r\n}, Object(nls["localize"])(\'symbolIcon.enumeratorMemberForeground\', \'The foreground color for enumerator member symbols. These symbols appear in the outline, breadcrumb, and suggest widget.\'));\r\nconst SYMBOL_ICON_EVENT_FOREGROUND = Object(colorRegistry["registerColor"])(\'symbolIcon.eventForeground\', {\r\n    dark: \'#EE9D28\',\r\n    light: \'#D67E00\',\r\n    hc: \'#EE9D28\'\r\n}, Object(nls["localize"])(\'symbolIcon.eventForeground\', \'The foreground color for event symbols. These symbols appear in the outline, breadcrumb, and suggest widget.\'));\r\nconst SYMBOL_ICON_FIELD_FOREGROUND = Object(colorRegistry["registerColor"])(\'symbolIcon.fieldForeground\', {\r\n    dark: \'#75BEFF\',\r\n    light: \'#007ACC\',\r\n    hc: \'#75BEFF\'\r\n}, Object(nls["localize"])(\'symbolIcon.fieldForeground\', \'The foreground color for field symbols. These symbols appear in the outline, breadcrumb, and suggest widget.\'));\r\nconst SYMBOL_ICON_FILE_FOREGROUND = Object(colorRegistry["registerColor"])(\'symbolIcon.fileForeground\', {\r\n    dark: colorRegistry["foreground"],\r\n    light: colorRegistry["foreground"],\r\n    hc: colorRegistry["foreground"]\r\n}, Object(nls["localize"])(\'symbolIcon.fileForeground\', \'The foreground color for file symbols. These symbols appear in the outline, breadcrumb, and suggest widget.\'));\r\nconst SYMBOL_ICON_FOLDER_FOREGROUND = Object(colorRegistry["registerColor"])(\'symbolIcon.folderForeground\', {\r\n    dark: colorRegistry["foreground"],\r\n    light: colorRegistry["foreground"],\r\n    hc: colorRegistry["foreground"]\r\n}, Object(nls["localize"])(\'symbolIcon.folderForeground\', \'The foreground color for folder symbols. These symbols appear in the outline, breadcrumb, and suggest widget.\'));\r\nconst SYMBOL_ICON_FUNCTION_FOREGROUND = Object(colorRegistry["registerColor"])(\'symbolIcon.functionForeground\', {\r\n    dark: \'#B180D7\',\r\n    light: \'#652D90\',\r\n    hc: \'#B180D7\'\r\n}, Object(nls["localize"])(\'symbolIcon.functionForeground\', \'The foreground color for function symbols. These symbols appear in the outline, breadcrumb, and suggest widget.\'));\r\nconst SYMBOL_ICON_INTERFACE_FOREGROUND = Object(colorRegistry["registerColor"])(\'symbolIcon.interfaceForeground\', {\r\n    dark: \'#75BEFF\',\r\n    light: \'#007ACC\',\r\n    hc: \'#75BEFF\'\r\n}, Object(nls["localize"])(\'symbolIcon.interfaceForeground\', \'The foreground color for interface symbols. These symbols appear in the outline, breadcrumb, and suggest widget.\'));\r\nconst SYMBOL_ICON_KEY_FOREGROUND = Object(colorRegistry["registerColor"])(\'symbolIcon.keyForeground\', {\r\n    dark: colorRegistry["foreground"],\r\n    light: colorRegistry["foreground"],\r\n    hc: colorRegistry["foreground"]\r\n}, Object(nls["localize"])(\'symbolIcon.keyForeground\', \'The foreground color for key symbols. These symbols appear in the outline, breadcrumb, and suggest widget.\'));\r\nconst SYMBOL_ICON_KEYWORD_FOREGROUND = Object(colorRegistry["registerColor"])(\'symbolIcon.keywordForeground\', {\r\n    dark: colorRegistry["foreground"],\r\n    light: colorRegistry["foreground"],\r\n    hc: colorRegistry["foreground"]\r\n}, Object(nls["localize"])(\'symbolIcon.keywordForeground\', \'The foreground color for keyword symbols. These symbols appear in the outline, breadcrumb, and suggest widget.\'));\r\nconst SYMBOL_ICON_METHOD_FOREGROUND = Object(colorRegistry["registerColor"])(\'symbolIcon.methodForeground\', {\r\n    dark: \'#B180D7\',\r\n    light: \'#652D90\',\r\n    hc: \'#B180D7\'\r\n}, Object(nls["localize"])(\'symbolIcon.methodForeground\', \'The foreground color for method symbols. These symbols appear in the outline, breadcrumb, and suggest widget.\'));\r\nconst SYMBOL_ICON_MODULE_FOREGROUND = Object(colorRegistry["registerColor"])(\'symbolIcon.moduleForeground\', {\r\n    dark: colorRegistry["foreground"],\r\n    light: colorRegistry["foreground"],\r\n    hc: colorRegistry["foreground"]\r\n}, Object(nls["localize"])(\'symbolIcon.moduleForeground\', \'The foreground color for module symbols. These symbols appear in the outline, breadcrumb, and suggest widget.\'));\r\nconst SYMBOL_ICON_NAMESPACE_FOREGROUND = Object(colorRegistry["registerColor"])(\'symbolIcon.namespaceForeground\', {\r\n    dark: colorRegistry["foreground"],\r\n    light: colorRegistry["foreground"],\r\n    hc: colorRegistry["foreground"]\r\n}, Object(nls["localize"])(\'symbolIcon.namespaceForeground\', \'The foreground color for namespace symbols. These symbols appear in the outline, breadcrumb, and suggest widget.\'));\r\nconst SYMBOL_ICON_NULL_FOREGROUND = Object(colorRegistry["registerColor"])(\'symbolIcon.nullForeground\', {\r\n    dark: colorRegistry["foreground"],\r\n    light: colorRegistry["foreground"],\r\n    hc: colorRegistry["foreground"]\r\n}, Object(nls["localize"])(\'symbolIcon.nullForeground\', \'The foreground color for null symbols. These symbols appear in the outline, breadcrumb, and suggest widget.\'));\r\nconst SYMBOL_ICON_NUMBER_FOREGROUND = Object(colorRegistry["registerColor"])(\'symbolIcon.numberForeground\', {\r\n    dark: colorRegistry["foreground"],\r\n    light: colorRegistry["foreground"],\r\n    hc: colorRegistry["foreground"]\r\n}, Object(nls["localize"])(\'symbolIcon.numberForeground\', \'The foreground color for number symbols. These symbols appear in the outline, breadcrumb, and suggest widget.\'));\r\nconst SYMBOL_ICON_OBJECT_FOREGROUND = Object(colorRegistry["registerColor"])(\'symbolIcon.objectForeground\', {\r\n    dark: colorRegistry["foreground"],\r\n    light: colorRegistry["foreground"],\r\n    hc: colorRegistry["foreground"]\r\n}, Object(nls["localize"])(\'symbolIcon.objectForeground\', \'The foreground color for object symbols. These symbols appear in the outline, breadcrumb, and suggest widget.\'));\r\nconst SYMBOL_ICON_OPERATOR_FOREGROUND = Object(colorRegistry["registerColor"])(\'symbolIcon.operatorForeground\', {\r\n    dark: colorRegistry["foreground"],\r\n    light: colorRegistry["foreground"],\r\n    hc: colorRegistry["foreground"]\r\n}, Object(nls["localize"])(\'symbolIcon.operatorForeground\', \'The foreground color for operator symbols. These symbols appear in the outline, breadcrumb, and suggest widget.\'));\r\nconst SYMBOL_ICON_PACKAGE_FOREGROUND = Object(colorRegistry["registerColor"])(\'symbolIcon.packageForeground\', {\r\n    dark: colorRegistry["foreground"],\r\n    light: colorRegistry["foreground"],\r\n    hc: colorRegistry["foreground"]\r\n}, Object(nls["localize"])(\'symbolIcon.packageForeground\', \'The foreground color for package symbols. These symbols appear in the outline, breadcrumb, and suggest widget.\'));\r\nconst SYMBOL_ICON_PROPERTY_FOREGROUND = Object(colorRegistry["registerColor"])(\'symbolIcon.propertyForeground\', {\r\n    dark: colorRegistry["foreground"],\r\n    light: colorRegistry["foreground"],\r\n    hc: colorRegistry["foreground"]\r\n}, Object(nls["localize"])(\'symbolIcon.propertyForeground\', \'The foreground color for property symbols. These symbols appear in the outline, breadcrumb, and suggest widget.\'));\r\nconst SYMBOL_ICON_REFERENCE_FOREGROUND = Object(colorRegistry["registerColor"])(\'symbolIcon.referenceForeground\', {\r\n    dark: colorRegistry["foreground"],\r\n    light: colorRegistry["foreground"],\r\n    hc: colorRegistry["foreground"]\r\n}, Object(nls["localize"])(\'symbolIcon.referenceForeground\', \'The foreground color for reference symbols. These symbols appear in the outline, breadcrumb, and suggest widget.\'));\r\nconst SYMBOL_ICON_SNIPPET_FOREGROUND = Object(colorRegistry["registerColor"])(\'symbolIcon.snippetForeground\', {\r\n    dark: colorRegistry["foreground"],\r\n    light: colorRegistry["foreground"],\r\n    hc: colorRegistry["foreground"]\r\n}, Object(nls["localize"])(\'symbolIcon.snippetForeground\', \'The foreground color for snippet symbols. These symbols appear in the outline, breadcrumb, and suggest widget.\'));\r\nconst SYMBOL_ICON_STRING_FOREGROUND = Object(colorRegistry["registerColor"])(\'symbolIcon.stringForeground\', {\r\n    dark: colorRegistry["foreground"],\r\n    light: colorRegistry["foreground"],\r\n    hc: colorRegistry["foreground"]\r\n}, Object(nls["localize"])(\'symbolIcon.stringForeground\', \'The foreground color for string symbols. These symbols appear in the outline, breadcrumb, and suggest widget.\'));\r\nconst SYMBOL_ICON_STRUCT_FOREGROUND = Object(colorRegistry["registerColor"])(\'symbolIcon.structForeground\', {\r\n    dark: colorRegistry["foreground"],\r\n    light: colorRegistry["foreground"],\r\n    hc: colorRegistry["foreground"]\r\n}, Object(nls["localize"])(\'symbolIcon.structForeground\', \'The foreground color for struct symbols. These symbols appear in the outline, breadcrumb, and suggest widget.\'));\r\nconst SYMBOL_ICON_TEXT_FOREGROUND = Object(colorRegistry["registerColor"])(\'symbolIcon.textForeground\', {\r\n    dark: colorRegistry["foreground"],\r\n    light: colorRegistry["foreground"],\r\n    hc: colorRegistry["foreground"]\r\n}, Object(nls["localize"])(\'symbolIcon.textForeground\', \'The foreground color for text symbols. These symbols appear in the outline, breadcrumb, and suggest widget.\'));\r\nconst SYMBOL_ICON_TYPEPARAMETER_FOREGROUND = Object(colorRegistry["registerColor"])(\'symbolIcon.typeParameterForeground\', {\r\n    dark: colorRegistry["foreground"],\r\n    light: colorRegistry["foreground"],\r\n    hc: colorRegistry["foreground"]\r\n}, Object(nls["localize"])(\'symbolIcon.typeParameterForeground\', \'The foreground color for type parameter symbols. These symbols appear in the outline, breadcrumb, and suggest widget.\'));\r\nconst SYMBOL_ICON_UNIT_FOREGROUND = Object(colorRegistry["registerColor"])(\'symbolIcon.unitForeground\', {\r\n    dark: colorRegistry["foreground"],\r\n    light: colorRegistry["foreground"],\r\n    hc: colorRegistry["foreground"]\r\n}, Object(nls["localize"])(\'symbolIcon.unitForeground\', \'The foreground color for unit symbols. These symbols appear in the outline, breadcrumb, and suggest widget.\'));\r\nconst SYMBOL_ICON_VARIABLE_FOREGROUND = Object(colorRegistry["registerColor"])(\'symbolIcon.variableForeground\', {\r\n    dark: \'#75BEFF\',\r\n    light: \'#007ACC\',\r\n    hc: \'#75BEFF\'\r\n}, Object(nls["localize"])(\'symbolIcon.variableForeground\', \'The foreground color for variable symbols. These symbols appear in the outline, breadcrumb, and suggest widget.\'));\r\nObject(common_themeService["registerThemingParticipant"])((theme, collector) => {\r\n    const symbolIconArrayColor = theme.getColor(SYMBOL_ICON_ARRAY_FOREGROUND);\r\n    if (symbolIconArrayColor) {\r\n        collector.addRule(`${codicons["Codicon"].symbolArray.cssSelector} { color: ${symbolIconArrayColor}; }`);\r\n    }\r\n    const symbolIconBooleanColor = theme.getColor(SYMBOL_ICON_BOOLEAN_FOREGROUND);\r\n    if (symbolIconBooleanColor) {\r\n        collector.addRule(`${codicons["Codicon"].symbolBoolean.cssSelector} { color: ${symbolIconBooleanColor}; }`);\r\n    }\r\n    const symbolIconClassColor = theme.getColor(SYMBOL_ICON_CLASS_FOREGROUND);\r\n    if (symbolIconClassColor) {\r\n        collector.addRule(`${codicons["Codicon"].symbolClass.cssSelector} { color: ${symbolIconClassColor}; }`);\r\n    }\r\n    const symbolIconMethodColor = theme.getColor(SYMBOL_ICON_METHOD_FOREGROUND);\r\n    if (symbolIconMethodColor) {\r\n        collector.addRule(`${codicons["Codicon"].symbolMethod.cssSelector} { color: ${symbolIconMethodColor}; }`);\r\n    }\r\n    const symbolIconColorColor = theme.getColor(SYMBOL_ICON_COLOR_FOREGROUND);\r\n    if (symbolIconColorColor) {\r\n        collector.addRule(`${codicons["Codicon"].symbolColor.cssSelector} { color: ${symbolIconColorColor}; }`);\r\n    }\r\n    const symbolIconConstantColor = theme.getColor(SYMBOL_ICON_CONSTANT_FOREGROUND);\r\n    if (symbolIconConstantColor) {\r\n        collector.addRule(`${codicons["Codicon"].symbolConstant.cssSelector} { color: ${symbolIconConstantColor}; }`);\r\n    }\r\n    const symbolIconConstructorColor = theme.getColor(SYMBOL_ICON_CONSTRUCTOR_FOREGROUND);\r\n    if (symbolIconConstructorColor) {\r\n        collector.addRule(`${codicons["Codicon"].symbolConstructor.cssSelector} { color: ${symbolIconConstructorColor}; }`);\r\n    }\r\n    const symbolIconEnumeratorColor = theme.getColor(SYMBOL_ICON_ENUMERATOR_FOREGROUND);\r\n    if (symbolIconEnumeratorColor) {\r\n        collector.addRule(`\n\t\t\t${codicons["Codicon"].symbolValue.cssSelector},${codicons["Codicon"].symbolEnum.cssSelector} { color: ${symbolIconEnumeratorColor}; }`);\r\n    }\r\n    const symbolIconEnumeratorMemberColor = theme.getColor(SYMBOL_ICON_ENUMERATOR_MEMBER_FOREGROUND);\r\n    if (symbolIconEnumeratorMemberColor) {\r\n        collector.addRule(`${codicons["Codicon"].symbolEnumMember.cssSelector} { color: ${symbolIconEnumeratorMemberColor}; }`);\r\n    }\r\n    const symbolIconEventColor = theme.getColor(SYMBOL_ICON_EVENT_FOREGROUND);\r\n    if (symbolIconEventColor) {\r\n        collector.addRule(`${codicons["Codicon"].symbolEvent.cssSelector} { color: ${symbolIconEventColor}; }`);\r\n    }\r\n    const symbolIconFieldColor = theme.getColor(SYMBOL_ICON_FIELD_FOREGROUND);\r\n    if (symbolIconFieldColor) {\r\n        collector.addRule(`${codicons["Codicon"].symbolField.cssSelector} { color: ${symbolIconFieldColor}; }`);\r\n    }\r\n    const symbolIconFileColor = theme.getColor(SYMBOL_ICON_FILE_FOREGROUND);\r\n    if (symbolIconFileColor) {\r\n        collector.addRule(`${codicons["Codicon"].symbolFile.cssSelector} { color: ${symbolIconFileColor}; }`);\r\n    }\r\n    const symbolIconFolderColor = theme.getColor(SYMBOL_ICON_FOLDER_FOREGROUND);\r\n    if (symbolIconFolderColor) {\r\n        collector.addRule(`${codicons["Codicon"].symbolFolder.cssSelector} { color: ${symbolIconFolderColor}; }`);\r\n    }\r\n    const symbolIconFunctionColor = theme.getColor(SYMBOL_ICON_FUNCTION_FOREGROUND);\r\n    if (symbolIconFunctionColor) {\r\n        collector.addRule(`${codicons["Codicon"].symbolFunction.cssSelector} { color: ${symbolIconFunctionColor}; }`);\r\n    }\r\n    const symbolIconInterfaceColor = theme.getColor(SYMBOL_ICON_INTERFACE_FOREGROUND);\r\n    if (symbolIconInterfaceColor) {\r\n        collector.addRule(`${codicons["Codicon"].symbolInterface.cssSelector} { color: ${symbolIconInterfaceColor}; }`);\r\n    }\r\n    const symbolIconKeyColor = theme.getColor(SYMBOL_ICON_KEY_FOREGROUND);\r\n    if (symbolIconKeyColor) {\r\n        collector.addRule(`${codicons["Codicon"].symbolKey.cssSelector} { color: ${symbolIconKeyColor}; }`);\r\n    }\r\n    const symbolIconKeywordColor = theme.getColor(SYMBOL_ICON_KEYWORD_FOREGROUND);\r\n    if (symbolIconKeywordColor) {\r\n        collector.addRule(`${codicons["Codicon"].symbolKeyword.cssSelector} { color: ${symbolIconKeywordColor}; }`);\r\n    }\r\n    const symbolIconModuleColor = theme.getColor(SYMBOL_ICON_MODULE_FOREGROUND);\r\n    if (symbolIconModuleColor) {\r\n        collector.addRule(`${codicons["Codicon"].symbolModule.cssSelector} { color: ${symbolIconModuleColor}; }`);\r\n    }\r\n    const outlineNamespaceColor = theme.getColor(SYMBOL_ICON_NAMESPACE_FOREGROUND);\r\n    if (outlineNamespaceColor) {\r\n        collector.addRule(`${codicons["Codicon"].symbolNamespace.cssSelector} { color: ${outlineNamespaceColor}; }`);\r\n    }\r\n    const symbolIconNullColor = theme.getColor(SYMBOL_ICON_NULL_FOREGROUND);\r\n    if (symbolIconNullColor) {\r\n        collector.addRule(`${codicons["Codicon"].symbolNull.cssSelector} { color: ${symbolIconNullColor}; }`);\r\n    }\r\n    const symbolIconNumberColor = theme.getColor(SYMBOL_ICON_NUMBER_FOREGROUND);\r\n    if (symbolIconNumberColor) {\r\n        collector.addRule(`${codicons["Codicon"].symbolNumber.cssSelector} { color: ${symbolIconNumberColor}; }`);\r\n    }\r\n    const symbolIconObjectColor = theme.getColor(SYMBOL_ICON_OBJECT_FOREGROUND);\r\n    if (symbolIconObjectColor) {\r\n        collector.addRule(`${codicons["Codicon"].symbolObject.cssSelector} { color: ${symbolIconObjectColor}; }`);\r\n    }\r\n    const symbolIconOperatorColor = theme.getColor(SYMBOL_ICON_OPERATOR_FOREGROUND);\r\n    if (symbolIconOperatorColor) {\r\n        collector.addRule(`${codicons["Codicon"].symbolOperator.cssSelector} { color: ${symbolIconOperatorColor}; }`);\r\n    }\r\n    const symbolIconPackageColor = theme.getColor(SYMBOL_ICON_PACKAGE_FOREGROUND);\r\n    if (symbolIconPackageColor) {\r\n        collector.addRule(`${codicons["Codicon"].symbolPackage.cssSelector} { color: ${symbolIconPackageColor}; }`);\r\n    }\r\n    const symbolIconPropertyColor = theme.getColor(SYMBOL_ICON_PROPERTY_FOREGROUND);\r\n    if (symbolIconPropertyColor) {\r\n        collector.addRule(`${codicons["Codicon"].symbolProperty.cssSelector} { color: ${symbolIconPropertyColor}; }`);\r\n    }\r\n    const symbolIconReferenceColor = theme.getColor(SYMBOL_ICON_REFERENCE_FOREGROUND);\r\n    if (symbolIconReferenceColor) {\r\n        collector.addRule(`${codicons["Codicon"].symbolReference.cssSelector} { color: ${symbolIconReferenceColor}; }`);\r\n    }\r\n    const symbolIconSnippetColor = theme.getColor(SYMBOL_ICON_SNIPPET_FOREGROUND);\r\n    if (symbolIconSnippetColor) {\r\n        collector.addRule(`${codicons["Codicon"].symbolSnippet.cssSelector} { color: ${symbolIconSnippetColor}; }`);\r\n    }\r\n    const symbolIconStringColor = theme.getColor(SYMBOL_ICON_STRING_FOREGROUND);\r\n    if (symbolIconStringColor) {\r\n        collector.addRule(`${codicons["Codicon"].symbolString.cssSelector} { color: ${symbolIconStringColor}; }`);\r\n    }\r\n    const symbolIconStructColor = theme.getColor(SYMBOL_ICON_STRUCT_FOREGROUND);\r\n    if (symbolIconStructColor) {\r\n        collector.addRule(`${codicons["Codicon"].symbolStruct.cssSelector} { color: ${symbolIconStructColor}; }`);\r\n    }\r\n    const symbolIconTextColor = theme.getColor(SYMBOL_ICON_TEXT_FOREGROUND);\r\n    if (symbolIconTextColor) {\r\n        collector.addRule(`${codicons["Codicon"].symbolText.cssSelector} { color: ${symbolIconTextColor}; }`);\r\n    }\r\n    const symbolIconTypeParameterColor = theme.getColor(SYMBOL_ICON_TYPEPARAMETER_FOREGROUND);\r\n    if (symbolIconTypeParameterColor) {\r\n        collector.addRule(`${codicons["Codicon"].symbolTypeParameter.cssSelector} { color: ${symbolIconTypeParameterColor}; }`);\r\n    }\r\n    const symbolIconUnitColor = theme.getColor(SYMBOL_ICON_UNIT_FOREGROUND);\r\n    if (symbolIconUnitColor) {\r\n        collector.addRule(`${codicons["Codicon"].symbolUnit.cssSelector} { color: ${symbolIconUnitColor}; }`);\r\n    }\r\n    const symbolIconVariableColor = theme.getColor(SYMBOL_ICON_VARIABLE_FOREGROUND);\r\n    if (symbolIconVariableColor) {\r\n        collector.addRule(`${codicons["Codicon"].symbolVariable.cssSelector} { color: ${symbolIconVariableColor}; }`);\r\n    }\r\n});\r\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/browser/ui/list/listWidget.js + 2 modules\nvar listWidget = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/browser/ui/list/listWidget.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/platform/theme/common/styler.js\nvar styler = __webpack_require__("./node_modules/monaco-editor/esm/vs/platform/theme/common/styler.js");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/suggest/resizable.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\n\r\nclass resizable_ResizableHTMLElement {\r\n    constructor() {\r\n        this._onDidWillResize = new common_event["Emitter"]();\r\n        this.onDidWillResize = this._onDidWillResize.event;\r\n        this._onDidResize = new common_event["Emitter"]();\r\n        this.onDidResize = this._onDidResize.event;\r\n        this._sashListener = new lifecycle["DisposableStore"]();\r\n        this._size = new dom["Dimension"](0, 0);\r\n        this._minSize = new dom["Dimension"](0, 0);\r\n        this._maxSize = new dom["Dimension"](Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);\r\n        this.domNode = document.createElement(\'div\');\r\n        this._eastSash = new sash["Sash"](this.domNode, { getVerticalSashLeft: () => this._size.width }, { orientation: 0 /* VERTICAL */ });\r\n        this._westSash = new sash["Sash"](this.domNode, { getVerticalSashLeft: () => 0 }, { orientation: 0 /* VERTICAL */ });\r\n        this._northSash = new sash["Sash"](this.domNode, { getHorizontalSashTop: () => 0 }, { orientation: 1 /* HORIZONTAL */, orthogonalEdge: sash["OrthogonalEdge"].North });\r\n        this._southSash = new sash["Sash"](this.domNode, { getHorizontalSashTop: () => this._size.height }, { orientation: 1 /* HORIZONTAL */, orthogonalEdge: sash["OrthogonalEdge"].South });\r\n        this._northSash.orthogonalStartSash = this._westSash;\r\n        this._northSash.orthogonalEndSash = this._eastSash;\r\n        this._southSash.orthogonalStartSash = this._westSash;\r\n        this._southSash.orthogonalEndSash = this._eastSash;\r\n        let currentSize;\r\n        let deltaY = 0;\r\n        let deltaX = 0;\r\n        this._sashListener.add(common_event["Event"].any(this._northSash.onDidStart, this._eastSash.onDidStart, this._southSash.onDidStart, this._westSash.onDidStart)(() => {\r\n            if (currentSize === undefined) {\r\n                this._onDidWillResize.fire();\r\n                currentSize = this._size;\r\n                deltaY = 0;\r\n                deltaX = 0;\r\n            }\r\n        }));\r\n        this._sashListener.add(common_event["Event"].any(this._northSash.onDidEnd, this._eastSash.onDidEnd, this._southSash.onDidEnd, this._westSash.onDidEnd)(() => {\r\n            if (currentSize !== undefined) {\r\n                currentSize = undefined;\r\n                deltaY = 0;\r\n                deltaX = 0;\r\n                this._onDidResize.fire({ dimension: this._size, done: true });\r\n            }\r\n        }));\r\n        this._sashListener.add(this._eastSash.onDidChange(e => {\r\n            if (currentSize) {\r\n                deltaX = e.currentX - e.startX;\r\n                this.layout(currentSize.height + deltaY, currentSize.width + deltaX);\r\n                this._onDidResize.fire({ dimension: this._size, done: false, east: true });\r\n            }\r\n        }));\r\n        this._sashListener.add(this._westSash.onDidChange(e => {\r\n            if (currentSize) {\r\n                deltaX = -(e.currentX - e.startX);\r\n                this.layout(currentSize.height + deltaY, currentSize.width + deltaX);\r\n                this._onDidResize.fire({ dimension: this._size, done: false, west: true });\r\n            }\r\n        }));\r\n        this._sashListener.add(this._northSash.onDidChange(e => {\r\n            if (currentSize) {\r\n                deltaY = -(e.currentY - e.startY);\r\n                this.layout(currentSize.height + deltaY, currentSize.width + deltaX);\r\n                this._onDidResize.fire({ dimension: this._size, done: false, north: true });\r\n            }\r\n        }));\r\n        this._sashListener.add(this._southSash.onDidChange(e => {\r\n            if (currentSize) {\r\n                deltaY = e.currentY - e.startY;\r\n                this.layout(currentSize.height + deltaY, currentSize.width + deltaX);\r\n                this._onDidResize.fire({ dimension: this._size, done: false, south: true });\r\n            }\r\n        }));\r\n        this._sashListener.add(common_event["Event"].any(this._eastSash.onDidReset, this._westSash.onDidReset)(e => {\r\n            if (this._preferredSize) {\r\n                this.layout(this._size.height, this._preferredSize.width);\r\n                this._onDidResize.fire({ dimension: this._size, done: true });\r\n            }\r\n        }));\r\n        this._sashListener.add(common_event["Event"].any(this._northSash.onDidReset, this._southSash.onDidReset)(e => {\r\n            if (this._preferredSize) {\r\n                this.layout(this._preferredSize.height, this._size.width);\r\n                this._onDidResize.fire({ dimension: this._size, done: true });\r\n            }\r\n        }));\r\n    }\r\n    dispose() {\r\n        this._northSash.dispose();\r\n        this._southSash.dispose();\r\n        this._eastSash.dispose();\r\n        this._westSash.dispose();\r\n        this._sashListener.dispose();\r\n        this._onDidResize.dispose();\r\n        this._onDidWillResize.dispose();\r\n        this.domNode.remove();\r\n    }\r\n    enableSashes(north, east, south, west) {\r\n        this._northSash.state = north ? 3 /* Enabled */ : 0 /* Disabled */;\r\n        this._eastSash.state = east ? 3 /* Enabled */ : 0 /* Disabled */;\r\n        this._southSash.state = south ? 3 /* Enabled */ : 0 /* Disabled */;\r\n        this._westSash.state = west ? 3 /* Enabled */ : 0 /* Disabled */;\r\n    }\r\n    layout(height = this.size.height, width = this.size.width) {\r\n        const { height: minHeight, width: minWidth } = this._minSize;\r\n        const { height: maxHeight, width: maxWidth } = this._maxSize;\r\n        height = Math.max(minHeight, Math.min(maxHeight, height));\r\n        width = Math.max(minWidth, Math.min(maxWidth, width));\r\n        const newSize = new dom["Dimension"](width, height);\r\n        if (!dom["Dimension"].equals(newSize, this._size)) {\r\n            this.domNode.style.height = height + \'px\';\r\n            this.domNode.style.width = width + \'px\';\r\n            this._size = newSize;\r\n            this._northSash.layout();\r\n            this._eastSash.layout();\r\n            this._southSash.layout();\r\n            this._westSash.layout();\r\n        }\r\n    }\r\n    clearSashHoverState() {\r\n        this._eastSash.clearSashHoverState();\r\n        this._westSash.clearSashHoverState();\r\n        this._northSash.clearSashHoverState();\r\n        this._southSash.clearSashHoverState();\r\n    }\r\n    get size() {\r\n        return this._size;\r\n    }\r\n    set maxSize(value) {\r\n        this._maxSize = value;\r\n    }\r\n    get maxSize() {\r\n        return this._maxSize;\r\n    }\r\n    set minSize(value) {\r\n        this._minSize = value;\r\n    }\r\n    get minSize() {\r\n        return this._minSize;\r\n    }\r\n    set preferredSize(value) {\r\n        this._preferredSize = value;\r\n    }\r\n    get preferredSize() {\r\n        return this._preferredSize;\r\n    }\r\n}\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestWidgetDetails.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar suggestWidgetDetails_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar suggestWidgetDetails_param = (undefined && undefined.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction canExpandCompletionItem(item) {\r\n    return !!item && Boolean(item.completion.documentation || item.completion.detail && item.completion.detail !== item.completion.label);\r\n}\r\nlet suggestWidgetDetails_SuggestDetailsWidget = class SuggestDetailsWidget {\r\n    constructor(_editor, instaService) {\r\n        this._editor = _editor;\r\n        this._onDidClose = new common_event["Emitter"]();\r\n        this.onDidClose = this._onDidClose.event;\r\n        this._onDidChangeContents = new common_event["Emitter"]();\r\n        this.onDidChangeContents = this._onDidChangeContents.event;\r\n        this._disposables = new lifecycle["DisposableStore"]();\r\n        this._renderDisposeable = new lifecycle["DisposableStore"]();\r\n        this._borderWidth = 1;\r\n        this._size = new dom["Dimension"](330, 0);\r\n        this.domNode = dom["$"](\'.suggest-details\');\r\n        this.domNode.classList.add(\'no-docs\');\r\n        this._markdownRenderer = instaService.createInstance(markdownRenderer_MarkdownRenderer, { editor: _editor });\r\n        this._body = dom["$"](\'.body\');\r\n        this._scrollbar = new scrollableElement["DomScrollableElement"](this._body, {});\r\n        dom["append"](this.domNode, this._scrollbar.getDomNode());\r\n        this._disposables.add(this._scrollbar);\r\n        this._header = dom["append"](this._body, dom["$"](\'.header\'));\r\n        this._close = dom["append"](this._header, dom["$"](\'span\' + codicons["Codicon"].close.cssSelector));\r\n        this._close.title = nls["localize"](\'details.close\', "Close");\r\n        this._type = dom["append"](this._header, dom["$"](\'p.type\'));\r\n        this._docs = dom["append"](this._body, dom["$"](\'p.docs\'));\r\n        this._configureFont();\r\n        this._disposables.add(this._editor.onDidChangeConfiguration(e => {\r\n            if (e.hasChanged(42 /* fontInfo */)) {\r\n                this._configureFont();\r\n            }\r\n        }));\r\n    }\r\n    dispose() {\r\n        this._disposables.dispose();\r\n        this._renderDisposeable.dispose();\r\n    }\r\n    _configureFont() {\r\n        const options = this._editor.getOptions();\r\n        const fontInfo = options.get(42 /* fontInfo */);\r\n        const fontFamily = fontInfo.fontFamily;\r\n        const fontSize = options.get(107 /* suggestFontSize */) || fontInfo.fontSize;\r\n        const lineHeight = options.get(108 /* suggestLineHeight */) || fontInfo.lineHeight;\r\n        const fontWeight = fontInfo.fontWeight;\r\n        const fontSizePx = `${fontSize}px`;\r\n        const lineHeightPx = `${lineHeight}px`;\r\n        this.domNode.style.fontSize = fontSizePx;\r\n        this.domNode.style.lineHeight = lineHeightPx;\r\n        this.domNode.style.fontWeight = fontWeight;\r\n        this.domNode.style.fontFeatureSettings = fontInfo.fontFeatureSettings;\r\n        this._type.style.fontFamily = fontFamily;\r\n        this._close.style.height = lineHeightPx;\r\n        this._close.style.width = lineHeightPx;\r\n    }\r\n    getLayoutInfo() {\r\n        const lineHeight = this._editor.getOption(108 /* suggestLineHeight */) || this._editor.getOption(42 /* fontInfo */).lineHeight;\r\n        const borderWidth = this._borderWidth;\r\n        const borderHeight = borderWidth * 2;\r\n        return {\r\n            lineHeight,\r\n            borderWidth,\r\n            borderHeight,\r\n            verticalPadding: 22,\r\n            horizontalPadding: 14\r\n        };\r\n    }\r\n    renderLoading() {\r\n        this._type.textContent = nls["localize"](\'loading\', "Loading...");\r\n        this._docs.textContent = \'\';\r\n        this.domNode.classList.remove(\'no-docs\', \'no-type\');\r\n        this.layout(this.size.width, this.getLayoutInfo().lineHeight * 2);\r\n        this._onDidChangeContents.fire(this);\r\n    }\r\n    renderItem(item, explainMode) {\r\n        var _a, _b;\r\n        this._renderDisposeable.clear();\r\n        let { detail, documentation } = item.completion;\r\n        if (explainMode) {\r\n            let md = \'\';\r\n            md += `score: ${item.score[0]}\\n`;\r\n            md += `prefix: ${(_a = item.word) !== null && _a !== void 0 ? _a : \'(no prefix)\'}\\n`;\r\n            md += `word: ${item.completion.filterText ? item.completion.filterText + \' (filterText)\' : item.textLabel}\\n`;\r\n            md += `distance: ${item.distance} (localityBonus-setting)\\n`;\r\n            md += `index: ${item.idx}, based on ${item.completion.sortText && `sortText: "${item.completion.sortText}"` || \'label\'}\\n`;\r\n            md += `commit_chars: ${(_b = item.completion.commitCharacters) === null || _b === void 0 ? void 0 : _b.join(\'\')}\\n`;\r\n            documentation = new htmlContent_MarkdownString().appendCodeblock(\'empty\', md);\r\n            detail = `Provider: ${item.provider._debugDisplayName}`;\r\n        }\r\n        if (!explainMode && !canExpandCompletionItem(item)) {\r\n            this.clearContents();\r\n            return;\r\n        }\r\n        this.domNode.classList.remove(\'no-docs\', \'no-type\');\r\n        // --- details\r\n        if (detail) {\r\n            const cappedDetail = detail.length > 100000 ? `${detail.substr(0, 100000)}` : detail;\r\n            this._type.textContent = cappedDetail;\r\n            this._type.title = cappedDetail;\r\n            dom["show"](this._type);\r\n            this._type.classList.toggle(\'auto-wrap\', !/\\r?\\n^\\s+/gmi.test(cappedDetail));\r\n        }\r\n        else {\r\n            dom["clearNode"](this._type);\r\n            this._type.title = \'\';\r\n            dom["hide"](this._type);\r\n            this.domNode.classList.add(\'no-type\');\r\n        }\r\n        // --- documentation\r\n        dom["clearNode"](this._docs);\r\n        if (typeof documentation === \'string\') {\r\n            this._docs.classList.remove(\'markdown-docs\');\r\n            this._docs.textContent = documentation;\r\n        }\r\n        else if (documentation) {\r\n            this._docs.classList.add(\'markdown-docs\');\r\n            dom["clearNode"](this._docs);\r\n            const renderedContents = this._markdownRenderer.render(documentation);\r\n            this._docs.appendChild(renderedContents.element);\r\n            this._renderDisposeable.add(renderedContents);\r\n            this._renderDisposeable.add(this._markdownRenderer.onDidRenderAsync(() => {\r\n                this.layout(this._size.width, this._type.clientHeight + this._docs.clientHeight);\r\n                this._onDidChangeContents.fire(this);\r\n            }));\r\n        }\r\n        this.domNode.style.userSelect = \'text\';\r\n        this.domNode.tabIndex = -1;\r\n        this._close.onmousedown = e => {\r\n            e.preventDefault();\r\n            e.stopPropagation();\r\n        };\r\n        this._close.onclick = e => {\r\n            e.preventDefault();\r\n            e.stopPropagation();\r\n            this._onDidClose.fire();\r\n        };\r\n        this._body.scrollTop = 0;\r\n        this.layout(this._size.width, this._type.clientHeight + this._docs.clientHeight);\r\n        this._onDidChangeContents.fire(this);\r\n    }\r\n    clearContents() {\r\n        this.domNode.classList.add(\'no-docs\');\r\n        this._type.textContent = \'\';\r\n        this._docs.textContent = \'\';\r\n    }\r\n    get size() {\r\n        return this._size;\r\n    }\r\n    layout(width, height) {\r\n        const newSize = new dom["Dimension"](width, height);\r\n        if (!dom["Dimension"].equals(newSize, this._size)) {\r\n            this._size = newSize;\r\n            dom["size"](this.domNode, width, height);\r\n        }\r\n        this._scrollbar.scanDomNode();\r\n    }\r\n    scrollDown(much = 8) {\r\n        this._body.scrollTop += much;\r\n    }\r\n    scrollUp(much = 8) {\r\n        this._body.scrollTop -= much;\r\n    }\r\n    scrollTop() {\r\n        this._body.scrollTop = 0;\r\n    }\r\n    scrollBottom() {\r\n        this._body.scrollTop = this._body.scrollHeight;\r\n    }\r\n    pageDown() {\r\n        this.scrollDown(80);\r\n    }\r\n    pageUp() {\r\n        this.scrollUp(80);\r\n    }\r\n    set borderWidth(width) {\r\n        this._borderWidth = width;\r\n    }\r\n    get borderWidth() {\r\n        return this._borderWidth;\r\n    }\r\n};\r\nsuggestWidgetDetails_SuggestDetailsWidget = suggestWidgetDetails_decorate([\r\n    suggestWidgetDetails_param(1, instantiation["IInstantiationService"])\r\n], suggestWidgetDetails_SuggestDetailsWidget);\r\n\r\nclass suggestWidgetDetails_SuggestDetailsOverlay {\r\n    constructor(widget, _editor) {\r\n        this.widget = widget;\r\n        this._editor = _editor;\r\n        this._disposables = new lifecycle["DisposableStore"]();\r\n        this._added = false;\r\n        this._resizable = new resizable_ResizableHTMLElement();\r\n        this._resizable.domNode.classList.add(\'suggest-details-container\');\r\n        this._resizable.domNode.appendChild(widget.domNode);\r\n        this._resizable.enableSashes(false, true, true, false);\r\n        let topLeftNow;\r\n        let sizeNow;\r\n        let deltaTop = 0;\r\n        let deltaLeft = 0;\r\n        this._disposables.add(this._resizable.onDidWillResize(() => {\r\n            topLeftNow = this._topLeft;\r\n            sizeNow = this._resizable.size;\r\n        }));\r\n        this._disposables.add(this._resizable.onDidResize(e => {\r\n            if (topLeftNow && sizeNow) {\r\n                this.widget.layout(e.dimension.width, e.dimension.height);\r\n                let updateTopLeft = false;\r\n                if (e.west) {\r\n                    deltaLeft = sizeNow.width - e.dimension.width;\r\n                    updateTopLeft = true;\r\n                }\r\n                if (e.north) {\r\n                    deltaTop = sizeNow.height - e.dimension.height;\r\n                    updateTopLeft = true;\r\n                }\r\n                if (updateTopLeft) {\r\n                    this._applyTopLeft({\r\n                        top: topLeftNow.top + deltaTop,\r\n                        left: topLeftNow.left + deltaLeft,\r\n                    });\r\n                }\r\n            }\r\n            if (e.done) {\r\n                topLeftNow = undefined;\r\n                sizeNow = undefined;\r\n                deltaTop = 0;\r\n                deltaLeft = 0;\r\n                this._userSize = e.dimension;\r\n            }\r\n        }));\r\n        this._disposables.add(this.widget.onDidChangeContents(() => {\r\n            var _a;\r\n            if (this._anchorBox) {\r\n                this._placeAtAnchor(this._anchorBox, (_a = this._userSize) !== null && _a !== void 0 ? _a : this.widget.size);\r\n            }\r\n        }));\r\n    }\r\n    dispose() {\r\n        this._resizable.dispose();\r\n        this._disposables.dispose();\r\n        this.hide();\r\n    }\r\n    getId() {\r\n        return \'suggest.details\';\r\n    }\r\n    getDomNode() {\r\n        return this._resizable.domNode;\r\n    }\r\n    getPosition() {\r\n        return null;\r\n    }\r\n    show() {\r\n        if (!this._added) {\r\n            this._editor.addOverlayWidget(this);\r\n            this.getDomNode().style.position = \'fixed\';\r\n            this._added = true;\r\n        }\r\n    }\r\n    hide(sessionEnded = false) {\r\n        this._resizable.clearSashHoverState();\r\n        if (this._added) {\r\n            this._editor.removeOverlayWidget(this);\r\n            this._added = false;\r\n            this._anchorBox = undefined;\r\n            this._topLeft = undefined;\r\n        }\r\n        if (sessionEnded) {\r\n            this._userSize = undefined;\r\n            this.widget.clearContents();\r\n        }\r\n    }\r\n    placeAtAnchor(anchor) {\r\n        var _a;\r\n        const anchorBox = dom["getDomNodePagePosition"](anchor);\r\n        this._anchorBox = anchorBox;\r\n        this._placeAtAnchor(this._anchorBox, (_a = this._userSize) !== null && _a !== void 0 ? _a : this.widget.size);\r\n    }\r\n    _placeAtAnchor(anchorBox, size) {\r\n        const bodyBox = dom["getClientArea"](document.body);\r\n        const info = this.widget.getLayoutInfo();\r\n        let maxSizeTop;\r\n        let maxSizeBottom;\r\n        let minSize = new dom["Dimension"](220, 2 * info.lineHeight);\r\n        let left = 0;\r\n        let top = anchorBox.top;\r\n        let bottom = anchorBox.top + anchorBox.height - info.borderHeight;\r\n        let alignAtTop;\r\n        let alignEast;\r\n        // position: EAST, west, south\r\n        let width = bodyBox.width - (anchorBox.left + anchorBox.width + info.borderWidth + info.horizontalPadding);\r\n        left = -info.borderWidth + anchorBox.left + anchorBox.width;\r\n        alignEast = true;\r\n        maxSizeTop = new dom["Dimension"](width, bodyBox.height - anchorBox.top - info.borderHeight - info.verticalPadding);\r\n        maxSizeBottom = maxSizeTop.with(undefined, anchorBox.top + anchorBox.height - info.borderHeight - info.verticalPadding);\r\n        // find a better place if the widget is wider than there is space available\r\n        if (size.width > width) {\r\n            // position: east, WEST, south\r\n            if (anchorBox.left > width) {\r\n                // pos = SuggestDetailsPosition.West;\r\n                width = anchorBox.left - info.borderWidth - info.horizontalPadding;\r\n                alignEast = false;\r\n                left = Math.max(info.horizontalPadding, anchorBox.left - size.width - info.borderWidth);\r\n                maxSizeTop = maxSizeTop.with(width);\r\n                maxSizeBottom = maxSizeTop.with(undefined, maxSizeBottom.height);\r\n            }\r\n            // position: east, west, SOUTH\r\n            if (anchorBox.width > width * 1.3 && bodyBox.height - (anchorBox.top + anchorBox.height) > anchorBox.height) {\r\n                width = anchorBox.width;\r\n                left = anchorBox.left;\r\n                top = -info.borderWidth + anchorBox.top + anchorBox.height;\r\n                maxSizeTop = new dom["Dimension"](anchorBox.width - info.borderHeight, bodyBox.height - anchorBox.top - anchorBox.height - info.verticalPadding);\r\n                maxSizeBottom = maxSizeTop.with(undefined, anchorBox.top - info.verticalPadding);\r\n                minSize = minSize.with(maxSizeTop.width);\r\n            }\r\n        }\r\n        // top/bottom placement\r\n        let height = size.height;\r\n        let maxHeight = Math.max(maxSizeTop.height, maxSizeBottom.height);\r\n        if (height > maxHeight) {\r\n            height = maxHeight;\r\n        }\r\n        let maxSize;\r\n        if (height <= maxSizeTop.height) {\r\n            alignAtTop = true;\r\n            maxSize = maxSizeTop;\r\n        }\r\n        else {\r\n            alignAtTop = false;\r\n            maxSize = maxSizeBottom;\r\n        }\r\n        this._applyTopLeft({ left, top: alignAtTop ? top : bottom - height });\r\n        this.getDomNode().style.position = \'fixed\';\r\n        this._resizable.enableSashes(!alignAtTop, alignEast, alignAtTop, !alignEast);\r\n        this._resizable.minSize = minSize;\r\n        this._resizable.maxSize = maxSize;\r\n        this._resizable.layout(height, Math.min(maxSize.width, size.width));\r\n        this.widget.layout(this._resizable.size.width, this._resizable.size.height);\r\n    }\r\n    _applyTopLeft(topLeft) {\r\n        this._topLeft = topLeft;\r\n        this.getDomNode().style.left = `${this._topLeft.left}px`;\r\n        this.getDomNode().style.top = `${this._topLeft.top}px`;\r\n    }\r\n}\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestWidgetStatus.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar suggestWidgetStatus_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar suggestWidgetStatus_param = (undefined && undefined.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass suggestWidgetStatus_StatusBarViewItem extends menuEntryActionViewItem_MenuEntryActionViewItem {\r\n    updateLabel() {\r\n        const kb = this._keybindingService.lookupKeybinding(this._action.id, this._contextKeyService);\r\n        if (!kb) {\r\n            return super.updateLabel();\r\n        }\r\n        if (this.label) {\r\n            this.label.textContent = Object(nls["localize"])(\'ddd\', \'{0} ({1})\', this._action.label, suggestWidgetStatus_StatusBarViewItem.symbolPrintEnter(kb));\r\n        }\r\n    }\r\n    static symbolPrintEnter(kb) {\r\n        var _a;\r\n        return (_a = kb.getLabel()) === null || _a === void 0 ? void 0 : _a.replace(/\\benter\\b/gi, \'\\u23CE\');\r\n    }\r\n}\r\nlet suggestWidgetStatus_SuggestWidgetStatus = class SuggestWidgetStatus {\r\n    constructor(container, instantiationService, _menuService, _contextKeyService) {\r\n        this._menuService = _menuService;\r\n        this._contextKeyService = _contextKeyService;\r\n        this._menuDisposables = new lifecycle["DisposableStore"]();\r\n        this.element = dom["append"](container, dom["$"](\'.suggest-status-bar\'));\r\n        const actionViewItemProvider = (action => {\r\n            return action instanceof actions_common_actions["MenuItemAction"] ? instantiationService.createInstance(suggestWidgetStatus_StatusBarViewItem, action, undefined) : undefined;\r\n        });\r\n        this._leftActions = new actionbar["ActionBar"](this.element, { actionViewItemProvider });\r\n        this._rightActions = new actionbar["ActionBar"](this.element, { actionViewItemProvider });\r\n        this._leftActions.domNode.classList.add(\'left\');\r\n        this._rightActions.domNode.classList.add(\'right\');\r\n    }\r\n    dispose() {\r\n        this._menuDisposables.dispose();\r\n        this.element.remove();\r\n    }\r\n    show() {\r\n        const menu = this._menuService.createMenu(suggestWidgetStatusbarMenu, this._contextKeyService);\r\n        const renderMenu = () => {\r\n            const left = [];\r\n            const right = [];\r\n            for (let [group, actions] of menu.getActions()) {\r\n                if (group === \'left\') {\r\n                    left.push(...actions);\r\n                }\r\n                else {\r\n                    right.push(...actions);\r\n                }\r\n            }\r\n            this._leftActions.clear();\r\n            this._leftActions.push(left);\r\n            this._rightActions.clear();\r\n            this._rightActions.push(right);\r\n        };\r\n        this._menuDisposables.add(menu.onDidChange(() => renderMenu()));\r\n        this._menuDisposables.add(menu);\r\n    }\r\n    hide() {\r\n        this._menuDisposables.clear();\r\n    }\r\n};\r\nsuggestWidgetStatus_SuggestWidgetStatus = suggestWidgetStatus_decorate([\r\n    suggestWidgetStatus_param(1, instantiation["IInstantiationService"]),\r\n    suggestWidgetStatus_param(2, actions_common_actions["IMenuService"]),\r\n    suggestWidgetStatus_param(3, contextkey["IContextKeyService"])\r\n], suggestWidgetStatus_SuggestWidgetStatus);\r\n\r\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/browser/ui/iconLabel/iconLabel.js + 1 modules\nvar iconLabel = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/browser/ui/iconLabel/iconLabel.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/modes/modesRegistry.js\nvar modesRegistry = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/common/modes/modesRegistry.js");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/platform/files/common/files.js\n//#endregion\r\n//#region Utilities\r\nvar FileKind;\r\n(function (FileKind) {\r\n    FileKind[FileKind["FILE"] = 0] = "FILE";\r\n    FileKind[FileKind["FOLDER"] = 1] = "FOLDER";\r\n    FileKind[FileKind["ROOT_FOLDER"] = 2] = "ROOT_FOLDER";\r\n})(FileKind || (FileKind = {}));\r\n//#endregion\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/services/getIconClasses.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\n\r\nfunction getIconClasses(modelService, modeService, resource, fileKind) {\r\n    // we always set these base classes even if we do not have a path\r\n    const classes = fileKind === FileKind.ROOT_FOLDER ? [\'rootfolder-icon\'] : fileKind === FileKind.FOLDER ? [\'folder-icon\'] : [\'file-icon\'];\r\n    if (resource) {\r\n        // Get the path and name of the resource. For data-URIs, we need to parse specially\r\n        let name;\r\n        if (resource.scheme === network["Schemas"].data) {\r\n            const metadata = common_resources["DataUri"].parseMetaData(resource);\r\n            name = metadata.get(common_resources["DataUri"].META_DATA_LABEL);\r\n        }\r\n        else {\r\n            name = cssEscape(Object(common_resources["basenameOrAuthority"])(resource).toLowerCase());\r\n        }\r\n        // Folders\r\n        if (fileKind === FileKind.FOLDER) {\r\n            classes.push(`${name}-name-folder-icon`);\r\n        }\r\n        // Files\r\n        else {\r\n            // Name & Extension(s)\r\n            if (name) {\r\n                classes.push(`${name}-name-file-icon`);\r\n                // Avoid doing an explosive combination of extensions for very long filenames\r\n                // (most file systems do not allow files > 255 length) with lots of `.` characters\r\n                // https://github.com/microsoft/vscode/issues/116199\r\n                if (name.length <= 255) {\r\n                    const dotSegments = name.split(\'.\');\r\n                    for (let i = 1; i < dotSegments.length; i++) {\r\n                        classes.push(`${dotSegments.slice(i).join(\'.\')}-ext-file-icon`); // add each combination of all found extensions if more than one\r\n                    }\r\n                }\r\n                classes.push(`ext-file-icon`); // extra segment to increase file-ext score\r\n            }\r\n            // Detected Mode\r\n            const detectedModeId = detectModeId(modelService, modeService, resource);\r\n            if (detectedModeId) {\r\n                classes.push(`${cssEscape(detectedModeId)}-lang-file-icon`);\r\n            }\r\n        }\r\n    }\r\n    return classes;\r\n}\r\nfunction detectModeId(modelService, modeService, resource) {\r\n    if (!resource) {\r\n        return null; // we need a resource at least\r\n    }\r\n    let modeId = null;\r\n    // Data URI: check for encoded metadata\r\n    if (resource.scheme === network["Schemas"].data) {\r\n        const metadata = common_resources["DataUri"].parseMetaData(resource);\r\n        const mime = metadata.get(common_resources["DataUri"].META_DATA_MIME);\r\n        if (mime) {\r\n            modeId = modeService.getModeId(mime);\r\n        }\r\n    }\r\n    // Any other URI: check for model if existing\r\n    else {\r\n        const model = modelService.getModel(resource);\r\n        if (model) {\r\n            modeId = model.getModeId();\r\n        }\r\n    }\r\n    // only take if the mode is specific (aka no just plain text)\r\n    if (modeId && modeId !== modesRegistry["PLAINTEXT_MODE_ID"]) {\r\n        return modeId;\r\n    }\r\n    // otherwise fallback to path based detection\r\n    return modeService.getModeIdByFilepathOrFirstLine(resource);\r\n}\r\nfunction cssEscape(str) {\r\n    return str.replace(/[\\11\\12\\14\\15\\40]/g, \'/\'); // HTML class names can not contain certain whitespace characters, use / instead, which doesn\'t exist in file names.\r\n}\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestWidgetRenderer.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar suggestWidgetRenderer_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar suggestWidgetRenderer_param = (undefined && undefined.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nvar suggestWidgetRenderer_a;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction getAriaId(index) {\r\n    return `suggest-aria-id:${index}`;\r\n}\r\nconst suggestMoreInfoIcon = Object(iconRegistry["registerIcon"])(\'suggest-more-info\', codicons["Codicon"].chevronRight, nls["localize"](\'suggestMoreInfoIcon\', \'Icon for more information in the suggest widget.\'));\r\nconst _completionItemColor = new (suggestWidgetRenderer_a = class ColorExtractor {\r\n        extract(item, out) {\r\n            if (item.textLabel.match(ColorExtractor._regexStrict)) {\r\n                out[0] = item.textLabel;\r\n                return true;\r\n            }\r\n            if (item.completion.detail && item.completion.detail.match(ColorExtractor._regexStrict)) {\r\n                out[0] = item.completion.detail;\r\n                return true;\r\n            }\r\n            if (typeof item.completion.documentation === \'string\') {\r\n                const match = ColorExtractor._regexRelaxed.exec(item.completion.documentation);\r\n                if (match && (match.index === 0 || match.index + match[0].length === item.completion.documentation.length)) {\r\n                    out[0] = match[0];\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n    },\r\n    suggestWidgetRenderer_a._regexRelaxed = /(#([\\da-fA-F]{3}){1,2}|(rgb|hsl)a\\(\\s*(\\d{1,3}%?\\s*,\\s*){3}(1|0?\\.\\d+)\\)|(rgb|hsl)\\(\\s*\\d{1,3}%?(\\s*,\\s*\\d{1,3}%?){2}\\s*\\))/,\r\n    suggestWidgetRenderer_a._regexStrict = new RegExp(`^${suggestWidgetRenderer_a._regexRelaxed.source}$`, \'i\'),\r\n    suggestWidgetRenderer_a);\r\nlet suggestWidgetRenderer_ItemRenderer = class ItemRenderer {\r\n    constructor(_editor, _modelService, _modeService, _themeService) {\r\n        this._editor = _editor;\r\n        this._modelService = _modelService;\r\n        this._modeService = _modeService;\r\n        this._themeService = _themeService;\r\n        this._onDidToggleDetails = new common_event["Emitter"]();\r\n        this.onDidToggleDetails = this._onDidToggleDetails.event;\r\n        this.templateId = \'suggestion\';\r\n    }\r\n    dispose() {\r\n        this._onDidToggleDetails.dispose();\r\n    }\r\n    renderTemplate(container) {\r\n        const data = Object.create(null);\r\n        data.disposables = new lifecycle["DisposableStore"]();\r\n        data.root = container;\r\n        data.root.classList.add(\'show-file-icons\');\r\n        data.icon = Object(dom["append"])(container, Object(dom["$"])(\'.icon\'));\r\n        data.colorspan = Object(dom["append"])(data.icon, Object(dom["$"])(\'span.colorspan\'));\r\n        const text = Object(dom["append"])(container, Object(dom["$"])(\'.contents\'));\r\n        const main = Object(dom["append"])(text, Object(dom["$"])(\'.main\'));\r\n        data.iconContainer = Object(dom["append"])(main, Object(dom["$"])(\'.icon-label.codicon\'));\r\n        data.left = Object(dom["append"])(main, Object(dom["$"])(\'span.left\'));\r\n        data.right = Object(dom["append"])(main, Object(dom["$"])(\'span.right\'));\r\n        data.iconLabel = new iconLabel["IconLabel"](data.left, { supportHighlights: true, supportIcons: true });\r\n        data.disposables.add(data.iconLabel);\r\n        data.parametersLabel = Object(dom["append"])(data.left, Object(dom["$"])(\'span.signature-label\'));\r\n        data.qualifierLabel = Object(dom["append"])(data.left, Object(dom["$"])(\'span.qualifier-label\'));\r\n        data.detailsLabel = Object(dom["append"])(data.right, Object(dom["$"])(\'span.details-label\'));\r\n        data.readMore = Object(dom["append"])(data.right, Object(dom["$"])(\'span.readMore\' + common_themeService["ThemeIcon"].asCSSSelector(suggestMoreInfoIcon)));\r\n        data.readMore.title = nls["localize"](\'readMore\', "Read More");\r\n        const configureFont = () => {\r\n            const options = this._editor.getOptions();\r\n            const fontInfo = options.get(42 /* fontInfo */);\r\n            const fontFamily = fontInfo.fontFamily;\r\n            const fontFeatureSettings = fontInfo.fontFeatureSettings;\r\n            const fontSize = options.get(107 /* suggestFontSize */) || fontInfo.fontSize;\r\n            const lineHeight = options.get(108 /* suggestLineHeight */) || fontInfo.lineHeight;\r\n            const fontWeight = fontInfo.fontWeight;\r\n            const fontSizePx = `${fontSize}px`;\r\n            const lineHeightPx = `${lineHeight}px`;\r\n            data.root.style.fontSize = fontSizePx;\r\n            data.root.style.fontWeight = fontWeight;\r\n            main.style.fontFamily = fontFamily;\r\n            main.style.fontFeatureSettings = fontFeatureSettings;\r\n            main.style.lineHeight = lineHeightPx;\r\n            data.icon.style.height = lineHeightPx;\r\n            data.icon.style.width = lineHeightPx;\r\n            data.readMore.style.height = lineHeightPx;\r\n            data.readMore.style.width = lineHeightPx;\r\n        };\r\n        configureFont();\r\n        data.disposables.add(this._editor.onDidChangeConfiguration(e => {\r\n            if (e.hasChanged(42 /* fontInfo */) || e.hasChanged(107 /* suggestFontSize */) || e.hasChanged(108 /* suggestLineHeight */)) {\r\n                configureFont();\r\n            }\r\n        }));\r\n        return data;\r\n    }\r\n    renderElement(element, index, data) {\r\n        const { completion } = element;\r\n        data.root.id = getAriaId(index);\r\n        data.colorspan.style.backgroundColor = \'\';\r\n        const labelOptions = {\r\n            labelEscapeNewLines: true,\r\n            matches: Object(filters["createMatches"])(element.score)\r\n        };\r\n        let color = [];\r\n        if (completion.kind === 19 /* Color */ && _completionItemColor.extract(element, color)) {\r\n            // special logic for \'color\' completion items\r\n            data.icon.className = \'icon customcolor\';\r\n            data.iconContainer.className = \'icon hide\';\r\n            data.colorspan.style.backgroundColor = color[0];\r\n        }\r\n        else if (completion.kind === 20 /* File */ && this._themeService.getFileIconTheme().hasFileIcons) {\r\n            // special logic for \'file\' completion items\r\n            data.icon.className = \'icon hide\';\r\n            data.iconContainer.className = \'icon hide\';\r\n            const labelClasses = getIconClasses(this._modelService, this._modeService, common_uri["URI"].from({ scheme: \'fake\', path: element.textLabel }), FileKind.FILE);\r\n            const detailClasses = getIconClasses(this._modelService, this._modeService, common_uri["URI"].from({ scheme: \'fake\', path: completion.detail }), FileKind.FILE);\r\n            labelOptions.extraClasses = labelClasses.length > detailClasses.length ? labelClasses : detailClasses;\r\n        }\r\n        else if (completion.kind === 23 /* Folder */ && this._themeService.getFileIconTheme().hasFolderIcons) {\r\n            // special logic for \'folder\' completion items\r\n            data.icon.className = \'icon hide\';\r\n            data.iconContainer.className = \'icon hide\';\r\n            labelOptions.extraClasses = Object(arrays["flatten"])([\r\n                getIconClasses(this._modelService, this._modeService, common_uri["URI"].from({ scheme: \'fake\', path: element.textLabel }), FileKind.FOLDER),\r\n                getIconClasses(this._modelService, this._modeService, common_uri["URI"].from({ scheme: \'fake\', path: completion.detail }), FileKind.FOLDER)\r\n            ]);\r\n        }\r\n        else {\r\n            // normal icon\r\n            data.icon.className = \'icon hide\';\r\n            data.iconContainer.className = \'\';\r\n            data.iconContainer.classList.add(\'suggest-icon\', ...Object(modes["completionKindToCssClass"])(completion.kind).split(\' \'));\r\n        }\r\n        if (completion.tags && completion.tags.indexOf(1 /* Deprecated */) >= 0) {\r\n            labelOptions.extraClasses = (labelOptions.extraClasses || []).concat([\'deprecated\']);\r\n            labelOptions.matches = [];\r\n        }\r\n        data.iconLabel.setLabel(element.textLabel, undefined, labelOptions);\r\n        if (typeof completion.label === \'string\') {\r\n            data.parametersLabel.textContent = \'\';\r\n            data.detailsLabel.textContent = stripNewLines(completion.detail || \'\');\r\n            data.root.classList.add(\'string-label\');\r\n        }\r\n        else {\r\n            data.parametersLabel.textContent = stripNewLines(completion.label.detail || \'\');\r\n            data.detailsLabel.textContent = stripNewLines(completion.label.description || \'\');\r\n            data.root.classList.remove(\'string-label\');\r\n        }\r\n        if (this._editor.getOption(106 /* suggest */).showInlineDetails) {\r\n            Object(dom["show"])(data.detailsLabel);\r\n        }\r\n        else {\r\n            Object(dom["hide"])(data.detailsLabel);\r\n        }\r\n        if (canExpandCompletionItem(element)) {\r\n            data.right.classList.add(\'can-expand-details\');\r\n            Object(dom["show"])(data.readMore);\r\n            data.readMore.onmousedown = e => {\r\n                e.stopPropagation();\r\n                e.preventDefault();\r\n            };\r\n            data.readMore.onclick = e => {\r\n                e.stopPropagation();\r\n                e.preventDefault();\r\n                this._onDidToggleDetails.fire();\r\n            };\r\n        }\r\n        else {\r\n            data.right.classList.remove(\'can-expand-details\');\r\n            Object(dom["hide"])(data.readMore);\r\n            data.readMore.onmousedown = null;\r\n            data.readMore.onclick = null;\r\n        }\r\n    }\r\n    disposeTemplate(templateData) {\r\n        templateData.disposables.dispose();\r\n    }\r\n};\r\nsuggestWidgetRenderer_ItemRenderer = suggestWidgetRenderer_decorate([\r\n    suggestWidgetRenderer_param(1, services_modelService["IModelService"]),\r\n    suggestWidgetRenderer_param(2, services_modeService["IModeService"]),\r\n    suggestWidgetRenderer_param(3, common_themeService["IThemeService"])\r\n], suggestWidgetRenderer_ItemRenderer);\r\n\r\nfunction stripNewLines(str) {\r\n    return str.replace(/\\r\\n|\\r|\\n/g, \'\');\r\n}\r\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/common/numbers.js\nvar numbers = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/common/numbers.js");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestWidget.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar suggestWidget_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar suggestWidget_param = (undefined && undefined.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nvar suggestWidget_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n // The codicon symbol styles are defined here and must be loaded\r\n // The codicon symbol colors are defined here and must be loaded to get colors\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Suggest widget colors\r\n */\r\nconst editorSuggestWidgetBackground = Object(colorRegistry["registerColor"])(\'editorSuggestWidget.background\', { dark: colorRegistry["editorWidgetBackground"], light: colorRegistry["editorWidgetBackground"], hc: colorRegistry["editorWidgetBackground"] }, nls["localize"](\'editorSuggestWidgetBackground\', \'Background color of the suggest widget.\'));\r\nconst editorSuggestWidgetBorder = Object(colorRegistry["registerColor"])(\'editorSuggestWidget.border\', { dark: colorRegistry["editorWidgetBorder"], light: colorRegistry["editorWidgetBorder"], hc: colorRegistry["editorWidgetBorder"] }, nls["localize"](\'editorSuggestWidgetBorder\', \'Border color of the suggest widget.\'));\r\nconst editorSuggestWidgetForeground = Object(colorRegistry["registerColor"])(\'editorSuggestWidget.foreground\', { dark: colorRegistry["editorForeground"], light: colorRegistry["editorForeground"], hc: colorRegistry["editorForeground"] }, nls["localize"](\'editorSuggestWidgetForeground\', \'Foreground color of the suggest widget.\'));\r\nconst editorSuggestWidgetSelectedForeground = Object(colorRegistry["registerColor"])(\'editorSuggestWidget.selectedForeground\', { dark: colorRegistry["quickInputListFocusForeground"], light: colorRegistry["quickInputListFocusForeground"], hc: colorRegistry["quickInputListFocusForeground"] }, nls["localize"](\'editorSuggestWidgetSelectedForeground\', \'Foreground color of the selected entry in the suggest widget.\'));\r\nconst editorSuggestWidgetSelectedIconForeground = Object(colorRegistry["registerColor"])(\'editorSuggestWidget.selectedIconForeground\', { dark: colorRegistry["quickInputListFocusIconForeground"], light: colorRegistry["quickInputListFocusIconForeground"], hc: colorRegistry["quickInputListFocusIconForeground"] }, nls["localize"](\'editorSuggestWidgetSelectedIconForeground\', \'Icon foreground color of the selected entry in the suggest widget.\'));\r\nconst editorSuggestWidgetSelectedBackground = Object(colorRegistry["registerColor"])(\'editorSuggestWidget.selectedBackground\', { dark: colorRegistry["quickInputListFocusBackground"], light: colorRegistry["quickInputListFocusBackground"], hc: colorRegistry["quickInputListFocusBackground"] }, nls["localize"](\'editorSuggestWidgetSelectedBackground\', \'Background color of the selected entry in the suggest widget.\'));\r\nconst editorSuggestWidgetHighlightForeground = Object(colorRegistry["registerColor"])(\'editorSuggestWidget.highlightForeground\', { dark: colorRegistry["listHighlightForeground"], light: colorRegistry["listHighlightForeground"], hc: colorRegistry["listHighlightForeground"] }, nls["localize"](\'editorSuggestWidgetHighlightForeground\', \'Color of the match highlights in the suggest widget.\'));\r\nconst editorSuggestWidgetHighlightFocusForeground = Object(colorRegistry["registerColor"])(\'editorSuggestWidget.focusHighlightForeground\', { dark: colorRegistry["listFocusHighlightForeground"], light: colorRegistry["listFocusHighlightForeground"], hc: colorRegistry["listFocusHighlightForeground"] }, nls["localize"](\'editorSuggestWidgetFocusHighlightForeground\', \'Color of the match highlights in the suggest widget when an item is focused.\'));\r\nclass suggestWidget_PersistedWidgetSize {\r\n    constructor(_service, editor) {\r\n        this._service = _service;\r\n        this._key = `suggestWidget.size/${editor.getEditorType()}/${editor instanceof embeddedCodeEditorWidget_EmbeddedCodeEditorWidget}`;\r\n    }\r\n    restore() {\r\n        var _a;\r\n        const raw = (_a = this._service.get(this._key, 0 /* GLOBAL */)) !== null && _a !== void 0 ? _a : \'\';\r\n        try {\r\n            const obj = JSON.parse(raw);\r\n            if (dom["Dimension"].is(obj)) {\r\n                return dom["Dimension"].lift(obj);\r\n            }\r\n        }\r\n        catch (_b) {\r\n            // ignore\r\n        }\r\n        return undefined;\r\n    }\r\n    store(size) {\r\n        this._service.store(this._key, JSON.stringify(size), 0 /* GLOBAL */, 1 /* MACHINE */);\r\n    }\r\n    reset() {\r\n        this._service.remove(this._key, 0 /* GLOBAL */);\r\n    }\r\n}\r\nlet suggestWidget_SuggestWidget = class SuggestWidget {\r\n    constructor(editor, _storageService, _contextKeyService, _themeService, instantiationService) {\r\n        this.editor = editor;\r\n        this._storageService = _storageService;\r\n        this._state = 0 /* Hidden */;\r\n        this._isAuto = false;\r\n        this._ignoreFocusEvents = false;\r\n        this._forceRenderingAbove = false;\r\n        this._explainMode = false;\r\n        this._showTimeout = new common_async["TimeoutTimer"]();\r\n        this._disposables = new lifecycle["DisposableStore"]();\r\n        this._onDidSelect = new common_event["Emitter"]();\r\n        this._onDidFocus = new common_event["Emitter"]();\r\n        this._onDidHide = new common_event["Emitter"]();\r\n        this._onDidShow = new common_event["Emitter"]();\r\n        this.onDidSelect = this._onDidSelect.event;\r\n        this.onDidFocus = this._onDidFocus.event;\r\n        this.onDidHide = this._onDidHide.event;\r\n        this.onDidShow = this._onDidShow.event;\r\n        this._onDetailsKeydown = new common_event["Emitter"]();\r\n        this.onDetailsKeyDown = this._onDetailsKeydown.event;\r\n        this.element = new resizable_ResizableHTMLElement();\r\n        this.element.domNode.classList.add(\'editor-widget\', \'suggest-widget\');\r\n        this._contentWidget = new suggestWidget_SuggestContentWidget(this, editor);\r\n        this._persistedSize = new suggestWidget_PersistedWidgetSize(_storageService, editor);\r\n        class ResizeState {\r\n            constructor(persistedSize, currentSize, persistHeight = false, persistWidth = false) {\r\n                this.persistedSize = persistedSize;\r\n                this.currentSize = currentSize;\r\n                this.persistHeight = persistHeight;\r\n                this.persistWidth = persistWidth;\r\n            }\r\n        }\r\n        let state;\r\n        this._disposables.add(this.element.onDidWillResize(() => {\r\n            this._contentWidget.lockPreference();\r\n            state = new ResizeState(this._persistedSize.restore(), this.element.size);\r\n        }));\r\n        this._disposables.add(this.element.onDidResize(e => {\r\n            var _a, _b, _c, _d;\r\n            this._resize(e.dimension.width, e.dimension.height);\r\n            if (state) {\r\n                state.persistHeight = state.persistHeight || !!e.north || !!e.south;\r\n                state.persistWidth = state.persistWidth || !!e.east || !!e.west;\r\n            }\r\n            if (!e.done) {\r\n                return;\r\n            }\r\n            if (state) {\r\n                // only store width or height value that have changed and also\r\n                // only store changes that are above a certain threshold\r\n                const { itemHeight, defaultSize } = this.getLayoutInfo();\r\n                const threshold = Math.round(itemHeight / 2);\r\n                let { width, height } = this.element.size;\r\n                if (!state.persistHeight || Math.abs(state.currentSize.height - height) <= threshold) {\r\n                    height = (_b = (_a = state.persistedSize) === null || _a === void 0 ? void 0 : _a.height) !== null && _b !== void 0 ? _b : defaultSize.height;\r\n                }\r\n                if (!state.persistWidth || Math.abs(state.currentSize.width - width) <= threshold) {\r\n                    width = (_d = (_c = state.persistedSize) === null || _c === void 0 ? void 0 : _c.width) !== null && _d !== void 0 ? _d : defaultSize.width;\r\n                }\r\n                this._persistedSize.store(new dom["Dimension"](width, height));\r\n            }\r\n            // reset working state\r\n            this._contentWidget.unlockPreference();\r\n            state = undefined;\r\n        }));\r\n        this._messageElement = dom["append"](this.element.domNode, dom["$"](\'.message\'));\r\n        this._listElement = dom["append"](this.element.domNode, dom["$"](\'.tree\'));\r\n        const details = instantiationService.createInstance(suggestWidgetDetails_SuggestDetailsWidget, this.editor);\r\n        details.onDidClose(this.toggleDetails, this, this._disposables);\r\n        this._details = new suggestWidgetDetails_SuggestDetailsOverlay(details, this.editor);\r\n        const applyIconStyle = () => this.element.domNode.classList.toggle(\'no-icons\', !this.editor.getOption(106 /* suggest */).showIcons);\r\n        applyIconStyle();\r\n        const renderer = instantiationService.createInstance(suggestWidgetRenderer_ItemRenderer, this.editor);\r\n        this._disposables.add(renderer);\r\n        this._disposables.add(renderer.onDidToggleDetails(() => this.toggleDetails()));\r\n        this._list = new listWidget["List"](\'SuggestWidget\', this._listElement, {\r\n            getHeight: (_element) => this.getLayoutInfo().itemHeight,\r\n            getTemplateId: (_element) => \'suggestion\'\r\n        }, [renderer], {\r\n            alwaysConsumeMouseWheel: true,\r\n            useShadows: false,\r\n            mouseSupport: false,\r\n            accessibilityProvider: {\r\n                getRole: () => \'option\',\r\n                getAriaLabel: (item) => {\r\n                    if (item.isResolved && this._isDetailsVisible()) {\r\n                        const { documentation, detail } = item.completion;\r\n                        const docs = strings["format"](\'{0}{1}\', detail || \'\', documentation ? (typeof documentation === \'string\' ? documentation : documentation.value) : \'\');\r\n                        return nls["localize"](\'ariaCurrenttSuggestionReadDetails\', "{0}, docs: {1}", item.textLabel, docs);\r\n                    }\r\n                    else {\r\n                        return item.textLabel;\r\n                    }\r\n                },\r\n                getWidgetAriaLabel: () => nls["localize"](\'suggest\', "Suggest"),\r\n                getWidgetRole: () => \'listbox\'\r\n            }\r\n        });\r\n        this._status = instantiationService.createInstance(suggestWidgetStatus_SuggestWidgetStatus, this.element.domNode);\r\n        const applyStatusBarStyle = () => this.element.domNode.classList.toggle(\'with-status-bar\', this.editor.getOption(106 /* suggest */).showStatusBar);\r\n        applyStatusBarStyle();\r\n        this._disposables.add(Object(styler["attachListStyler"])(this._list, _themeService, {\r\n            listInactiveFocusBackground: editorSuggestWidgetSelectedBackground,\r\n            listInactiveFocusOutline: colorRegistry["activeContrastBorder"]\r\n        }));\r\n        this._disposables.add(_themeService.onDidColorThemeChange(t => this._onThemeChange(t)));\r\n        this._onThemeChange(_themeService.getColorTheme());\r\n        this._disposables.add(this._list.onMouseDown(e => this._onListMouseDownOrTap(e)));\r\n        this._disposables.add(this._list.onTap(e => this._onListMouseDownOrTap(e)));\r\n        this._disposables.add(this._list.onDidChangeSelection(e => this._onListSelection(e)));\r\n        this._disposables.add(this._list.onDidChangeFocus(e => this._onListFocus(e)));\r\n        this._disposables.add(this.editor.onDidChangeCursorSelection(() => this._onCursorSelectionChanged()));\r\n        this._disposables.add(this.editor.onDidChangeConfiguration(e => {\r\n            if (e.hasChanged(106 /* suggest */)) {\r\n                applyStatusBarStyle();\r\n                applyIconStyle();\r\n            }\r\n        }));\r\n        this._ctxSuggestWidgetVisible = Context.Visible.bindTo(_contextKeyService);\r\n        this._ctxSuggestWidgetDetailsVisible = Context.DetailsVisible.bindTo(_contextKeyService);\r\n        this._ctxSuggestWidgetMultipleSuggestions = Context.MultipleSuggestions.bindTo(_contextKeyService);\r\n        this._disposables.add(dom["addStandardDisposableListener"](this._details.widget.domNode, \'keydown\', e => {\r\n            this._onDetailsKeydown.fire(e);\r\n        }));\r\n        this._disposables.add(this.editor.onMouseDown((e) => this._onEditorMouseDown(e)));\r\n    }\r\n    dispose() {\r\n        var _a;\r\n        this._details.widget.dispose();\r\n        this._details.dispose();\r\n        this._list.dispose();\r\n        this._status.dispose();\r\n        this._disposables.dispose();\r\n        (_a = this._loadingTimeout) === null || _a === void 0 ? void 0 : _a.dispose();\r\n        this._showTimeout.dispose();\r\n        this._contentWidget.dispose();\r\n        this.element.dispose();\r\n    }\r\n    _onEditorMouseDown(mouseEvent) {\r\n        if (this._details.widget.domNode.contains(mouseEvent.target.element)) {\r\n            // Clicking inside details\r\n            this._details.widget.domNode.focus();\r\n        }\r\n        else {\r\n            // Clicking outside details and inside suggest\r\n            if (this.element.domNode.contains(mouseEvent.target.element)) {\r\n                this.editor.focus();\r\n            }\r\n        }\r\n    }\r\n    _onCursorSelectionChanged() {\r\n        if (this._state !== 0 /* Hidden */) {\r\n            this._contentWidget.layout();\r\n        }\r\n    }\r\n    _onListMouseDownOrTap(e) {\r\n        if (typeof e.element === \'undefined\' || typeof e.index === \'undefined\') {\r\n            return;\r\n        }\r\n        // prevent stealing browser focus from the editor\r\n        e.browserEvent.preventDefault();\r\n        e.browserEvent.stopPropagation();\r\n        this._select(e.element, e.index);\r\n    }\r\n    _onListSelection(e) {\r\n        if (e.elements.length) {\r\n            this._select(e.elements[0], e.indexes[0]);\r\n        }\r\n    }\r\n    _select(item, index) {\r\n        const completionModel = this._completionModel;\r\n        if (completionModel) {\r\n            this._onDidSelect.fire({ item, index, model: completionModel });\r\n            this.editor.focus();\r\n        }\r\n    }\r\n    _onThemeChange(theme) {\r\n        const backgroundColor = theme.getColor(editorSuggestWidgetBackground);\r\n        if (backgroundColor) {\r\n            this.element.domNode.style.backgroundColor = backgroundColor.toString();\r\n            this._messageElement.style.backgroundColor = backgroundColor.toString();\r\n            this._details.widget.domNode.style.backgroundColor = backgroundColor.toString();\r\n        }\r\n        const borderColor = theme.getColor(editorSuggestWidgetBorder);\r\n        if (borderColor) {\r\n            this.element.domNode.style.borderColor = borderColor.toString();\r\n            this._messageElement.style.borderColor = borderColor.toString();\r\n            this._status.element.style.borderTopColor = borderColor.toString();\r\n            this._details.widget.domNode.style.borderColor = borderColor.toString();\r\n            this._detailsBorderColor = borderColor.toString();\r\n        }\r\n        const focusBorderColor = theme.getColor(colorRegistry["focusBorder"]);\r\n        if (focusBorderColor) {\r\n            this._detailsFocusBorderColor = focusBorderColor.toString();\r\n        }\r\n        this._details.widget.borderWidth = theme.type === \'hc\' ? 2 : 1;\r\n    }\r\n    _onListFocus(e) {\r\n        var _a;\r\n        if (this._ignoreFocusEvents) {\r\n            return;\r\n        }\r\n        if (!e.elements.length) {\r\n            if (this._currentSuggestionDetails) {\r\n                this._currentSuggestionDetails.cancel();\r\n                this._currentSuggestionDetails = undefined;\r\n                this._focusedItem = undefined;\r\n            }\r\n            this.editor.setAriaOptions({ activeDescendant: undefined });\r\n            return;\r\n        }\r\n        if (!this._completionModel) {\r\n            return;\r\n        }\r\n        const item = e.elements[0];\r\n        const index = e.indexes[0];\r\n        if (item !== this._focusedItem) {\r\n            (_a = this._currentSuggestionDetails) === null || _a === void 0 ? void 0 : _a.cancel();\r\n            this._currentSuggestionDetails = undefined;\r\n            this._focusedItem = item;\r\n            this._list.reveal(index);\r\n            this._currentSuggestionDetails = Object(common_async["createCancelablePromise"])((token) => suggestWidget_awaiter(this, void 0, void 0, function* () {\r\n                const loading = Object(common_async["disposableTimeout"])(() => {\r\n                    if (this._isDetailsVisible()) {\r\n                        this.showDetails(true);\r\n                    }\r\n                }, 250);\r\n                token.onCancellationRequested(() => loading.dispose());\r\n                const result = yield item.resolve(token);\r\n                loading.dispose();\r\n                return result;\r\n            }));\r\n            this._currentSuggestionDetails.then(() => {\r\n                if (index >= this._list.length || item !== this._list.element(index)) {\r\n                    return;\r\n                }\r\n                // item can have extra information, so re-render\r\n                this._ignoreFocusEvents = true;\r\n                this._list.splice(index, 1, [item]);\r\n                this._list.setFocus([index]);\r\n                this._ignoreFocusEvents = false;\r\n                if (this._isDetailsVisible()) {\r\n                    this.showDetails(false);\r\n                }\r\n                else {\r\n                    this.element.domNode.classList.remove(\'docs-side\');\r\n                }\r\n                this.editor.setAriaOptions({ activeDescendant: getAriaId(index) });\r\n            }).catch(errors["onUnexpectedError"]);\r\n        }\r\n        // emit an event\r\n        this._onDidFocus.fire({ item, index, model: this._completionModel });\r\n    }\r\n    _setState(state) {\r\n        if (this._state === state) {\r\n            return;\r\n        }\r\n        this._state = state;\r\n        this.element.domNode.classList.toggle(\'frozen\', state === 4 /* Frozen */);\r\n        this.element.domNode.classList.remove(\'message\');\r\n        switch (state) {\r\n            case 0 /* Hidden */:\r\n                dom["hide"](this._messageElement, this._listElement, this._status.element);\r\n                this._details.hide(true);\r\n                this._status.hide();\r\n                this._contentWidget.hide();\r\n                this._ctxSuggestWidgetVisible.reset();\r\n                this._ctxSuggestWidgetMultipleSuggestions.reset();\r\n                this._showTimeout.cancel();\r\n                this.element.domNode.classList.remove(\'visible\');\r\n                this._list.splice(0, this._list.length);\r\n                this._focusedItem = undefined;\r\n                this._cappedHeight = undefined;\r\n                this._explainMode = false;\r\n                break;\r\n            case 1 /* Loading */:\r\n                this.element.domNode.classList.add(\'message\');\r\n                this._messageElement.textContent = SuggestWidget.LOADING_MESSAGE;\r\n                dom["hide"](this._listElement, this._status.element);\r\n                dom["show"](this._messageElement);\r\n                this._details.hide();\r\n                this._show();\r\n                this._focusedItem = undefined;\r\n                break;\r\n            case 2 /* Empty */:\r\n                this.element.domNode.classList.add(\'message\');\r\n                this._messageElement.textContent = SuggestWidget.NO_SUGGESTIONS_MESSAGE;\r\n                dom["hide"](this._listElement, this._status.element);\r\n                dom["show"](this._messageElement);\r\n                this._details.hide();\r\n                this._show();\r\n                this._focusedItem = undefined;\r\n                break;\r\n            case 3 /* Open */:\r\n                dom["hide"](this._messageElement);\r\n                dom["show"](this._listElement, this._status.element);\r\n                this._show();\r\n                break;\r\n            case 4 /* Frozen */:\r\n                dom["hide"](this._messageElement);\r\n                dom["show"](this._listElement, this._status.element);\r\n                this._show();\r\n                break;\r\n            case 5 /* Details */:\r\n                dom["hide"](this._messageElement);\r\n                dom["show"](this._listElement, this._status.element);\r\n                this._details.show();\r\n                this._show();\r\n                break;\r\n        }\r\n    }\r\n    _show() {\r\n        this._status.show();\r\n        this._contentWidget.show();\r\n        this._layout(this._persistedSize.restore());\r\n        this._ctxSuggestWidgetVisible.set(true);\r\n        this._showTimeout.cancelAndSet(() => {\r\n            this.element.domNode.classList.add(\'visible\');\r\n            this._onDidShow.fire(this);\r\n        }, 100);\r\n    }\r\n    showTriggered(auto, delay) {\r\n        if (this._state !== 0 /* Hidden */) {\r\n            return;\r\n        }\r\n        this._contentWidget.setPosition(this.editor.getPosition());\r\n        this._isAuto = !!auto;\r\n        if (!this._isAuto) {\r\n            this._loadingTimeout = Object(common_async["disposableTimeout"])(() => this._setState(1 /* Loading */), delay);\r\n        }\r\n    }\r\n    showSuggestions(completionModel, selectionIndex, isFrozen, isAuto) {\r\n        var _a, _b;\r\n        this._contentWidget.setPosition(this.editor.getPosition());\r\n        (_a = this._loadingTimeout) === null || _a === void 0 ? void 0 : _a.dispose();\r\n        (_b = this._currentSuggestionDetails) === null || _b === void 0 ? void 0 : _b.cancel();\r\n        this._currentSuggestionDetails = undefined;\r\n        if (this._completionModel !== completionModel) {\r\n            this._completionModel = completionModel;\r\n        }\r\n        if (isFrozen && this._state !== 2 /* Empty */ && this._state !== 0 /* Hidden */) {\r\n            this._setState(4 /* Frozen */);\r\n            return;\r\n        }\r\n        const visibleCount = this._completionModel.items.length;\r\n        const isEmpty = visibleCount === 0;\r\n        this._ctxSuggestWidgetMultipleSuggestions.set(visibleCount > 1);\r\n        if (isEmpty) {\r\n            this._setState(isAuto ? 0 /* Hidden */ : 2 /* Empty */);\r\n            this._completionModel = undefined;\r\n            return;\r\n        }\r\n        this._focusedItem = undefined;\r\n        this._list.splice(0, this._list.length, this._completionModel.items);\r\n        this._setState(isFrozen ? 4 /* Frozen */ : 3 /* Open */);\r\n        this._list.reveal(selectionIndex, 0);\r\n        this._list.setFocus([selectionIndex]);\r\n        this._layout(this.element.size);\r\n        // Reset focus border\r\n        if (this._detailsBorderColor) {\r\n            this._details.widget.domNode.style.borderColor = this._detailsBorderColor;\r\n        }\r\n    }\r\n    selectNextPage() {\r\n        switch (this._state) {\r\n            case 0 /* Hidden */:\r\n                return false;\r\n            case 5 /* Details */:\r\n                this._details.widget.pageDown();\r\n                return true;\r\n            case 1 /* Loading */:\r\n                return !this._isAuto;\r\n            default:\r\n                this._list.focusNextPage();\r\n                return true;\r\n        }\r\n    }\r\n    selectNext() {\r\n        switch (this._state) {\r\n            case 0 /* Hidden */:\r\n                return false;\r\n            case 1 /* Loading */:\r\n                return !this._isAuto;\r\n            default:\r\n                this._list.focusNext(1, true);\r\n                return true;\r\n        }\r\n    }\r\n    selectLast() {\r\n        switch (this._state) {\r\n            case 0 /* Hidden */:\r\n                return false;\r\n            case 5 /* Details */:\r\n                this._details.widget.scrollBottom();\r\n                return true;\r\n            case 1 /* Loading */:\r\n                return !this._isAuto;\r\n            default:\r\n                this._list.focusLast();\r\n                return true;\r\n        }\r\n    }\r\n    selectPreviousPage() {\r\n        switch (this._state) {\r\n            case 0 /* Hidden */:\r\n                return false;\r\n            case 5 /* Details */:\r\n                this._details.widget.pageUp();\r\n                return true;\r\n            case 1 /* Loading */:\r\n                return !this._isAuto;\r\n            default:\r\n                this._list.focusPreviousPage();\r\n                return true;\r\n        }\r\n    }\r\n    selectPrevious() {\r\n        switch (this._state) {\r\n            case 0 /* Hidden */:\r\n                return false;\r\n            case 1 /* Loading */:\r\n                return !this._isAuto;\r\n            default:\r\n                this._list.focusPrevious(1, true);\r\n                return false;\r\n        }\r\n    }\r\n    selectFirst() {\r\n        switch (this._state) {\r\n            case 0 /* Hidden */:\r\n                return false;\r\n            case 5 /* Details */:\r\n                this._details.widget.scrollTop();\r\n                return true;\r\n            case 1 /* Loading */:\r\n                return !this._isAuto;\r\n            default:\r\n                this._list.focusFirst();\r\n                return true;\r\n        }\r\n    }\r\n    getFocusedItem() {\r\n        if (this._state !== 0 /* Hidden */\r\n            && this._state !== 2 /* Empty */\r\n            && this._state !== 1 /* Loading */\r\n            && this._completionModel) {\r\n            return {\r\n                item: this._list.getFocusedElements()[0],\r\n                index: this._list.getFocus()[0],\r\n                model: this._completionModel\r\n            };\r\n        }\r\n        return undefined;\r\n    }\r\n    toggleDetailsFocus() {\r\n        if (this._state === 5 /* Details */) {\r\n            this._setState(3 /* Open */);\r\n            if (this._detailsBorderColor) {\r\n                this._details.widget.domNode.style.borderColor = this._detailsBorderColor;\r\n            }\r\n        }\r\n        else if (this._state === 3 /* Open */ && this._isDetailsVisible()) {\r\n            this._setState(5 /* Details */);\r\n            if (this._detailsFocusBorderColor) {\r\n                this._details.widget.domNode.style.borderColor = this._detailsFocusBorderColor;\r\n            }\r\n        }\r\n    }\r\n    toggleDetails() {\r\n        if (this._isDetailsVisible()) {\r\n            // hide details widget\r\n            this._ctxSuggestWidgetDetailsVisible.set(false);\r\n            this._setDetailsVisible(false);\r\n            this._details.hide();\r\n            this.element.domNode.classList.remove(\'shows-details\');\r\n        }\r\n        else if ((canExpandCompletionItem(this._list.getFocusedElements()[0]) || this._explainMode) && (this._state === 3 /* Open */ || this._state === 5 /* Details */ || this._state === 4 /* Frozen */)) {\r\n            // show details widget (iff possible)\r\n            this._ctxSuggestWidgetDetailsVisible.set(true);\r\n            this._setDetailsVisible(true);\r\n            this.showDetails(false);\r\n        }\r\n    }\r\n    showDetails(loading) {\r\n        this._details.show();\r\n        if (loading) {\r\n            this._details.widget.renderLoading();\r\n        }\r\n        else {\r\n            this._details.widget.renderItem(this._list.getFocusedElements()[0], this._explainMode);\r\n        }\r\n        this._positionDetails();\r\n        this.editor.focus();\r\n        this.element.domNode.classList.add(\'shows-details\');\r\n    }\r\n    toggleExplainMode() {\r\n        if (this._list.getFocusedElements()[0]) {\r\n            this._explainMode = !this._explainMode;\r\n            if (!this._isDetailsVisible()) {\r\n                this.toggleDetails();\r\n            }\r\n            else {\r\n                this.showDetails(false);\r\n            }\r\n        }\r\n    }\r\n    resetPersistedSize() {\r\n        this._persistedSize.reset();\r\n    }\r\n    hideWidget() {\r\n        var _a;\r\n        (_a = this._loadingTimeout) === null || _a === void 0 ? void 0 : _a.dispose();\r\n        this._setState(0 /* Hidden */);\r\n        this._onDidHide.fire(this);\r\n        this.element.clearSashHoverState();\r\n        // ensure that a reasonable widget height is persisted so that\r\n        // accidential "resize-to-single-items" cases aren\'t happening\r\n        const dim = this._persistedSize.restore();\r\n        const minPersistedHeight = Math.ceil(this.getLayoutInfo().itemHeight * 4.3);\r\n        if (dim && dim.height < minPersistedHeight) {\r\n            this._persistedSize.store(dim.with(undefined, minPersistedHeight));\r\n        }\r\n    }\r\n    isFrozen() {\r\n        return this._state === 4 /* Frozen */;\r\n    }\r\n    _afterRender(position) {\r\n        if (position === null) {\r\n            if (this._isDetailsVisible()) {\r\n                this._details.hide(); //todo@jrieken soft-hide\r\n            }\r\n            return;\r\n        }\r\n        if (this._state === 2 /* Empty */ || this._state === 1 /* Loading */) {\r\n            // no special positioning when widget isn\'t showing list\r\n            return;\r\n        }\r\n        if (this._isDetailsVisible()) {\r\n            this._details.show();\r\n        }\r\n        this._positionDetails();\r\n    }\r\n    _layout(size) {\r\n        var _a, _b, _c;\r\n        if (!this.editor.hasModel()) {\r\n            return;\r\n        }\r\n        if (!this.editor.getDomNode()) {\r\n            // happens when running tests\r\n            return;\r\n        }\r\n        const bodyBox = dom["getClientArea"](document.body);\r\n        const info = this.getLayoutInfo();\r\n        if (!size) {\r\n            size = info.defaultSize;\r\n        }\r\n        let height = size.height;\r\n        let width = size.width;\r\n        // status bar\r\n        this._status.element.style.lineHeight = `${info.itemHeight}px`;\r\n        if (this._state === 2 /* Empty */ || this._state === 1 /* Loading */) {\r\n            // showing a message only\r\n            height = info.itemHeight + info.borderHeight;\r\n            width = info.defaultSize.width / 2;\r\n            this.element.enableSashes(false, false, false, false);\r\n            this.element.minSize = this.element.maxSize = new dom["Dimension"](width, height);\r\n            this._contentWidget.setPreference(2 /* BELOW */);\r\n        }\r\n        else {\r\n            // showing items\r\n            // width math\r\n            const maxWidth = bodyBox.width - info.borderHeight - 2 * info.horizontalPadding;\r\n            if (width > maxWidth) {\r\n                width = maxWidth;\r\n            }\r\n            const preferredWidth = this._completionModel ? this._completionModel.stats.pLabelLen * info.typicalHalfwidthCharacterWidth : width;\r\n            // height math\r\n            const fullHeight = info.statusBarHeight + this._list.contentHeight + info.borderHeight;\r\n            const minHeight = info.itemHeight + info.statusBarHeight;\r\n            const editorBox = dom["getDomNodePagePosition"](this.editor.getDomNode());\r\n            const cursorBox = this.editor.getScrolledVisiblePosition(this.editor.getPosition());\r\n            const cursorBottom = editorBox.top + cursorBox.top + cursorBox.height;\r\n            const maxHeightBelow = Math.min(bodyBox.height - cursorBottom - info.verticalPadding, fullHeight);\r\n            const availableSpaceAbove = editorBox.top + cursorBox.top - info.verticalPadding;\r\n            const maxHeightAbove = Math.min(availableSpaceAbove, fullHeight);\r\n            let maxHeight = Math.min(Math.max(maxHeightAbove, maxHeightBelow) + info.borderHeight, fullHeight);\r\n            if (height === ((_a = this._cappedHeight) === null || _a === void 0 ? void 0 : _a.capped)) {\r\n                // Restore the old (wanted) height when the current\r\n                // height is capped to fit\r\n                height = this._cappedHeight.wanted;\r\n            }\r\n            if (height < minHeight) {\r\n                height = minHeight;\r\n            }\r\n            if (height > maxHeight) {\r\n                height = maxHeight;\r\n            }\r\n            const forceRenderingAboveRequiredSpace = 150;\r\n            if (height > maxHeightBelow || (this._forceRenderingAbove && availableSpaceAbove > forceRenderingAboveRequiredSpace)) {\r\n                this._contentWidget.setPreference(1 /* ABOVE */);\r\n                this.element.enableSashes(true, true, false, false);\r\n                maxHeight = maxHeightAbove;\r\n            }\r\n            else {\r\n                this._contentWidget.setPreference(2 /* BELOW */);\r\n                this.element.enableSashes(false, true, true, false);\r\n                maxHeight = maxHeightBelow;\r\n            }\r\n            this.element.preferredSize = new dom["Dimension"](preferredWidth, info.defaultSize.height);\r\n            this.element.maxSize = new dom["Dimension"](maxWidth, maxHeight);\r\n            this.element.minSize = new dom["Dimension"](220, minHeight);\r\n            // Know when the height was capped to fit and remember\r\n            // the wanted height for later. This is required when going\r\n            // left to widen suggestions.\r\n            this._cappedHeight = height === fullHeight\r\n                ? { wanted: (_c = (_b = this._cappedHeight) === null || _b === void 0 ? void 0 : _b.wanted) !== null && _c !== void 0 ? _c : size.height, capped: height }\r\n                : undefined;\r\n        }\r\n        this._resize(width, height);\r\n    }\r\n    _resize(width, height) {\r\n        const { width: maxWidth, height: maxHeight } = this.element.maxSize;\r\n        width = Math.min(maxWidth, width);\r\n        height = Math.min(maxHeight, height);\r\n        const { statusBarHeight } = this.getLayoutInfo();\r\n        this._list.layout(height - statusBarHeight, width);\r\n        this._listElement.style.height = `${height - statusBarHeight}px`;\r\n        this.element.layout(height, width);\r\n        this._contentWidget.layout();\r\n        this._positionDetails();\r\n    }\r\n    _positionDetails() {\r\n        if (this._isDetailsVisible()) {\r\n            this._details.placeAtAnchor(this.element.domNode);\r\n        }\r\n    }\r\n    getLayoutInfo() {\r\n        const fontInfo = this.editor.getOption(42 /* fontInfo */);\r\n        const itemHeight = Object(numbers["clamp"])(this.editor.getOption(108 /* suggestLineHeight */) || fontInfo.lineHeight, 8, 1000);\r\n        const statusBarHeight = !this.editor.getOption(106 /* suggest */).showStatusBar || this._state === 2 /* Empty */ || this._state === 1 /* Loading */ ? 0 : itemHeight;\r\n        const borderWidth = this._details.widget.borderWidth;\r\n        const borderHeight = 2 * borderWidth;\r\n        return {\r\n            itemHeight,\r\n            statusBarHeight,\r\n            borderWidth,\r\n            borderHeight,\r\n            typicalHalfwidthCharacterWidth: fontInfo.typicalHalfwidthCharacterWidth,\r\n            verticalPadding: 22,\r\n            horizontalPadding: 14,\r\n            defaultSize: new dom["Dimension"](430, statusBarHeight + 12 * itemHeight + borderHeight)\r\n        };\r\n    }\r\n    _isDetailsVisible() {\r\n        return this._storageService.getBoolean(\'expandSuggestionDocs\', 0 /* GLOBAL */, false);\r\n    }\r\n    _setDetailsVisible(value) {\r\n        this._storageService.store(\'expandSuggestionDocs\', value, 0 /* GLOBAL */, 0 /* USER */);\r\n    }\r\n    forceRenderingAbove() {\r\n        if (!this._forceRenderingAbove) {\r\n            this._forceRenderingAbove = true;\r\n            this._layout(this._persistedSize.restore());\r\n        }\r\n    }\r\n    stopForceRenderingAbove() {\r\n        this._forceRenderingAbove = false;\r\n    }\r\n};\r\nsuggestWidget_SuggestWidget.LOADING_MESSAGE = nls["localize"](\'suggestWidget.loading\', "Loading...");\r\nsuggestWidget_SuggestWidget.NO_SUGGESTIONS_MESSAGE = nls["localize"](\'suggestWidget.noSuggestions\', "No suggestions.");\r\nsuggestWidget_SuggestWidget = suggestWidget_decorate([\r\n    suggestWidget_param(1, storage["IStorageService"]),\r\n    suggestWidget_param(2, contextkey["IContextKeyService"]),\r\n    suggestWidget_param(3, common_themeService["IThemeService"]),\r\n    suggestWidget_param(4, instantiation["IInstantiationService"])\r\n], suggestWidget_SuggestWidget);\r\n\r\nclass suggestWidget_SuggestContentWidget {\r\n    constructor(_widget, _editor) {\r\n        this._widget = _widget;\r\n        this._editor = _editor;\r\n        this.allowEditorOverflow = true;\r\n        this.suppressMouseDown = false;\r\n        this._preferenceLocked = false;\r\n        this._added = false;\r\n        this._hidden = false;\r\n    }\r\n    dispose() {\r\n        if (this._added) {\r\n            this._added = false;\r\n            this._editor.removeContentWidget(this);\r\n        }\r\n    }\r\n    getId() {\r\n        return \'editor.widget.suggestWidget\';\r\n    }\r\n    getDomNode() {\r\n        return this._widget.element.domNode;\r\n    }\r\n    show() {\r\n        this._hidden = false;\r\n        if (!this._added) {\r\n            this._added = true;\r\n            this._editor.addContentWidget(this);\r\n        }\r\n    }\r\n    hide() {\r\n        if (!this._hidden) {\r\n            this._hidden = true;\r\n            this.layout();\r\n        }\r\n    }\r\n    layout() {\r\n        this._editor.layoutContentWidget(this);\r\n    }\r\n    getPosition() {\r\n        if (this._hidden || !this._position || !this._preference) {\r\n            return null;\r\n        }\r\n        return {\r\n            position: this._position,\r\n            preference: [this._preference]\r\n        };\r\n    }\r\n    beforeRender() {\r\n        const { height, width } = this._widget.element.size;\r\n        const { borderWidth, horizontalPadding } = this._widget.getLayoutInfo();\r\n        return new dom["Dimension"](width + 2 * borderWidth + horizontalPadding, height + 2 * borderWidth);\r\n    }\r\n    afterRender(position) {\r\n        this._widget._afterRender(position);\r\n    }\r\n    setPreference(preference) {\r\n        if (!this._preferenceLocked) {\r\n            this._preference = preference;\r\n        }\r\n    }\r\n    lockPreference() {\r\n        this._preferenceLocked = true;\r\n    }\r\n    unlockPreference() {\r\n        this._preferenceLocked = false;\r\n    }\r\n    setPosition(position) {\r\n        this._position = position;\r\n    }\r\n}\r\nObject(common_themeService["registerThemingParticipant"])((theme, collector) => {\r\n    const matchHighlight = theme.getColor(editorSuggestWidgetHighlightForeground);\r\n    if (matchHighlight) {\r\n        collector.addRule(`.monaco-editor .suggest-widget .monaco-list .monaco-list-row .monaco-highlighted-label .highlight { color: ${matchHighlight}; }`);\r\n    }\r\n    const matchHighlightFocus = theme.getColor(editorSuggestWidgetHighlightFocusForeground);\r\n    if (matchHighlight) {\r\n        collector.addRule(`.monaco-editor .suggest-widget .monaco-list .monaco-list-row.focused .monaco-highlighted-label .highlight { color: ${matchHighlightFocus}; }`);\r\n    }\r\n    const foreground = theme.getColor(editorSuggestWidgetForeground);\r\n    if (foreground) {\r\n        collector.addRule(`.monaco-editor .suggest-widget, .monaco-editor .suggest-details { color: ${foreground}; }`);\r\n    }\r\n    const selectedForeground = theme.getColor(editorSuggestWidgetSelectedForeground);\r\n    if (selectedForeground) {\r\n        collector.addRule(`.monaco-editor .suggest-widget .monaco-list .monaco-list-row.focused { color: ${selectedForeground}; }`);\r\n    }\r\n    const selectedIconForeground = theme.getColor(editorSuggestWidgetSelectedIconForeground);\r\n    if (selectedIconForeground) {\r\n        collector.addRule(`.monaco-editor .suggest-widget .monaco-list .monaco-list-row.focused .codicon { color: ${selectedIconForeground}; }`);\r\n    }\r\n    const link = theme.getColor(colorRegistry["textLinkForeground"]);\r\n    if (link) {\r\n        collector.addRule(`.monaco-editor .suggest-details a { color: ${link}; }`);\r\n    }\r\n    const linkHover = theme.getColor(colorRegistry["textLinkActiveForeground"]);\r\n    if (linkHover) {\r\n        collector.addRule(`.monaco-editor .suggest-details a:hover { color: ${linkHover}; }`);\r\n    }\r\n    const codeBackground = theme.getColor(colorRegistry["textCodeBlockBackground"]);\r\n    if (codeBackground) {\r\n        collector.addRule(`.monaco-editor .suggest-details code { background-color: ${codeBackground}; }`);\r\n    }\r\n});\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/suggest/wordContextKey.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar wordContextKey_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar wordContextKey_param = (undefined && undefined.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\n\r\nlet WordContextKey = class WordContextKey {\r\n    constructor(_editor, contextKeyService) {\r\n        this._editor = _editor;\r\n        this._enabled = false;\r\n        this._ckAtEnd = WordContextKey.AtEnd.bindTo(contextKeyService);\r\n        this._configListener = this._editor.onDidChangeConfiguration(e => e.hasChanged(111 /* tabCompletion */) && this._update());\r\n        this._update();\r\n    }\r\n    dispose() {\r\n        var _a;\r\n        this._configListener.dispose();\r\n        (_a = this._selectionListener) === null || _a === void 0 ? void 0 : _a.dispose();\r\n        this._ckAtEnd.reset();\r\n    }\r\n    _update() {\r\n        // only update this when tab completions are enabled\r\n        const enabled = this._editor.getOption(111 /* tabCompletion */) === \'on\';\r\n        if (this._enabled === enabled) {\r\n            return;\r\n        }\r\n        this._enabled = enabled;\r\n        if (this._enabled) {\r\n            const checkForWordEnd = () => {\r\n                if (!this._editor.hasModel()) {\r\n                    this._ckAtEnd.set(false);\r\n                    return;\r\n                }\r\n                const model = this._editor.getModel();\r\n                const selection = this._editor.getSelection();\r\n                const word = model.getWordAtPosition(selection.getStartPosition());\r\n                if (!word) {\r\n                    this._ckAtEnd.set(false);\r\n                    return;\r\n                }\r\n                this._ckAtEnd.set(word.endColumn === selection.getStartPosition().column);\r\n            };\r\n            this._selectionListener = this._editor.onDidChangeCursorSelection(checkForWordEnd);\r\n            checkForWordEnd();\r\n        }\r\n        else if (this._selectionListener) {\r\n            this._ckAtEnd.reset();\r\n            this._selectionListener.dispose();\r\n            this._selectionListener = undefined;\r\n        }\r\n    }\r\n};\r\nWordContextKey.AtEnd = new contextkey["RawContextKey"](\'atEndOfWord\', false);\r\nWordContextKey = wordContextKey_decorate([\r\n    wordContextKey_param(1, contextkey["IContextKeyService"])\r\n], WordContextKey);\r\n\r\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js\nvar characterClassifier = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestCommitCharacters.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\nclass suggestCommitCharacters_CommitCharacterController {\r\n    constructor(editor, widget, accept) {\r\n        this._disposables = new lifecycle["DisposableStore"]();\r\n        this._disposables.add(widget.onDidShow(() => this._onItem(widget.getFocusedItem())));\r\n        this._disposables.add(widget.onDidFocus(this._onItem, this));\r\n        this._disposables.add(widget.onDidHide(this.reset, this));\r\n        this._disposables.add(editor.onWillType(text => {\r\n            if (this._active && !widget.isFrozen()) {\r\n                const ch = text.charCodeAt(text.length - 1);\r\n                if (this._active.acceptCharacters.has(ch) && editor.getOption(0 /* acceptSuggestionOnCommitCharacter */)) {\r\n                    accept(this._active.item);\r\n                }\r\n            }\r\n        }));\r\n    }\r\n    _onItem(selected) {\r\n        if (!selected || !Object(arrays["isNonEmptyArray"])(selected.item.completion.commitCharacters)) {\r\n            // no item or no commit characters\r\n            this.reset();\r\n            return;\r\n        }\r\n        if (this._active && this._active.item.item === selected.item) {\r\n            // still the same item\r\n            return;\r\n        }\r\n        // keep item and its commit characters\r\n        const acceptCharacters = new characterClassifier["CharacterSet"]();\r\n        for (const ch of selected.item.completion.commitCharacters) {\r\n            if (ch.length > 0) {\r\n                acceptCharacters.add(ch.charCodeAt(0));\r\n            }\r\n        }\r\n        this._active = { acceptCharacters, item: selected };\r\n    }\r\n    reset() {\r\n        this._active = undefined;\r\n    }\r\n    dispose() {\r\n        this._disposables.dispose();\r\n    }\r\n}\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestOvertypingCapturer.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\nclass suggestOvertypingCapturer_OvertypingCapturer {\r\n    constructor(editor, suggestModel) {\r\n        this._disposables = new lifecycle["DisposableStore"]();\r\n        this._lastOvertyped = [];\r\n        this._empty = true;\r\n        this._disposables.add(editor.onWillType(() => {\r\n            if (!this._empty) {\r\n                return;\r\n            }\r\n            if (!editor.hasModel()) {\r\n                return;\r\n            }\r\n            const selections = editor.getSelections();\r\n            const selectionsLength = selections.length;\r\n            // Check if it will overtype any selections\r\n            let willOvertype = false;\r\n            for (let i = 0; i < selectionsLength; i++) {\r\n                if (!selections[i].isEmpty()) {\r\n                    willOvertype = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!willOvertype) {\r\n                return;\r\n            }\r\n            this._lastOvertyped = [];\r\n            const model = editor.getModel();\r\n            for (let i = 0; i < selectionsLength; i++) {\r\n                const selection = selections[i];\r\n                // Check for overtyping capturer restrictions\r\n                if (model.getValueLengthInRange(selection) > suggestOvertypingCapturer_OvertypingCapturer._maxSelectionLength) {\r\n                    return;\r\n                }\r\n                this._lastOvertyped[i] = { value: model.getValueInRange(selection), multiline: selection.startLineNumber !== selection.endLineNumber };\r\n            }\r\n            this._empty = false;\r\n        }));\r\n        this._disposables.add(suggestModel.onDidCancel(e => {\r\n            if (!this._empty && !e.retrigger) {\r\n                this._empty = true;\r\n            }\r\n        }));\r\n    }\r\n    getLastOvertypedInfo(idx) {\r\n        if (!this._empty && idx >= 0 && idx < this._lastOvertyped.length) {\r\n            return this._lastOvertyped[idx];\r\n        }\r\n        return undefined;\r\n    }\r\n    dispose() {\r\n        this._disposables.dispose();\r\n    }\r\n}\r\nsuggestOvertypingCapturer_OvertypingCapturer._maxSelectionLength = 51200;\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestController.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar suggestController_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar suggestController_param = (undefined && undefined.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// sticky suggest widget which doesn\'t disappear on focus out and such\r\nlet _sticky = false;\r\n// _sticky = Boolean("true"); // done "weirdly" so that a lint warning prevents you from pushing this\r\nclass suggestController_LineSuffix {\r\n    constructor(_model, _position) {\r\n        this._model = _model;\r\n        this._position = _position;\r\n        // spy on what\'s happening right of the cursor. two cases:\r\n        // 1. end of line -> check that it\'s still end of line\r\n        // 2. mid of line -> add a marker and compute the delta\r\n        const maxColumn = _model.getLineMaxColumn(_position.lineNumber);\r\n        if (maxColumn !== _position.column) {\r\n            const offset = _model.getOffsetAt(_position);\r\n            const end = _model.getPositionAt(offset + 1);\r\n            this._marker = _model.deltaDecorations([], [{\r\n                    range: core_range["Range"].fromPositions(_position, end),\r\n                    options: { description: \'suggest-line-suffix\', stickiness: 1 /* NeverGrowsWhenTypingAtEdges */ }\r\n                }]);\r\n        }\r\n    }\r\n    dispose() {\r\n        if (this._marker && !this._model.isDisposed()) {\r\n            this._model.deltaDecorations(this._marker, []);\r\n        }\r\n    }\r\n    delta(position) {\r\n        if (this._model.isDisposed() || this._position.lineNumber !== position.lineNumber) {\r\n            // bail out early if things seems fishy\r\n            return 0;\r\n        }\r\n        // read the marker (in case suggest was triggered at line end) or compare\r\n        // the cursor to the line end.\r\n        if (this._marker) {\r\n            const range = this._model.getDecorationRange(this._marker[0]);\r\n            const end = this._model.getOffsetAt(range.getStartPosition());\r\n            return end - this._model.getOffsetAt(position);\r\n        }\r\n        else {\r\n            return this._model.getLineMaxColumn(position.lineNumber) - position.column;\r\n        }\r\n    }\r\n}\r\nlet suggestController_SuggestController = class SuggestController {\r\n    constructor(editor, _memoryService, _commandService, _contextKeyService, _instantiationService, _logService) {\r\n        this._memoryService = _memoryService;\r\n        this._commandService = _commandService;\r\n        this._contextKeyService = _contextKeyService;\r\n        this._instantiationService = _instantiationService;\r\n        this._logService = _logService;\r\n        this._lineSuffix = new lifecycle["MutableDisposable"]();\r\n        this._toDispose = new lifecycle["DisposableStore"]();\r\n        this.editor = editor;\r\n        this.model = _instantiationService.createInstance(suggestModel_SuggestModel, this.editor);\r\n        // context key: update insert/replace mode\r\n        const ctxInsertMode = Context.InsertMode.bindTo(_contextKeyService);\r\n        ctxInsertMode.set(editor.getOption(106 /* suggest */).insertMode);\r\n        this.model.onDidTrigger(() => ctxInsertMode.set(editor.getOption(106 /* suggest */).insertMode));\r\n        this.widget = this._toDispose.add(new common_async["IdleValue"](() => {\r\n            const widget = this._instantiationService.createInstance(suggestWidget_SuggestWidget, this.editor);\r\n            this._toDispose.add(widget);\r\n            this._toDispose.add(widget.onDidSelect(item => this._insertSuggestion(item, 0), this));\r\n            // Wire up logic to accept a suggestion on certain characters\r\n            const commitCharacterController = new suggestCommitCharacters_CommitCharacterController(this.editor, widget, item => this._insertSuggestion(item, 2 /* NoAfterUndoStop */));\r\n            this._toDispose.add(commitCharacterController);\r\n            this._toDispose.add(this.model.onDidSuggest(e => {\r\n                if (e.completionModel.items.length === 0) {\r\n                    commitCharacterController.reset();\r\n                }\r\n            }));\r\n            // Wire up makes text edit context key\r\n            const ctxMakesTextEdit = Context.MakesTextEdit.bindTo(this._contextKeyService);\r\n            const ctxHasInsertAndReplace = Context.HasInsertAndReplaceRange.bindTo(this._contextKeyService);\r\n            const ctxCanResolve = Context.CanResolve.bindTo(this._contextKeyService);\r\n            this._toDispose.add(Object(lifecycle["toDisposable"])(() => {\r\n                ctxMakesTextEdit.reset();\r\n                ctxHasInsertAndReplace.reset();\r\n                ctxCanResolve.reset();\r\n            }));\r\n            this._toDispose.add(widget.onDidFocus(({ item }) => {\r\n                // (ctx: makesTextEdit)\r\n                const position = this.editor.getPosition();\r\n                const startColumn = item.editStart.column;\r\n                const endColumn = position.column;\r\n                let value = true;\r\n                if (this.editor.getOption(1 /* acceptSuggestionOnEnter */) === \'smart\'\r\n                    && this.model.state === 2 /* Auto */\r\n                    && !item.completion.command\r\n                    && !item.completion.additionalTextEdits\r\n                    && !(item.completion.insertTextRules & 4 /* InsertAsSnippet */)\r\n                    && endColumn - startColumn === item.completion.insertText.length) {\r\n                    const oldText = this.editor.getModel().getValueInRange({\r\n                        startLineNumber: position.lineNumber,\r\n                        startColumn,\r\n                        endLineNumber: position.lineNumber,\r\n                        endColumn\r\n                    });\r\n                    value = oldText !== item.completion.insertText;\r\n                }\r\n                ctxMakesTextEdit.set(value);\r\n                // (ctx: hasInsertAndReplaceRange)\r\n                ctxHasInsertAndReplace.set(!core_position["Position"].equals(item.editInsertEnd, item.editReplaceEnd));\r\n                // (ctx: canResolve)\r\n                ctxCanResolve.set(Boolean(item.provider.resolveCompletionItem) || Boolean(item.completion.documentation) || item.completion.detail !== item.completion.label);\r\n            }));\r\n            this._toDispose.add(widget.onDetailsKeyDown(e => {\r\n                // cmd + c on macOS, ctrl + c on Win / Linux\r\n                if (e.toKeybinding().equals(new keyCodes["SimpleKeybinding"](true, false, false, false, 33 /* KEY_C */)) ||\r\n                    (platform["isMacintosh"] && e.toKeybinding().equals(new keyCodes["SimpleKeybinding"](false, false, false, true, 33 /* KEY_C */)))) {\r\n                    e.stopPropagation();\r\n                    return;\r\n                }\r\n                if (!e.toKeybinding().isModifierKey()) {\r\n                    this.editor.focus();\r\n                }\r\n            }));\r\n            return widget;\r\n        }));\r\n        // Wire up text overtyping capture\r\n        this._overtypingCapturer = this._toDispose.add(new common_async["IdleValue"](() => {\r\n            return this._toDispose.add(new suggestOvertypingCapturer_OvertypingCapturer(this.editor, this.model));\r\n        }));\r\n        this._alternatives = this._toDispose.add(new common_async["IdleValue"](() => {\r\n            return this._toDispose.add(new SuggestAlternatives(this.editor, this._contextKeyService));\r\n        }));\r\n        this._toDispose.add(_instantiationService.createInstance(WordContextKey, editor));\r\n        this._toDispose.add(this.model.onDidTrigger(e => {\r\n            this.widget.value.showTriggered(e.auto, e.shy ? 250 : 50);\r\n            this._lineSuffix.value = new suggestController_LineSuffix(this.editor.getModel(), e.position);\r\n        }));\r\n        this._toDispose.add(this.model.onDidSuggest(e => {\r\n            if (!e.shy) {\r\n                let index = this._memoryService.select(this.editor.getModel(), this.editor.getPosition(), e.completionModel.items);\r\n                this.widget.value.showSuggestions(e.completionModel, index, e.isFrozen, e.auto);\r\n            }\r\n        }));\r\n        this._toDispose.add(this.model.onDidCancel(e => {\r\n            if (!e.retrigger) {\r\n                this.widget.value.hideWidget();\r\n            }\r\n        }));\r\n        this._toDispose.add(this.editor.onDidBlurEditorWidget(() => {\r\n            if (!_sticky) {\r\n                this.model.cancel();\r\n                this.model.clear();\r\n            }\r\n        }));\r\n        // Manage the acceptSuggestionsOnEnter context key\r\n        let acceptSuggestionsOnEnter = Context.AcceptSuggestionsOnEnter.bindTo(_contextKeyService);\r\n        let updateFromConfig = () => {\r\n            const acceptSuggestionOnEnter = this.editor.getOption(1 /* acceptSuggestionOnEnter */);\r\n            acceptSuggestionsOnEnter.set(acceptSuggestionOnEnter === \'on\' || acceptSuggestionOnEnter === \'smart\');\r\n        };\r\n        this._toDispose.add(this.editor.onDidChangeConfiguration(() => updateFromConfig()));\r\n        updateFromConfig();\r\n    }\r\n    static get(editor) {\r\n        return editor.getContribution(SuggestController.ID);\r\n    }\r\n    dispose() {\r\n        this._alternatives.dispose();\r\n        this._toDispose.dispose();\r\n        this.widget.dispose();\r\n        this.model.dispose();\r\n        this._lineSuffix.dispose();\r\n    }\r\n    _insertSuggestion(event, flags) {\r\n        if (!event || !event.item) {\r\n            this._alternatives.value.reset();\r\n            this.model.cancel();\r\n            this.model.clear();\r\n            return;\r\n        }\r\n        if (!this.editor.hasModel()) {\r\n            return;\r\n        }\r\n        const model = this.editor.getModel();\r\n        const modelVersionNow = model.getAlternativeVersionId();\r\n        const { item } = event;\r\n        //\r\n        const tasks = [];\r\n        const cts = new cancellation["CancellationTokenSource"]();\r\n        // pushing undo stops *before* additional text edits and\r\n        // *after* the main edit\r\n        if (!(flags & 1 /* NoBeforeUndoStop */)) {\r\n            this.editor.pushUndoStop();\r\n        }\r\n        // compute overwrite[Before|After] deltas BEFORE applying extra edits\r\n        const info = this.getOverwriteInfo(item, Boolean(flags & 8 /* AlternativeOverwriteConfig */));\r\n        // keep item in memory\r\n        this._memoryService.memorize(model, this.editor.getPosition(), item);\r\n        if (Array.isArray(item.completion.additionalTextEdits)) {\r\n            // sync additional edits\r\n            const scrollState = core_editorState["StableEditorScrollState"].capture(this.editor);\r\n            this.editor.executeEdits(\'suggestController.additionalTextEdits.sync\', item.completion.additionalTextEdits.map(edit => editOperation["EditOperation"].replace(core_range["Range"].lift(edit.range), edit.text)));\r\n            scrollState.restoreRelativeVerticalPositionOfCursor(this.editor);\r\n        }\r\n        else if (!item.isResolved) {\r\n            // async additional edits\r\n            const sw = new stopwatch["StopWatch"](true);\r\n            let position;\r\n            const docListener = model.onDidChangeContent(e => {\r\n                if (e.isFlush) {\r\n                    cts.cancel();\r\n                    docListener.dispose();\r\n                    return;\r\n                }\r\n                for (let change of e.changes) {\r\n                    const thisPosition = core_range["Range"].getEndPosition(change.range);\r\n                    if (!position || core_position["Position"].isBefore(thisPosition, position)) {\r\n                        position = thisPosition;\r\n                    }\r\n                }\r\n            });\r\n            let oldFlags = flags;\r\n            flags |= 2 /* NoAfterUndoStop */;\r\n            let didType = false;\r\n            let typeListener = this.editor.onWillType(() => {\r\n                typeListener.dispose();\r\n                didType = true;\r\n                if (!(oldFlags & 2 /* NoAfterUndoStop */)) {\r\n                    this.editor.pushUndoStop();\r\n                }\r\n            });\r\n            tasks.push(item.resolve(cts.token).then(() => {\r\n                if (!item.completion.additionalTextEdits || cts.token.isCancellationRequested) {\r\n                    return false;\r\n                }\r\n                if (position && item.completion.additionalTextEdits.some(edit => core_position["Position"].isBefore(position, core_range["Range"].getStartPosition(edit.range)))) {\r\n                    return false;\r\n                }\r\n                if (didType) {\r\n                    this.editor.pushUndoStop();\r\n                }\r\n                const scrollState = core_editorState["StableEditorScrollState"].capture(this.editor);\r\n                this.editor.executeEdits(\'suggestController.additionalTextEdits.async\', item.completion.additionalTextEdits.map(edit => editOperation["EditOperation"].replace(core_range["Range"].lift(edit.range), edit.text)));\r\n                scrollState.restoreRelativeVerticalPositionOfCursor(this.editor);\r\n                if (didType || !(oldFlags & 2 /* NoAfterUndoStop */)) {\r\n                    this.editor.pushUndoStop();\r\n                }\r\n                return true;\r\n            }).then(applied => {\r\n                this._logService.trace(\'[suggest] async resolving of edits DONE (ms, applied?)\', sw.elapsed(), applied);\r\n                docListener.dispose();\r\n                typeListener.dispose();\r\n            }));\r\n        }\r\n        let { insertText } = item.completion;\r\n        if (!(item.completion.insertTextRules & 4 /* InsertAsSnippet */)) {\r\n            insertText = SnippetParser.escape(insertText);\r\n        }\r\n        snippetController2_SnippetController2.get(this.editor).insert(insertText, {\r\n            overwriteBefore: info.overwriteBefore,\r\n            overwriteAfter: info.overwriteAfter,\r\n            undoStopBefore: false,\r\n            undoStopAfter: false,\r\n            adjustWhitespace: !(item.completion.insertTextRules & 1 /* KeepWhitespace */),\r\n            clipboardText: event.model.clipboardText,\r\n            overtypingCapturer: this._overtypingCapturer.value\r\n        });\r\n        if (!(flags & 2 /* NoAfterUndoStop */)) {\r\n            this.editor.pushUndoStop();\r\n        }\r\n        if (!item.completion.command) {\r\n            // done\r\n            this.model.cancel();\r\n        }\r\n        else if (item.completion.command.id === suggestController_TriggerSuggestAction.id) {\r\n            // retigger\r\n            this.model.trigger({ auto: true, shy: false }, true);\r\n        }\r\n        else {\r\n            // exec command, done\r\n            tasks.push(this._commandService.executeCommand(item.completion.command.id, ...(item.completion.command.arguments ? [...item.completion.command.arguments] : [])).catch(errors["onUnexpectedError"]));\r\n            this.model.cancel();\r\n        }\r\n        if (flags & 4 /* KeepAlternativeSuggestions */) {\r\n            this._alternatives.value.set(event, next => {\r\n                // cancel resolving of additional edits\r\n                cts.cancel();\r\n                // this is not so pretty. when inserting the \'next\'\r\n                // suggestion we undo until we are at the state at\r\n                // which we were before inserting the previous suggestion...\r\n                while (model.canUndo()) {\r\n                    if (modelVersionNow !== model.getAlternativeVersionId()) {\r\n                        model.undo();\r\n                    }\r\n                    this._insertSuggestion(next, 1 /* NoBeforeUndoStop */ | 2 /* NoAfterUndoStop */ | (flags & 8 /* AlternativeOverwriteConfig */ ? 8 /* AlternativeOverwriteConfig */ : 0));\r\n                    break;\r\n                }\r\n            });\r\n        }\r\n        this._alertCompletionItem(item);\r\n        // clear only now - after all tasks are done\r\n        Promise.all(tasks).finally(() => {\r\n            this.model.clear();\r\n            cts.dispose();\r\n        });\r\n    }\r\n    getOverwriteInfo(item, toggleMode) {\r\n        Object(types["assertType"])(this.editor.hasModel());\r\n        let replace = this.editor.getOption(106 /* suggest */).insertMode === \'replace\';\r\n        if (toggleMode) {\r\n            replace = !replace;\r\n        }\r\n        const overwriteBefore = item.position.column - item.editStart.column;\r\n        const overwriteAfter = (replace ? item.editReplaceEnd.column : item.editInsertEnd.column) - item.position.column;\r\n        const columnDelta = this.editor.getPosition().column - item.position.column;\r\n        const suffixDelta = this._lineSuffix.value ? this._lineSuffix.value.delta(this.editor.getPosition()) : 0;\r\n        return {\r\n            overwriteBefore: overwriteBefore + columnDelta,\r\n            overwriteAfter: overwriteAfter + suffixDelta\r\n        };\r\n    }\r\n    _alertCompletionItem(item) {\r\n        if (Object(arrays["isNonEmptyArray"])(item.completion.additionalTextEdits)) {\r\n            let msg = nls["localize"](\'aria.alert.snippet\', "Accepting \'{0}\' made {1} additional edits", item.textLabel, item.completion.additionalTextEdits.length);\r\n            Object(aria["alert"])(msg);\r\n        }\r\n    }\r\n    triggerSuggest(onlyFrom) {\r\n        if (this.editor.hasModel()) {\r\n            this.model.trigger({ auto: false, shy: false }, false, onlyFrom);\r\n            this.editor.revealLine(this.editor.getPosition().lineNumber, 0 /* Smooth */);\r\n            this.editor.focus();\r\n        }\r\n    }\r\n    triggerSuggestAndAcceptBest(arg) {\r\n        if (!this.editor.hasModel()) {\r\n            return;\r\n        }\r\n        const positionNow = this.editor.getPosition();\r\n        const fallback = () => {\r\n            if (positionNow.equals(this.editor.getPosition())) {\r\n                this._commandService.executeCommand(arg.fallback);\r\n            }\r\n        };\r\n        const makesTextEdit = (item) => {\r\n            if (item.completion.insertTextRules & 4 /* InsertAsSnippet */ || item.completion.additionalTextEdits) {\r\n                // snippet, other editor -> makes edit\r\n                return true;\r\n            }\r\n            const position = this.editor.getPosition();\r\n            const startColumn = item.editStart.column;\r\n            const endColumn = position.column;\r\n            if (endColumn - startColumn !== item.completion.insertText.length) {\r\n                // unequal lengths -> makes edit\r\n                return true;\r\n            }\r\n            const textNow = this.editor.getModel().getValueInRange({\r\n                startLineNumber: position.lineNumber,\r\n                startColumn,\r\n                endLineNumber: position.lineNumber,\r\n                endColumn\r\n            });\r\n            // unequal text -> makes edit\r\n            return textNow !== item.completion.insertText;\r\n        };\r\n        common_event["Event"].once(this.model.onDidTrigger)(_ => {\r\n            // wait for trigger because only then the cancel-event is trustworthy\r\n            let listener = [];\r\n            common_event["Event"].any(this.model.onDidTrigger, this.model.onDidCancel)(() => {\r\n                // retrigger or cancel -> try to type default text\r\n                Object(lifecycle["dispose"])(listener);\r\n                fallback();\r\n            }, undefined, listener);\r\n            this.model.onDidSuggest(({ completionModel }) => {\r\n                Object(lifecycle["dispose"])(listener);\r\n                if (completionModel.items.length === 0) {\r\n                    fallback();\r\n                    return;\r\n                }\r\n                const index = this._memoryService.select(this.editor.getModel(), this.editor.getPosition(), completionModel.items);\r\n                const item = completionModel.items[index];\r\n                if (!makesTextEdit(item)) {\r\n                    fallback();\r\n                    return;\r\n                }\r\n                this.editor.pushUndoStop();\r\n                this._insertSuggestion({ index, item, model: completionModel }, 4 /* KeepAlternativeSuggestions */ | 1 /* NoBeforeUndoStop */ | 2 /* NoAfterUndoStop */);\r\n            }, undefined, listener);\r\n        });\r\n        this.model.trigger({ auto: false, shy: true });\r\n        this.editor.revealLine(positionNow.lineNumber, 0 /* Smooth */);\r\n        this.editor.focus();\r\n    }\r\n    acceptSelectedSuggestion(keepAlternativeSuggestions, alternativeOverwriteConfig) {\r\n        const item = this.widget.value.getFocusedItem();\r\n        let flags = 0;\r\n        if (keepAlternativeSuggestions) {\r\n            flags |= 4 /* KeepAlternativeSuggestions */;\r\n        }\r\n        if (alternativeOverwriteConfig) {\r\n            flags |= 8 /* AlternativeOverwriteConfig */;\r\n        }\r\n        this._insertSuggestion(item, flags);\r\n    }\r\n    acceptNextSuggestion() {\r\n        this._alternatives.value.next();\r\n    }\r\n    acceptPrevSuggestion() {\r\n        this._alternatives.value.prev();\r\n    }\r\n    cancelSuggestWidget() {\r\n        this.model.cancel();\r\n        this.model.clear();\r\n        this.widget.value.hideWidget();\r\n    }\r\n    selectNextSuggestion() {\r\n        this.widget.value.selectNext();\r\n    }\r\n    selectNextPageSuggestion() {\r\n        this.widget.value.selectNextPage();\r\n    }\r\n    selectLastSuggestion() {\r\n        this.widget.value.selectLast();\r\n    }\r\n    selectPrevSuggestion() {\r\n        this.widget.value.selectPrevious();\r\n    }\r\n    selectPrevPageSuggestion() {\r\n        this.widget.value.selectPreviousPage();\r\n    }\r\n    selectFirstSuggestion() {\r\n        this.widget.value.selectFirst();\r\n    }\r\n    toggleSuggestionDetails() {\r\n        this.widget.value.toggleDetails();\r\n    }\r\n    toggleExplainMode() {\r\n        this.widget.value.toggleExplainMode();\r\n    }\r\n    toggleSuggestionFocus() {\r\n        this.widget.value.toggleDetailsFocus();\r\n    }\r\n    resetWidgetSize() {\r\n        this.widget.value.resetPersistedSize();\r\n    }\r\n    forceRenderingAbove() {\r\n        this.widget.value.forceRenderingAbove();\r\n    }\r\n    stopForceRenderingAbove() {\r\n        if (!this.widget.isInitialized) {\r\n            // This method has no effect if the widget is not initialized yet.\r\n            return;\r\n        }\r\n        this.widget.value.stopForceRenderingAbove();\r\n    }\r\n};\r\nsuggestController_SuggestController.ID = \'editor.contrib.suggestController\';\r\nsuggestController_SuggestController = suggestController_decorate([\r\n    suggestController_param(1, ISuggestMemoryService),\r\n    suggestController_param(2, common_commands["ICommandService"]),\r\n    suggestController_param(3, contextkey["IContextKeyService"]),\r\n    suggestController_param(4, instantiation["IInstantiationService"]),\r\n    suggestController_param(5, log["ILogService"])\r\n], suggestController_SuggestController);\r\n\r\nclass suggestController_TriggerSuggestAction extends editorExtensions["EditorAction"] {\r\n    constructor() {\r\n        super({\r\n            id: suggestController_TriggerSuggestAction.id,\r\n            label: nls["localize"](\'suggest.trigger.label\', "Trigger Suggest"),\r\n            alias: \'Trigger Suggest\',\r\n            precondition: contextkey["ContextKeyExpr"].and(editorContextKeys["EditorContextKeys"].writable, editorContextKeys["EditorContextKeys"].hasCompletionItemProvider),\r\n            kbOpts: {\r\n                kbExpr: editorContextKeys["EditorContextKeys"].textInputFocus,\r\n                primary: 2048 /* CtrlCmd */ | 10 /* Space */,\r\n                secondary: [2048 /* CtrlCmd */ | 39 /* KEY_I */],\r\n                mac: { primary: 256 /* WinCtrl */ | 10 /* Space */, secondary: [512 /* Alt */ | 9 /* Escape */, 2048 /* CtrlCmd */ | 39 /* KEY_I */] },\r\n                weight: 100 /* EditorContrib */\r\n            }\r\n        });\r\n    }\r\n    run(accessor, editor) {\r\n        const controller = suggestController_SuggestController.get(editor);\r\n        if (!controller) {\r\n            return;\r\n        }\r\n        controller.triggerSuggest();\r\n    }\r\n}\r\nsuggestController_TriggerSuggestAction.id = \'editor.action.triggerSuggest\';\r\nObject(editorExtensions["registerEditorContribution"])(suggestController_SuggestController.ID, suggestController_SuggestController);\r\nObject(editorExtensions["registerEditorAction"])(suggestController_TriggerSuggestAction);\r\nconst weight = 100 /* EditorContrib */ + 90;\r\nconst SuggestCommand = editorExtensions["EditorCommand"].bindToContribution(suggestController_SuggestController.get);\r\nObject(editorExtensions["registerEditorCommand"])(new SuggestCommand({\r\n    id: \'acceptSelectedSuggestion\',\r\n    precondition: Context.Visible,\r\n    handler(x) {\r\n        x.acceptSelectedSuggestion(true, false);\r\n    }\r\n}));\r\n// normal tab\r\nkeybindingsRegistry["KeybindingsRegistry"].registerKeybindingRule({\r\n    id: \'acceptSelectedSuggestion\',\r\n    when: contextkey["ContextKeyExpr"].and(Context.Visible, editorContextKeys["EditorContextKeys"].textInputFocus),\r\n    primary: 2 /* Tab */,\r\n    weight\r\n});\r\n// accept on enter has special rules\r\nkeybindingsRegistry["KeybindingsRegistry"].registerKeybindingRule({\r\n    id: \'acceptSelectedSuggestion\',\r\n    when: contextkey["ContextKeyExpr"].and(Context.Visible, editorContextKeys["EditorContextKeys"].textInputFocus, Context.AcceptSuggestionsOnEnter, Context.MakesTextEdit),\r\n    primary: 3 /* Enter */,\r\n    weight,\r\n});\r\nactions_common_actions["MenuRegistry"].appendMenuItem(suggestWidgetStatusbarMenu, {\r\n    command: { id: \'acceptSelectedSuggestion\', title: nls["localize"](\'accept.insert\', "Insert") },\r\n    group: \'left\',\r\n    order: 1,\r\n    when: Context.HasInsertAndReplaceRange.toNegated()\r\n});\r\nactions_common_actions["MenuRegistry"].appendMenuItem(suggestWidgetStatusbarMenu, {\r\n    command: { id: \'acceptSelectedSuggestion\', title: nls["localize"](\'accept.insert\', "Insert") },\r\n    group: \'left\',\r\n    order: 1,\r\n    when: contextkey["ContextKeyExpr"].and(Context.HasInsertAndReplaceRange, Context.InsertMode.isEqualTo(\'insert\'))\r\n});\r\nactions_common_actions["MenuRegistry"].appendMenuItem(suggestWidgetStatusbarMenu, {\r\n    command: { id: \'acceptSelectedSuggestion\', title: nls["localize"](\'accept.replace\', "Replace") },\r\n    group: \'left\',\r\n    order: 1,\r\n    when: contextkey["ContextKeyExpr"].and(Context.HasInsertAndReplaceRange, Context.InsertMode.isEqualTo(\'replace\'))\r\n});\r\nObject(editorExtensions["registerEditorCommand"])(new SuggestCommand({\r\n    id: \'acceptAlternativeSelectedSuggestion\',\r\n    precondition: contextkey["ContextKeyExpr"].and(Context.Visible, editorContextKeys["EditorContextKeys"].textInputFocus),\r\n    kbOpts: {\r\n        weight: weight,\r\n        kbExpr: editorContextKeys["EditorContextKeys"].textInputFocus,\r\n        primary: 1024 /* Shift */ | 3 /* Enter */,\r\n        secondary: [1024 /* Shift */ | 2 /* Tab */],\r\n    },\r\n    handler(x) {\r\n        x.acceptSelectedSuggestion(false, true);\r\n    },\r\n    menuOpts: [{\r\n            menuId: suggestWidgetStatusbarMenu,\r\n            group: \'left\',\r\n            order: 2,\r\n            when: contextkey["ContextKeyExpr"].and(Context.HasInsertAndReplaceRange, Context.InsertMode.isEqualTo(\'insert\')),\r\n            title: nls["localize"](\'accept.replace\', "Replace")\r\n        }, {\r\n            menuId: suggestWidgetStatusbarMenu,\r\n            group: \'left\',\r\n            order: 2,\r\n            when: contextkey["ContextKeyExpr"].and(Context.HasInsertAndReplaceRange, Context.InsertMode.isEqualTo(\'replace\')),\r\n            title: nls["localize"](\'accept.insert\', "Insert")\r\n        }]\r\n}));\r\n// continue to support the old command\r\ncommon_commands["CommandsRegistry"].registerCommandAlias(\'acceptSelectedSuggestionOnEnter\', \'acceptSelectedSuggestion\');\r\nObject(editorExtensions["registerEditorCommand"])(new SuggestCommand({\r\n    id: \'hideSuggestWidget\',\r\n    precondition: Context.Visible,\r\n    handler: x => x.cancelSuggestWidget(),\r\n    kbOpts: {\r\n        weight: weight,\r\n        kbExpr: editorContextKeys["EditorContextKeys"].textInputFocus,\r\n        primary: 9 /* Escape */,\r\n        secondary: [1024 /* Shift */ | 9 /* Escape */]\r\n    }\r\n}));\r\nObject(editorExtensions["registerEditorCommand"])(new SuggestCommand({\r\n    id: \'selectNextSuggestion\',\r\n    precondition: contextkey["ContextKeyExpr"].and(Context.Visible, Context.MultipleSuggestions),\r\n    handler: c => c.selectNextSuggestion(),\r\n    kbOpts: {\r\n        weight: weight,\r\n        kbExpr: editorContextKeys["EditorContextKeys"].textInputFocus,\r\n        primary: 18 /* DownArrow */,\r\n        secondary: [2048 /* CtrlCmd */ | 18 /* DownArrow */],\r\n        mac: { primary: 18 /* DownArrow */, secondary: [2048 /* CtrlCmd */ | 18 /* DownArrow */, 256 /* WinCtrl */ | 44 /* KEY_N */] }\r\n    }\r\n}));\r\nObject(editorExtensions["registerEditorCommand"])(new SuggestCommand({\r\n    id: \'selectNextPageSuggestion\',\r\n    precondition: contextkey["ContextKeyExpr"].and(Context.Visible, Context.MultipleSuggestions),\r\n    handler: c => c.selectNextPageSuggestion(),\r\n    kbOpts: {\r\n        weight: weight,\r\n        kbExpr: editorContextKeys["EditorContextKeys"].textInputFocus,\r\n        primary: 12 /* PageDown */,\r\n        secondary: [2048 /* CtrlCmd */ | 12 /* PageDown */]\r\n    }\r\n}));\r\nObject(editorExtensions["registerEditorCommand"])(new SuggestCommand({\r\n    id: \'selectLastSuggestion\',\r\n    precondition: contextkey["ContextKeyExpr"].and(Context.Visible, Context.MultipleSuggestions),\r\n    handler: c => c.selectLastSuggestion()\r\n}));\r\nObject(editorExtensions["registerEditorCommand"])(new SuggestCommand({\r\n    id: \'selectPrevSuggestion\',\r\n    precondition: contextkey["ContextKeyExpr"].and(Context.Visible, Context.MultipleSuggestions),\r\n    handler: c => c.selectPrevSuggestion(),\r\n    kbOpts: {\r\n        weight: weight,\r\n        kbExpr: editorContextKeys["EditorContextKeys"].textInputFocus,\r\n        primary: 16 /* UpArrow */,\r\n        secondary: [2048 /* CtrlCmd */ | 16 /* UpArrow */],\r\n        mac: { primary: 16 /* UpArrow */, secondary: [2048 /* CtrlCmd */ | 16 /* UpArrow */, 256 /* WinCtrl */ | 46 /* KEY_P */] }\r\n    }\r\n}));\r\nObject(editorExtensions["registerEditorCommand"])(new SuggestCommand({\r\n    id: \'selectPrevPageSuggestion\',\r\n    precondition: contextkey["ContextKeyExpr"].and(Context.Visible, Context.MultipleSuggestions),\r\n    handler: c => c.selectPrevPageSuggestion(),\r\n    kbOpts: {\r\n        weight: weight,\r\n        kbExpr: editorContextKeys["EditorContextKeys"].textInputFocus,\r\n        primary: 11 /* PageUp */,\r\n        secondary: [2048 /* CtrlCmd */ | 11 /* PageUp */]\r\n    }\r\n}));\r\nObject(editorExtensions["registerEditorCommand"])(new SuggestCommand({\r\n    id: \'selectFirstSuggestion\',\r\n    precondition: contextkey["ContextKeyExpr"].and(Context.Visible, Context.MultipleSuggestions),\r\n    handler: c => c.selectFirstSuggestion()\r\n}));\r\nObject(editorExtensions["registerEditorCommand"])(new SuggestCommand({\r\n    id: \'toggleSuggestionDetails\',\r\n    precondition: Context.Visible,\r\n    handler: x => x.toggleSuggestionDetails(),\r\n    kbOpts: {\r\n        weight: weight,\r\n        kbExpr: editorContextKeys["EditorContextKeys"].textInputFocus,\r\n        primary: 2048 /* CtrlCmd */ | 10 /* Space */,\r\n        mac: { primary: 256 /* WinCtrl */ | 10 /* Space */ }\r\n    },\r\n    menuOpts: [{\r\n            menuId: suggestWidgetStatusbarMenu,\r\n            group: \'right\',\r\n            order: 1,\r\n            when: contextkey["ContextKeyExpr"].and(Context.DetailsVisible, Context.CanResolve),\r\n            title: nls["localize"](\'detail.more\', "show less")\r\n        }, {\r\n            menuId: suggestWidgetStatusbarMenu,\r\n            group: \'right\',\r\n            order: 1,\r\n            when: contextkey["ContextKeyExpr"].and(Context.DetailsVisible.toNegated(), Context.CanResolve),\r\n            title: nls["localize"](\'detail.less\', "show more")\r\n        }]\r\n}));\r\nObject(editorExtensions["registerEditorCommand"])(new SuggestCommand({\r\n    id: \'toggleExplainMode\',\r\n    precondition: Context.Visible,\r\n    handler: x => x.toggleExplainMode(),\r\n    kbOpts: {\r\n        weight: 100 /* EditorContrib */,\r\n        primary: 2048 /* CtrlCmd */ | 85 /* US_SLASH */,\r\n    }\r\n}));\r\nObject(editorExtensions["registerEditorCommand"])(new SuggestCommand({\r\n    id: \'toggleSuggestionFocus\',\r\n    precondition: Context.Visible,\r\n    handler: x => x.toggleSuggestionFocus(),\r\n    kbOpts: {\r\n        weight: weight,\r\n        kbExpr: editorContextKeys["EditorContextKeys"].textInputFocus,\r\n        primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 10 /* Space */,\r\n        mac: { primary: 256 /* WinCtrl */ | 512 /* Alt */ | 10 /* Space */ }\r\n    }\r\n}));\r\n//#region tab completions\r\nObject(editorExtensions["registerEditorCommand"])(new SuggestCommand({\r\n    id: \'insertBestCompletion\',\r\n    precondition: contextkey["ContextKeyExpr"].and(editorContextKeys["EditorContextKeys"].textInputFocus, contextkey["ContextKeyExpr"].equals(\'config.editor.tabCompletion\', \'on\'), WordContextKey.AtEnd, Context.Visible.toNegated(), SuggestAlternatives.OtherSuggestions.toNegated(), snippetController2_SnippetController2.InSnippetMode.toNegated()),\r\n    handler: (x, arg) => {\r\n        x.triggerSuggestAndAcceptBest(Object(types["isObject"])(arg) ? Object.assign({ fallback: \'tab\' }, arg) : { fallback: \'tab\' });\r\n    },\r\n    kbOpts: {\r\n        weight,\r\n        primary: 2 /* Tab */\r\n    }\r\n}));\r\nObject(editorExtensions["registerEditorCommand"])(new SuggestCommand({\r\n    id: \'insertNextSuggestion\',\r\n    precondition: contextkey["ContextKeyExpr"].and(editorContextKeys["EditorContextKeys"].textInputFocus, contextkey["ContextKeyExpr"].equals(\'config.editor.tabCompletion\', \'on\'), SuggestAlternatives.OtherSuggestions, Context.Visible.toNegated(), snippetController2_SnippetController2.InSnippetMode.toNegated()),\r\n    handler: x => x.acceptNextSuggestion(),\r\n    kbOpts: {\r\n        weight: weight,\r\n        kbExpr: editorContextKeys["EditorContextKeys"].textInputFocus,\r\n        primary: 2 /* Tab */\r\n    }\r\n}));\r\nObject(editorExtensions["registerEditorCommand"])(new SuggestCommand({\r\n    id: \'insertPrevSuggestion\',\r\n    precondition: contextkey["ContextKeyExpr"].and(editorContextKeys["EditorContextKeys"].textInputFocus, contextkey["ContextKeyExpr"].equals(\'config.editor.tabCompletion\', \'on\'), SuggestAlternatives.OtherSuggestions, Context.Visible.toNegated(), snippetController2_SnippetController2.InSnippetMode.toNegated()),\r\n    handler: x => x.acceptPrevSuggestion(),\r\n    kbOpts: {\r\n        weight: weight,\r\n        kbExpr: editorContextKeys["EditorContextKeys"].textInputFocus,\r\n        primary: 1024 /* Shift */ | 2 /* Tab */\r\n    }\r\n}));\r\nObject(editorExtensions["registerEditorAction"])(class extends editorExtensions["EditorAction"] {\r\n    constructor() {\r\n        super({\r\n            id: \'editor.action.resetSuggestSize\',\r\n            label: nls["localize"](\'suggest.reset.label\', "Reset Suggest Widget Size"),\r\n            alias: \'Reset Suggest Widget Size\',\r\n            precondition: undefined\r\n        });\r\n    }\r\n    run(_accessor, editor) {\r\n        suggestController_SuggestController.get(editor).resetWidgetSize();\r\n    }\r\n});\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/suggestWidgetInlineCompletionProvider.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass suggestWidgetInlineCompletionProvider_SuggestWidgetInlineCompletionProvider extends lifecycle["Disposable"] {\r\n    constructor(editor) {\r\n        super();\r\n        this.editor = editor;\r\n        this.isSuggestWidgetVisible = false;\r\n        this.isShiftKeyPressed = false;\r\n        this._isActive = false;\r\n        this._currentInlineCompletion = undefined;\r\n        this.onDidChangeEmitter = new common_event["Emitter"]();\r\n        this.onDidChange = this.onDidChangeEmitter.event;\r\n        // This delay fixes a suggest widget issue when typing "." immediately restarts the suggestion session.\r\n        this.setInactiveDelayed = this._register(new common_async["RunOnceScheduler"](() => {\r\n            if (!this.isSuggestWidgetVisible) {\r\n                if (this._isActive) {\r\n                    this._isActive = false;\r\n                    this.onDidChangeEmitter.fire();\r\n                }\r\n            }\r\n        }, 100));\r\n        // See the command acceptAlternativeSelectedSuggestion that is bound to shift+tab\r\n        this._register(editor.onKeyDown(e => {\r\n            if (e.shiftKey && !this.isShiftKeyPressed) {\r\n                this.isShiftKeyPressed = true;\r\n                this.update(this._isActive);\r\n            }\r\n        }));\r\n        this._register(editor.onKeyUp(e => {\r\n            if (e.shiftKey && this.isShiftKeyPressed) {\r\n                this.isShiftKeyPressed = false;\r\n                this.update(this._isActive);\r\n            }\r\n        }));\r\n        const suggestController = suggestController_SuggestController.get(this.editor);\r\n        if (suggestController) {\r\n            let isBoundToSuggestWidget = false;\r\n            const bindToSuggestWidget = () => {\r\n                if (isBoundToSuggestWidget) {\r\n                    return;\r\n                }\r\n                isBoundToSuggestWidget = true;\r\n                this._register(suggestController.widget.value.onDidShow(() => {\r\n                    this.isSuggestWidgetVisible = true;\r\n                    this.update(true);\r\n                }));\r\n                this._register(suggestController.widget.value.onDidHide(() => {\r\n                    this.isSuggestWidgetVisible = false;\r\n                    this.setInactiveDelayed.schedule();\r\n                    this.update(this._isActive);\r\n                }));\r\n                this._register(suggestController.widget.value.onDidFocus(() => {\r\n                    this.isSuggestWidgetVisible = true;\r\n                    this.update(true);\r\n                }));\r\n            };\r\n            this._register(common_event["Event"].once(suggestController.model.onDidTrigger)(e => {\r\n                bindToSuggestWidget();\r\n            }));\r\n        }\r\n        this.update(this._isActive);\r\n    }\r\n    /**\r\n     * Returns undefined if the suggest widget is not active.\r\n    */\r\n    get state() {\r\n        if (!this._isActive) {\r\n            return undefined;\r\n        }\r\n        return { selectedItemAsInlineCompletion: this._currentInlineCompletion };\r\n    }\r\n    update(newActive) {\r\n        const newInlineCompletion = this.getInlineCompletion();\r\n        let shouldFire = false;\r\n        if (this._currentInlineCompletion !== newInlineCompletion) {\r\n            this._currentInlineCompletion = newInlineCompletion;\r\n            shouldFire = true;\r\n        }\r\n        if (this._isActive !== newActive) {\r\n            this._isActive = newActive;\r\n            shouldFire = true;\r\n        }\r\n        if (shouldFire) {\r\n            this.onDidChangeEmitter.fire();\r\n        }\r\n    }\r\n    getInlineCompletion() {\r\n        const suggestController = suggestController_SuggestController.get(this.editor);\r\n        if (!suggestController) {\r\n            return undefined;\r\n        }\r\n        if (!this.isSuggestWidgetVisible) {\r\n            return undefined;\r\n        }\r\n        const focusedItem = suggestController.widget.value.getFocusedItem();\r\n        if (!focusedItem) {\r\n            return undefined;\r\n        }\r\n        // TODO: item.isResolved\r\n        return suggestionToInlineCompletion(suggestController, this.editor.getPosition(), focusedItem, this.isShiftKeyPressed);\r\n    }\r\n    stopForceRenderingAbove() {\r\n        const suggestController = suggestController_SuggestController.get(this.editor);\r\n        if (suggestController) {\r\n            suggestController.stopForceRenderingAbove();\r\n        }\r\n    }\r\n    forceRenderingAbove() {\r\n        const suggestController = suggestController_SuggestController.get(this.editor);\r\n        if (suggestController) {\r\n            suggestController.forceRenderingAbove();\r\n        }\r\n    }\r\n}\r\nfunction suggestionToInlineCompletion(suggestController, position, suggestion, toggleMode) {\r\n    const item = suggestion.item;\r\n    if (Array.isArray(item.completion.additionalTextEdits) && item.completion.additionalTextEdits.length > 0) {\r\n        // cannot represent additional text edits\r\n        return {\r\n            text: \'\',\r\n            range: core_range["Range"].fromPositions(position, position),\r\n        };\r\n    }\r\n    let { insertText } = item.completion;\r\n    if (item.completion.insertTextRules & 4 /* InsertAsSnippet */) {\r\n        const snippet = new SnippetParser().parse(insertText);\r\n        const model = suggestController.editor.getModel();\r\n        snippetSession_SnippetSession.adjustWhitespace(model, position, snippet, true, true);\r\n        insertText = snippet.toString();\r\n    }\r\n    const info = suggestController.getOverwriteInfo(item, toggleMode);\r\n    return {\r\n        text: insertText,\r\n        range: core_range["Range"].fromPositions(position.delta(0, -info.overwriteBefore), position.delta(0, Math.max(info.overwriteAfter, 0))),\r\n    };\r\n}\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/suggestWidgetPreviewModel.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar suggestWidgetPreviewModel_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass suggestWidgetPreviewModel_SuggestWidgetPreviewModel extends ghostText_BaseGhostTextWidgetModel {\r\n    constructor(editor, cache) {\r\n        super(editor);\r\n        this.cache = cache;\r\n        this.suggestionInlineCompletionSource = this._register(new suggestWidgetInlineCompletionProvider_SuggestWidgetInlineCompletionProvider(this.editor));\r\n        this.updateOperation = this._register(new lifecycle["MutableDisposable"]());\r\n        this.updateCacheSoon = this._register(new common_async["RunOnceScheduler"](() => this.updateCache(), 50));\r\n        this.minReservedLineCount = 0;\r\n        this._register(this.suggestionInlineCompletionSource.onDidChange(() => {\r\n            this.updateCacheSoon.schedule();\r\n            const suggestWidgetState = this.suggestionInlineCompletionSource.state;\r\n            if (!suggestWidgetState) {\r\n                this.minReservedLineCount = 0;\r\n            }\r\n            const newGhostText = this.ghostText;\r\n            if (newGhostText) {\r\n                this.minReservedLineCount = Math.max(this.minReservedLineCount, sum(newGhostText.parts.map(p => p.lines.length - 1)));\r\n            }\r\n            if (this.minReservedLineCount >= 1 && this.isSuggestionPreviewEnabled()) {\r\n                this.suggestionInlineCompletionSource.forceRenderingAbove();\r\n            }\r\n            else {\r\n                this.suggestionInlineCompletionSource.stopForceRenderingAbove();\r\n            }\r\n            this.onDidChangeEmitter.fire();\r\n        }));\r\n        this._register(this.cache.onDidChange(() => {\r\n            this.onDidChangeEmitter.fire();\r\n        }));\r\n        this._register(this.editor.onDidChangeCursorPosition((e) => {\r\n            if (this.isSuggestionPreviewEnabled()) {\r\n                this.minReservedLineCount = 0;\r\n                this.updateCacheSoon.schedule();\r\n                this.onDidChangeEmitter.fire();\r\n            }\r\n        }));\r\n        this._register(Object(lifecycle["toDisposable"])(() => this.suggestionInlineCompletionSource.stopForceRenderingAbove()));\r\n    }\r\n    get isActive() {\r\n        return this.suggestionInlineCompletionSource.state !== undefined;\r\n    }\r\n    isSuggestionPreviewEnabled() {\r\n        const suggestOptions = this.editor.getOption(106 /* suggest */);\r\n        return suggestOptions.preview;\r\n    }\r\n    updateCache() {\r\n        return suggestWidgetPreviewModel_awaiter(this, void 0, void 0, function* () {\r\n            const state = this.suggestionInlineCompletionSource.state;\r\n            if (!state || !state.selectedItemAsInlineCompletion) {\r\n                return;\r\n            }\r\n            const info = {\r\n                text: state.selectedItemAsInlineCompletion.text,\r\n                range: state.selectedItemAsInlineCompletion.range,\r\n            };\r\n            const position = this.editor.getPosition();\r\n            const promise = Object(common_async["createCancelablePromise"])((token) => suggestWidgetPreviewModel_awaiter(this, void 0, void 0, function* () {\r\n                let result;\r\n                try {\r\n                    result = yield provideInlineCompletions(position, this.editor.getModel(), { triggerKind: modes["InlineCompletionTriggerKind"].Automatic, selectedSuggestionInfo: info }, token);\r\n                }\r\n                catch (e) {\r\n                    Object(errors["onUnexpectedError"])(e);\r\n                    return;\r\n                }\r\n                if (token.isCancellationRequested) {\r\n                    return;\r\n                }\r\n                this.cache.setValue(this.editor, result, modes["InlineCompletionTriggerKind"].Automatic);\r\n                this.onDidChangeEmitter.fire();\r\n            }));\r\n            const operation = new UpdateOperation(promise, modes["InlineCompletionTriggerKind"].Automatic);\r\n            this.updateOperation.value = operation;\r\n            yield promise;\r\n            if (this.updateOperation.value === operation) {\r\n                this.updateOperation.clear();\r\n            }\r\n        });\r\n    }\r\n    get ghostText() {\r\n        var _a, _b;\r\n        const suggestWidgetState = this.suggestionInlineCompletionSource.state;\r\n        const originalInlineCompletion = minimizeInlineCompletion(this.editor.getModel(), suggestWidgetState === null || suggestWidgetState === void 0 ? void 0 : suggestWidgetState.selectedItemAsInlineCompletion);\r\n        const augmentedCompletion = minimizeInlineCompletion(this.editor.getModel(), (_b = (_a = this.cache.value) === null || _a === void 0 ? void 0 : _a.completions[0]) === null || _b === void 0 ? void 0 : _b.toLiveInlineCompletion());\r\n        const finalCompletion = augmentedCompletion\r\n            && originalInlineCompletion\r\n            && augmentedCompletion.text.startsWith(originalInlineCompletion.text)\r\n            && augmentedCompletion.range.equalsRange(originalInlineCompletion.range)\r\n            ? augmentedCompletion : (originalInlineCompletion || augmentedCompletion);\r\n        const inlineCompletionPreviewLength = originalInlineCompletion ? ((finalCompletion === null || finalCompletion === void 0 ? void 0 : finalCompletion.text.length) || 0) - (originalInlineCompletion.text.length) : 0;\r\n        const toGhostText = (completion) => {\r\n            const mode = this.editor.getOptions().get(106 /* suggest */).previewMode;\r\n            return completion\r\n                ? (inlineCompletionToGhostText(completion, this.editor.getModel(), mode, this.editor.getPosition(), inlineCompletionPreviewLength) ||\r\n                    // Show an invisible ghost text to reserve space\r\n                    new GhostText(completion.range.endLineNumber, [], this.minReservedLineCount))\r\n                : undefined;\r\n        };\r\n        const newGhostText = toGhostText(finalCompletion);\r\n        return this.isSuggestionPreviewEnabled()\r\n            ? newGhostText\r\n            : undefined;\r\n    }\r\n}\r\nfunction sum(arr) {\r\n    return arr.reduce((a, b) => a + b, 0);\r\n}\r\nfunction lengthOfLongestCommonPrefix(str1, str2) {\r\n    let i = 0;\r\n    while (i < str1.length && i < str2.length && str1[i] === str2[i]) {\r\n        i++;\r\n    }\r\n    return i;\r\n}\r\nfunction lengthOfLongestCommonSuffix(str1, str2) {\r\n    let i = 0;\r\n    while (i < str1.length && i < str2.length && str1[str1.length - i - 1] === str2[str2.length - i - 1]) {\r\n        i++;\r\n    }\r\n    return i;\r\n}\r\nfunction minimizeInlineCompletion(model, inlineCompletion) {\r\n    if (!inlineCompletion) {\r\n        return inlineCompletion;\r\n    }\r\n    const valueToReplace = model.getValueInRange(inlineCompletion.range);\r\n    const commonPrefixLength = lengthOfLongestCommonPrefix(valueToReplace, inlineCompletion.text);\r\n    const startOffset = model.getOffsetAt(inlineCompletion.range.getStartPosition()) + commonPrefixLength;\r\n    const start = model.getPositionAt(startOffset);\r\n    const remainingValueToReplace = valueToReplace.substr(commonPrefixLength);\r\n    const commonSuffixLength = lengthOfLongestCommonSuffix(remainingValueToReplace, inlineCompletion.text);\r\n    const end = model.getPositionAt(Math.max(startOffset, model.getOffsetAt(inlineCompletion.range.getEndPosition()) - commonSuffixLength));\r\n    return {\r\n        range: core_range["Range"].fromPositions(start, end),\r\n        text: inlineCompletion.text.substr(commonPrefixLength, inlineCompletion.text.length - commonPrefixLength - commonSuffixLength),\r\n    };\r\n}\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/utils.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nfunction createDisposableRef(object, disposable) {\r\n    return {\r\n        object,\r\n        dispose: () => disposable === null || disposable === void 0 ? void 0 : disposable.dispose(),\r\n    };\r\n}\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/ghostTextModel.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar ghostTextModel_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar ghostTextModel_param = (undefined && undefined.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nvar ghostTextModel_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass ghostTextModel_DelegatingModel extends lifecycle["Disposable"] {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.onDidChangeEmitter = new common_event["Emitter"]();\r\n        this.onDidChange = this.onDidChangeEmitter.event;\r\n        this.hasCachedGhostText = false;\r\n        this.currentModelRef = this._register(new lifecycle["MutableDisposable"]());\r\n    }\r\n    get targetModel() {\r\n        var _a;\r\n        return (_a = this.currentModelRef.value) === null || _a === void 0 ? void 0 : _a.object;\r\n    }\r\n    setTargetModel(model) {\r\n        var _a;\r\n        if (((_a = this.currentModelRef.value) === null || _a === void 0 ? void 0 : _a.object) === model) {\r\n            return;\r\n        }\r\n        this.currentModelRef.clear();\r\n        this.currentModelRef.value = model ? createDisposableRef(model, model.onDidChange(() => {\r\n            this.hasCachedGhostText = false;\r\n            this.onDidChangeEmitter.fire();\r\n        })) : undefined;\r\n        this.hasCachedGhostText = false;\r\n        this.onDidChangeEmitter.fire();\r\n    }\r\n    get ghostText() {\r\n        var _a, _b;\r\n        if (!this.hasCachedGhostText) {\r\n            this.cachedGhostText = (_b = (_a = this.currentModelRef.value) === null || _a === void 0 ? void 0 : _a.object) === null || _b === void 0 ? void 0 : _b.ghostText;\r\n            this.hasCachedGhostText = true;\r\n        }\r\n        return this.cachedGhostText;\r\n    }\r\n    setExpanded(expanded) {\r\n        var _a;\r\n        (_a = this.targetModel) === null || _a === void 0 ? void 0 : _a.setExpanded(expanded);\r\n    }\r\n    get minReservedLineCount() {\r\n        return this.targetModel ? this.targetModel.minReservedLineCount : 0;\r\n    }\r\n}\r\n/**\r\n * A ghost text model that is both driven by inline completions and the suggest widget.\r\n*/\r\nlet ghostTextModel_GhostTextModel = class GhostTextModel extends ghostTextModel_DelegatingModel {\r\n    constructor(editor, commandService) {\r\n        super();\r\n        this.editor = editor;\r\n        this.commandService = commandService;\r\n        this.sharedCache = this._register(new ghostTextModel_SharedInlineCompletionCache());\r\n        this.suggestWidgetAdapterModel = this._register(new suggestWidgetPreviewModel_SuggestWidgetPreviewModel(this.editor, this.sharedCache));\r\n        this.inlineCompletionsModel = this._register(new inlineCompletionsModel_InlineCompletionsModel(this.editor, this.sharedCache, this.commandService));\r\n        this._register(this.suggestWidgetAdapterModel.onDidChange(() => {\r\n            this.updateModel();\r\n        }));\r\n        this.updateModel();\r\n    }\r\n    get activeInlineCompletionsModel() {\r\n        if (this.targetModel === this.inlineCompletionsModel) {\r\n            return this.inlineCompletionsModel;\r\n        }\r\n        return undefined;\r\n    }\r\n    updateModel() {\r\n        this.setTargetModel(this.suggestWidgetAdapterModel.isActive\r\n            ? this.suggestWidgetAdapterModel\r\n            : this.inlineCompletionsModel);\r\n        this.inlineCompletionsModel.setActive(this.targetModel === this.inlineCompletionsModel);\r\n    }\r\n    shouldShowHoverAt(hoverRange) {\r\n        var _a;\r\n        const ghostText = (_a = this.activeInlineCompletionsModel) === null || _a === void 0 ? void 0 : _a.ghostText;\r\n        if (ghostText) {\r\n            return ghostText.parts.some(p => hoverRange.containsPosition(new core_position["Position"](ghostText.lineNumber, p.column)));\r\n        }\r\n        return false;\r\n    }\r\n    triggerInlineCompletion() {\r\n        var _a;\r\n        (_a = this.activeInlineCompletionsModel) === null || _a === void 0 ? void 0 : _a.trigger(modes["InlineCompletionTriggerKind"].Explicit);\r\n    }\r\n    commitInlineCompletion() {\r\n        var _a;\r\n        (_a = this.activeInlineCompletionsModel) === null || _a === void 0 ? void 0 : _a.commitCurrentSuggestion();\r\n    }\r\n    hideInlineCompletion() {\r\n        var _a;\r\n        (_a = this.activeInlineCompletionsModel) === null || _a === void 0 ? void 0 : _a.hide();\r\n    }\r\n    showNextInlineCompletion() {\r\n        var _a;\r\n        (_a = this.activeInlineCompletionsModel) === null || _a === void 0 ? void 0 : _a.showNext();\r\n    }\r\n    showPreviousInlineCompletion() {\r\n        var _a;\r\n        (_a = this.activeInlineCompletionsModel) === null || _a === void 0 ? void 0 : _a.showPrevious();\r\n    }\r\n    hasMultipleInlineCompletions() {\r\n        var _a;\r\n        return ghostTextModel_awaiter(this, void 0, void 0, function* () {\r\n            const result = yield ((_a = this.activeInlineCompletionsModel) === null || _a === void 0 ? void 0 : _a.hasMultipleInlineCompletions());\r\n            return result !== undefined ? result : false;\r\n        });\r\n    }\r\n};\r\nghostTextModel_GhostTextModel = ghostTextModel_decorate([\r\n    ghostTextModel_param(1, common_commands["ICommandService"])\r\n], ghostTextModel_GhostTextModel);\r\n\r\nclass ghostTextModel_SharedInlineCompletionCache extends lifecycle["Disposable"] {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.onDidChangeEmitter = new common_event["Emitter"]();\r\n        this.onDidChange = this.onDidChangeEmitter.event;\r\n        this.cache = this._register(new lifecycle["MutableDisposable"]());\r\n    }\r\n    get value() {\r\n        return this.cache.value;\r\n    }\r\n    setValue(editor, completionsSource, triggerKind) {\r\n        this.cache.value = new inlineCompletionsModel_SynchronizedInlineCompletionsCache(editor, completionsSource, () => this.onDidChangeEmitter.fire(), triggerKind);\r\n    }\r\n    clearAndLeak() {\r\n        return this.cache.clearAndLeak();\r\n    }\r\n    clear() {\r\n        this.cache.clear();\r\n    }\r\n}\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/ghostTextController.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar ghostTextController_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar ghostTextController_param = (undefined && undefined.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nvar ghostTextController_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nlet ghostTextController_GhostTextController = class GhostTextController extends lifecycle["Disposable"] {\r\n    constructor(editor, instantiationService) {\r\n        super();\r\n        this.editor = editor;\r\n        this.instantiationService = instantiationService;\r\n        this.triggeredExplicitly = false;\r\n        this.activeController = this._register(new lifecycle["MutableDisposable"]());\r\n        this._register(this.editor.onDidChangeModel(() => {\r\n            this.updateModelController();\r\n        }));\r\n        this._register(this.editor.onDidChangeConfiguration((e) => {\r\n            if (e.hasChanged(106 /* suggest */)) {\r\n                this.updateModelController();\r\n            }\r\n            if (e.hasChanged(54 /* inlineSuggest */)) {\r\n                this.updateModelController();\r\n            }\r\n        }));\r\n        this.updateModelController();\r\n    }\r\n    static get(editor) {\r\n        return editor.getContribution(GhostTextController.ID);\r\n    }\r\n    get activeModel() {\r\n        var _a;\r\n        return (_a = this.activeController.value) === null || _a === void 0 ? void 0 : _a.model;\r\n    }\r\n    // Don\'t call this method when not neccessary. It will recreate the activeController.\r\n    updateModelController() {\r\n        const suggestOptions = this.editor.getOption(106 /* suggest */);\r\n        const inlineSuggestOptions = this.editor.getOption(54 /* inlineSuggest */);\r\n        this.activeController.value = undefined;\r\n        // ActiveGhostTextController is only created if one of those settings is set or if the inline completions are triggered explicitly.\r\n        this.activeController.value =\r\n            this.editor.hasModel() && (suggestOptions.preview || inlineSuggestOptions.enabled || this.triggeredExplicitly)\r\n                ? this.instantiationService.createInstance(ghostTextController_ActiveGhostTextController, this.editor)\r\n                : undefined;\r\n    }\r\n    shouldShowHoverAt(hoverRange) {\r\n        var _a;\r\n        return ((_a = this.activeModel) === null || _a === void 0 ? void 0 : _a.shouldShowHoverAt(hoverRange)) || false;\r\n    }\r\n    shouldShowHoverAtViewZone(viewZoneId) {\r\n        var _a, _b;\r\n        return ((_b = (_a = this.activeController.value) === null || _a === void 0 ? void 0 : _a.widget) === null || _b === void 0 ? void 0 : _b.shouldShowHoverAtViewZone(viewZoneId)) || false;\r\n    }\r\n    trigger() {\r\n        var _a;\r\n        this.triggeredExplicitly = true;\r\n        if (!this.activeController.value) {\r\n            this.updateModelController();\r\n        }\r\n        (_a = this.activeModel) === null || _a === void 0 ? void 0 : _a.triggerInlineCompletion();\r\n    }\r\n    commit() {\r\n        var _a;\r\n        (_a = this.activeModel) === null || _a === void 0 ? void 0 : _a.commitInlineCompletion();\r\n    }\r\n    hide() {\r\n        var _a;\r\n        (_a = this.activeModel) === null || _a === void 0 ? void 0 : _a.hideInlineCompletion();\r\n    }\r\n    showNextInlineCompletion() {\r\n        var _a;\r\n        (_a = this.activeModel) === null || _a === void 0 ? void 0 : _a.showNextInlineCompletion();\r\n    }\r\n    showPreviousInlineCompletion() {\r\n        var _a;\r\n        (_a = this.activeModel) === null || _a === void 0 ? void 0 : _a.showPreviousInlineCompletion();\r\n    }\r\n    hasMultipleInlineCompletions() {\r\n        var _a;\r\n        return ghostTextController_awaiter(this, void 0, void 0, function* () {\r\n            const result = yield ((_a = this.activeModel) === null || _a === void 0 ? void 0 : _a.hasMultipleInlineCompletions());\r\n            return result !== undefined ? result : false;\r\n        });\r\n    }\r\n};\r\nghostTextController_GhostTextController.inlineSuggestionVisible = new contextkey["RawContextKey"](\'inlineSuggestionVisible\', false, nls["localize"](\'inlineSuggestionVisible\', "Whether an inline suggestion is visible"));\r\nghostTextController_GhostTextController.inlineSuggestionHasIndentation = new contextkey["RawContextKey"](\'inlineSuggestionHasIndentation\', false, nls["localize"](\'inlineSuggestionHasIndentation\', "Whether the inline suggestion starts with whitespace"));\r\nghostTextController_GhostTextController.ID = \'editor.contrib.ghostTextController\';\r\nghostTextController_GhostTextController = ghostTextController_decorate([\r\n    ghostTextController_param(1, instantiation["IInstantiationService"])\r\n], ghostTextController_GhostTextController);\r\n\r\nclass GhostTextContextKeys {\r\n    constructor(contextKeyService) {\r\n        this.contextKeyService = contextKeyService;\r\n        this.inlineCompletionVisible = ghostTextController_GhostTextController.inlineSuggestionVisible.bindTo(this.contextKeyService);\r\n        this.inlineCompletionSuggestsIndentation = ghostTextController_GhostTextController.inlineSuggestionHasIndentation.bindTo(this.contextKeyService);\r\n    }\r\n}\r\n/**\r\n * The controller for a text editor with an initialized text model.\r\n * Must be disposed as soon as the model detaches from the editor.\r\n*/\r\nlet ghostTextController_ActiveGhostTextController = class ActiveGhostTextController extends lifecycle["Disposable"] {\r\n    constructor(editor, instantiationService, contextKeyService) {\r\n        super();\r\n        this.editor = editor;\r\n        this.instantiationService = instantiationService;\r\n        this.contextKeyService = contextKeyService;\r\n        this.contextKeys = new GhostTextContextKeys(this.contextKeyService);\r\n        this.model = this._register(this.instantiationService.createInstance(ghostTextModel_GhostTextModel, this.editor));\r\n        this.widget = this._register(this.instantiationService.createInstance(ghostTextWidget_GhostTextWidget, this.editor, this.model));\r\n        this._register(Object(lifecycle["toDisposable"])(() => {\r\n            this.contextKeys.inlineCompletionVisible.set(false);\r\n            this.contextKeys.inlineCompletionSuggestsIndentation.set(false);\r\n        }));\r\n        this._register(this.model.onDidChange(() => {\r\n            this.updateContextKeys();\r\n        }));\r\n        this.updateContextKeys();\r\n    }\r\n    updateContextKeys() {\r\n        var _a;\r\n        this.contextKeys.inlineCompletionVisible.set(((_a = this.model.activeInlineCompletionsModel) === null || _a === void 0 ? void 0 : _a.ghostText) !== undefined);\r\n        const ghostText = this.model.inlineCompletionsModel.ghostText;\r\n        if (ghostText && ghostText.parts.length > 0) {\r\n            const { column, lines } = ghostText.parts[0];\r\n            const suggestionStartsWithWs = lines[0].startsWith(\' \') || lines[0].startsWith(\'\\t\');\r\n            const indentationEndColumn = this.editor.getModel().getLineIndentColumn(ghostText.lineNumber);\r\n            const inIndentation = column <= indentationEndColumn;\r\n            this.contextKeys.inlineCompletionSuggestsIndentation.set(!!this.model.activeInlineCompletionsModel\r\n                && suggestionStartsWithWs && inIndentation);\r\n        }\r\n        else {\r\n            this.contextKeys.inlineCompletionSuggestsIndentation.set(false);\r\n        }\r\n    }\r\n};\r\nghostTextController_ActiveGhostTextController = ghostTextController_decorate([\r\n    ghostTextController_param(1, instantiation["IInstantiationService"]),\r\n    ghostTextController_param(2, contextkey["IContextKeyService"])\r\n], ghostTextController_ActiveGhostTextController);\r\n\r\nconst GhostTextCommand = editorExtensions["EditorCommand"].bindToContribution(ghostTextController_GhostTextController.get);\r\nconst commitInlineSuggestionAction = new GhostTextCommand({\r\n    id: inlineSuggestCommitId,\r\n    precondition: ghostTextController_GhostTextController.inlineSuggestionVisible,\r\n    handler(x) {\r\n        x.commit();\r\n        x.editor.focus();\r\n    }\r\n});\r\nObject(editorExtensions["registerEditorCommand"])(commitInlineSuggestionAction);\r\nkeybindingsRegistry["KeybindingsRegistry"].registerKeybindingRule({\r\n    primary: 2 /* Tab */,\r\n    weight: 200,\r\n    id: commitInlineSuggestionAction.id,\r\n    when: contextkey["ContextKeyExpr"].and(commitInlineSuggestionAction.precondition, editorContextKeys["EditorContextKeys"].tabMovesFocus.toNegated(), ghostTextController_GhostTextController.inlineSuggestionHasIndentation.toNegated()),\r\n});\r\nObject(editorExtensions["registerEditorCommand"])(new GhostTextCommand({\r\n    id: \'editor.action.inlineSuggest.hide\',\r\n    precondition: ghostTextController_GhostTextController.inlineSuggestionVisible,\r\n    kbOpts: {\r\n        weight: 100,\r\n        primary: 9 /* Escape */,\r\n    },\r\n    handler(x) {\r\n        x.hide();\r\n    }\r\n}));\r\nclass ghostTextController_ShowNextInlineSuggestionAction extends editorExtensions["EditorAction"] {\r\n    constructor() {\r\n        super({\r\n            id: ghostTextController_ShowNextInlineSuggestionAction.ID,\r\n            label: nls["localize"](\'action.inlineSuggest.showNext\', "Show Next Inline Suggestion"),\r\n            alias: \'Show Next Inline Suggestion\',\r\n            precondition: contextkey["ContextKeyExpr"].and(editorContextKeys["EditorContextKeys"].writable, ghostTextController_GhostTextController.inlineSuggestionVisible),\r\n            kbOpts: {\r\n                weight: 100,\r\n                primary: 512 /* Alt */ | 89 /* US_CLOSE_SQUARE_BRACKET */,\r\n            },\r\n        });\r\n    }\r\n    run(accessor, editor) {\r\n        return ghostTextController_awaiter(this, void 0, void 0, function* () {\r\n            const controller = ghostTextController_GhostTextController.get(editor);\r\n            if (controller) {\r\n                controller.showNextInlineCompletion();\r\n                editor.focus();\r\n            }\r\n        });\r\n    }\r\n}\r\nghostTextController_ShowNextInlineSuggestionAction.ID = \'editor.action.inlineSuggest.showNext\';\r\nclass ghostTextController_ShowPreviousInlineSuggestionAction extends editorExtensions["EditorAction"] {\r\n    constructor() {\r\n        super({\r\n            id: ghostTextController_ShowPreviousInlineSuggestionAction.ID,\r\n            label: nls["localize"](\'action.inlineSuggest.showPrevious\', "Show Previous Inline Suggestion"),\r\n            alias: \'Show Previous Inline Suggestion\',\r\n            precondition: contextkey["ContextKeyExpr"].and(editorContextKeys["EditorContextKeys"].writable, ghostTextController_GhostTextController.inlineSuggestionVisible),\r\n            kbOpts: {\r\n                weight: 100,\r\n                primary: 512 /* Alt */ | 87 /* US_OPEN_SQUARE_BRACKET */,\r\n            },\r\n        });\r\n    }\r\n    run(accessor, editor) {\r\n        return ghostTextController_awaiter(this, void 0, void 0, function* () {\r\n            const controller = ghostTextController_GhostTextController.get(editor);\r\n            if (controller) {\r\n                controller.showPreviousInlineCompletion();\r\n                editor.focus();\r\n            }\r\n        });\r\n    }\r\n}\r\nghostTextController_ShowPreviousInlineSuggestionAction.ID = \'editor.action.inlineSuggest.showPrevious\';\r\nclass ghostTextController_TriggerInlineSuggestionAction extends editorExtensions["EditorAction"] {\r\n    constructor() {\r\n        super({\r\n            id: \'editor.action.inlineSuggest.trigger\',\r\n            label: nls["localize"](\'action.inlineSuggest.trigger\', "Trigger Inline Suggestion"),\r\n            alias: \'Trigger Inline Suggestion\',\r\n            precondition: editorContextKeys["EditorContextKeys"].writable\r\n        });\r\n    }\r\n    run(accessor, editor) {\r\n        return ghostTextController_awaiter(this, void 0, void 0, function* () {\r\n            const controller = ghostTextController_GhostTextController.get(editor);\r\n            if (controller) {\r\n                controller.trigger();\r\n            }\r\n        });\r\n    }\r\n}\r\nObject(editorExtensions["registerEditorContribution"])(ghostTextController_GhostTextController.ID, ghostTextController_GhostTextController);\r\nObject(editorExtensions["registerEditorAction"])(ghostTextController_TriggerInlineSuggestionAction);\r\nObject(editorExtensions["registerEditorAction"])(ghostTextController_ShowNextInlineSuggestionAction);\r\nObject(editorExtensions["registerEditorAction"])(ghostTextController_ShowPreviousInlineSuggestionAction);\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/inlineCompletionsHoverParticipant.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar inlineCompletionsHoverParticipant_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar inlineCompletionsHoverParticipant_param = (undefined && undefined.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass InlineCompletionsHover {\r\n    constructor(owner, range, controller) {\r\n        this.owner = owner;\r\n        this.range = range;\r\n        this.controller = controller;\r\n    }\r\n    isValidForHoverAnchor(anchor) {\r\n        return (anchor.type === 1 /* Range */\r\n            && this.range.startColumn <= anchor.range.startColumn\r\n            && this.range.endColumn >= anchor.range.endColumn);\r\n    }\r\n    hasMultipleSuggestions() {\r\n        return this.controller.hasMultipleInlineCompletions();\r\n    }\r\n}\r\nlet inlineCompletionsHoverParticipant_InlineCompletionsHoverParticipant = class InlineCompletionsHoverParticipant {\r\n    constructor(_editor, _hover, _commandService, _menuService, _contextKeyService, _modeService, _openerService, accessibilityService) {\r\n        this._editor = _editor;\r\n        this._hover = _hover;\r\n        this._commandService = _commandService;\r\n        this._menuService = _menuService;\r\n        this._contextKeyService = _contextKeyService;\r\n        this._modeService = _modeService;\r\n        this._openerService = _openerService;\r\n        this.accessibilityService = accessibilityService;\r\n    }\r\n    suggestHoverAnchor(mouseEvent) {\r\n        const controller = ghostTextController_GhostTextController.get(this._editor);\r\n        if (!controller) {\r\n            return null;\r\n        }\r\n        if (mouseEvent.target.type === 8 /* CONTENT_VIEW_ZONE */) {\r\n            // handle the case where the mouse is over the view zone\r\n            const viewZoneData = mouseEvent.target.detail;\r\n            if (controller.shouldShowHoverAtViewZone(viewZoneData.viewZoneId)) {\r\n                return new HoverForeignElementAnchor(1000, this, core_range["Range"].fromPositions(viewZoneData.positionBefore || viewZoneData.position, viewZoneData.positionBefore || viewZoneData.position));\r\n            }\r\n        }\r\n        if (mouseEvent.target.type === 7 /* CONTENT_EMPTY */ && mouseEvent.target.range) {\r\n            // handle the case where the mouse is over the empty portion of a line following ghost text\r\n            if (controller.shouldShowHoverAt(mouseEvent.target.range)) {\r\n                return new HoverForeignElementAnchor(1000, this, mouseEvent.target.range);\r\n            }\r\n        }\r\n        if (mouseEvent.target.type === 6 /* CONTENT_TEXT */ && mouseEvent.target.range && mouseEvent.target.detail) {\r\n            // handle the case where the mouse is directly over ghost text\r\n            const mightBeForeignElement = mouseEvent.target.detail.mightBeForeignElement;\r\n            if (mightBeForeignElement && controller.shouldShowHoverAt(mouseEvent.target.range)) {\r\n                return new HoverForeignElementAnchor(1000, this, mouseEvent.target.range);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    computeSync(anchor, lineDecorations) {\r\n        const controller = ghostTextController_GhostTextController.get(this._editor);\r\n        if (controller && controller.shouldShowHoverAt(anchor.range)) {\r\n            return [new InlineCompletionsHover(this, anchor.range, controller)];\r\n        }\r\n        return [];\r\n    }\r\n    renderHoverParts(hoverParts, fragment, statusBar) {\r\n        const disposableStore = new lifecycle["DisposableStore"]();\r\n        const part = hoverParts[0];\r\n        if (this.accessibilityService.isScreenReaderOptimized()) {\r\n            this.renderScreenReaderText(part, fragment, disposableStore);\r\n        }\r\n        const menu = disposableStore.add(this._menuService.createMenu(actions_common_actions["MenuId"].InlineCompletionsActions, this._contextKeyService));\r\n        const previousAction = statusBar.addAction({\r\n            label: nls["localize"](\'showNextInlineSuggestion\', "Next"),\r\n            commandId: ghostTextController_ShowNextInlineSuggestionAction.ID,\r\n            run: () => this._commandService.executeCommand(ghostTextController_ShowNextInlineSuggestionAction.ID)\r\n        });\r\n        const nextAction = statusBar.addAction({\r\n            label: nls["localize"](\'showPreviousInlineSuggestion\', "Previous"),\r\n            commandId: ghostTextController_ShowPreviousInlineSuggestionAction.ID,\r\n            run: () => this._commandService.executeCommand(ghostTextController_ShowPreviousInlineSuggestionAction.ID)\r\n        });\r\n        statusBar.addAction({\r\n            label: nls["localize"](\'acceptInlineSuggestion\', "Accept"),\r\n            commandId: commitInlineSuggestionAction.id,\r\n            run: () => this._commandService.executeCommand(commitInlineSuggestionAction.id)\r\n        });\r\n        const actions = [previousAction, nextAction];\r\n        for (const action of actions) {\r\n            action.setEnabled(false);\r\n        }\r\n        part.hasMultipleSuggestions().then(hasMore => {\r\n            for (const action of actions) {\r\n                action.setEnabled(hasMore);\r\n            }\r\n        });\r\n        for (const [_, group] of menu.getActions()) {\r\n            for (const action of group) {\r\n                if (action instanceof actions_common_actions["MenuItemAction"]) {\r\n                    statusBar.addAction({\r\n                        label: action.label,\r\n                        commandId: action.item.id,\r\n                        run: () => this._commandService.executeCommand(action.item.id)\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        return disposableStore;\r\n    }\r\n    renderScreenReaderText(part, fragment, disposableStore) {\r\n        var _a, _b;\r\n        const $ = dom["$"];\r\n        const markdownHoverElement = $(\'div.hover-row.markdown-hover\');\r\n        const hoverContentsElement = dom["append"](markdownHoverElement, $(\'div.hover-contents\'));\r\n        const renderer = disposableStore.add(new markdownRenderer_MarkdownRenderer({ editor: this._editor }, this._modeService, this._openerService));\r\n        const render = (code) => {\r\n            disposableStore.add(renderer.onDidRenderAsync(() => {\r\n                hoverContentsElement.className = \'hover-contents code-hover-contents\';\r\n                this._hover.onContentsChanged();\r\n            }));\r\n            const inlineSuggestionAvailable = nls["localize"](\'inlineSuggestionFollows\', "Suggestion:");\r\n            const renderedContents = disposableStore.add(renderer.render(new htmlContent_MarkdownString().appendText(inlineSuggestionAvailable).appendCodeblock(\'text\', code)));\r\n            hoverContentsElement.replaceChildren(renderedContents.element);\r\n        };\r\n        const ghostText = (_b = (_a = part.controller.activeModel) === null || _a === void 0 ? void 0 : _a.inlineCompletionsModel) === null || _b === void 0 ? void 0 : _b.ghostText;\r\n        if (ghostText) {\r\n            const lineText = this._editor.getModel().getLineContent(ghostText.lineNumber);\r\n            render(ghostText.renderForScreenReader(lineText));\r\n        }\r\n        fragment.appendChild(markdownHoverElement);\r\n    }\r\n};\r\ninlineCompletionsHoverParticipant_InlineCompletionsHoverParticipant = inlineCompletionsHoverParticipant_decorate([\r\n    inlineCompletionsHoverParticipant_param(2, common_commands["ICommandService"]),\r\n    inlineCompletionsHoverParticipant_param(3, actions_common_actions["IMenuService"]),\r\n    inlineCompletionsHoverParticipant_param(4, contextkey["IContextKeyService"]),\r\n    inlineCompletionsHoverParticipant_param(5, services_modeService["IModeService"]),\r\n    inlineCompletionsHoverParticipant_param(6, common_opener["IOpenerService"]),\r\n    inlineCompletionsHoverParticipant_param(7, accessibility["IAccessibilityService"])\r\n], inlineCompletionsHoverParticipant_InlineCompletionsHoverParticipant);\r\n\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/color.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction getColors(model, token) {\r\n    const colors = [];\r\n    const providers = modes["ColorProviderRegistry"].ordered(model).reverse();\r\n    const promises = providers.map(provider => Promise.resolve(provider.provideDocumentColors(model, token)).then(result => {\r\n        if (Array.isArray(result)) {\r\n            for (let colorInfo of result) {\r\n                colors.push({ colorInfo, provider });\r\n            }\r\n        }\r\n    }));\r\n    return Promise.all(promises).then(() => colors);\r\n}\r\nfunction getColorPresentations(model, colorInfo, provider, token) {\r\n    return Promise.resolve(provider.provideColorPresentations(model, colorInfo, token));\r\n}\r\ncommon_commands["CommandsRegistry"].registerCommand(\'_executeDocumentColorProvider\', function (accessor, ...args) {\r\n    const [resource] = args;\r\n    if (!(resource instanceof common_uri["URI"])) {\r\n        throw Object(errors["illegalArgument"])();\r\n    }\r\n    const model = accessor.get(services_modelService["IModelService"]).getModel(resource);\r\n    if (!model) {\r\n        throw Object(errors["illegalArgument"])();\r\n    }\r\n    const rawCIs = [];\r\n    const providers = modes["ColorProviderRegistry"].ordered(model).reverse();\r\n    const promises = providers.map(provider => Promise.resolve(provider.provideDocumentColors(model, cancellation["CancellationToken"].None)).then(result => {\r\n        if (Array.isArray(result)) {\r\n            for (let ci of result) {\r\n                rawCIs.push({ range: ci.range, color: [ci.color.red, ci.color.green, ci.color.blue, ci.color.alpha] });\r\n            }\r\n        }\r\n    }));\r\n    return Promise.all(promises).then(() => rawCIs);\r\n});\r\ncommon_commands["CommandsRegistry"].registerCommand(\'_executeColorPresentationProvider\', function (accessor, ...args) {\r\n    const [color, context] = args;\r\n    const { uri, range } = context;\r\n    if (!(uri instanceof common_uri["URI"]) || !Array.isArray(color) || color.length !== 4 || !core_range["Range"].isIRange(range)) {\r\n        throw Object(errors["illegalArgument"])();\r\n    }\r\n    const [red, green, blue, alpha] = color;\r\n    const model = accessor.get(services_modelService["IModelService"]).getModel(uri);\r\n    if (!model) {\r\n        throw Object(errors["illegalArgument"])();\r\n    }\r\n    const colorInfo = {\r\n        range,\r\n        color: { red, green, blue, alpha }\r\n    };\r\n    const presentations = [];\r\n    const providers = modes["ColorProviderRegistry"].ordered(model).reverse();\r\n    const promises = providers.map(provider => Promise.resolve(provider.provideColorPresentations(model, colorInfo, cancellation["CancellationToken"].None)).then(result => {\r\n        if (Array.isArray(result)) {\r\n            presentations.push(...result);\r\n        }\r\n    }));\r\n    return Promise.all(promises).then(() => presentations);\r\n});\r\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/common/hash.js\nvar hash = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/common/hash.js");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/colorDetector.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar colorDetector_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar colorDetector_param = (undefined && undefined.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst MAX_DECORATORS = 500;\r\nlet colorDetector_ColorDetector = class ColorDetector extends lifecycle["Disposable"] {\r\n    constructor(_editor, _codeEditorService, _configurationService) {\r\n        super();\r\n        this._editor = _editor;\r\n        this._codeEditorService = _codeEditorService;\r\n        this._configurationService = _configurationService;\r\n        this._localToDispose = this._register(new lifecycle["DisposableStore"]());\r\n        this._decorationsIds = [];\r\n        this._colorDatas = new Map();\r\n        this._colorDecoratorIds = [];\r\n        this._decorationsTypes = new Set();\r\n        this._register(_editor.onDidChangeModel(() => {\r\n            this._isEnabled = this.isEnabled();\r\n            this.onModelChanged();\r\n        }));\r\n        this._register(_editor.onDidChangeModelLanguage(() => this.onModelChanged()));\r\n        this._register(modes["ColorProviderRegistry"].onDidChange(() => this.onModelChanged()));\r\n        this._register(_editor.onDidChangeConfiguration(() => {\r\n            let prevIsEnabled = this._isEnabled;\r\n            this._isEnabled = this.isEnabled();\r\n            if (prevIsEnabled !== this._isEnabled) {\r\n                if (this._isEnabled) {\r\n                    this.onModelChanged();\r\n                }\r\n                else {\r\n                    this.removeAllDecorations();\r\n                }\r\n            }\r\n        }));\r\n        this._timeoutTimer = null;\r\n        this._computePromise = null;\r\n        this._isEnabled = this.isEnabled();\r\n        this.onModelChanged();\r\n    }\r\n    isEnabled() {\r\n        const model = this._editor.getModel();\r\n        if (!model) {\r\n            return false;\r\n        }\r\n        const languageId = model.getLanguageIdentifier();\r\n        // handle deprecated settings. [languageId].colorDecorators.enable\r\n        const deprecatedConfig = this._configurationService.getValue(languageId.language);\r\n        if (deprecatedConfig && typeof deprecatedConfig === \'object\') {\r\n            const colorDecorators = deprecatedConfig[\'colorDecorators\']; // deprecatedConfig.valueOf(\'.colorDecorators.enable\');\r\n            if (colorDecorators && colorDecorators[\'enable\'] !== undefined && !colorDecorators[\'enable\']) {\r\n                return colorDecorators[\'enable\'];\r\n            }\r\n        }\r\n        return this._editor.getOption(16 /* colorDecorators */);\r\n    }\r\n    static get(editor) {\r\n        return editor.getContribution(this.ID);\r\n    }\r\n    dispose() {\r\n        this.stop();\r\n        this.removeAllDecorations();\r\n        super.dispose();\r\n    }\r\n    onModelChanged() {\r\n        this.stop();\r\n        if (!this._isEnabled) {\r\n            return;\r\n        }\r\n        const model = this._editor.getModel();\r\n        if (!model || !modes["ColorProviderRegistry"].has(model)) {\r\n            return;\r\n        }\r\n        this._localToDispose.add(this._editor.onDidChangeModelContent(() => {\r\n            if (!this._timeoutTimer) {\r\n                this._timeoutTimer = new common_async["TimeoutTimer"]();\r\n                this._timeoutTimer.cancelAndSet(() => {\r\n                    this._timeoutTimer = null;\r\n                    this.beginCompute();\r\n                }, ColorDetector.RECOMPUTE_TIME);\r\n            }\r\n        }));\r\n        this.beginCompute();\r\n    }\r\n    beginCompute() {\r\n        this._computePromise = Object(common_async["createCancelablePromise"])(token => {\r\n            const model = this._editor.getModel();\r\n            if (!model) {\r\n                return Promise.resolve([]);\r\n            }\r\n            return getColors(model, token);\r\n        });\r\n        this._computePromise.then((colorInfos) => {\r\n            this.updateDecorations(colorInfos);\r\n            this.updateColorDecorators(colorInfos);\r\n            this._computePromise = null;\r\n        }, errors["onUnexpectedError"]);\r\n    }\r\n    stop() {\r\n        if (this._timeoutTimer) {\r\n            this._timeoutTimer.cancel();\r\n            this._timeoutTimer = null;\r\n        }\r\n        if (this._computePromise) {\r\n            this._computePromise.cancel();\r\n            this._computePromise = null;\r\n        }\r\n        this._localToDispose.clear();\r\n    }\r\n    updateDecorations(colorDatas) {\r\n        const decorations = colorDatas.map(c => ({\r\n            range: {\r\n                startLineNumber: c.colorInfo.range.startLineNumber,\r\n                startColumn: c.colorInfo.range.startColumn,\r\n                endLineNumber: c.colorInfo.range.endLineNumber,\r\n                endColumn: c.colorInfo.range.endColumn\r\n            },\r\n            options: model_textModel["ModelDecorationOptions"].EMPTY\r\n        }));\r\n        this._decorationsIds = this._editor.deltaDecorations(this._decorationsIds, decorations);\r\n        this._colorDatas = new Map();\r\n        this._decorationsIds.forEach((id, i) => this._colorDatas.set(id, colorDatas[i]));\r\n    }\r\n    updateColorDecorators(colorData) {\r\n        let decorations = [];\r\n        let newDecorationsTypes = {};\r\n        for (let i = 0; i < colorData.length && decorations.length < MAX_DECORATORS; i++) {\r\n            const { red, green, blue, alpha } = colorData[i].colorInfo.color;\r\n            const rgba = new common_color["RGBA"](Math.round(red * 255), Math.round(green * 255), Math.round(blue * 255), alpha);\r\n            let subKey = Object(hash["hash"])(`rgba(${rgba.r},${rgba.g},${rgba.b},${rgba.a})`).toString(16);\r\n            let color = `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, ${rgba.a})`;\r\n            let key = \'colorBox-\' + subKey;\r\n            if (!this._decorationsTypes.has(key) && !newDecorationsTypes[key]) {\r\n                this._codeEditorService.registerDecorationType(\'color-detector-color\', key, {\r\n                    before: {\r\n                        contentText: \' \',\r\n                        border: \'solid 0.1em #000\',\r\n                        margin: \'0.1em 0.2em 0 0.2em\',\r\n                        width: \'0.8em\',\r\n                        height: \'0.8em\',\r\n                        backgroundColor: color\r\n                    },\r\n                    dark: {\r\n                        before: {\r\n                            border: \'solid 0.1em #eee\'\r\n                        }\r\n                    }\r\n                }, undefined, this._editor);\r\n            }\r\n            newDecorationsTypes[key] = true;\r\n            decorations.push({\r\n                range: {\r\n                    startLineNumber: colorData[i].colorInfo.range.startLineNumber,\r\n                    startColumn: colorData[i].colorInfo.range.startColumn,\r\n                    endLineNumber: colorData[i].colorInfo.range.endLineNumber,\r\n                    endColumn: colorData[i].colorInfo.range.endColumn\r\n                },\r\n                options: this._codeEditorService.resolveDecorationOptions(key, true)\r\n            });\r\n        }\r\n        this._decorationsTypes.forEach(subType => {\r\n            if (!newDecorationsTypes[subType]) {\r\n                this._codeEditorService.removeDecorationType(subType);\r\n            }\r\n        });\r\n        this._colorDecoratorIds = this._editor.deltaDecorations(this._colorDecoratorIds, decorations);\r\n    }\r\n    removeAllDecorations() {\r\n        this._decorationsIds = this._editor.deltaDecorations(this._decorationsIds, []);\r\n        this._colorDecoratorIds = this._editor.deltaDecorations(this._colorDecoratorIds, []);\r\n        this._decorationsTypes.forEach(subType => {\r\n            this._codeEditorService.removeDecorationType(subType);\r\n        });\r\n    }\r\n    getColorData(position) {\r\n        const model = this._editor.getModel();\r\n        if (!model) {\r\n            return null;\r\n        }\r\n        const decorations = model\r\n            .getDecorationsInRange(core_range["Range"].fromPositions(position, position))\r\n            .filter(d => this._colorDatas.has(d.id));\r\n        if (decorations.length === 0) {\r\n            return null;\r\n        }\r\n        return this._colorDatas.get(decorations[0].id);\r\n    }\r\n};\r\ncolorDetector_ColorDetector.ID = \'editor.contrib.colorDetector\';\r\ncolorDetector_ColorDetector.RECOMPUTE_TIME = 1000; // ms\r\ncolorDetector_ColorDetector = colorDetector_decorate([\r\n    colorDetector_param(1, services_codeEditorService["ICodeEditorService"]),\r\n    colorDetector_param(2, configuration["IConfigurationService"])\r\n], colorDetector_ColorDetector);\r\n\r\nObject(editorExtensions["registerEditorContribution"])(colorDetector_ColorDetector.ID, colorDetector_ColorDetector);\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/colorPickerModel.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\nclass colorPickerModel_ColorPickerModel {\r\n    constructor(color, availableColorPresentations, presentationIndex) {\r\n        this.presentationIndex = presentationIndex;\r\n        this._onColorFlushed = new common_event["Emitter"]();\r\n        this.onColorFlushed = this._onColorFlushed.event;\r\n        this._onDidChangeColor = new common_event["Emitter"]();\r\n        this.onDidChangeColor = this._onDidChangeColor.event;\r\n        this._onDidChangePresentation = new common_event["Emitter"]();\r\n        this.onDidChangePresentation = this._onDidChangePresentation.event;\r\n        this.originalColor = color;\r\n        this._color = color;\r\n        this._colorPresentations = availableColorPresentations;\r\n    }\r\n    get color() {\r\n        return this._color;\r\n    }\r\n    set color(color) {\r\n        if (this._color.equals(color)) {\r\n            return;\r\n        }\r\n        this._color = color;\r\n        this._onDidChangeColor.fire(color);\r\n    }\r\n    get presentation() { return this.colorPresentations[this.presentationIndex]; }\r\n    get colorPresentations() {\r\n        return this._colorPresentations;\r\n    }\r\n    set colorPresentations(colorPresentations) {\r\n        this._colorPresentations = colorPresentations;\r\n        if (this.presentationIndex > colorPresentations.length - 1) {\r\n            this.presentationIndex = 0;\r\n        }\r\n        this._onDidChangePresentation.fire(this.presentation);\r\n    }\r\n    selectNextColorPresentation() {\r\n        this.presentationIndex = (this.presentationIndex + 1) % this.colorPresentations.length;\r\n        this.flushColor();\r\n        this._onDidChangePresentation.fire(this.presentation);\r\n    }\r\n    guessColorPresentation(color, originalText) {\r\n        for (let i = 0; i < this.colorPresentations.length; i++) {\r\n            if (originalText.toLowerCase() === this.colorPresentations[i].label) {\r\n                this.presentationIndex = i;\r\n                this._onDidChangePresentation.fire(this.presentation);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    flushColor() {\r\n        this._onColorFlushed.fire(this._color);\r\n    }\r\n}\r\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/colorPicker.css\nvar colorPicker = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/colorPicker.css");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/browser/browser.js\nvar browser = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/browser/browser.js");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/colorPickerWidget.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst colorPickerWidget_$ = dom["$"];\r\nclass colorPickerWidget_ColorPickerHeader extends lifecycle["Disposable"] {\r\n    constructor(container, model, themeService) {\r\n        super();\r\n        this.model = model;\r\n        this.domNode = colorPickerWidget_$(\'.colorpicker-header\');\r\n        dom["append"](container, this.domNode);\r\n        this.pickedColorNode = dom["append"](this.domNode, colorPickerWidget_$(\'.picked-color\'));\r\n        const colorBox = dom["append"](this.domNode, colorPickerWidget_$(\'.original-color\'));\r\n        colorBox.style.backgroundColor = common_color["Color"].Format.CSS.format(this.model.originalColor) || \'\';\r\n        this.backgroundColor = themeService.getColorTheme().getColor(colorRegistry["editorHoverBackground"]) || common_color["Color"].white;\r\n        this._register(Object(common_themeService["registerThemingParticipant"])((theme, collector) => {\r\n            this.backgroundColor = theme.getColor(colorRegistry["editorHoverBackground"]) || common_color["Color"].white;\r\n        }));\r\n        this._register(dom["addDisposableListener"](this.pickedColorNode, dom["EventType"].CLICK, () => this.model.selectNextColorPresentation()));\r\n        this._register(dom["addDisposableListener"](colorBox, dom["EventType"].CLICK, () => {\r\n            this.model.color = this.model.originalColor;\r\n            this.model.flushColor();\r\n        }));\r\n        this._register(model.onDidChangeColor(this.onDidChangeColor, this));\r\n        this._register(model.onDidChangePresentation(this.onDidChangePresentation, this));\r\n        this.pickedColorNode.style.backgroundColor = common_color["Color"].Format.CSS.format(model.color) || \'\';\r\n        this.pickedColorNode.classList.toggle(\'light\', model.color.rgba.a < 0.5 ? this.backgroundColor.isLighter() : model.color.isLighter());\r\n    }\r\n    onDidChangeColor(color) {\r\n        this.pickedColorNode.style.backgroundColor = common_color["Color"].Format.CSS.format(color) || \'\';\r\n        this.pickedColorNode.classList.toggle(\'light\', color.rgba.a < 0.5 ? this.backgroundColor.isLighter() : color.isLighter());\r\n        this.onDidChangePresentation();\r\n    }\r\n    onDidChangePresentation() {\r\n        this.pickedColorNode.textContent = this.model.presentation ? this.model.presentation.label : \'\';\r\n    }\r\n}\r\nclass colorPickerWidget_ColorPickerBody extends lifecycle["Disposable"] {\r\n    constructor(container, model, pixelRatio) {\r\n        super();\r\n        this.model = model;\r\n        this.pixelRatio = pixelRatio;\r\n        this.domNode = colorPickerWidget_$(\'.colorpicker-body\');\r\n        dom["append"](container, this.domNode);\r\n        this.saturationBox = new colorPickerWidget_SaturationBox(this.domNode, this.model, this.pixelRatio);\r\n        this._register(this.saturationBox);\r\n        this._register(this.saturationBox.onDidChange(this.onDidSaturationValueChange, this));\r\n        this._register(this.saturationBox.onColorFlushed(this.flushColor, this));\r\n        this.opacityStrip = new colorPickerWidget_OpacityStrip(this.domNode, this.model);\r\n        this._register(this.opacityStrip);\r\n        this._register(this.opacityStrip.onDidChange(this.onDidOpacityChange, this));\r\n        this._register(this.opacityStrip.onColorFlushed(this.flushColor, this));\r\n        this.hueStrip = new HueStrip(this.domNode, this.model);\r\n        this._register(this.hueStrip);\r\n        this._register(this.hueStrip.onDidChange(this.onDidHueChange, this));\r\n        this._register(this.hueStrip.onColorFlushed(this.flushColor, this));\r\n    }\r\n    flushColor() {\r\n        this.model.flushColor();\r\n    }\r\n    onDidSaturationValueChange({ s, v }) {\r\n        const hsva = this.model.color.hsva;\r\n        this.model.color = new common_color["Color"](new common_color["HSVA"](hsva.h, s, v, hsva.a));\r\n    }\r\n    onDidOpacityChange(a) {\r\n        const hsva = this.model.color.hsva;\r\n        this.model.color = new common_color["Color"](new common_color["HSVA"](hsva.h, hsva.s, hsva.v, a));\r\n    }\r\n    onDidHueChange(value) {\r\n        const hsva = this.model.color.hsva;\r\n        const h = (1 - value) * 360;\r\n        this.model.color = new common_color["Color"](new common_color["HSVA"](h === 360 ? 0 : h, hsva.s, hsva.v, hsva.a));\r\n    }\r\n    layout() {\r\n        this.saturationBox.layout();\r\n        this.opacityStrip.layout();\r\n        this.hueStrip.layout();\r\n    }\r\n}\r\nclass colorPickerWidget_SaturationBox extends lifecycle["Disposable"] {\r\n    constructor(container, model, pixelRatio) {\r\n        super();\r\n        this.model = model;\r\n        this.pixelRatio = pixelRatio;\r\n        this._onDidChange = new common_event["Emitter"]();\r\n        this.onDidChange = this._onDidChange.event;\r\n        this._onColorFlushed = new common_event["Emitter"]();\r\n        this.onColorFlushed = this._onColorFlushed.event;\r\n        this.domNode = colorPickerWidget_$(\'.saturation-wrap\');\r\n        dom["append"](container, this.domNode);\r\n        // Create canvas, draw selected color\r\n        this.canvas = document.createElement(\'canvas\');\r\n        this.canvas.className = \'saturation-box\';\r\n        dom["append"](this.domNode, this.canvas);\r\n        // Add selection circle\r\n        this.selection = colorPickerWidget_$(\'.saturation-selection\');\r\n        dom["append"](this.domNode, this.selection);\r\n        this.layout();\r\n        this._register(dom["addDisposableGenericMouseDownListner"](this.domNode, e => this.onMouseDown(e)));\r\n        this._register(this.model.onDidChangeColor(this.onDidChangeColor, this));\r\n        this.monitor = null;\r\n    }\r\n    onMouseDown(e) {\r\n        this.monitor = this._register(new globalMouseMoveMonitor["GlobalMouseMoveMonitor"]());\r\n        const origin = dom["getDomNodePagePosition"](this.domNode);\r\n        if (e.target !== this.selection) {\r\n            this.onDidChangePosition(e.offsetX, e.offsetY);\r\n        }\r\n        this.monitor.startMonitoring(e.target, e.buttons, globalMouseMoveMonitor["standardMouseMoveMerger"], event => this.onDidChangePosition(event.posx - origin.left, event.posy - origin.top), () => null);\r\n        const mouseUpListener = dom["addDisposableGenericMouseUpListner"](document, () => {\r\n            this._onColorFlushed.fire();\r\n            mouseUpListener.dispose();\r\n            if (this.monitor) {\r\n                this.monitor.stopMonitoring(true);\r\n                this.monitor = null;\r\n            }\r\n        }, true);\r\n    }\r\n    onDidChangePosition(left, top) {\r\n        const s = Math.max(0, Math.min(1, left / this.width));\r\n        const v = Math.max(0, Math.min(1, 1 - (top / this.height)));\r\n        this.paintSelection(s, v);\r\n        this._onDidChange.fire({ s, v });\r\n    }\r\n    layout() {\r\n        this.width = this.domNode.offsetWidth;\r\n        this.height = this.domNode.offsetHeight;\r\n        this.canvas.width = this.width * this.pixelRatio;\r\n        this.canvas.height = this.height * this.pixelRatio;\r\n        this.paint();\r\n        const hsva = this.model.color.hsva;\r\n        this.paintSelection(hsva.s, hsva.v);\r\n    }\r\n    paint() {\r\n        const hsva = this.model.color.hsva;\r\n        const saturatedColor = new common_color["Color"](new common_color["HSVA"](hsva.h, 1, 1, 1));\r\n        const ctx = this.canvas.getContext(\'2d\');\r\n        const whiteGradient = ctx.createLinearGradient(0, 0, this.canvas.width, 0);\r\n        whiteGradient.addColorStop(0, \'rgba(255, 255, 255, 1)\');\r\n        whiteGradient.addColorStop(0.5, \'rgba(255, 255, 255, 0.5)\');\r\n        whiteGradient.addColorStop(1, \'rgba(255, 255, 255, 0)\');\r\n        const blackGradient = ctx.createLinearGradient(0, 0, 0, this.canvas.height);\r\n        blackGradient.addColorStop(0, \'rgba(0, 0, 0, 0)\');\r\n        blackGradient.addColorStop(1, \'rgba(0, 0, 0, 1)\');\r\n        ctx.rect(0, 0, this.canvas.width, this.canvas.height);\r\n        ctx.fillStyle = common_color["Color"].Format.CSS.format(saturatedColor);\r\n        ctx.fill();\r\n        ctx.fillStyle = whiteGradient;\r\n        ctx.fill();\r\n        ctx.fillStyle = blackGradient;\r\n        ctx.fill();\r\n    }\r\n    paintSelection(s, v) {\r\n        this.selection.style.left = `${s * this.width}px`;\r\n        this.selection.style.top = `${this.height - v * this.height}px`;\r\n    }\r\n    onDidChangeColor() {\r\n        if (this.monitor && this.monitor.isMonitoring()) {\r\n            return;\r\n        }\r\n        this.paint();\r\n    }\r\n}\r\nclass colorPickerWidget_Strip extends lifecycle["Disposable"] {\r\n    constructor(container, model) {\r\n        super();\r\n        this.model = model;\r\n        this._onDidChange = new common_event["Emitter"]();\r\n        this.onDidChange = this._onDidChange.event;\r\n        this._onColorFlushed = new common_event["Emitter"]();\r\n        this.onColorFlushed = this._onColorFlushed.event;\r\n        this.domNode = dom["append"](container, colorPickerWidget_$(\'.strip\'));\r\n        this.overlay = dom["append"](this.domNode, colorPickerWidget_$(\'.overlay\'));\r\n        this.slider = dom["append"](this.domNode, colorPickerWidget_$(\'.slider\'));\r\n        this.slider.style.top = `0px`;\r\n        this._register(dom["addDisposableGenericMouseDownListner"](this.domNode, e => this.onMouseDown(e)));\r\n        this.layout();\r\n    }\r\n    layout() {\r\n        this.height = this.domNode.offsetHeight - this.slider.offsetHeight;\r\n        const value = this.getValue(this.model.color);\r\n        this.updateSliderPosition(value);\r\n    }\r\n    onMouseDown(e) {\r\n        const monitor = this._register(new globalMouseMoveMonitor["GlobalMouseMoveMonitor"]());\r\n        const origin = dom["getDomNodePagePosition"](this.domNode);\r\n        this.domNode.classList.add(\'grabbing\');\r\n        if (e.target !== this.slider) {\r\n            this.onDidChangeTop(e.offsetY);\r\n        }\r\n        monitor.startMonitoring(e.target, e.buttons, globalMouseMoveMonitor["standardMouseMoveMerger"], event => this.onDidChangeTop(event.posy - origin.top), () => null);\r\n        const mouseUpListener = dom["addDisposableGenericMouseUpListner"](document, () => {\r\n            this._onColorFlushed.fire();\r\n            mouseUpListener.dispose();\r\n            monitor.stopMonitoring(true);\r\n            this.domNode.classList.remove(\'grabbing\');\r\n        }, true);\r\n    }\r\n    onDidChangeTop(top) {\r\n        const value = Math.max(0, Math.min(1, 1 - (top / this.height)));\r\n        this.updateSliderPosition(value);\r\n        this._onDidChange.fire(value);\r\n    }\r\n    updateSliderPosition(value) {\r\n        this.slider.style.top = `${(1 - value) * this.height}px`;\r\n    }\r\n}\r\nclass colorPickerWidget_OpacityStrip extends colorPickerWidget_Strip {\r\n    constructor(container, model) {\r\n        super(container, model);\r\n        this.domNode.classList.add(\'opacity-strip\');\r\n        this._register(model.onDidChangeColor(this.onDidChangeColor, this));\r\n        this.onDidChangeColor(this.model.color);\r\n    }\r\n    onDidChangeColor(color) {\r\n        const { r, g, b } = color.rgba;\r\n        const opaque = new common_color["Color"](new common_color["RGBA"](r, g, b, 1));\r\n        const transparent = new common_color["Color"](new common_color["RGBA"](r, g, b, 0));\r\n        this.overlay.style.background = `linear-gradient(to bottom, ${opaque} 0%, ${transparent} 100%)`;\r\n    }\r\n    getValue(color) {\r\n        return color.hsva.a;\r\n    }\r\n}\r\nclass HueStrip extends colorPickerWidget_Strip {\r\n    constructor(container, model) {\r\n        super(container, model);\r\n        this.domNode.classList.add(\'hue-strip\');\r\n    }\r\n    getValue(color) {\r\n        return 1 - (color.hsva.h / 360);\r\n    }\r\n}\r\nclass colorPickerWidget_ColorPickerWidget extends ui_widget["Widget"] {\r\n    constructor(container, model, pixelRatio, themeService) {\r\n        super();\r\n        this.model = model;\r\n        this.pixelRatio = pixelRatio;\r\n        this._register(Object(browser["onDidChangeZoomLevel"])(() => this.layout()));\r\n        const element = colorPickerWidget_$(\'.colorpicker-widget\');\r\n        container.appendChild(element);\r\n        const header = new colorPickerWidget_ColorPickerHeader(element, this.model, themeService);\r\n        this.body = new colorPickerWidget_ColorPickerBody(element, this.model, this.pixelRatio);\r\n        this._register(header);\r\n        this._register(this.body);\r\n    }\r\n    layout() {\r\n        this.body.layout();\r\n    }\r\n}\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/hover/colorHoverParticipant.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar colorHoverParticipant_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar colorHoverParticipant_param = (undefined && undefined.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nvar colorHoverParticipant_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass ColorHover {\r\n    constructor(owner, range, model, provider) {\r\n        this.owner = owner;\r\n        this.range = range;\r\n        this.model = model;\r\n        this.provider = provider;\r\n        /**\r\n         * Force the hover to always be rendered at this specific range,\r\n         * even in the case of multiple hover parts.\r\n         */\r\n        this.forceShowAtRange = true;\r\n    }\r\n    isValidForHoverAnchor(anchor) {\r\n        return (anchor.type === 1 /* Range */\r\n            && this.range.startColumn <= anchor.range.startColumn\r\n            && this.range.endColumn >= anchor.range.endColumn);\r\n    }\r\n}\r\nlet colorHoverParticipant_ColorHoverParticipant = class ColorHoverParticipant {\r\n    constructor(_editor, _hover, _themeService) {\r\n        this._editor = _editor;\r\n        this._hover = _hover;\r\n        this._themeService = _themeService;\r\n    }\r\n    computeSync(anchor, lineDecorations) {\r\n        return [];\r\n    }\r\n    computeAsync(anchor, lineDecorations, token) {\r\n        return colorHoverParticipant_awaiter(this, void 0, void 0, function* () {\r\n            if (!this._editor.hasModel()) {\r\n                return [];\r\n            }\r\n            const colorDetector = colorDetector_ColorDetector.get(this._editor);\r\n            for (const d of lineDecorations) {\r\n                const colorData = colorDetector.getColorData(d.range.getStartPosition());\r\n                if (colorData) {\r\n                    const colorHover = yield this._createColorHover(this._editor.getModel(), colorData.colorInfo, colorData.provider);\r\n                    return [colorHover];\r\n                }\r\n            }\r\n            return [];\r\n        });\r\n    }\r\n    _createColorHover(editorModel, colorInfo, provider) {\r\n        return colorHoverParticipant_awaiter(this, void 0, void 0, function* () {\r\n            const originalText = editorModel.getValueInRange(colorInfo.range);\r\n            const { red, green, blue, alpha } = colorInfo.color;\r\n            const rgba = new common_color["RGBA"](Math.round(red * 255), Math.round(green * 255), Math.round(blue * 255), alpha);\r\n            const color = new common_color["Color"](rgba);\r\n            const colorPresentations = yield getColorPresentations(editorModel, colorInfo, provider, cancellation["CancellationToken"].None);\r\n            const model = new colorPickerModel_ColorPickerModel(color, [], 0);\r\n            model.colorPresentations = colorPresentations || [];\r\n            model.guessColorPresentation(color, originalText);\r\n            return new ColorHover(this, core_range["Range"].lift(colorInfo.range), model, provider);\r\n        });\r\n    }\r\n    renderHoverParts(hoverParts, fragment, statusBar) {\r\n        if (hoverParts.length === 0 || !this._editor.hasModel()) {\r\n            return lifecycle["Disposable"].None;\r\n        }\r\n        const disposables = new lifecycle["DisposableStore"]();\r\n        const colorHover = hoverParts[0];\r\n        const editorModel = this._editor.getModel();\r\n        const model = colorHover.model;\r\n        const widget = disposables.add(new colorPickerWidget_ColorPickerWidget(fragment, model, this._editor.getOption(128 /* pixelRatio */), this._themeService));\r\n        let range = new core_range["Range"](colorHover.range.startLineNumber, colorHover.range.startColumn, colorHover.range.endLineNumber, colorHover.range.endColumn);\r\n        const updateEditorModel = () => {\r\n            let textEdits;\r\n            let newRange;\r\n            if (model.presentation.textEdit) {\r\n                textEdits = [model.presentation.textEdit];\r\n                newRange = new core_range["Range"](model.presentation.textEdit.range.startLineNumber, model.presentation.textEdit.range.startColumn, model.presentation.textEdit.range.endLineNumber, model.presentation.textEdit.range.endColumn);\r\n                const trackedRange = this._editor.getModel()._setTrackedRange(null, newRange, 3 /* GrowsOnlyWhenTypingAfter */);\r\n                this._editor.pushUndoStop();\r\n                this._editor.executeEdits(\'colorpicker\', textEdits);\r\n                newRange = this._editor.getModel()._getTrackedRange(trackedRange) || newRange;\r\n            }\r\n            else {\r\n                textEdits = [{ identifier: null, range, text: model.presentation.label, forceMoveMarkers: false }];\r\n                newRange = range.setEndPosition(range.endLineNumber, range.startColumn + model.presentation.label.length);\r\n                this._editor.pushUndoStop();\r\n                this._editor.executeEdits(\'colorpicker\', textEdits);\r\n            }\r\n            if (model.presentation.additionalTextEdits) {\r\n                textEdits = [...model.presentation.additionalTextEdits];\r\n                this._editor.executeEdits(\'colorpicker\', textEdits);\r\n                this._hover.hide();\r\n            }\r\n            this._editor.pushUndoStop();\r\n            range = newRange;\r\n        };\r\n        const updateColorPresentations = (color) => {\r\n            return getColorPresentations(editorModel, {\r\n                range: range,\r\n                color: {\r\n                    red: color.rgba.r / 255,\r\n                    green: color.rgba.g / 255,\r\n                    blue: color.rgba.b / 255,\r\n                    alpha: color.rgba.a\r\n                }\r\n            }, colorHover.provider, cancellation["CancellationToken"].None).then((colorPresentations) => {\r\n                model.colorPresentations = colorPresentations || [];\r\n            });\r\n        };\r\n        disposables.add(model.onColorFlushed((color) => {\r\n            updateColorPresentations(color).then(updateEditorModel);\r\n        }));\r\n        disposables.add(model.onDidChangeColor(updateColorPresentations));\r\n        this._hover.setColorPicker(widget);\r\n        return disposables;\r\n    }\r\n};\r\ncolorHoverParticipant_ColorHoverParticipant = colorHoverParticipant_decorate([\r\n    colorHoverParticipant_param(2, common_themeService["IThemeService"])\r\n], colorHoverParticipant_ColorHoverParticipant);\r\n\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/hover/modesContentHover.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar modesContentHover_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar modesContentHover_param = (undefined && undefined.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nvar modesContentHover_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst modesContentHover_$ = dom["$"];\r\nlet modesContentHover_EditorHoverStatusBar = class EditorHoverStatusBar extends lifecycle["Disposable"] {\r\n    constructor(_keybindingService) {\r\n        super();\r\n        this._keybindingService = _keybindingService;\r\n        this._hasContent = false;\r\n        this.hoverElement = modesContentHover_$(\'div.hover-row.status-bar\');\r\n        this.actionsElement = dom["append"](this.hoverElement, modesContentHover_$(\'div.actions\'));\r\n    }\r\n    get hasContent() {\r\n        return this._hasContent;\r\n    }\r\n    addAction(actionOptions) {\r\n        const keybinding = this._keybindingService.lookupKeybinding(actionOptions.commandId);\r\n        const keybindingLabel = keybinding ? keybinding.getLabel() : null;\r\n        this._hasContent = true;\r\n        return this._register(hoverWidget_HoverAction.render(this.actionsElement, actionOptions, keybindingLabel));\r\n    }\r\n    append(element) {\r\n        const result = dom["append"](this.actionsElement, element);\r\n        this._hasContent = true;\r\n        return result;\r\n    }\r\n};\r\nmodesContentHover_EditorHoverStatusBar = modesContentHover_decorate([\r\n    modesContentHover_param(0, common_keybinding["IKeybindingService"])\r\n], modesContentHover_EditorHoverStatusBar);\r\nclass modesContentHover_ModesContentComputer {\r\n    constructor(editor, _participants) {\r\n        this._participants = _participants;\r\n        this._editor = editor;\r\n        this._result = [];\r\n        this._anchor = null;\r\n    }\r\n    setAnchor(anchor) {\r\n        this._anchor = anchor;\r\n        this._result = [];\r\n    }\r\n    clearResult() {\r\n        this._result = [];\r\n    }\r\n    static _getLineDecorations(editor, anchor) {\r\n        if (anchor.type !== 1 /* Range */) {\r\n            return [];\r\n        }\r\n        const model = editor.getModel();\r\n        const lineNumber = anchor.range.startLineNumber;\r\n        const maxColumn = model.getLineMaxColumn(lineNumber);\r\n        return editor.getLineDecorations(lineNumber).filter((d) => {\r\n            if (d.options.isWholeLine) {\r\n                return true;\r\n            }\r\n            const startColumn = (d.range.startLineNumber === lineNumber) ? d.range.startColumn : 1;\r\n            const endColumn = (d.range.endLineNumber === lineNumber) ? d.range.endColumn : maxColumn;\r\n            if (startColumn > anchor.range.startColumn || anchor.range.endColumn > endColumn) {\r\n                return false;\r\n            }\r\n            return true;\r\n        });\r\n    }\r\n    computeAsync(token) {\r\n        return modesContentHover_awaiter(this, void 0, void 0, function* () {\r\n            const anchor = this._anchor;\r\n            if (!this._editor.hasModel() || !anchor) {\r\n                return Promise.resolve([]);\r\n            }\r\n            const lineDecorations = modesContentHover_ModesContentComputer._getLineDecorations(this._editor, anchor);\r\n            const allResults = yield Promise.all(this._participants.map(p => this._computeAsync(p, lineDecorations, anchor, token)));\r\n            return Object(arrays["flatten"])(allResults);\r\n        });\r\n    }\r\n    _computeAsync(participant, lineDecorations, anchor, token) {\r\n        return modesContentHover_awaiter(this, void 0, void 0, function* () {\r\n            if (!participant.computeAsync) {\r\n                return [];\r\n            }\r\n            return participant.computeAsync(anchor, lineDecorations, token);\r\n        });\r\n    }\r\n    computeSync() {\r\n        if (!this._editor.hasModel() || !this._anchor) {\r\n            return [];\r\n        }\r\n        const lineDecorations = modesContentHover_ModesContentComputer._getLineDecorations(this._editor, this._anchor);\r\n        let result = [];\r\n        for (const participant of this._participants) {\r\n            result = result.concat(participant.computeSync(this._anchor, lineDecorations));\r\n        }\r\n        return Object(arrays["coalesce"])(result);\r\n    }\r\n    onResult(result, isFromSynchronousComputation) {\r\n        // Always put synchronous messages before asynchronous ones\r\n        if (isFromSynchronousComputation) {\r\n            this._result = result.concat(this._result);\r\n        }\r\n        else {\r\n            this._result = this._result.concat(result);\r\n        }\r\n    }\r\n    getResult() {\r\n        return this._result.slice(0);\r\n    }\r\n    getResultWithLoadingMessage() {\r\n        if (this._anchor) {\r\n            for (const participant of this._participants) {\r\n                if (participant.createLoadingMessage) {\r\n                    const loadingMessage = participant.createLoadingMessage(this._anchor);\r\n                    if (loadingMessage) {\r\n                        return this._result.slice(0).concat([loadingMessage]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return this._result.slice(0);\r\n    }\r\n}\r\nlet modesContentHover_ModesContentHoverWidget = class ModesContentHoverWidget extends ui_widget["Widget"] {\r\n    constructor(editor, _hoverVisibleKey, instantiationService, _keybindingService) {\r\n        super();\r\n        this._hoverVisibleKey = _hoverVisibleKey;\r\n        this._keybindingService = _keybindingService;\r\n        // IContentWidget.allowEditorOverflow\r\n        this.allowEditorOverflow = true;\r\n        this._participants = [\r\n            instantiationService.createInstance(colorHoverParticipant_ColorHoverParticipant, editor, this),\r\n            instantiationService.createInstance(markdownHoverParticipant_MarkdownHoverParticipant, editor, this),\r\n            instantiationService.createInstance(inlineCompletionsHoverParticipant_InlineCompletionsHoverParticipant, editor, this),\r\n            instantiationService.createInstance(markerHoverParticipant_MarkerHoverParticipant, editor, this),\r\n        ];\r\n        this._hover = this._register(new hoverWidget_HoverWidget());\r\n        this._id = ModesContentHoverWidget.ID;\r\n        this._editor = editor;\r\n        this._isVisible = false;\r\n        this._stoleFocus = false;\r\n        this._renderDisposable = null;\r\n        this.onkeydown(this._hover.containerDomNode, (e) => {\r\n            if (e.equals(9 /* Escape */)) {\r\n                this.hide();\r\n            }\r\n        });\r\n        this._register(this._editor.onDidChangeConfiguration((e) => {\r\n            if (e.hasChanged(42 /* fontInfo */)) {\r\n                this._updateFont();\r\n            }\r\n        }));\r\n        this._editor.onDidLayoutChange(() => this.layout());\r\n        this.layout();\r\n        this._editor.addContentWidget(this);\r\n        this._showAtPosition = null;\r\n        this._showAtRange = null;\r\n        this._stoleFocus = false;\r\n        this._messages = [];\r\n        this._lastAnchor = null;\r\n        this._computer = new modesContentHover_ModesContentComputer(this._editor, this._participants);\r\n        this._highlightDecorations = [];\r\n        this._isChangingDecorations = false;\r\n        this._shouldFocus = false;\r\n        this._colorPicker = null;\r\n        this._hoverOperation = new hoverOperation_HoverOperation(this._computer, result => this._withResult(result, true), null, result => this._withResult(result, false), this._editor.getOption(52 /* hover */).delay);\r\n        this._register(dom["addStandardDisposableListener"](this.getDomNode(), dom["EventType"].FOCUS, () => {\r\n            if (this._colorPicker) {\r\n                this.getDomNode().classList.add(\'colorpicker-hover\');\r\n            }\r\n        }));\r\n        this._register(dom["addStandardDisposableListener"](this.getDomNode(), dom["EventType"].BLUR, () => {\r\n            this.getDomNode().classList.remove(\'colorpicker-hover\');\r\n        }));\r\n        this._register(editor.onDidChangeConfiguration(() => {\r\n            this._hoverOperation.setHoverTime(this._editor.getOption(52 /* hover */).delay);\r\n        }));\r\n        this._register(modes["TokenizationRegistry"].onDidChange(() => {\r\n            if (this._isVisible && this._lastAnchor && this._messages.length > 0) {\r\n                this._hover.contentsDomNode.textContent = \'\';\r\n                this._renderMessages(this._lastAnchor, this._messages);\r\n            }\r\n        }));\r\n    }\r\n    dispose() {\r\n        this._hoverOperation.cancel();\r\n        this._editor.removeContentWidget(this);\r\n        super.dispose();\r\n    }\r\n    getId() {\r\n        return this._id;\r\n    }\r\n    getDomNode() {\r\n        return this._hover.containerDomNode;\r\n    }\r\n    _shouldShowAt(mouseEvent) {\r\n        const targetType = mouseEvent.target.type;\r\n        if (targetType === 6 /* CONTENT_TEXT */) {\r\n            return true;\r\n        }\r\n        if (targetType === 7 /* CONTENT_EMPTY */) {\r\n            const epsilon = this._editor.getOption(42 /* fontInfo */).typicalHalfwidthCharacterWidth / 2;\r\n            const data = mouseEvent.target.detail;\r\n            if (data && !data.isAfterLines && typeof data.horizontalDistanceToText === \'number\' && data.horizontalDistanceToText < epsilon) {\r\n                // Let hover kick in even when the mouse is technically in the empty area after a line, given the distance is small enough\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    maybeShowAt(mouseEvent) {\r\n        var _a;\r\n        const anchorCandidates = [];\r\n        for (const participant of this._participants) {\r\n            if (typeof participant.suggestHoverAnchor === \'function\') {\r\n                const anchor = participant.suggestHoverAnchor(mouseEvent);\r\n                if (anchor) {\r\n                    anchorCandidates.push(anchor);\r\n                }\r\n            }\r\n        }\r\n        if (this._shouldShowAt(mouseEvent) && mouseEvent.target.range) {\r\n            // TODO@rebornix. This should be removed if we move Color Picker out of Hover component.\r\n            // Check if mouse is hovering on color decorator\r\n            const hoverOnColorDecorator = [...((_a = mouseEvent.target.element) === null || _a === void 0 ? void 0 : _a.classList.values()) || []].find(className => className.startsWith(\'ced-colorBox\'))\r\n                && mouseEvent.target.range.endColumn - mouseEvent.target.range.startColumn === 1;\r\n            const showAtRange = (hoverOnColorDecorator // shift the mouse focus by one as color decorator is a `before` decoration of next character.\r\n                ? new core_range["Range"](mouseEvent.target.range.startLineNumber, mouseEvent.target.range.startColumn + 1, mouseEvent.target.range.endLineNumber, mouseEvent.target.range.endColumn + 1)\r\n                : mouseEvent.target.range);\r\n            anchorCandidates.push(new HoverRangeAnchor(0, showAtRange));\r\n        }\r\n        if (anchorCandidates.length === 0) {\r\n            return false;\r\n        }\r\n        anchorCandidates.sort((a, b) => b.priority - a.priority);\r\n        this._startShowingAt(anchorCandidates[0], 0 /* Delayed */, false);\r\n        return true;\r\n    }\r\n    _showAt(position, range, focus) {\r\n        // Position has changed\r\n        this._showAtPosition = position;\r\n        this._showAtRange = range;\r\n        this._hoverVisibleKey.set(true);\r\n        this._isVisible = true;\r\n        this._hover.containerDomNode.classList.toggle(\'hidden\', !this._isVisible);\r\n        this._editor.layoutContentWidget(this);\r\n        // Simply force a synchronous render on the editor\r\n        // such that the widget does not really render with left = \'0px\'\r\n        this._editor.render();\r\n        this._stoleFocus = focus;\r\n        if (focus) {\r\n            this._hover.containerDomNode.focus();\r\n        }\r\n    }\r\n    getPosition() {\r\n        if (this._isVisible) {\r\n            return {\r\n                position: this._showAtPosition,\r\n                range: this._showAtRange,\r\n                preference: [\r\n                    1 /* ABOVE */,\r\n                    2 /* BELOW */\r\n                ]\r\n            };\r\n        }\r\n        return null;\r\n    }\r\n    _updateFont() {\r\n        const codeClasses = Array.prototype.slice.call(this._hover.contentsDomNode.getElementsByClassName(\'code\'));\r\n        codeClasses.forEach(node => this._editor.applyFontInfo(node));\r\n    }\r\n    _updateContents(node) {\r\n        this._hover.contentsDomNode.textContent = \'\';\r\n        this._hover.contentsDomNode.appendChild(node);\r\n        this._updateFont();\r\n        this._editor.layoutContentWidget(this);\r\n        this._hover.onContentsChanged();\r\n    }\r\n    layout() {\r\n        const height = Math.max(this._editor.getLayoutInfo().height / 4, 250);\r\n        const { fontSize, lineHeight } = this._editor.getOption(42 /* fontInfo */);\r\n        this._hover.contentsDomNode.style.fontSize = `${fontSize}px`;\r\n        this._hover.contentsDomNode.style.lineHeight = `${lineHeight}px`;\r\n        this._hover.contentsDomNode.style.maxHeight = `${height}px`;\r\n        this._hover.contentsDomNode.style.maxWidth = `${Math.max(this._editor.getLayoutInfo().width * 0.66, 500)}px`;\r\n    }\r\n    onModelDecorationsChanged() {\r\n        if (this._isChangingDecorations) {\r\n            return;\r\n        }\r\n        if (this._isVisible) {\r\n            // The decorations have changed and the hover is visible,\r\n            // we need to recompute the displayed text\r\n            this._hoverOperation.cancel();\r\n            this._computer.clearResult();\r\n            if (!this._colorPicker) { // TODO@Michel ensure that displayed text for other decorations is computed even if color picker is in place\r\n                this._hoverOperation.start(0 /* Delayed */);\r\n            }\r\n        }\r\n    }\r\n    startShowingAtRange(range, mode, focus) {\r\n        this._startShowingAt(new HoverRangeAnchor(0, range), mode, focus);\r\n    }\r\n    _startShowingAt(anchor, mode, focus) {\r\n        if (this._lastAnchor && this._lastAnchor.equals(anchor)) {\r\n            // We have to show the widget at the exact same range as before, so no work is needed\r\n            return;\r\n        }\r\n        this._hoverOperation.cancel();\r\n        if (this._isVisible) {\r\n            // The range might have changed, but the hover is visible\r\n            // Instead of hiding it completely, filter out messages that are still in the new range and\r\n            // kick off a new computation\r\n            if (!this._showAtPosition || !this._lastAnchor || !anchor.canAdoptVisibleHover(this._lastAnchor, this._showAtPosition)) {\r\n                this.hide();\r\n            }\r\n            else {\r\n                const filteredMessages = this._messages.filter((m) => m.isValidForHoverAnchor(anchor));\r\n                if (filteredMessages.length === 0) {\r\n                    this.hide();\r\n                }\r\n                else if (filteredMessages.length === this._messages.length) {\r\n                    // no change\r\n                    return;\r\n                }\r\n                else {\r\n                    this._renderMessages(anchor, filteredMessages);\r\n                }\r\n            }\r\n        }\r\n        this._lastAnchor = anchor;\r\n        this._computer.setAnchor(anchor);\r\n        this._shouldFocus = focus;\r\n        this._hoverOperation.start(mode);\r\n    }\r\n    hide() {\r\n        this._lastAnchor = null;\r\n        this._hoverOperation.cancel();\r\n        if (this._isVisible) {\r\n            setTimeout(() => {\r\n                // Give commands a chance to see the key\r\n                if (!this._isVisible) {\r\n                    this._hoverVisibleKey.set(false);\r\n                }\r\n            }, 0);\r\n            this._isVisible = false;\r\n            this._hover.containerDomNode.classList.toggle(\'hidden\', !this._isVisible);\r\n            this._editor.layoutContentWidget(this);\r\n            if (this._stoleFocus) {\r\n                this._editor.focus();\r\n            }\r\n        }\r\n        this._isChangingDecorations = true;\r\n        this._highlightDecorations = this._editor.deltaDecorations(this._highlightDecorations, []);\r\n        this._isChangingDecorations = false;\r\n        if (this._renderDisposable) {\r\n            this._renderDisposable.dispose();\r\n            this._renderDisposable = null;\r\n        }\r\n        this._colorPicker = null;\r\n    }\r\n    isColorPickerVisible() {\r\n        return !!this._colorPicker;\r\n    }\r\n    setColorPicker(widget) {\r\n        this._colorPicker = widget;\r\n    }\r\n    onContentsChanged() {\r\n        this._hover.onContentsChanged();\r\n    }\r\n    _withResult(result, complete) {\r\n        this._messages = result;\r\n        if (this._lastAnchor && this._messages.length > 0) {\r\n            this._renderMessages(this._lastAnchor, this._messages);\r\n        }\r\n        else if (complete) {\r\n            this.hide();\r\n        }\r\n    }\r\n    _renderMessages(anchor, messages) {\r\n        if (this._renderDisposable) {\r\n            this._renderDisposable.dispose();\r\n            this._renderDisposable = null;\r\n        }\r\n        this._colorPicker = null; // TODO: TypeScript thinks this is always null\r\n        // update column from which to show\r\n        let renderColumn = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\r\n        let highlightRange = messages[0].range;\r\n        let forceShowAtRange = null;\r\n        let fragment = document.createDocumentFragment();\r\n        const disposables = new lifecycle["DisposableStore"]();\r\n        const hoverParts = new Map();\r\n        for (const msg of messages) {\r\n            renderColumn = Math.min(renderColumn, msg.range.startColumn);\r\n            highlightRange = core_range["Range"].plusRange(highlightRange, msg.range);\r\n            if (msg.forceShowAtRange) {\r\n                forceShowAtRange = msg.range;\r\n            }\r\n            if (!hoverParts.has(msg.owner)) {\r\n                hoverParts.set(msg.owner, []);\r\n            }\r\n            const dest = hoverParts.get(msg.owner);\r\n            dest.push(msg);\r\n        }\r\n        const statusBar = disposables.add(new modesContentHover_EditorHoverStatusBar(this._keybindingService));\r\n        for (const [participant, participantHoverParts] of hoverParts) {\r\n            disposables.add(participant.renderHoverParts(participantHoverParts, fragment, statusBar));\r\n        }\r\n        if (statusBar.hasContent) {\r\n            fragment.appendChild(statusBar.hoverElement);\r\n        }\r\n        this._renderDisposable = disposables;\r\n        // show\r\n        if (fragment.hasChildNodes()) {\r\n            if (forceShowAtRange) {\r\n                this._showAt(forceShowAtRange.getStartPosition(), forceShowAtRange, this._shouldFocus);\r\n            }\r\n            else {\r\n                this._showAt(new core_position["Position"](anchor.range.startLineNumber, renderColumn), highlightRange, this._shouldFocus);\r\n            }\r\n            this._updateContents(fragment);\r\n        }\r\n        if (this._colorPicker) {\r\n            this._colorPicker.layout();\r\n        }\r\n        this._isChangingDecorations = true;\r\n        this._highlightDecorations = this._editor.deltaDecorations(this._highlightDecorations, highlightRange ? [{\r\n                range: highlightRange,\r\n                options: ModesContentHoverWidget._DECORATION_OPTIONS\r\n            }] : []);\r\n        this._isChangingDecorations = false;\r\n    }\r\n};\r\nmodesContentHover_ModesContentHoverWidget.ID = \'editor.contrib.modesContentHoverWidget\';\r\nmodesContentHover_ModesContentHoverWidget._DECORATION_OPTIONS = model_textModel["ModelDecorationOptions"].register({\r\n    description: \'content-hover-highlight\',\r\n    className: \'hoverHighlight\'\r\n});\r\nmodesContentHover_ModesContentHoverWidget = modesContentHover_decorate([\r\n    modesContentHover_param(2, instantiation["IInstantiationService"]),\r\n    modesContentHover_param(3, common_keybinding["IKeybindingService"])\r\n], modesContentHover_ModesContentHoverWidget);\r\n\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/hover/hoverWidgets.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\nclass hoverWidgets_GlyphHoverWidget extends ui_widget["Widget"] {\r\n    constructor(id, editor) {\r\n        super();\r\n        this._id = id;\r\n        this._editor = editor;\r\n        this._isVisible = false;\r\n        this._domNode = document.createElement(\'div\');\r\n        this._domNode.className = \'monaco-hover hidden\';\r\n        this._domNode.setAttribute(\'aria-hidden\', \'true\');\r\n        this._domNode.setAttribute(\'role\', \'tooltip\');\r\n        this._showAtLineNumber = -1;\r\n        this._register(this._editor.onDidChangeConfiguration((e) => {\r\n            if (e.hasChanged(42 /* fontInfo */)) {\r\n                this.updateFont();\r\n            }\r\n        }));\r\n        this._editor.addOverlayWidget(this);\r\n    }\r\n    get isVisible() {\r\n        return this._isVisible;\r\n    }\r\n    set isVisible(value) {\r\n        this._isVisible = value;\r\n        this._domNode.classList.toggle(\'hidden\', !this._isVisible);\r\n    }\r\n    getId() {\r\n        return this._id;\r\n    }\r\n    getDomNode() {\r\n        return this._domNode;\r\n    }\r\n    showAt(lineNumber) {\r\n        this._showAtLineNumber = lineNumber;\r\n        if (!this.isVisible) {\r\n            this.isVisible = true;\r\n        }\r\n        const editorLayout = this._editor.getLayoutInfo();\r\n        const topForLineNumber = this._editor.getTopForLineNumber(this._showAtLineNumber);\r\n        const editorScrollTop = this._editor.getScrollTop();\r\n        const lineHeight = this._editor.getOption(58 /* lineHeight */);\r\n        const nodeHeight = this._domNode.clientHeight;\r\n        const top = topForLineNumber - editorScrollTop - ((nodeHeight - lineHeight) / 2);\r\n        this._domNode.style.left = `${editorLayout.glyphMarginLeft + editorLayout.glyphMarginWidth}px`;\r\n        this._domNode.style.top = `${Math.max(Math.round(top), 0)}px`;\r\n    }\r\n    hide() {\r\n        if (!this.isVisible) {\r\n            return;\r\n        }\r\n        this.isVisible = false;\r\n    }\r\n    getPosition() {\r\n        return null;\r\n    }\r\n    dispose() {\r\n        this._editor.removeOverlayWidget(this);\r\n        super.dispose();\r\n    }\r\n    updateFont() {\r\n        const codeTags = Array.prototype.slice.call(this._domNode.getElementsByTagName(\'code\'));\r\n        const codeClasses = Array.prototype.slice.call(this._domNode.getElementsByClassName(\'code\'));\r\n        [...codeTags, ...codeClasses].forEach(node => this._editor.applyFontInfo(node));\r\n    }\r\n    updateContents(node) {\r\n        this._domNode.textContent = \'\';\r\n        this._domNode.appendChild(node);\r\n        this.updateFont();\r\n    }\r\n}\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/hover/modesGlyphHover.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass modesGlyphHover_MarginComputer {\r\n    constructor(editor) {\r\n        this._editor = editor;\r\n        this._lineNumber = -1;\r\n        this._result = [];\r\n    }\r\n    setLineNumber(lineNumber) {\r\n        this._lineNumber = lineNumber;\r\n        this._result = [];\r\n    }\r\n    clearResult() {\r\n        this._result = [];\r\n    }\r\n    computeSync() {\r\n        const toHoverMessage = (contents) => {\r\n            return {\r\n                value: contents\r\n            };\r\n        };\r\n        const lineDecorations = this._editor.getLineDecorations(this._lineNumber);\r\n        const result = [];\r\n        if (!lineDecorations) {\r\n            return result;\r\n        }\r\n        for (const d of lineDecorations) {\r\n            if (!d.options.glyphMarginClassName) {\r\n                continue;\r\n            }\r\n            const hoverMessage = d.options.glyphMarginHoverMessage;\r\n            if (!hoverMessage || isEmptyMarkdownString(hoverMessage)) {\r\n                continue;\r\n            }\r\n            result.push(...Object(arrays["asArray"])(hoverMessage).map(toHoverMessage));\r\n        }\r\n        return result;\r\n    }\r\n    onResult(result, isFromSynchronousComputation) {\r\n        this._result = this._result.concat(result);\r\n    }\r\n    getResult() {\r\n        return this._result;\r\n    }\r\n    getResultWithLoadingMessage() {\r\n        return this.getResult();\r\n    }\r\n}\r\nclass modesGlyphHover_ModesGlyphHoverWidget extends hoverWidgets_GlyphHoverWidget {\r\n    constructor(editor, modeService, openerService = common_opener["NullOpenerService"]) {\r\n        super(modesGlyphHover_ModesGlyphHoverWidget.ID, editor);\r\n        this._renderDisposeables = this._register(new lifecycle["DisposableStore"]());\r\n        this._messages = [];\r\n        this._lastLineNumber = -1;\r\n        this._markdownRenderer = this._register(new markdownRenderer_MarkdownRenderer({ editor: this._editor }, modeService, openerService));\r\n        this._computer = new modesGlyphHover_MarginComputer(this._editor);\r\n        this._hoverOperation = new hoverOperation_HoverOperation(this._computer, (result) => this._withResult(result), undefined, (result) => this._withResult(result), 300);\r\n    }\r\n    dispose() {\r\n        this._hoverOperation.cancel();\r\n        super.dispose();\r\n    }\r\n    onModelDecorationsChanged() {\r\n        if (this.isVisible) {\r\n            // The decorations have changed and the hover is visible,\r\n            // we need to recompute the displayed text\r\n            this._hoverOperation.cancel();\r\n            this._computer.clearResult();\r\n            this._hoverOperation.start(0 /* Delayed */);\r\n        }\r\n    }\r\n    startShowingAt(lineNumber) {\r\n        if (this._lastLineNumber === lineNumber) {\r\n            // We have to show the widget at the exact same line number as before, so no work is needed\r\n            return;\r\n        }\r\n        this._hoverOperation.cancel();\r\n        this.hide();\r\n        this._lastLineNumber = lineNumber;\r\n        this._computer.setLineNumber(lineNumber);\r\n        this._hoverOperation.start(0 /* Delayed */);\r\n    }\r\n    hide() {\r\n        this._lastLineNumber = -1;\r\n        this._hoverOperation.cancel();\r\n        super.hide();\r\n    }\r\n    _withResult(result) {\r\n        this._messages = result;\r\n        if (this._messages.length > 0) {\r\n            this._renderMessages(this._lastLineNumber, this._messages);\r\n        }\r\n        else {\r\n            this.hide();\r\n        }\r\n    }\r\n    _renderMessages(lineNumber, messages) {\r\n        this._renderDisposeables.clear();\r\n        const fragment = document.createDocumentFragment();\r\n        for (const msg of messages) {\r\n            const renderedContents = this._markdownRenderer.render(msg.value);\r\n            this._renderDisposeables.add(renderedContents);\r\n            fragment.appendChild(Object(dom["$"])(\'div.hover-row\', undefined, renderedContents.element));\r\n        }\r\n        this.updateContents(fragment);\r\n        this.showAt(lineNumber);\r\n    }\r\n}\r\nmodesGlyphHover_ModesGlyphHoverWidget.ID = \'editor.contrib.modesGlyphHoverWidget\';\r\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/link/goToDefinitionAtPosition.css\nvar goToDefinitionAtPosition = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/link/goToDefinitionAtPosition.css");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/referencesModel.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar referencesModel_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass referencesModel_OneReference {\r\n    constructor(isProviderFirst, parent, link, _rangeCallback) {\r\n        this.isProviderFirst = isProviderFirst;\r\n        this.parent = parent;\r\n        this.link = link;\r\n        this._rangeCallback = _rangeCallback;\r\n        this.id = idGenerator["defaultGenerator"].nextId();\r\n    }\r\n    get uri() {\r\n        return this.link.uri;\r\n    }\r\n    get range() {\r\n        var _a, _b;\r\n        return (_b = (_a = this._range) !== null && _a !== void 0 ? _a : this.link.targetSelectionRange) !== null && _b !== void 0 ? _b : this.link.range;\r\n    }\r\n    set range(value) {\r\n        this._range = value;\r\n        this._rangeCallback(this);\r\n    }\r\n    get ariaMessage() {\r\n        var _a;\r\n        const preview = (_a = this.parent.getPreview(this)) === null || _a === void 0 ? void 0 : _a.preview(this.range);\r\n        if (!preview) {\r\n            return Object(nls["localize"])(\'aria.oneReference\', "symbol in {0} on line {1} at column {2}", Object(common_resources["basename"])(this.uri), this.range.startLineNumber, this.range.startColumn);\r\n        }\r\n        else {\r\n            return Object(nls["localize"])({ key: \'aria.oneReference.preview\', comment: [\'Placeholders are: 0: filename, 1:line number, 2: column number, 3: preview snippet of source code\'] }, "symbol in {0} on line {1} at column {2}, {3}", Object(common_resources["basename"])(this.uri), this.range.startLineNumber, this.range.startColumn, preview.value);\r\n        }\r\n    }\r\n}\r\nclass referencesModel_FilePreview {\r\n    constructor(_modelReference) {\r\n        this._modelReference = _modelReference;\r\n    }\r\n    dispose() {\r\n        this._modelReference.dispose();\r\n    }\r\n    preview(range, n = 8) {\r\n        const model = this._modelReference.object.textEditorModel;\r\n        if (!model) {\r\n            return undefined;\r\n        }\r\n        const { startLineNumber, startColumn, endLineNumber, endColumn } = range;\r\n        const word = model.getWordUntilPosition({ lineNumber: startLineNumber, column: startColumn - n });\r\n        const beforeRange = new core_range["Range"](startLineNumber, word.startColumn, startLineNumber, startColumn);\r\n        const afterRange = new core_range["Range"](endLineNumber, endColumn, endLineNumber, 1073741824 /* MAX_SAFE_SMALL_INTEGER */);\r\n        const before = model.getValueInRange(beforeRange).replace(/^\\s+/, \'\');\r\n        const inside = model.getValueInRange(range);\r\n        const after = model.getValueInRange(afterRange).replace(/\\s+$/, \'\');\r\n        return {\r\n            value: before + inside + after,\r\n            highlight: { start: before.length, end: before.length + inside.length }\r\n        };\r\n    }\r\n}\r\nclass referencesModel_FileReferences {\r\n    constructor(parent, uri) {\r\n        this.parent = parent;\r\n        this.uri = uri;\r\n        this.children = [];\r\n        this._previews = new map["ResourceMap"]();\r\n    }\r\n    dispose() {\r\n        Object(lifecycle["dispose"])(this._previews.values());\r\n        this._previews.clear();\r\n    }\r\n    getPreview(child) {\r\n        return this._previews.get(child.uri);\r\n    }\r\n    get ariaMessage() {\r\n        const len = this.children.length;\r\n        if (len === 1) {\r\n            return Object(nls["localize"])(\'aria.fileReferences.1\', "1 symbol in {0}, full path {1}", Object(common_resources["basename"])(this.uri), this.uri.fsPath);\r\n        }\r\n        else {\r\n            return Object(nls["localize"])(\'aria.fileReferences.N\', "{0} symbols in {1}, full path {2}", len, Object(common_resources["basename"])(this.uri), this.uri.fsPath);\r\n        }\r\n    }\r\n    resolve(textModelResolverService) {\r\n        return referencesModel_awaiter(this, void 0, void 0, function* () {\r\n            if (this._previews.size !== 0) {\r\n                return this;\r\n            }\r\n            for (let child of this.children) {\r\n                if (this._previews.has(child.uri)) {\r\n                    continue;\r\n                }\r\n                try {\r\n                    const ref = yield textModelResolverService.createModelReference(child.uri);\r\n                    this._previews.set(child.uri, new referencesModel_FilePreview(ref));\r\n                }\r\n                catch (err) {\r\n                    Object(errors["onUnexpectedError"])(err);\r\n                }\r\n            }\r\n            return this;\r\n        });\r\n    }\r\n}\r\nclass referencesModel_ReferencesModel {\r\n    constructor(links, title) {\r\n        this.groups = [];\r\n        this.references = [];\r\n        this._onDidChangeReferenceRange = new common_event["Emitter"]();\r\n        this.onDidChangeReferenceRange = this._onDidChangeReferenceRange.event;\r\n        this._links = links;\r\n        this._title = title;\r\n        // grouping and sorting\r\n        const [providersFirst] = links;\r\n        links.sort(referencesModel_ReferencesModel._compareReferences);\r\n        let current;\r\n        for (let link of links) {\r\n            if (!current || !common_resources["extUri"].isEqual(current.uri, link.uri, true)) {\r\n                // new group\r\n                current = new referencesModel_FileReferences(this, link.uri);\r\n                this.groups.push(current);\r\n            }\r\n            // append, check for equality first!\r\n            if (current.children.length === 0 || referencesModel_ReferencesModel._compareReferences(link, current.children[current.children.length - 1]) !== 0) {\r\n                const oneRef = new referencesModel_OneReference(providersFirst === link, current, link, ref => this._onDidChangeReferenceRange.fire(ref));\r\n                this.references.push(oneRef);\r\n                current.children.push(oneRef);\r\n            }\r\n        }\r\n    }\r\n    dispose() {\r\n        Object(lifecycle["dispose"])(this.groups);\r\n        this._onDidChangeReferenceRange.dispose();\r\n        this.groups.length = 0;\r\n    }\r\n    clone() {\r\n        return new referencesModel_ReferencesModel(this._links, this._title);\r\n    }\r\n    get title() {\r\n        return this._title;\r\n    }\r\n    get isEmpty() {\r\n        return this.groups.length === 0;\r\n    }\r\n    get ariaMessage() {\r\n        if (this.isEmpty) {\r\n            return Object(nls["localize"])(\'aria.result.0\', "No results found");\r\n        }\r\n        else if (this.references.length === 1) {\r\n            return Object(nls["localize"])(\'aria.result.1\', "Found 1 symbol in {0}", this.references[0].uri.fsPath);\r\n        }\r\n        else if (this.groups.length === 1) {\r\n            return Object(nls["localize"])(\'aria.result.n1\', "Found {0} symbols in {1}", this.references.length, this.groups[0].uri.fsPath);\r\n        }\r\n        else {\r\n            return Object(nls["localize"])(\'aria.result.nm\', "Found {0} symbols in {1} files", this.references.length, this.groups.length);\r\n        }\r\n    }\r\n    nextOrPreviousReference(reference, next) {\r\n        let { parent } = reference;\r\n        let idx = parent.children.indexOf(reference);\r\n        let childCount = parent.children.length;\r\n        let groupCount = parent.parent.groups.length;\r\n        if (groupCount === 1 || next && idx + 1 < childCount || !next && idx > 0) {\r\n            // cycling within one file\r\n            if (next) {\r\n                idx = (idx + 1) % childCount;\r\n            }\r\n            else {\r\n                idx = (idx + childCount - 1) % childCount;\r\n            }\r\n            return parent.children[idx];\r\n        }\r\n        idx = parent.parent.groups.indexOf(parent);\r\n        if (next) {\r\n            idx = (idx + 1) % groupCount;\r\n            return parent.parent.groups[idx].children[0];\r\n        }\r\n        else {\r\n            idx = (idx + groupCount - 1) % groupCount;\r\n            return parent.parent.groups[idx].children[parent.parent.groups[idx].children.length - 1];\r\n        }\r\n    }\r\n    nearestReference(resource, position) {\r\n        const nearest = this.references.map((ref, idx) => {\r\n            return {\r\n                idx,\r\n                prefixLen: strings["commonPrefixLength"](ref.uri.toString(), resource.toString()),\r\n                offsetDist: Math.abs(ref.range.startLineNumber - position.lineNumber) * 100 + Math.abs(ref.range.startColumn - position.column)\r\n            };\r\n        }).sort((a, b) => {\r\n            if (a.prefixLen > b.prefixLen) {\r\n                return -1;\r\n            }\r\n            else if (a.prefixLen < b.prefixLen) {\r\n                return 1;\r\n            }\r\n            else if (a.offsetDist < b.offsetDist) {\r\n                return -1;\r\n            }\r\n            else if (a.offsetDist > b.offsetDist) {\r\n                return 1;\r\n            }\r\n            else {\r\n                return 0;\r\n            }\r\n        })[0];\r\n        if (nearest) {\r\n            return this.references[nearest.idx];\r\n        }\r\n        return undefined;\r\n    }\r\n    referenceAt(resource, position) {\r\n        for (const ref of this.references) {\r\n            if (ref.uri.toString() === resource.toString()) {\r\n                if (core_range["Range"].containsPosition(ref.range, position)) {\r\n                    return ref;\r\n                }\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    firstReference() {\r\n        for (const ref of this.references) {\r\n            if (ref.isProviderFirst) {\r\n                return ref;\r\n            }\r\n        }\r\n        return this.references[0];\r\n    }\r\n    static _compareReferences(a, b) {\r\n        return common_resources["extUri"].compare(a.uri, b.uri) || core_range["Range"].compareRangesUsingStarts(a.range, b.range);\r\n    }\r\n}\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/goToSymbol.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar goToSymbol_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\nfunction getLocationLinks(model, position, registry, provide) {\r\n    const provider = registry.ordered(model);\r\n    // get results\r\n    const promises = provider.map((provider) => {\r\n        return Promise.resolve(provide(provider, model, position)).then(undefined, err => {\r\n            Object(errors["onUnexpectedExternalError"])(err);\r\n            return undefined;\r\n        });\r\n    });\r\n    return Promise.all(promises).then(values => {\r\n        const result = [];\r\n        for (let value of values) {\r\n            if (Array.isArray(value)) {\r\n                result.push(...value);\r\n            }\r\n            else if (value) {\r\n                result.push(value);\r\n            }\r\n        }\r\n        return result;\r\n    });\r\n}\r\nfunction getDefinitionsAtPosition(model, position, token) {\r\n    return getLocationLinks(model, position, modes["DefinitionProviderRegistry"], (provider, model, position) => {\r\n        return provider.provideDefinition(model, position, token);\r\n    });\r\n}\r\nfunction getDeclarationsAtPosition(model, position, token) {\r\n    return getLocationLinks(model, position, modes["DeclarationProviderRegistry"], (provider, model, position) => {\r\n        return provider.provideDeclaration(model, position, token);\r\n    });\r\n}\r\nfunction getImplementationsAtPosition(model, position, token) {\r\n    return getLocationLinks(model, position, modes["ImplementationProviderRegistry"], (provider, model, position) => {\r\n        return provider.provideImplementation(model, position, token);\r\n    });\r\n}\r\nfunction getTypeDefinitionsAtPosition(model, position, token) {\r\n    return getLocationLinks(model, position, modes["TypeDefinitionProviderRegistry"], (provider, model, position) => {\r\n        return provider.provideTypeDefinition(model, position, token);\r\n    });\r\n}\r\nfunction getReferencesAtPosition(model, position, compact, token) {\r\n    return getLocationLinks(model, position, modes["ReferenceProviderRegistry"], (provider, model, position) => goToSymbol_awaiter(this, void 0, void 0, function* () {\r\n        const result = yield provider.provideReferences(model, position, { includeDeclaration: true }, token);\r\n        if (!compact || !result || result.length !== 2) {\r\n            return result;\r\n        }\r\n        const resultWithoutDeclaration = yield provider.provideReferences(model, position, { includeDeclaration: false }, token);\r\n        if (resultWithoutDeclaration && resultWithoutDeclaration.length === 1) {\r\n            return resultWithoutDeclaration;\r\n        }\r\n        return result;\r\n    }));\r\n}\r\n// -- API commands ----\r\nfunction _sortedAndDeduped(callback) {\r\n    return goToSymbol_awaiter(this, void 0, void 0, function* () {\r\n        const rawLinks = yield callback();\r\n        const model = new referencesModel_ReferencesModel(rawLinks, \'\');\r\n        const modelLinks = model.references.map(ref => ref.link);\r\n        model.dispose();\r\n        return modelLinks;\r\n    });\r\n}\r\nObject(editorExtensions["registerModelAndPositionCommand"])(\'_executeDefinitionProvider\', (model, position) => _sortedAndDeduped(() => getDefinitionsAtPosition(model, position, cancellation["CancellationToken"].None)));\r\nObject(editorExtensions["registerModelAndPositionCommand"])(\'_executeDeclarationProvider\', (model, position) => _sortedAndDeduped(() => getDeclarationsAtPosition(model, position, cancellation["CancellationToken"].None)));\r\nObject(editorExtensions["registerModelAndPositionCommand"])(\'_executeImplementationProvider\', (model, position) => _sortedAndDeduped(() => getImplementationsAtPosition(model, position, cancellation["CancellationToken"].None)));\r\nObject(editorExtensions["registerModelAndPositionCommand"])(\'_executeTypeDefinitionProvider\', (model, position) => _sortedAndDeduped(() => getTypeDefinitionsAtPosition(model, position, cancellation["CancellationToken"].None)));\r\nObject(editorExtensions["registerModelAndPositionCommand"])(\'_executeReferenceProvider\', (model, position) => _sortedAndDeduped(() => getReferencesAtPosition(model, position, false, cancellation["CancellationToken"].None)));\r\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/browser/editorBrowser.js\nvar editorBrowser = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/browser/editorBrowser.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/peek/referencesWidget.css\nvar referencesWidget = __webpack_require__("./node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/peek/referencesWidget.css");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/browser/ui/countBadge/countBadge.js\nvar countBadge = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/browser/ui/countBadge/countBadge.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/browser/ui/highlightedlabel/highlightedLabel.js\nvar highlightedLabel = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/browser/ui/highlightedlabel/highlightedLabel.js");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/peek/referencesTree.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar referencesTree_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar referencesTree_param = (undefined && undefined.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nlet referencesTree_DataSource = class DataSource {\r\n    constructor(_resolverService) {\r\n        this._resolverService = _resolverService;\r\n    }\r\n    hasChildren(element) {\r\n        if (element instanceof referencesModel_ReferencesModel) {\r\n            return true;\r\n        }\r\n        if (element instanceof referencesModel_FileReferences) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    getChildren(element) {\r\n        if (element instanceof referencesModel_ReferencesModel) {\r\n            return element.groups;\r\n        }\r\n        if (element instanceof referencesModel_FileReferences) {\r\n            return element.resolve(this._resolverService).then(val => {\r\n                // if (element.failure) {\r\n                // \t// refresh the element on failure so that\r\n                // \t// we can update its rendering\r\n                // \treturn tree.refresh(element).then(() => val.children);\r\n                // }\r\n                return val.children;\r\n            });\r\n        }\r\n        throw new Error(\'bad tree\');\r\n    }\r\n};\r\nreferencesTree_DataSource = referencesTree_decorate([\r\n    referencesTree_param(0, resolverService["ITextModelService"])\r\n], referencesTree_DataSource);\r\n\r\n//#endregion\r\nclass referencesTree_Delegate {\r\n    getHeight() {\r\n        return 23;\r\n    }\r\n    getTemplateId(element) {\r\n        if (element instanceof referencesModel_FileReferences) {\r\n            return referencesTree_FileReferencesRenderer.id;\r\n        }\r\n        else {\r\n            return OneReferenceRenderer.id;\r\n        }\r\n    }\r\n}\r\nlet referencesTree_StringRepresentationProvider = class StringRepresentationProvider {\r\n    constructor(_keybindingService) {\r\n        this._keybindingService = _keybindingService;\r\n    }\r\n    getKeyboardNavigationLabel(element) {\r\n        var _a;\r\n        if (element instanceof referencesModel_OneReference) {\r\n            const parts = (_a = element.parent.getPreview(element)) === null || _a === void 0 ? void 0 : _a.preview(element.range);\r\n            if (parts) {\r\n                return parts.value;\r\n            }\r\n        }\r\n        // FileReferences or unresolved OneReference\r\n        return Object(common_resources["basename"])(element.uri);\r\n    }\r\n};\r\nreferencesTree_StringRepresentationProvider = referencesTree_decorate([\r\n    referencesTree_param(0, common_keybinding["IKeybindingService"])\r\n], referencesTree_StringRepresentationProvider);\r\n\r\nclass referencesTree_IdentityProvider {\r\n    getId(element) {\r\n        return element instanceof referencesModel_OneReference ? element.id : element.uri;\r\n    }\r\n}\r\n//#region render: File\r\nlet referencesTree_FileReferencesTemplate = class FileReferencesTemplate extends lifecycle["Disposable"] {\r\n    constructor(container, _uriLabel, themeService) {\r\n        super();\r\n        this._uriLabel = _uriLabel;\r\n        const parent = document.createElement(\'div\');\r\n        parent.classList.add(\'reference-file\');\r\n        this.file = this._register(new iconLabel["IconLabel"](parent, { supportHighlights: true }));\r\n        this.badge = new countBadge["CountBadge"](dom["append"](parent, dom["$"](\'.count\')));\r\n        this._register(Object(styler["attachBadgeStyler"])(this.badge, themeService));\r\n        container.appendChild(parent);\r\n    }\r\n    set(element, matches) {\r\n        let parent = Object(common_resources["dirname"])(element.uri);\r\n        this.file.setLabel(getBaseLabel(element.uri), this._uriLabel.getUriLabel(parent, { relative: true }), { title: this._uriLabel.getUriLabel(element.uri), matches });\r\n        const len = element.children.length;\r\n        this.badge.setCount(len);\r\n        if (len > 1) {\r\n            this.badge.setTitleFormat(Object(nls["localize"])(\'referencesCount\', "{0} references", len));\r\n        }\r\n        else {\r\n            this.badge.setTitleFormat(Object(nls["localize"])(\'referenceCount\', "{0} reference", len));\r\n        }\r\n    }\r\n};\r\nreferencesTree_FileReferencesTemplate = referencesTree_decorate([\r\n    referencesTree_param(1, common_label["ILabelService"]),\r\n    referencesTree_param(2, common_themeService["IThemeService"])\r\n], referencesTree_FileReferencesTemplate);\r\nlet referencesTree_FileReferencesRenderer = class FileReferencesRenderer {\r\n    constructor(_instantiationService) {\r\n        this._instantiationService = _instantiationService;\r\n        this.templateId = FileReferencesRenderer.id;\r\n    }\r\n    renderTemplate(container) {\r\n        return this._instantiationService.createInstance(referencesTree_FileReferencesTemplate, container);\r\n    }\r\n    renderElement(node, index, template) {\r\n        template.set(node.element, Object(filters["createMatches"])(node.filterData));\r\n    }\r\n    disposeTemplate(templateData) {\r\n        templateData.dispose();\r\n    }\r\n};\r\nreferencesTree_FileReferencesRenderer.id = \'FileReferencesRenderer\';\r\nreferencesTree_FileReferencesRenderer = referencesTree_decorate([\r\n    referencesTree_param(0, instantiation["IInstantiationService"])\r\n], referencesTree_FileReferencesRenderer);\r\n\r\n//#endregion\r\n//#region render: Reference\r\nclass referencesTree_OneReferenceTemplate {\r\n    constructor(container) {\r\n        this.label = new highlightedLabel["HighlightedLabel"](container, false);\r\n    }\r\n    set(element, score) {\r\n        var _a;\r\n        const preview = (_a = element.parent.getPreview(element)) === null || _a === void 0 ? void 0 : _a.preview(element.range);\r\n        if (!preview || !preview.value) {\r\n            // this means we FAILED to resolve the document or the value is the empty string\r\n            this.label.set(`${Object(common_resources["basename"])(element.uri)}:${element.range.startLineNumber + 1}:${element.range.startColumn + 1}`);\r\n        }\r\n        else {\r\n            // render search match as highlight unless\r\n            // we have score, then render the score\r\n            const { value, highlight } = preview;\r\n            if (score && !filters["FuzzyScore"].isDefault(score)) {\r\n                this.label.element.classList.toggle(\'referenceMatch\', false);\r\n                this.label.set(value, Object(filters["createMatches"])(score));\r\n            }\r\n            else {\r\n                this.label.element.classList.toggle(\'referenceMatch\', true);\r\n                this.label.set(value, [highlight]);\r\n            }\r\n        }\r\n    }\r\n}\r\nclass OneReferenceRenderer {\r\n    constructor() {\r\n        this.templateId = OneReferenceRenderer.id;\r\n    }\r\n    renderTemplate(container) {\r\n        return new referencesTree_OneReferenceTemplate(container);\r\n    }\r\n    renderElement(node, index, templateData) {\r\n        templateData.set(node.element, node.filterData);\r\n    }\r\n    disposeTemplate() {\r\n    }\r\n}\r\nOneReferenceRenderer.id = \'OneReferenceRenderer\';\r\n//#endregion\r\nclass referencesTree_AccessibilityProvider {\r\n    getWidgetAriaLabel() {\r\n        return Object(nls["localize"])(\'treeAriaLabel\', "References");\r\n    }\r\n    getAriaLabel(element) {\r\n        return element.ariaMessage;\r\n    }\r\n}\r\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/platform/list/browser/listService.js + 12 modules\nvar browser_listService = __webpack_require__("./node_modules/monaco-editor/esm/vs/platform/list/browser/listService.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/base/browser/ui/splitview/splitview.js\nvar splitview = __webpack_require__("./node_modules/monaco-editor/esm/vs/base/browser/ui/splitview/splitview.js");\n\n// EXTERNAL MODULE: ./node_modules/monaco-editor/esm/vs/platform/undoRedo/common/undoRedo.js\nvar undoRedo = __webpack_require__("./node_modules/monaco-editor/esm/vs/platform/undoRedo/common/undoRedo.js");\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/peek/referencesWidget.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar referencesWidget_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar referencesWidget_param = (undefined && undefined.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nvar referencesWidget_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass referencesWidget_DecorationsManager {\r\n    constructor(_editor, _model) {\r\n        this._editor = _editor;\r\n        this._model = _model;\r\n        this._decorations = new Map();\r\n        this._decorationIgnoreSet = new Set();\r\n        this._callOnDispose = new lifecycle["DisposableStore"]();\r\n        this._callOnModelChange = new lifecycle["DisposableStore"]();\r\n        this._callOnDispose.add(this._editor.onDidChangeModel(() => this._onModelChanged()));\r\n        this._onModelChanged();\r\n    }\r\n    dispose() {\r\n        this._callOnModelChange.dispose();\r\n        this._callOnDispose.dispose();\r\n        this.removeDecorations();\r\n    }\r\n    _onModelChanged() {\r\n        this._callOnModelChange.clear();\r\n        const model = this._editor.getModel();\r\n        if (!model) {\r\n            return;\r\n        }\r\n        for (let ref of this._model.references) {\r\n            if (ref.uri.toString() === model.uri.toString()) {\r\n                this._addDecorations(ref.parent);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    _addDecorations(reference) {\r\n        if (!this._editor.hasModel()) {\r\n            return;\r\n        }\r\n        this._callOnModelChange.add(this._editor.getModel().onDidChangeDecorations(() => this._onDecorationChanged()));\r\n        const newDecorations = [];\r\n        const newDecorationsActualIndex = [];\r\n        for (let i = 0, len = reference.children.length; i < len; i++) {\r\n            let oneReference = reference.children[i];\r\n            if (this._decorationIgnoreSet.has(oneReference.id)) {\r\n                continue;\r\n            }\r\n            if (oneReference.uri.toString() !== this._editor.getModel().uri.toString()) {\r\n                continue;\r\n            }\r\n            newDecorations.push({\r\n                range: oneReference.range,\r\n                options: referencesWidget_DecorationsManager.DecorationOptions\r\n            });\r\n            newDecorationsActualIndex.push(i);\r\n        }\r\n        const decorations = this._editor.deltaDecorations([], newDecorations);\r\n        for (let i = 0; i < decorations.length; i++) {\r\n            this._decorations.set(decorations[i], reference.children[newDecorationsActualIndex[i]]);\r\n        }\r\n    }\r\n    _onDecorationChanged() {\r\n        const toRemove = [];\r\n        const model = this._editor.getModel();\r\n        if (!model) {\r\n            return;\r\n        }\r\n        for (let [decorationId, reference] of this._decorations) {\r\n            const newRange = model.getDecorationRange(decorationId);\r\n            if (!newRange) {\r\n                continue;\r\n            }\r\n            let ignore = false;\r\n            if (core_range["Range"].equalsRange(newRange, reference.range)) {\r\n                continue;\r\n            }\r\n            if (core_range["Range"].spansMultipleLines(newRange)) {\r\n                ignore = true;\r\n            }\r\n            else {\r\n                const lineLength = reference.range.endColumn - reference.range.startColumn;\r\n                const newLineLength = newRange.endColumn - newRange.startColumn;\r\n                if (lineLength !== newLineLength) {\r\n                    ignore = true;\r\n                }\r\n            }\r\n            if (ignore) {\r\n                this._decorationIgnoreSet.add(reference.id);\r\n                toRemove.push(decorationId);\r\n            }\r\n            else {\r\n                reference.range = newRange;\r\n            }\r\n        }\r\n        for (let i = 0, len = toRemove.length; i < len; i++) {\r\n            this._decorations.delete(toRemove[i]);\r\n        }\r\n        this._editor.deltaDecorations(toRemove, []);\r\n    }\r\n    removeDecorations() {\r\n        this._editor.deltaDecorations([...this._decorations.keys()], []);\r\n        this._decorations.clear();\r\n    }\r\n}\r\nreferencesWidget_DecorationsManager.DecorationOptions = model_textModel["ModelDecorationOptions"].register({\r\n    description: \'reference-decoration\',\r\n    stickiness: 1 /* NeverGrowsWhenTypingAtEdges */,\r\n    className: \'reference-decoration\'\r\n});\r\nclass LayoutData {\r\n    constructor() {\r\n        this.ratio = 0.7;\r\n        this.heightInLines = 18;\r\n    }\r\n    static fromJSON(raw) {\r\n        let ratio;\r\n        let heightInLines;\r\n        try {\r\n            const data = JSON.parse(raw);\r\n            ratio = data.ratio;\r\n            heightInLines = data.heightInLines;\r\n        }\r\n        catch (_a) {\r\n            //\r\n        }\r\n        return {\r\n            ratio: ratio || 0.7,\r\n            heightInLines: heightInLines || 18\r\n        };\r\n    }\r\n}\r\nclass referencesWidget_ReferencesTree extends browser_listService["WorkbenchAsyncDataTree"] {\r\n}\r\n/**\r\n * ZoneWidget that is shown inside the editor\r\n */\r\nlet referencesWidget_ReferenceWidget = class ReferenceWidget extends peekView_PeekViewWidget {\r\n    constructor(editor, _defaultTreeKeyboardSupport, layoutData, themeService, _textModelResolverService, _instantiationService, _peekViewService, _uriLabel, _undoRedoService, _keybindingService) {\r\n        super(editor, { showFrame: false, showArrow: true, isResizeable: true, isAccessible: true, supportOnTitleClick: true }, _instantiationService);\r\n        this._defaultTreeKeyboardSupport = _defaultTreeKeyboardSupport;\r\n        this.layoutData = layoutData;\r\n        this._textModelResolverService = _textModelResolverService;\r\n        this._instantiationService = _instantiationService;\r\n        this._peekViewService = _peekViewService;\r\n        this._uriLabel = _uriLabel;\r\n        this._undoRedoService = _undoRedoService;\r\n        this._keybindingService = _keybindingService;\r\n        this._disposeOnNewModel = new lifecycle["DisposableStore"]();\r\n        this._callOnDispose = new lifecycle["DisposableStore"]();\r\n        this._onDidSelectReference = new common_event["Emitter"]();\r\n        this.onDidSelectReference = this._onDidSelectReference.event;\r\n        this._dim = new dom["Dimension"](0, 0);\r\n        this._applyTheme(themeService.getColorTheme());\r\n        this._callOnDispose.add(themeService.onDidColorThemeChange(this._applyTheme.bind(this)));\r\n        this._peekViewService.addExclusiveWidget(editor, this);\r\n        this.create();\r\n    }\r\n    dispose() {\r\n        this.setModel(undefined);\r\n        this._callOnDispose.dispose();\r\n        this._disposeOnNewModel.dispose();\r\n        Object(lifecycle["dispose"])(this._preview);\r\n        Object(lifecycle["dispose"])(this._previewNotAvailableMessage);\r\n        Object(lifecycle["dispose"])(this._tree);\r\n        Object(lifecycle["dispose"])(this._previewModelReference);\r\n        this._splitView.dispose();\r\n        super.dispose();\r\n    }\r\n    _applyTheme(theme) {\r\n        const borderColor = theme.getColor(peekViewBorder) || common_color["Color"].transparent;\r\n        this.style({\r\n            arrowColor: borderColor,\r\n            frameColor: borderColor,\r\n            headerBackgroundColor: theme.getColor(peekViewTitleBackground) || common_color["Color"].transparent,\r\n            primaryHeadingColor: theme.getColor(peekViewTitleForeground),\r\n            secondaryHeadingColor: theme.getColor(peekViewTitleInfoForeground)\r\n        });\r\n    }\r\n    show(where) {\r\n        this.editor.revealRangeInCenterIfOutsideViewport(where, 0 /* Smooth */);\r\n        super.show(where, this.layoutData.heightInLines || 18);\r\n    }\r\n    focusOnReferenceTree() {\r\n        this._tree.domFocus();\r\n    }\r\n    focusOnPreviewEditor() {\r\n        this._preview.focus();\r\n    }\r\n    isPreviewEditorFocused() {\r\n        return this._preview.hasTextFocus();\r\n    }\r\n    _onTitleClick(e) {\r\n        if (this._preview && this._preview.getModel()) {\r\n            this._onDidSelectReference.fire({\r\n                element: this._getFocusedReference(),\r\n                kind: e.ctrlKey || e.metaKey || e.altKey ? \'side\' : \'open\',\r\n                source: \'title\'\r\n            });\r\n        }\r\n    }\r\n    _fillBody(containerElement) {\r\n        this.setCssClass(\'reference-zone-widget\');\r\n        // message pane\r\n        this._messageContainer = dom["append"](containerElement, dom["$"](\'div.messages\'));\r\n        dom["hide"](this._messageContainer);\r\n        this._splitView = new splitview["SplitView"](containerElement, { orientation: 1 /* HORIZONTAL */ });\r\n        // editor\r\n        this._previewContainer = dom["append"](containerElement, dom["$"](\'div.preview.inline\'));\r\n        let options = {\r\n            scrollBeyondLastLine: false,\r\n            scrollbar: {\r\n                verticalScrollbarSize: 14,\r\n                horizontal: \'auto\',\r\n                useShadows: true,\r\n                verticalHasArrows: false,\r\n                horizontalHasArrows: false,\r\n                alwaysConsumeMouseWheel: false\r\n            },\r\n            overviewRulerLanes: 2,\r\n            fixedOverflowWidgets: true,\r\n            minimap: {\r\n                enabled: false\r\n            }\r\n        };\r\n        this._preview = this._instantiationService.createInstance(embeddedCodeEditorWidget_EmbeddedCodeEditorWidget, this._previewContainer, options, this.editor);\r\n        dom["hide"](this._previewContainer);\r\n        this._previewNotAvailableMessage = new model_textModel["TextModel"](nls["localize"](\'missingPreviewMessage\', "no preview available"), model_textModel["TextModel"].DEFAULT_CREATION_OPTIONS, null, null, this._undoRedoService);\r\n        // tree\r\n        this._treeContainer = dom["append"](containerElement, dom["$"](\'div.ref-tree.inline\'));\r\n        const treeOptions = {\r\n            keyboardSupport: this._defaultTreeKeyboardSupport,\r\n            accessibilityProvider: new referencesTree_AccessibilityProvider(),\r\n            keyboardNavigationLabelProvider: this._instantiationService.createInstance(referencesTree_StringRepresentationProvider),\r\n            identityProvider: new referencesTree_IdentityProvider(),\r\n            openOnSingleClick: true,\r\n            selectionNavigation: true,\r\n            overrideStyles: {\r\n                listBackground: peekViewResultsBackground\r\n            }\r\n        };\r\n        if (this._defaultTreeKeyboardSupport) {\r\n            // the tree will consume `Escape` and prevent the widget from closing\r\n            this._callOnDispose.add(dom["addStandardDisposableListener"](this._treeContainer, \'keydown\', (e) => {\r\n                if (e.equals(9 /* Escape */)) {\r\n                    this._keybindingService.dispatchEvent(e, e.target);\r\n                    e.stopPropagation();\r\n                }\r\n            }, true));\r\n        }\r\n        this._tree = this._instantiationService.createInstance(referencesWidget_ReferencesTree, \'ReferencesWidget\', this._treeContainer, new referencesTree_Delegate(), [\r\n            this._instantiationService.createInstance(referencesTree_FileReferencesRenderer),\r\n            this._instantiationService.createInstance(OneReferenceRenderer),\r\n        ], this._instantiationService.createInstance(referencesTree_DataSource), treeOptions);\r\n        // split stuff\r\n        this._splitView.addView({\r\n            onDidChange: common_event["Event"].None,\r\n            element: this._previewContainer,\r\n            minimumSize: 200,\r\n            maximumSize: Number.MAX_VALUE,\r\n            layout: (width) => {\r\n                this._preview.layout({ height: this._dim.height, width });\r\n            }\r\n        }, splitview["Sizing"].Distribute);\r\n        this._splitView.addView({\r\n            onDidChange: common_event["Event"].None,\r\n            element: this._treeContainer,\r\n            minimumSize: 100,\r\n            maximumSize: Number.MAX_VALUE,\r\n            layout: (width) => {\r\n                this._treeContainer.style.height = `${this._dim.height}px`;\r\n                this._treeContainer.style.width = `${width}px`;\r\n                this._tree.layout(this._dim.height, width);\r\n            }\r\n        }, splitview["Sizing"].Distribute);\r\n        this._disposables.add(this._splitView.onDidSashChange(() => {\r\n            if (this._dim.width) {\r\n                this.layoutData.ratio = this._splitView.getViewSize(0) / this._dim.width;\r\n            }\r\n        }, undefined));\r\n        // listen on selection and focus\r\n        let onEvent = (element, kind) => {\r\n            if (element instanceof referencesModel_OneReference) {\r\n                if (kind === \'show\') {\r\n                    this._revealReference(element, false);\r\n                }\r\n                this._onDidSelectReference.fire({ element, kind, source: \'tree\' });\r\n            }\r\n        };\r\n        this._tree.onDidOpen(e => {\r\n            if (e.sideBySide) {\r\n                onEvent(e.element, \'side\');\r\n            }\r\n            else if (e.editorOptions.pinned) {\r\n                onEvent(e.element, \'goto\');\r\n            }\r\n            else {\r\n                onEvent(e.element, \'show\');\r\n            }\r\n        });\r\n        dom["hide"](this._treeContainer);\r\n    }\r\n    _onWidth(width) {\r\n        if (this._dim) {\r\n            this._doLayoutBody(this._dim.height, width);\r\n        }\r\n    }\r\n    _doLayoutBody(heightInPixel, widthInPixel) {\r\n        super._doLayoutBody(heightInPixel, widthInPixel);\r\n        this._dim = new dom["Dimension"](widthInPixel, heightInPixel);\r\n        this.layoutData.heightInLines = this._viewZone ? this._viewZone.heightInLines : this.layoutData.heightInLines;\r\n        this._splitView.layout(widthInPixel);\r\n        this._splitView.resizeView(0, widthInPixel * this.layoutData.ratio);\r\n    }\r\n    setSelection(selection) {\r\n        return this._revealReference(selection, true).then(() => {\r\n            if (!this._model) {\r\n                // disposed\r\n                return;\r\n            }\r\n            // show in tree\r\n            this._tree.setSelection([selection]);\r\n            this._tree.setFocus([selection]);\r\n        });\r\n    }\r\n    setModel(newModel) {\r\n        // clean up\r\n        this._disposeOnNewModel.clear();\r\n        this._model = newModel;\r\n        if (this._model) {\r\n            return this._onNewModel();\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n    _onNewModel() {\r\n        if (!this._model) {\r\n            return Promise.resolve(undefined);\r\n        }\r\n        if (this._model.isEmpty) {\r\n            this.setTitle(\'\');\r\n            this._messageContainer.innerText = nls["localize"](\'noResults\', "No results");\r\n            dom["show"](this._messageContainer);\r\n            return Promise.resolve(undefined);\r\n        }\r\n        dom["hide"](this._messageContainer);\r\n        this._decorationsManager = new referencesWidget_DecorationsManager(this._preview, this._model);\r\n        this._disposeOnNewModel.add(this._decorationsManager);\r\n        // listen on model changes\r\n        this._disposeOnNewModel.add(this._model.onDidChangeReferenceRange(reference => this._tree.rerender(reference)));\r\n        // listen on editor\r\n        this._disposeOnNewModel.add(this._preview.onMouseDown(e => {\r\n            const { event, target } = e;\r\n            if (event.detail !== 2) {\r\n                return;\r\n            }\r\n            const element = this._getFocusedReference();\r\n            if (!element) {\r\n                return;\r\n            }\r\n            this._onDidSelectReference.fire({\r\n                element: { uri: element.uri, range: target.range },\r\n                kind: (event.ctrlKey || event.metaKey || event.altKey) ? \'side\' : \'open\',\r\n                source: \'editor\'\r\n            });\r\n        }));\r\n        // make sure things are rendered\r\n        this.container.classList.add(\'results-loaded\');\r\n        dom["show"](this._treeContainer);\r\n        dom["show"](this._previewContainer);\r\n        this._splitView.layout(this._dim.width);\r\n        this.focusOnReferenceTree();\r\n        // pick input and a reference to begin with\r\n        return this._tree.setInput(this._model.groups.length === 1 ? this._model.groups[0] : this._model);\r\n    }\r\n    _getFocusedReference() {\r\n        const [element] = this._tree.getFocus();\r\n        if (element instanceof referencesModel_OneReference) {\r\n            return element;\r\n        }\r\n        else if (element instanceof referencesModel_FileReferences) {\r\n            if (element.children.length > 0) {\r\n                return element.children[0];\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    revealReference(reference) {\r\n        return referencesWidget_awaiter(this, void 0, void 0, function* () {\r\n            yield this._revealReference(reference, false);\r\n            this._onDidSelectReference.fire({ element: reference, kind: \'goto\', source: \'tree\' });\r\n        });\r\n    }\r\n    _revealReference(reference, revealParent) {\r\n        return referencesWidget_awaiter(this, void 0, void 0, function* () {\r\n            // check if there is anything to do...\r\n            if (this._revealedReference === reference) {\r\n                return;\r\n            }\r\n            this._revealedReference = reference;\r\n            // Update widget header\r\n            if (reference.uri.scheme !== network["Schemas"].inMemory) {\r\n                this.setTitle(Object(common_resources["basenameOrAuthority"])(reference.uri), this._uriLabel.getUriLabel(Object(common_resources["dirname"])(reference.uri)));\r\n            }\r\n            else {\r\n                this.setTitle(nls["localize"](\'peekView.alternateTitle\', "References"));\r\n            }\r\n            const promise = this._textModelResolverService.createModelReference(reference.uri);\r\n            if (this._tree.getInput() === reference.parent) {\r\n                this._tree.reveal(reference);\r\n            }\r\n            else {\r\n                if (revealParent) {\r\n                    this._tree.reveal(reference.parent);\r\n                }\r\n                yield this._tree.expand(reference.parent);\r\n                this._tree.reveal(reference);\r\n            }\r\n            const ref = yield promise;\r\n            if (!this._model) {\r\n                // disposed\r\n                ref.dispose();\r\n                return;\r\n            }\r\n            Object(lifecycle["dispose"])(this._previewModelReference);\r\n            // show in editor\r\n            const model = ref.object;\r\n            if (model) {\r\n                const scrollType = this._preview.getModel() === model.textEditorModel ? 0 /* Smooth */ : 1 /* Immediate */;\r\n                const sel = core_range["Range"].lift(reference.range).collapseToStart();\r\n                this._previewModelReference = ref;\r\n                this._preview.setModel(model.textEditorModel);\r\n                this._preview.setSelection(sel);\r\n                this._preview.revealRangeInCenter(sel, scrollType);\r\n            }\r\n            else {\r\n                this._preview.setModel(this._previewNotAvailableMessage);\r\n                ref.dispose();\r\n            }\r\n        });\r\n    }\r\n};\r\nreferencesWidget_ReferenceWidget = referencesWidget_decorate([\r\n    referencesWidget_param(3, common_themeService["IThemeService"]),\r\n    referencesWidget_param(4, resolverService["ITextModelService"]),\r\n    referencesWidget_param(5, instantiation["IInstantiationService"]),\r\n    referencesWidget_param(6, IPeekViewService),\r\n    referencesWidget_param(7, common_label["ILabelService"]),\r\n    referencesWidget_param(8, undoRedo["IUndoRedoService"]),\r\n    referencesWidget_param(9, common_keybinding["IKeybindingService"])\r\n], referencesWidget_ReferenceWidget);\r\n\r\n// theming\r\nObject(common_themeService["registerThemingParticipant"])((theme, collector) => {\r\n    const findMatchHighlightColor = theme.getColor(peekViewResultsMatchHighlight);\r\n    if (findMatchHighlightColor) {\r\n        collector.addRule(`.monaco-editor .reference-zone-widget .ref-tree .referenceMatch .highlight { background-color: ${findMatchHighlightColor}; }`);\r\n    }\r\n    const referenceHighlightColor = theme.getColor(peekViewEditorMatchHighlight);\r\n    if (referenceHighlightColor) {\r\n        collector.addRule(`.monaco-editor .reference-zone-widget .preview .reference-decoration { background-color: ${referenceHighlightColor}; }`);\r\n    }\r\n    const referenceHighlightBorder = theme.getColor(peekViewEditorMatchHighlightBorder);\r\n    if (referenceHighlightBorder) {\r\n        collector.addRule(`.monaco-editor .reference-zone-widget .preview .reference-decoration { border: 2px solid ${referenceHighlightBorder}; box-sizing: border-box; }`);\r\n    }\r\n    const hcOutline = theme.getColor(colorRegistry["activeContrastBorder"]);\r\n    if (hcOutline) {\r\n        collector.addRule(`.monaco-editor .reference-zone-widget .ref-tree .referenceMatch .highlight { border: 1px dotted ${hcOutline}; box-sizing: border-box; }`);\r\n    }\r\n    const resultsBackground = theme.getColor(peekViewResultsBackground);\r\n    if (resultsBackground) {\r\n        collector.addRule(`.monaco-editor .reference-zone-widget .ref-tree { background-color: ${resultsBackground}; }`);\r\n    }\r\n    const resultsMatchForeground = theme.getColor(peekViewResultsMatchForeground);\r\n    if (resultsMatchForeground) {\r\n        collector.addRule(`.monaco-editor .reference-zone-widget .ref-tree { color: ${resultsMatchForeground}; }`);\r\n    }\r\n    const resultsFileForeground = theme.getColor(peekViewResultsFileForeground);\r\n    if (resultsFileForeground) {\r\n        collector.addRule(`.monaco-editor .reference-zone-widget .ref-tree .reference-file { color: ${resultsFileForeground}; }`);\r\n    }\r\n    const resultsSelectedBackground = theme.getColor(peekViewResultsSelectionBackground);\r\n    if (resultsSelectedBackground) {\r\n        collector.addRule(`.monaco-editor .reference-zone-widget .ref-tree .monaco-list:focus .monaco-list-rows > .monaco-list-row.selected:not(.highlighted) { background-color: ${resultsSelectedBackground}; }`);\r\n    }\r\n    const resultsSelectedForeground = theme.getColor(peekViewResultsSelectionForeground);\r\n    if (resultsSelectedForeground) {\r\n        collector.addRule(`.monaco-editor .reference-zone-widget .ref-tree .monaco-list:focus .monaco-list-rows > .monaco-list-row.selected:not(.highlighted) { color: ${resultsSelectedForeground} !important; }`);\r\n    }\r\n    const editorBackground = theme.getColor(peekViewEditorBackground);\r\n    if (editorBackground) {\r\n        collector.addRule(`.monaco-editor .reference-zone-widget .preview .monaco-editor .monaco-editor-background,` +\r\n            `.monaco-editor .reference-zone-widget .preview .monaco-editor .inputarea.ime-input {` +\r\n            `\tbackground-color: ${editorBackground};` +\r\n            `}`);\r\n    }\r\n    const editorGutterBackground = theme.getColor(peekViewEditorGutterBackground);\r\n    if (editorGutterBackground) {\r\n        collector.addRule(`.monaco-editor .reference-zone-widget .preview .monaco-editor .margin {` +\r\n            `\tbackground-color: ${editorGutterBackground};` +\r\n            `}`);\r\n    }\r\n});\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/peek/referencesController.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar referencesController_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar referencesController_param = (undefined && undefined.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\nvar referencesController_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst ctxReferenceSearchVisible = new contextkey["RawContextKey"](\'referenceSearchVisible\', false, nls["localize"](\'referenceSearchVisible\', "Whether reference peek is visible, like \'Peek References\' or \'Peek Definition\'"));\r\nlet referencesController_ReferencesController = class ReferencesController {\r\n    constructor(_defaultTreeKeyboardSupport, _editor, contextKeyService, _editorService, _notificationService, _instantiationService, _storageService, _configurationService) {\r\n        this._defaultTreeKeyboardSupport = _defaultTreeKeyboardSupport;\r\n        this._editor = _editor;\r\n        this._editorService = _editorService;\r\n        this._notificationService = _notificationService;\r\n        this._instantiationService = _instantiationService;\r\n        this._storageService = _storageService;\r\n        this._configurationService = _configurationService;\r\n        this._disposables = new lifecycle["DisposableStore"]();\r\n        this._requestIdPool = 0;\r\n        this._ignoreModelChangeEvent = false;\r\n        this._referenceSearchVisible = ctxReferenceSearchVisible.bindTo(contextKeyService);\r\n    }\r\n    static get(editor) {\r\n        return editor.getContribution(ReferencesController.ID);\r\n    }\r\n    dispose() {\r\n        var _a, _b;\r\n        this._referenceSearchVisible.reset();\r\n        this._disposables.dispose();\r\n        (_a = this._widget) === null || _a === void 0 ? void 0 : _a.dispose();\r\n        (_b = this._model) === null || _b === void 0 ? void 0 : _b.dispose();\r\n        this._widget = undefined;\r\n        this._model = undefined;\r\n    }\r\n    toggleWidget(range, modelPromise, peekMode) {\r\n        // close current widget and return early is position didn\'t change\r\n        let widgetPosition;\r\n        if (this._widget) {\r\n            widgetPosition = this._widget.position;\r\n        }\r\n        this.closeWidget();\r\n        if (!!widgetPosition && range.containsPosition(widgetPosition)) {\r\n            return;\r\n        }\r\n        this._peekMode = peekMode;\r\n        this._referenceSearchVisible.set(true);\r\n        // close the widget on model/mode changes\r\n        this._disposables.add(this._editor.onDidChangeModelLanguage(() => { this.closeWidget(); }));\r\n        this._disposables.add(this._editor.onDidChangeModel(() => {\r\n            if (!this._ignoreModelChangeEvent) {\r\n                this.closeWidget();\r\n            }\r\n        }));\r\n        const storageKey = \'peekViewLayout\';\r\n        const data = LayoutData.fromJSON(this._storageService.get(storageKey, 0 /* GLOBAL */, \'{}\'));\r\n        this._widget = this._instantiationService.createInstance(referencesWidget_ReferenceWidget, this._editor, this._defaultTreeKeyboardSupport, data);\r\n        this._widget.setTitle(nls["localize"](\'labelLoading\', "Loading..."));\r\n        this._widget.show(range);\r\n        this._disposables.add(this._widget.onDidClose(() => {\r\n            modelPromise.cancel();\r\n            if (this._widget) {\r\n                this._storageService.store(storageKey, JSON.stringify(this._widget.layoutData), 0 /* GLOBAL */, 1 /* MACHINE */);\r\n                this._widget = undefined;\r\n            }\r\n            this.closeWidget();\r\n        }));\r\n        this._disposables.add(this._widget.onDidSelectReference(event => {\r\n            let { element, kind } = event;\r\n            if (!element) {\r\n                return;\r\n            }\r\n            switch (kind) {\r\n                case \'open\':\r\n                    if (event.source !== \'editor\' || !this._configurationService.getValue(\'editor.stablePeek\')) {\r\n                        // when stable peek is configured we don\'t close\r\n                        // the peek window on selecting the editor\r\n                        this.openReference(element, false, false);\r\n                    }\r\n                    break;\r\n                case \'side\':\r\n                    this.openReference(element, true, false);\r\n                    break;\r\n                case \'goto\':\r\n                    if (peekMode) {\r\n                        this._gotoReference(element);\r\n                    }\r\n                    else {\r\n                        this.openReference(element, false, true);\r\n                    }\r\n                    break;\r\n            }\r\n        }));\r\n        const requestId = ++this._requestIdPool;\r\n        modelPromise.then(model => {\r\n            var _a;\r\n            // still current request? widget still open?\r\n            if (requestId !== this._requestIdPool || !this._widget) {\r\n                model.dispose();\r\n                return undefined;\r\n            }\r\n            (_a = this._model) === null || _a === void 0 ? void 0 : _a.dispose();\r\n            this._model = model;\r\n            // show widget\r\n            return this._widget.setModel(this._model).then(() => {\r\n                if (this._widget && this._model && this._editor.hasModel()) { // might have been closed\r\n                    // set title\r\n                    if (!this._model.isEmpty) {\r\n                        this._widget.setMetaTitle(nls["localize"](\'metaTitle.N\', "{0} ({1})", this._model.title, this._model.references.length));\r\n                    }\r\n                    else {\r\n                        this._widget.setMetaTitle(\'\');\r\n                    }\r\n                    // set \'best\' selection\r\n                    let uri = this._editor.getModel().uri;\r\n                    let pos = new core_position["Position"](range.startLineNumber, range.startColumn);\r\n                    let selection = this._model.nearestReference(uri, pos);\r\n                    if (selection) {\r\n                        return this._widget.setSelection(selection).then(() => {\r\n                            if (this._widget && this._editor.getOption(76 /* peekWidgetDefaultFocus */) === \'editor\') {\r\n                                this._widget.focusOnPreviewEditor();\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n                return undefined;\r\n            });\r\n        }, error => {\r\n            this._notificationService.error(error);\r\n        });\r\n    }\r\n    changeFocusBetweenPreviewAndReferences() {\r\n        if (!this._widget) {\r\n            // can be called while still resolving...\r\n            return;\r\n        }\r\n        if (this._widget.isPreviewEditorFocused()) {\r\n            this._widget.focusOnReferenceTree();\r\n        }\r\n        else {\r\n            this._widget.focusOnPreviewEditor();\r\n        }\r\n    }\r\n    goToNextOrPreviousReference(fwd) {\r\n        return referencesController_awaiter(this, void 0, void 0, function* () {\r\n            if (!this._editor.hasModel() || !this._model || !this._widget) {\r\n                // can be called while still resolving...\r\n                return;\r\n            }\r\n            const currentPosition = this._widget.position;\r\n            if (!currentPosition) {\r\n                return;\r\n            }\r\n            const source = this._model.nearestReference(this._editor.getModel().uri, currentPosition);\r\n            if (!source) {\r\n                return;\r\n            }\r\n            const target = this._model.nextOrPreviousReference(source, fwd);\r\n            const editorFocus = this._editor.hasTextFocus();\r\n            const previewEditorFocus = this._widget.isPreviewEditorFocused();\r\n            yield this._widget.setSelection(target);\r\n            yield this._gotoReference(target);\r\n            if (editorFocus) {\r\n                this._editor.focus();\r\n            }\r\n            else if (this._widget && previewEditorFocus) {\r\n                this._widget.focusOnPreviewEditor();\r\n            }\r\n        });\r\n    }\r\n    revealReference(reference) {\r\n        return referencesController_awaiter(this, void 0, void 0, function* () {\r\n            if (!this._editor.hasModel() || !this._model || !this._widget) {\r\n                // can be called while still resolving...\r\n                return;\r\n            }\r\n            yield this._widget.revealReference(reference);\r\n        });\r\n    }\r\n    closeWidget(focusEditor = true) {\r\n        var _a, _b;\r\n        (_a = this._widget) === null || _a === void 0 ? void 0 : _a.dispose();\r\n        (_b = this._model) === null || _b === void 0 ? void 0 : _b.dispose();\r\n        this._referenceSearchVisible.reset();\r\n        this._disposables.clear();\r\n        this._widget = undefined;\r\n        this._model = undefined;\r\n        if (focusEditor) {\r\n            this._editor.focus();\r\n        }\r\n        this._requestIdPool += 1; // Cancel pending requests\r\n    }\r\n    _gotoReference(ref) {\r\n        if (this._widget) {\r\n            this._widget.hide();\r\n        }\r\n        this._ignoreModelChangeEvent = true;\r\n        const range = core_range["Range"].lift(ref.range).collapseToStart();\r\n        return this._editorService.openCodeEditor({\r\n            resource: ref.uri,\r\n            options: { selection: range }\r\n        }, this._editor).then(openedEditor => {\r\n            var _a;\r\n            this._ignoreModelChangeEvent = false;\r\n            if (!openedEditor || !this._widget) {\r\n                // something went wrong...\r\n                this.closeWidget();\r\n                return;\r\n            }\r\n            if (this._editor === openedEditor) {\r\n                //\r\n                this._widget.show(range);\r\n                this._widget.focusOnReferenceTree();\r\n            }\r\n            else {\r\n                // we opened a different editor instance which means a different controller instance.\r\n                // therefore we stop with this controller and continue with the other\r\n                const other = ReferencesController.get(openedEditor);\r\n                const model = this._model.clone();\r\n                this.closeWidget();\r\n                openedEditor.focus();\r\n                other.toggleWidget(range, Object(common_async["createCancelablePromise"])(_ => Promise.resolve(model)), (_a = this._peekMode) !== null && _a !== void 0 ? _a : false);\r\n            }\r\n        }, (err) => {\r\n            this._ignoreModelChangeEvent = false;\r\n            Object(errors["onUnexpectedError"])(err);\r\n        });\r\n    }\r\n    openReference(ref, sideBySide, pinned) {\r\n        // clear stage\r\n        if (!sideBySide) {\r\n            this.closeWidget();\r\n        }\r\n        const { uri, range } = ref;\r\n        this._editorService.openCodeEditor({\r\n            resource: uri,\r\n            options: { selection: range, pinned }\r\n        }, this._editor, sideBySide);\r\n    }\r\n};\r\nreferencesController_ReferencesController.ID = \'editor.contrib.referencesController\';\r\nreferencesController_ReferencesController = referencesController_decorate([\r\n    referencesController_param(2, contextkey["IContextKeyService"]),\r\n    referencesController_param(3, services_codeEditorService["ICodeEditorService"]),\r\n    referencesController_param(4, notification["INotificationService"]),\r\n    referencesController_param(5, instantiation["IInstantiationService"]),\r\n    referencesController_param(6, storage["IStorageService"]),\r\n    referencesController_param(7, configuration["IConfigurationService"])\r\n], referencesController_ReferencesController);\r\n\r\nfunction withController(accessor, fn) {\r\n    const outerEditor = getOuterEditor(accessor);\r\n    if (!outerEditor) {\r\n        return;\r\n    }\r\n    let controller = referencesController_ReferencesController.get(outerEditor);\r\n    if (controller) {\r\n        fn(controller);\r\n    }\r\n}\r\nkeybindingsRegistry["KeybindingsRegistry"].registerCommandAndKeybindingRule({\r\n    id: \'togglePeekWidgetFocus\',\r\n    weight: 100 /* EditorContrib */,\r\n    primary: Object(keyCodes["KeyChord"])(2048 /* CtrlCmd */ | 41 /* KEY_K */, 60 /* F2 */),\r\n    when: contextkey["ContextKeyExpr"].or(ctxReferenceSearchVisible, peekView_PeekContext.inPeekEditor),\r\n    handler(accessor) {\r\n        withController(accessor, controller => {\r\n            controller.changeFocusBetweenPreviewAndReferences();\r\n        });\r\n    }\r\n});\r\nkeybindingsRegistry["KeybindingsRegistry"].registerCommandAndKeybindingRule({\r\n    id: \'goToNextReference\',\r\n    weight: 100 /* EditorContrib */ - 10,\r\n    primary: 62 /* F4 */,\r\n    secondary: [70 /* F12 */],\r\n    when: contextkey["ContextKeyExpr"].or(ctxReferenceSearchVisible, peekView_PeekContext.inPeekEditor),\r\n    handler(accessor) {\r\n        withController(accessor, controller => {\r\n            controller.goToNextOrPreviousReference(true);\r\n        });\r\n    }\r\n});\r\nkeybindingsRegistry["KeybindingsRegistry"].registerCommandAndKeybindingRule({\r\n    id: \'goToPreviousReference\',\r\n    weight: 100 /* EditorContrib */ - 10,\r\n    primary: 1024 /* Shift */ | 62 /* F4 */,\r\n    secondary: [1024 /* Shift */ | 70 /* F12 */],\r\n    when: contextkey["ContextKeyExpr"].or(ctxReferenceSearchVisible, peekView_PeekContext.inPeekEditor),\r\n    handler(accessor) {\r\n        withController(accessor, controller => {\r\n            controller.goToNextOrPreviousReference(false);\r\n        });\r\n    }\r\n});\r\n// commands that aren\'t needed anymore because there is now ContextKeyExpr.OR\r\ncommon_commands["CommandsRegistry"].registerCommandAlias(\'goToNextReferenceFromEmbeddedEditor\', \'goToNextReference\');\r\ncommon_commands["CommandsRegistry"].registerCommandAlias(\'goToPreviousReferenceFromEmbeddedEditor\', \'goToPreviousReference\');\r\n// close\r\ncommon_commands["CommandsRegistry"].registerCommandAlias(\'closeReferenceSearchEditor\', \'closeReferenceSearch\');\r\ncommon_commands["CommandsRegistry"].registerCommand(\'closeReferenceSearch\', accessor => withController(accessor, controller => controller.closeWidget()));\r\nkeybindingsRegistry["KeybindingsRegistry"].registerKeybindingRule({\r\n    id: \'closeReferenceSearch\',\r\n    weight: 100 /* EditorContrib */ - 101,\r\n    primary: 9 /* Escape */,\r\n    secondary: [1024 /* Shift */ | 9 /* Escape */],\r\n    when: contextkey["ContextKeyExpr"].and(peekView_PeekContext.inPeekEditor, contextkey["ContextKeyExpr"].not(\'config.editor.stablePeek\'))\r\n});\r\nkeybindingsRegistry["KeybindingsRegistry"].registerKeybindingRule({\r\n    id: \'closeReferenceSearch\',\r\n    weight: 200 /* WorkbenchContrib */ + 50,\r\n    primary: 9 /* Escape */,\r\n    secondary: [1024 /* Shift */ | 9 /* Escape */],\r\n    when: contextkey["ContextKeyExpr"].and(ctxReferenceSearchVisible, contextkey["ContextKeyExpr"].not(\'config.editor.stablePeek\'))\r\n});\r\nkeybindingsRegistry["KeybindingsRegistry"].registerCommandAndKeybindingRule({\r\n    id: \'revealReference\',\r\n    weight: 200 /* WorkbenchContrib */,\r\n    primary: 3 /* Enter */,\r\n    mac: {\r\n        primary: 3 /* Enter */,\r\n        secondary: [2048 /* CtrlCmd */ | 18 /* DownArrow */]\r\n    },\r\n    when: contextkey["ContextKeyExpr"].and(ctxReferenceSearchVisible, browser_listService["WorkbenchListFocusContextKey"]),\r\n    handler(accessor) {\r\n        var _a;\r\n        const listService = accessor.get(browser_listService["IListService"]);\r\n        const focus = (_a = listService.lastFocusedList) === null || _a === void 0 ? void 0 : _a.getFocus();\r\n        if (Array.isArray(focus) && focus[0] instanceof referencesModel_OneReference) {\r\n            withController(accessor, controller => controller.revealReference(focus[0]));\r\n        }\r\n    }\r\n});\r\nkeybindingsRegistry["KeybindingsRegistry"].registerCommandAndKeybindingRule({\r\n    id: \'openReferenceToSide\',\r\n    weight: 100 /* EditorContrib */,\r\n    primary: 2048 /* CtrlCmd */ | 3 /* Enter */,\r\n    mac: {\r\n        primary: 256 /* WinCtrl */ | 3 /* Enter */\r\n    },\r\n    when: contextkey["ContextKeyExpr"].and(ctxReferenceSearchVisible, browser_listService["WorkbenchListFocusContextKey"]),\r\n    handler(accessor) {\r\n        var _a;\r\n        const listService = accessor.get(browser_listService["IListService"]);\r\n        const focus = (_a = listService.lastFocusedList) === null || _a === void 0 ? void 0 : _a.getFocus();\r\n        if (Array.isArray(focus) && focus[0] instanceof referencesModel_OneReference) {\r\n            withController(accessor, controller => controller.openReference(focus[0], true, true));\r\n        }\r\n    }\r\n});\r\ncommon_commands["CommandsRegistry"].registerCommand(\'openReference\', (accessor) => {\r\n    var _a;\r\n    const listService = accessor.get(browser_listService["IListService"]);\r\n    const focus = (_a = listService.lastFocusedList) === null || _a === void 0 ? void 0 : _a.getFocus();\r\n    if (Array.isArray(focus) && focus[0] instanceof referencesModel_OneReference) {\r\n        withController(accessor, controller => controller.openReference(focus[0], false, true));\r\n    }\r\n});\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/symbolNavigation.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar symbolNavigation_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar symbolNavigation_param = (undefined && undefined.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst ctxHasSymbols = new contextkey["RawContextKey"](\'hasSymbols\', false, Object(nls["localize"])(\'hasSymbols\', "Whether there are symbol locations that can be navigated via keyboard-only."));\r\nconst ISymbolNavigationService = Object(instantiation["createDecorator"])(\'ISymbolNavigationService\');\r\nlet symbolNavigation_SymbolNavigationService = class SymbolNavigationService {\r\n    constructor(contextKeyService, _editorService, _notificationService, _keybindingService) {\r\n        this._editorService = _editorService;\r\n        this._notificationService = _notificationService;\r\n        this._keybindingService = _keybindingService;\r\n        this._currentModel = undefined;\r\n        this._currentIdx = -1;\r\n        this._ignoreEditorChange = false;\r\n        this._ctxHasSymbols = ctxHasSymbols.bindTo(contextKeyService);\r\n    }\r\n    reset() {\r\n        var _a, _b;\r\n        this._ctxHasSymbols.reset();\r\n        (_a = this._currentState) === null || _a === void 0 ? void 0 : _a.dispose();\r\n        (_b = this._currentMessage) === null || _b === void 0 ? void 0 : _b.dispose();\r\n        this._currentModel = undefined;\r\n        this._currentIdx = -1;\r\n    }\r\n    put(anchor) {\r\n        const refModel = anchor.parent.parent;\r\n        if (refModel.references.length <= 1) {\r\n            this.reset();\r\n            return;\r\n        }\r\n        this._currentModel = refModel;\r\n        this._currentIdx = refModel.references.indexOf(anchor);\r\n        this._ctxHasSymbols.set(true);\r\n        this._showMessage();\r\n        const editorState = new symbolNavigation_EditorState(this._editorService);\r\n        const listener = editorState.onDidChange(_ => {\r\n            if (this._ignoreEditorChange) {\r\n                return;\r\n            }\r\n            const editor = this._editorService.getActiveCodeEditor();\r\n            if (!editor) {\r\n                return;\r\n            }\r\n            const model = editor.getModel();\r\n            const position = editor.getPosition();\r\n            if (!model || !position) {\r\n                return;\r\n            }\r\n            let seenUri = false;\r\n            let seenPosition = false;\r\n            for (const reference of refModel.references) {\r\n                if (Object(common_resources["isEqual"])(reference.uri, model.uri)) {\r\n                    seenUri = true;\r\n                    seenPosition = seenPosition || core_range["Range"].containsPosition(reference.range, position);\r\n                }\r\n                else if (seenUri) {\r\n                    break;\r\n                }\r\n            }\r\n            if (!seenUri || !seenPosition) {\r\n                this.reset();\r\n            }\r\n        });\r\n        this._currentState = Object(lifecycle["combinedDisposable"])(editorState, listener);\r\n    }\r\n    revealNext(source) {\r\n        if (!this._currentModel) {\r\n            return Promise.resolve();\r\n        }\r\n        // get next result and advance\r\n        this._currentIdx += 1;\r\n        this._currentIdx %= this._currentModel.references.length;\r\n        const reference = this._currentModel.references[this._currentIdx];\r\n        // status\r\n        this._showMessage();\r\n        // open editor, ignore events while that happens\r\n        this._ignoreEditorChange = true;\r\n        return this._editorService.openCodeEditor({\r\n            resource: reference.uri,\r\n            options: {\r\n                selection: core_range["Range"].collapseToStart(reference.range),\r\n                selectionRevealType: 3 /* NearTopIfOutsideViewport */\r\n            }\r\n        }, source).finally(() => {\r\n            this._ignoreEditorChange = false;\r\n        });\r\n    }\r\n    _showMessage() {\r\n        var _a;\r\n        (_a = this._currentMessage) === null || _a === void 0 ? void 0 : _a.dispose();\r\n        const kb = this._keybindingService.lookupKeybinding(\'editor.gotoNextSymbolFromResult\');\r\n        const message = kb\r\n            ? Object(nls["localize"])(\'location.kb\', "Symbol {0} of {1}, {2} for next", this._currentIdx + 1, this._currentModel.references.length, kb.getLabel())\r\n            : Object(nls["localize"])(\'location\', "Symbol {0} of {1}", this._currentIdx + 1, this._currentModel.references.length);\r\n        this._currentMessage = this._notificationService.status(message);\r\n    }\r\n};\r\nsymbolNavigation_SymbolNavigationService = symbolNavigation_decorate([\r\n    symbolNavigation_param(0, contextkey["IContextKeyService"]),\r\n    symbolNavigation_param(1, services_codeEditorService["ICodeEditorService"]),\r\n    symbolNavigation_param(2, notification["INotificationService"]),\r\n    symbolNavigation_param(3, common_keybinding["IKeybindingService"])\r\n], symbolNavigation_SymbolNavigationService);\r\nObject(extensions["registerSingleton"])(ISymbolNavigationService, symbolNavigation_SymbolNavigationService, true);\r\nObject(editorExtensions["registerEditorCommand"])(new class extends editorExtensions["EditorCommand"] {\r\n    constructor() {\r\n        super({\r\n            id: \'editor.gotoNextSymbolFromResult\',\r\n            precondition: ctxHasSymbols,\r\n            kbOpts: {\r\n                weight: 100 /* EditorContrib */,\r\n                primary: 70 /* F12 */\r\n            }\r\n        });\r\n    }\r\n    runEditorCommand(accessor, editor) {\r\n        return accessor.get(ISymbolNavigationService).revealNext(editor);\r\n    }\r\n});\r\nkeybindingsRegistry["KeybindingsRegistry"].registerCommandAndKeybindingRule({\r\n    id: \'editor.gotoNextSymbolFromResult.cancel\',\r\n    weight: 100 /* EditorContrib */,\r\n    when: ctxHasSymbols,\r\n    primary: 9 /* Escape */,\r\n    handler(accessor) {\r\n        accessor.get(ISymbolNavigationService).reset();\r\n    }\r\n});\r\n//\r\nlet symbolNavigation_EditorState = class EditorState {\r\n    constructor(editorService) {\r\n        this._listener = new Map();\r\n        this._disposables = new lifecycle["DisposableStore"]();\r\n        this._onDidChange = new common_event["Emitter"]();\r\n        this.onDidChange = this._onDidChange.event;\r\n        this._disposables.add(editorService.onCodeEditorRemove(this._onDidRemoveEditor, this));\r\n        this._disposables.add(editorService.onCodeEditorAdd(this._onDidAddEditor, this));\r\n        editorService.listCodeEditors().forEach(this._onDidAddEditor, this);\r\n    }\r\n    dispose() {\r\n        this._disposables.dispose();\r\n        this._onDidChange.dispose();\r\n        Object(lifecycle["dispose"])(this._listener.values());\r\n    }\r\n    _onDidAddEditor(editor) {\r\n        this._listener.set(editor, Object(lifecycle["combinedDisposable"])(editor.onDidChangeCursorPosition(_ => this._onDidChange.fire({ editor })), editor.onDidChangeModelContent(_ => this._onDidChange.fire({ editor }))));\r\n    }\r\n    _onDidRemoveEditor(editor) {\r\n        var _a;\r\n        (_a = this._listener.get(editor)) === null || _a === void 0 ? void 0 : _a.dispose();\r\n        this._listener.delete(editor);\r\n    }\r\n};\r\nsymbolNavigation_EditorState = symbolNavigation_decorate([\r\n    symbolNavigation_param(0, services_codeEditorService["ICodeEditorService"])\r\n], symbolNavigation_EditorState);\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/goToCommands.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar goToCommands_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar goToCommands_a, goToCommands_b, goToCommands_c, goToCommands_d, goToCommands_e, _f, _g, _h;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nactions_common_actions["MenuRegistry"].appendMenuItem(actions_common_actions["MenuId"].EditorContext, {\r\n    submenu: actions_common_actions["MenuId"].EditorContextPeek,\r\n    title: nls["localize"](\'peek.submenu\', "Peek"),\r\n    group: \'navigation\',\r\n    order: 100\r\n});\r\nconst _goToActionIds = new Set();\r\nfunction registerGoToAction(ctor) {\r\n    const result = new ctor();\r\n    Object(editorExtensions["registerInstantiatedEditorAction"])(result);\r\n    _goToActionIds.add(result.id);\r\n    return result;\r\n}\r\nclass goToCommands_SymbolNavigationAction extends editorExtensions["EditorAction"] {\r\n    constructor(configuration, opts) {\r\n        super(opts);\r\n        this._configuration = configuration;\r\n    }\r\n    run(accessor, editor) {\r\n        if (!editor.hasModel()) {\r\n            return Promise.resolve(undefined);\r\n        }\r\n        const notificationService = accessor.get(notification["INotificationService"]);\r\n        const editorService = accessor.get(services_codeEditorService["ICodeEditorService"]);\r\n        const progressService = accessor.get(common_progress["IEditorProgressService"]);\r\n        const symbolNavService = accessor.get(ISymbolNavigationService);\r\n        const model = editor.getModel();\r\n        const pos = editor.getPosition();\r\n        const cts = new core_editorState["EditorStateCancellationTokenSource"](editor, 1 /* Value */ | 4 /* Position */);\r\n        const promise = Object(common_async["raceCancellation"])(this._getLocationModel(model, pos, cts.token), cts.token).then((references) => goToCommands_awaiter(this, void 0, void 0, function* () {\r\n            if (!references || cts.token.isCancellationRequested) {\r\n                return;\r\n            }\r\n            Object(aria["alert"])(references.ariaMessage);\r\n            let altAction;\r\n            if (references.referenceAt(model.uri, pos)) {\r\n                const altActionId = this._getAlternativeCommand(editor);\r\n                if (altActionId !== this.id && _goToActionIds.has(altActionId)) {\r\n                    altAction = editor.getAction(altActionId);\r\n                }\r\n            }\r\n            const referenceCount = references.references.length;\r\n            if (referenceCount === 0) {\r\n                // no result -> show message\r\n                if (!this._configuration.muteMessage) {\r\n                    const info = model.getWordAtPosition(pos);\r\n                    messageController_MessageController.get(editor).showMessage(this._getNoResultFoundMessage(info), pos);\r\n                }\r\n            }\r\n            else if (referenceCount === 1 && altAction) {\r\n                // already at the only result, run alternative\r\n                altAction.run();\r\n            }\r\n            else {\r\n                // normal results handling\r\n                return this._onResult(editorService, symbolNavService, editor, references);\r\n            }\r\n        }), (err) => {\r\n            // report an error\r\n            notificationService.error(err);\r\n        }).finally(() => {\r\n            cts.dispose();\r\n        });\r\n        progressService.showWhile(promise, 250);\r\n        return promise;\r\n    }\r\n    _onResult(editorService, symbolNavService, editor, model) {\r\n        return goToCommands_awaiter(this, void 0, void 0, function* () {\r\n            const gotoLocation = this._getGoToPreference(editor);\r\n            if (!(editor instanceof embeddedCodeEditorWidget_EmbeddedCodeEditorWidget) && (this._configuration.openInPeek || (gotoLocation === \'peek\' && model.references.length > 1))) {\r\n                this._openInPeek(editor, model);\r\n            }\r\n            else {\r\n                const next = model.firstReference();\r\n                const peek = model.references.length > 1 && gotoLocation === \'gotoAndPeek\';\r\n                const targetEditor = yield this._openReference(editor, editorService, next, this._configuration.openToSide, !peek);\r\n                if (peek && targetEditor) {\r\n                    this._openInPeek(targetEditor, model);\r\n                }\r\n                else {\r\n                    model.dispose();\r\n                }\r\n                // keep remaining locations around when using\r\n                // \'goto\'-mode\r\n                if (gotoLocation === \'goto\') {\r\n                    symbolNavService.put(next);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    _openReference(editor, editorService, reference, sideBySide, highlight) {\r\n        return goToCommands_awaiter(this, void 0, void 0, function* () {\r\n            // range is the target-selection-range when we have one\r\n            // and the fallback is the \'full\' range\r\n            let range = undefined;\r\n            if (Object(modes["isLocationLink"])(reference)) {\r\n                range = reference.targetSelectionRange;\r\n            }\r\n            if (!range) {\r\n                range = reference.range;\r\n            }\r\n            if (!range) {\r\n                return undefined;\r\n            }\r\n            const targetEditor = yield editorService.openCodeEditor({\r\n                resource: reference.uri,\r\n                options: {\r\n                    selection: core_range["Range"].collapseToStart(range),\r\n                    selectionRevealType: 3 /* NearTopIfOutsideViewport */\r\n                }\r\n            }, editor, sideBySide);\r\n            if (!targetEditor) {\r\n                return undefined;\r\n            }\r\n            if (highlight) {\r\n                const modelNow = targetEditor.getModel();\r\n                const ids = targetEditor.deltaDecorations([], [{ range, options: { description: \'symbol-navigate-action-highlight\', className: \'symbolHighlight\' } }]);\r\n                setTimeout(() => {\r\n                    if (targetEditor.getModel() === modelNow) {\r\n                        targetEditor.deltaDecorations(ids, []);\r\n                    }\r\n                }, 350);\r\n            }\r\n            return targetEditor;\r\n        });\r\n    }\r\n    _openInPeek(target, model) {\r\n        let controller = referencesController_ReferencesController.get(target);\r\n        if (controller && target.hasModel()) {\r\n            controller.toggleWidget(target.getSelection(), Object(common_async["createCancelablePromise"])(_ => Promise.resolve(model)), this._configuration.openInPeek);\r\n        }\r\n        else {\r\n            model.dispose();\r\n        }\r\n    }\r\n}\r\n//#region --- DEFINITION\r\nclass goToCommands_DefinitionAction extends goToCommands_SymbolNavigationAction {\r\n    _getLocationModel(model, position, token) {\r\n        return goToCommands_awaiter(this, void 0, void 0, function* () {\r\n            return new referencesModel_ReferencesModel(yield getDefinitionsAtPosition(model, position, token), nls["localize"](\'def.title\', \'Definitions\'));\r\n        });\r\n    }\r\n    _getNoResultFoundMessage(info) {\r\n        return info && info.word\r\n            ? nls["localize"](\'noResultWord\', "No definition found for \'{0}\'", info.word)\r\n            : nls["localize"](\'generic.noResults\', "No definition found");\r\n    }\r\n    _getAlternativeCommand(editor) {\r\n        return editor.getOption(49 /* gotoLocation */).alternativeDefinitionCommand;\r\n    }\r\n    _getGoToPreference(editor) {\r\n        return editor.getOption(49 /* gotoLocation */).multipleDefinitions;\r\n    }\r\n}\r\nconst goToDefinitionKb = platform["isWeb"] && !browser["isStandalone"]\r\n    ? 2048 /* CtrlCmd */ | 70 /* F12 */\r\n    : 70 /* F12 */;\r\nregisterGoToAction((goToCommands_a = class GoToDefinitionAction extends goToCommands_DefinitionAction {\r\n        constructor() {\r\n            super({\r\n                openToSide: false,\r\n                openInPeek: false,\r\n                muteMessage: false\r\n            }, {\r\n                id: GoToDefinitionAction.id,\r\n                label: nls["localize"](\'actions.goToDecl.label\', "Go to Definition"),\r\n                alias: \'Go to Definition\',\r\n                precondition: contextkey["ContextKeyExpr"].and(editorContextKeys["EditorContextKeys"].hasDefinitionProvider, editorContextKeys["EditorContextKeys"].isInWalkThroughSnippet.toNegated()),\r\n                kbOpts: {\r\n                    kbExpr: editorContextKeys["EditorContextKeys"].editorTextFocus,\r\n                    primary: goToDefinitionKb,\r\n                    weight: 100 /* EditorContrib */\r\n                },\r\n                contextMenuOpts: {\r\n                    group: \'navigation\',\r\n                    order: 1.1\r\n                }\r\n            });\r\n            common_commands["CommandsRegistry"].registerCommandAlias(\'editor.action.goToDeclaration\', GoToDefinitionAction.id);\r\n        }\r\n    },\r\n    goToCommands_a.id = \'editor.action.revealDefinition\',\r\n    goToCommands_a));\r\nregisterGoToAction((goToCommands_b = class OpenDefinitionToSideAction extends goToCommands_DefinitionAction {\r\n        constructor() {\r\n            super({\r\n                openToSide: true,\r\n                openInPeek: false,\r\n                muteMessage: false\r\n            }, {\r\n                id: OpenDefinitionToSideAction.id,\r\n                label: nls["localize"](\'actions.goToDeclToSide.label\', "Open Definition to the Side"),\r\n                alias: \'Open Definition to the Side\',\r\n                precondition: contextkey["ContextKeyExpr"].and(editorContextKeys["EditorContextKeys"].hasDefinitionProvider, editorContextKeys["EditorContextKeys"].isInWalkThroughSnippet.toNegated()),\r\n                kbOpts: {\r\n                    kbExpr: editorContextKeys["EditorContextKeys"].editorTextFocus,\r\n                    primary: Object(keyCodes["KeyChord"])(2048 /* CtrlCmd */ | 41 /* KEY_K */, goToDefinitionKb),\r\n                    weight: 100 /* EditorContrib */\r\n                }\r\n            });\r\n            common_commands["CommandsRegistry"].registerCommandAlias(\'editor.action.openDeclarationToTheSide\', OpenDefinitionToSideAction.id);\r\n        }\r\n    },\r\n    goToCommands_b.id = \'editor.action.revealDefinitionAside\',\r\n    goToCommands_b));\r\nregisterGoToAction((goToCommands_c = class PeekDefinitionAction extends goToCommands_DefinitionAction {\r\n        constructor() {\r\n            super({\r\n                openToSide: false,\r\n                openInPeek: true,\r\n                muteMessage: false\r\n            }, {\r\n                id: PeekDefinitionAction.id,\r\n                label: nls["localize"](\'actions.previewDecl.label\', "Peek Definition"),\r\n                alias: \'Peek Definition\',\r\n                precondition: contextkey["ContextKeyExpr"].and(editorContextKeys["EditorContextKeys"].hasDefinitionProvider, peekView_PeekContext.notInPeekEditor, editorContextKeys["EditorContextKeys"].isInWalkThroughSnippet.toNegated()),\r\n                kbOpts: {\r\n                    kbExpr: editorContextKeys["EditorContextKeys"].editorTextFocus,\r\n                    primary: 512 /* Alt */ | 70 /* F12 */,\r\n                    linux: { primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 68 /* F10 */ },\r\n                    weight: 100 /* EditorContrib */\r\n                },\r\n                contextMenuOpts: {\r\n                    menuId: actions_common_actions["MenuId"].EditorContextPeek,\r\n                    group: \'peek\',\r\n                    order: 2\r\n                }\r\n            });\r\n            common_commands["CommandsRegistry"].registerCommandAlias(\'editor.action.previewDeclaration\', PeekDefinitionAction.id);\r\n        }\r\n    },\r\n    goToCommands_c.id = \'editor.action.peekDefinition\',\r\n    goToCommands_c));\r\n//#endregion\r\n//#region --- DECLARATION\r\nclass goToCommands_DeclarationAction extends goToCommands_SymbolNavigationAction {\r\n    _getLocationModel(model, position, token) {\r\n        return goToCommands_awaiter(this, void 0, void 0, function* () {\r\n            return new referencesModel_ReferencesModel(yield getDeclarationsAtPosition(model, position, token), nls["localize"](\'decl.title\', \'Declarations\'));\r\n        });\r\n    }\r\n    _getNoResultFoundMessage(info) {\r\n        return info && info.word\r\n            ? nls["localize"](\'decl.noResultWord\', "No declaration found for \'{0}\'", info.word)\r\n            : nls["localize"](\'decl.generic.noResults\', "No declaration found");\r\n    }\r\n    _getAlternativeCommand(editor) {\r\n        return editor.getOption(49 /* gotoLocation */).alternativeDeclarationCommand;\r\n    }\r\n    _getGoToPreference(editor) {\r\n        return editor.getOption(49 /* gotoLocation */).multipleDeclarations;\r\n    }\r\n}\r\nregisterGoToAction((goToCommands_d = class GoToDeclarationAction extends goToCommands_DeclarationAction {\r\n        constructor() {\r\n            super({\r\n                openToSide: false,\r\n                openInPeek: false,\r\n                muteMessage: false\r\n            }, {\r\n                id: GoToDeclarationAction.id,\r\n                label: nls["localize"](\'actions.goToDeclaration.label\', "Go to Declaration"),\r\n                alias: \'Go to Declaration\',\r\n                precondition: contextkey["ContextKeyExpr"].and(editorContextKeys["EditorContextKeys"].hasDeclarationProvider, editorContextKeys["EditorContextKeys"].isInWalkThroughSnippet.toNegated()),\r\n                contextMenuOpts: {\r\n                    group: \'navigation\',\r\n                    order: 1.3\r\n                },\r\n            });\r\n        }\r\n        _getNoResultFoundMessage(info) {\r\n            return info && info.word\r\n                ? nls["localize"](\'decl.noResultWord\', "No declaration found for \'{0}\'", info.word)\r\n                : nls["localize"](\'decl.generic.noResults\', "No declaration found");\r\n        }\r\n    },\r\n    goToCommands_d.id = \'editor.action.revealDeclaration\',\r\n    goToCommands_d));\r\nregisterGoToAction(class PeekDeclarationAction extends goToCommands_DeclarationAction {\r\n    constructor() {\r\n        super({\r\n            openToSide: false,\r\n            openInPeek: true,\r\n            muteMessage: false\r\n        }, {\r\n            id: \'editor.action.peekDeclaration\',\r\n            label: nls["localize"](\'actions.peekDecl.label\', "Peek Declaration"),\r\n            alias: \'Peek Declaration\',\r\n            precondition: contextkey["ContextKeyExpr"].and(editorContextKeys["EditorContextKeys"].hasDeclarationProvider, peekView_PeekContext.notInPeekEditor, editorContextKeys["EditorContextKeys"].isInWalkThroughSnippet.toNegated()),\r\n            contextMenuOpts: {\r\n                menuId: actions_common_actions["MenuId"].EditorContextPeek,\r\n                group: \'peek\',\r\n                order: 3\r\n            }\r\n        });\r\n    }\r\n});\r\n//#endregion\r\n//#region --- TYPE DEFINITION\r\nclass goToCommands_TypeDefinitionAction extends goToCommands_SymbolNavigationAction {\r\n    _getLocationModel(model, position, token) {\r\n        return goToCommands_awaiter(this, void 0, void 0, function* () {\r\n            return new referencesModel_ReferencesModel(yield getTypeDefinitionsAtPosition(model, position, token), nls["localize"](\'typedef.title\', \'Type Definitions\'));\r\n        });\r\n    }\r\n    _getNoResultFoundMessage(info) {\r\n        return info && info.word\r\n            ? nls["localize"](\'goToTypeDefinition.noResultWord\', "No type definition found for \'{0}\'", info.word)\r\n            : nls["localize"](\'goToTypeDefinition.generic.noResults\', "No type definition found");\r\n    }\r\n    _getAlternativeCommand(editor) {\r\n        return editor.getOption(49 /* gotoLocation */).alternativeTypeDefinitionCommand;\r\n    }\r\n    _getGoToPreference(editor) {\r\n        return editor.getOption(49 /* gotoLocation */).multipleTypeDefinitions;\r\n    }\r\n}\r\nregisterGoToAction((goToCommands_e = class GoToTypeDefinitionAction extends goToCommands_TypeDefinitionAction {\r\n        constructor() {\r\n            super({\r\n                openToSide: false,\r\n                openInPeek: false,\r\n                muteMessage: false\r\n            }, {\r\n                id: GoToTypeDefinitionAction.ID,\r\n                label: nls["localize"](\'actions.goToTypeDefinition.label\', "Go to Type Definition"),\r\n                alias: \'Go to Type Definition\',\r\n                precondition: contextkey["ContextKeyExpr"].and(editorContextKeys["EditorContextKeys"].hasTypeDefinitionProvider, editorContextKeys["EditorContextKeys"].isInWalkThroughSnippet.toNegated()),\r\n                kbOpts: {\r\n                    kbExpr: editorContextKeys["EditorContextKeys"].editorTextFocus,\r\n                    primary: 0,\r\n                    weight: 100 /* EditorContrib */\r\n                },\r\n                contextMenuOpts: {\r\n                    group: \'navigation\',\r\n                    order: 1.4\r\n                }\r\n            });\r\n        }\r\n    },\r\n    goToCommands_e.ID = \'editor.action.goToTypeDefinition\',\r\n    goToCommands_e));\r\nregisterGoToAction((_f = class PeekTypeDefinitionAction extends goToCommands_TypeDefinitionAction {\r\n        constructor() {\r\n            super({\r\n                openToSide: false,\r\n                openInPeek: true,\r\n                muteMessage: false\r\n            }, {\r\n                id: PeekTypeDefinitionAction.ID,\r\n                label: nls["localize"](\'actions.peekTypeDefinition.label\', "Peek Type Definition"),\r\n                alias: \'Peek Type Definition\',\r\n                precondition: contextkey["ContextKeyExpr"].and(editorContextKeys["EditorContextKeys"].hasTypeDefinitionProvider, peekView_PeekContext.notInPeekEditor, editorContextKeys["EditorContextKeys"].isInWalkThroughSnippet.toNegated()),\r\n                contextMenuOpts: {\r\n                    menuId: actions_common_actions["MenuId"].EditorContextPeek,\r\n                    group: \'peek\',\r\n                    order: 4\r\n                }\r\n            });\r\n        }\r\n    },\r\n    _f.ID = \'editor.action.peekTypeDefinition\',\r\n    _f));\r\n//#endregion\r\n//#region --- IMPLEMENTATION\r\nclass goToCommands_ImplementationAction extends goToCommands_SymbolNavigationAction {\r\n    _getLocationModel(model, position, token) {\r\n        return goToCommands_awaiter(this, void 0, void 0, function* () {\r\n            return new referencesModel_ReferencesModel(yield getImplementationsAtPosition(model, position, token), nls["localize"](\'impl.title\', \'Implementations\'));\r\n        });\r\n    }\r\n    _getNoResultFoundMessage(info) {\r\n        return info && info.word\r\n            ? nls["localize"](\'goToImplementation.noResultWord\', "No implementation found for \'{0}\'", info.word)\r\n            : nls["localize"](\'goToImplementation.generic.noResults\', "No implementation found");\r\n    }\r\n    _getAlternativeCommand(editor) {\r\n        return editor.getOption(49 /* gotoLocation */).alternativeImplementationCommand;\r\n    }\r\n    _getGoToPreference(editor) {\r\n        return editor.getOption(49 /* gotoLocation */).multipleImplementations;\r\n    }\r\n}\r\nregisterGoToAction((_g = class GoToImplementationAction extends goToCommands_ImplementationAction {\r\n        constructor() {\r\n            super({\r\n                openToSide: false,\r\n                openInPeek: false,\r\n                muteMessage: false\r\n            }, {\r\n                id: GoToImplementationAction.ID,\r\n                label: nls["localize"](\'actions.goToImplementation.label\', "Go to Implementations"),\r\n                alias: \'Go to Implementations\',\r\n                precondition: contextkey["ContextKeyExpr"].and(editorContextKeys["EditorContextKeys"].hasImplementationProvider, editorContextKeys["EditorContextKeys"].isInWalkThroughSnippet.toNegated()),\r\n                kbOpts: {\r\n                    kbExpr: editorContextKeys["EditorContextKeys"].editorTextFocus,\r\n                    primary: 2048 /* CtrlCmd */ | 70 /* F12 */,\r\n                    weight: 100 /* EditorContrib */\r\n                },\r\n                contextMenuOpts: {\r\n                    group: \'navigation\',\r\n                    order: 1.45\r\n                }\r\n            });\r\n        }\r\n    },\r\n    _g.ID = \'editor.action.goToImplementation\',\r\n    _g));\r\nregisterGoToAction((_h = class PeekImplementationAction extends goToCommands_ImplementationAction {\r\n        constructor() {\r\n            super({\r\n                openToSide: false,\r\n                openInPeek: true,\r\n                muteMessage: false\r\n            }, {\r\n                id: PeekImplementationAction.ID,\r\n                label: nls["localize"](\'actions.peekImplementation.label\', "Peek Implementations"),\r\n                alias: \'Peek Implementations\',\r\n                precondition: contextkey["ContextKeyExpr"].and(editorContextKeys["EditorContextKeys"].hasImplementationProvider, peekView_PeekContext.notInPeekEditor, editorContextKeys["EditorContextKeys"].isInWalkThroughSnippet.toNegated()),\r\n                kbOpts: {\r\n                    kbExpr: editorContextKeys["EditorContextKeys"].editorTextFocus,\r\n                    primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 70 /* F12 */,\r\n                    weight: 100 /* EditorContrib */\r\n                },\r\n                contextMenuOpts: {\r\n                    menuId: actions_common_actions["MenuId"].EditorContextPeek,\r\n                    group: \'peek\',\r\n                    order: 5\r\n                }\r\n            });\r\n        }\r\n    },\r\n    _h.ID = \'editor.action.peekImplementation\',\r\n    _h));\r\n//#endregion\r\n//#region --- REFERENCES\r\nclass goToCommands_ReferencesAction extends goToCommands_SymbolNavigationAction {\r\n    _getNoResultFoundMessage(info) {\r\n        return info\r\n            ? nls["localize"](\'references.no\', "No references found for \'{0}\'", info.word)\r\n            : nls["localize"](\'references.noGeneric\', "No references found");\r\n    }\r\n    _getAlternativeCommand(editor) {\r\n        return editor.getOption(49 /* gotoLocation */).alternativeReferenceCommand;\r\n    }\r\n    _getGoToPreference(editor) {\r\n        return editor.getOption(49 /* gotoLocation */).multipleReferences;\r\n    }\r\n}\r\nregisterGoToAction(class GoToReferencesAction extends goToCommands_ReferencesAction {\r\n    constructor() {\r\n        super({\r\n            openToSide: false,\r\n            openInPeek: false,\r\n            muteMessage: false\r\n        }, {\r\n            id: \'editor.action.goToReferences\',\r\n            label: nls["localize"](\'goToReferences.label\', "Go to References"),\r\n            alias: \'Go to References\',\r\n            precondition: contextkey["ContextKeyExpr"].and(editorContextKeys["EditorContextKeys"].hasReferenceProvider, peekView_PeekContext.notInPeekEditor, editorContextKeys["EditorContextKeys"].isInWalkThroughSnippet.toNegated()),\r\n            kbOpts: {\r\n                kbExpr: editorContextKeys["EditorContextKeys"].editorTextFocus,\r\n                primary: 1024 /* Shift */ | 70 /* F12 */,\r\n                weight: 100 /* EditorContrib */\r\n            },\r\n            contextMenuOpts: {\r\n                group: \'navigation\',\r\n                order: 1.45\r\n            }\r\n        });\r\n    }\r\n    _getLocationModel(model, position, token) {\r\n        return goToCommands_awaiter(this, void 0, void 0, function* () {\r\n            return new referencesModel_ReferencesModel(yield getReferencesAtPosition(model, position, true, token), nls["localize"](\'ref.title\', \'References\'));\r\n        });\r\n    }\r\n});\r\nregisterGoToAction(class PeekReferencesAction extends goToCommands_ReferencesAction {\r\n    constructor() {\r\n        super({\r\n            openToSide: false,\r\n            openInPeek: true,\r\n            muteMessage: false\r\n        }, {\r\n            id: \'editor.action.referenceSearch.trigger\',\r\n            label: nls["localize"](\'references.action.label\', "Peek References"),\r\n            alias: \'Peek References\',\r\n            precondition: contextkey["ContextKeyExpr"].and(editorContextKeys["EditorContextKeys"].hasReferenceProvider, peekView_PeekContext.notInPeekEditor, editorContextKeys["EditorContextKeys"].isInWalkThroughSnippet.toNegated()),\r\n            contextMenuOpts: {\r\n                menuId: actions_common_actions["MenuId"].EditorContextPeek,\r\n                group: \'peek\',\r\n                order: 6\r\n            }\r\n        });\r\n    }\r\n    _getLocationModel(model, position, token) {\r\n        return goToCommands_awaiter(this, void 0, void 0, function* () {\r\n            return new referencesModel_ReferencesModel(yield getReferencesAtPosition(model, position, false, token), nls["localize"](\'ref.title\', \'References\'));\r\n        });\r\n    }\r\n});\r\n//#endregion\r\n//#region --- GENERIC goto symbols command\r\nclass goToCommands_GenericGoToLocationAction extends goToCommands_SymbolNavigationAction {\r\n    constructor(config, _references, _gotoMultipleBehaviour) {\r\n        super(config, {\r\n            id: \'editor.action.goToLocation\',\r\n            label: nls["localize"](\'label.generic\', "Go To Any Symbol"),\r\n            alias: \'Go To Any Symbol\',\r\n            precondition: contextkey["ContextKeyExpr"].and(peekView_PeekContext.notInPeekEditor, editorContextKeys["EditorContextKeys"].isInWalkThroughSnippet.toNegated()),\r\n        });\r\n        this._references = _references;\r\n        this._gotoMultipleBehaviour = _gotoMultipleBehaviour;\r\n    }\r\n    _getLocationModel(_model, _position, _token) {\r\n        return goToCommands_awaiter(this, void 0, void 0, function* () {\r\n            return new referencesModel_ReferencesModel(this._references, nls["localize"](\'generic.title\', \'Locations\'));\r\n        });\r\n    }\r\n    _getNoResultFoundMessage(info) {\r\n        return info && nls["localize"](\'generic.noResult\', "No results for \'{0}\'", info.word) || \'\';\r\n    }\r\n    _getGoToPreference(editor) {\r\n        var _a;\r\n        return (_a = this._gotoMultipleBehaviour) !== null && _a !== void 0 ? _a : editor.getOption(49 /* gotoLocation */).multipleReferences;\r\n    }\r\n    _getAlternativeCommand() { return \'\'; }\r\n}\r\ncommon_commands["CommandsRegistry"].registerCommand({\r\n    id: \'editor.action.goToLocations\',\r\n    description: {\r\n        description: \'Go to locations from a position in a file\',\r\n        args: [\r\n            { name: \'uri\', description: \'The text document in which to start\', constraint: common_uri["URI"] },\r\n            { name: \'position\', description: \'The position at which to start\', constraint: core_position["Position"].isIPosition },\r\n            { name: \'locations\', description: \'An array of locations.\', constraint: Array },\r\n            { name: \'multiple\', description: \'Define what to do when having multiple results, either `peek`, `gotoAndPeek`, or `goto\' },\r\n            { name: \'noResultsMessage\', description: \'Human readable message that shows when locations is empty.\' },\r\n        ]\r\n    },\r\n    handler: (accessor, resource, position, references, multiple, noResultsMessage, openInPeek) => goToCommands_awaiter(void 0, void 0, void 0, function* () {\r\n        Object(types["assertType"])(common_uri["URI"].isUri(resource));\r\n        Object(types["assertType"])(core_position["Position"].isIPosition(position));\r\n        Object(types["assertType"])(Array.isArray(references));\r\n        Object(types["assertType"])(typeof multiple === \'undefined\' || typeof multiple === \'string\');\r\n        Object(types["assertType"])(typeof openInPeek === \'undefined\' || typeof openInPeek === \'boolean\');\r\n        const editorService = accessor.get(services_codeEditorService["ICodeEditorService"]);\r\n        const editor = yield editorService.openCodeEditor({ resource }, editorService.getFocusedCodeEditor());\r\n        if (Object(editorBrowser["isCodeEditor"])(editor)) {\r\n            editor.setPosition(position);\r\n            editor.revealPositionInCenterIfOutsideViewport(position, 0 /* Smooth */);\r\n            return editor.invokeWithinContext(accessor => {\r\n                const command = new class extends goToCommands_GenericGoToLocationAction {\r\n                    _getNoResultFoundMessage(info) {\r\n                        return noResultsMessage || super._getNoResultFoundMessage(info);\r\n                    }\r\n                }({\r\n                    muteMessage: !Boolean(noResultsMessage),\r\n                    openInPeek: Boolean(openInPeek),\r\n                    openToSide: false\r\n                }, references, multiple);\r\n                accessor.get(instantiation["IInstantiationService"]).invokeFunction(command.run.bind(command), editor);\r\n            });\r\n        }\r\n    })\r\n});\r\ncommon_commands["CommandsRegistry"].registerCommand({\r\n    id: \'editor.action.peekLocations\',\r\n    description: {\r\n        description: \'Peek locations from a position in a file\',\r\n        args: [\r\n            { name: \'uri\', description: \'The text document in which to start\', constraint: common_uri["URI"] },\r\n            { name: \'position\', description: \'The position at which to start\', constraint: core_position["Position"].isIPosition },\r\n            { name: \'locations\', description: \'An array of locations.\', constraint: Array },\r\n            { name: \'multiple\', description: \'Define what to do when having multiple results, either `peek`, `gotoAndPeek`, or `goto\' },\r\n        ]\r\n    },\r\n    handler: (accessor, resource, position, references, multiple) => goToCommands_awaiter(void 0, void 0, void 0, function* () {\r\n        accessor.get(common_commands["ICommandService"]).executeCommand(\'editor.action.goToLocations\', resource, position, references, multiple, undefined, true);\r\n    })\r\n});\r\n//#endregion\r\n//#region --- REFERENCE search special commands\r\ncommon_commands["CommandsRegistry"].registerCommand({\r\n    id: \'editor.action.findReferences\',\r\n    handler: (accessor, resource, position) => {\r\n        Object(types["assertType"])(common_uri["URI"].isUri(resource));\r\n        Object(types["assertType"])(core_position["Position"].isIPosition(position));\r\n        const codeEditorService = accessor.get(services_codeEditorService["ICodeEditorService"]);\r\n        return codeEditorService.openCodeEditor({ resource }, codeEditorService.getFocusedCodeEditor()).then(control => {\r\n            if (!Object(editorBrowser["isCodeEditor"])(control) || !control.hasModel()) {\r\n                return undefined;\r\n            }\r\n            const controller = referencesController_ReferencesController.get(control);\r\n            if (!controller) {\r\n                return undefined;\r\n            }\r\n            const references = Object(common_async["createCancelablePromise"])(token => getReferencesAtPosition(control.getModel(), core_position["Position"].lift(position), false, token).then(references => new referencesModel_ReferencesModel(references, nls["localize"](\'ref.title\', \'References\'))));\r\n            const range = new core_range["Range"](position.lineNumber, position.column, position.lineNumber, position.column);\r\n            return Promise.resolve(controller.toggleWidget(range, references, false));\r\n        });\r\n    }\r\n});\r\n// use NEW command\r\ncommon_commands["CommandsRegistry"].registerCommandAlias(\'editor.action.showReferences\', \'editor.action.peekLocations\');\r\n//#endregion\r\n// -- unconditionally register goto-action\r\nactions_common_actions["MenuRegistry"].appendMenuItems([\r\n    {\r\n        id: actions_common_actions["MenuId"].MenubarGoMenu,\r\n        item: {\r\n            command: {\r\n                id: \'editor.action.revealDefinition\',\r\n                title: nls["localize"]({ key: \'miGotoDefinition\', comment: [\'&& denotes a mnemonic\'] }, "Go to &&Definition")\r\n            },\r\n            group: \'4_symbol_nav\',\r\n            order: 2,\r\n        },\r\n    },\r\n    {\r\n        id: actions_common_actions["MenuId"].MenubarGoMenu,\r\n        item: {\r\n            command: {\r\n                id: \'editor.action.revealDeclaration\',\r\n                title: nls["localize"]({ key: \'miGotoDeclaration\', comment: [\'&& denotes a mnemonic\'] }, "Go to &&Declaration")\r\n            },\r\n            group: \'4_symbol_nav\',\r\n            order: 3,\r\n        },\r\n    },\r\n    {\r\n        id: actions_common_actions["MenuId"].MenubarGoMenu,\r\n        item: {\r\n            command: {\r\n                id: \'editor.action.goToTypeDefinition\',\r\n                title: nls["localize"]({ key: \'miGotoTypeDefinition\', comment: [\'&& denotes a mnemonic\'] }, "Go to &&Type Definition")\r\n            },\r\n            group: \'4_symbol_nav\',\r\n            order: 3,\r\n        },\r\n    },\r\n    {\r\n        id: actions_common_actions["MenuId"].MenubarGoMenu,\r\n        item: {\r\n            command: {\r\n                id: \'editor.action.goToImplementation\',\r\n                title: nls["localize"]({ key: \'miGotoImplementation\', comment: [\'&& denotes a mnemonic\'] }, "Go to &&Implementations")\r\n            },\r\n            group: \'4_symbol_nav\',\r\n            order: 4,\r\n        },\r\n    },\r\n    {\r\n        id: actions_common_actions["MenuId"].MenubarGoMenu,\r\n        item: {\r\n            command: {\r\n                id: \'editor.action.goToReferences\',\r\n                title: nls["localize"]({ key: \'miGotoReference\', comment: [\'&& denotes a mnemonic\'] }, "Go to &&References")\r\n            },\r\n            group: \'4_symbol_nav\',\r\n            order: 5,\r\n        },\r\n    },\r\n]);\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/link/clickLinkGesture.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\n\r\n\r\n\r\nfunction hasModifier(e, modifier) {\r\n    return !!e[modifier];\r\n}\r\n/**\r\n * An event that encapsulates the various trigger modifiers logic needed for go to definition.\r\n */\r\nclass ClickLinkMouseEvent {\r\n    constructor(source, opts) {\r\n        this.target = source.target;\r\n        this.hasTriggerModifier = hasModifier(source.event, opts.triggerModifier);\r\n        this.hasSideBySideModifier = hasModifier(source.event, opts.triggerSideBySideModifier);\r\n        this.isNoneOrSingleMouseDown = (source.event.detail <= 1);\r\n    }\r\n}\r\n/**\r\n * An event that encapsulates the various trigger modifiers logic needed for go to definition.\r\n */\r\nclass ClickLinkKeyboardEvent {\r\n    constructor(source, opts) {\r\n        this.keyCodeIsTriggerKey = (source.keyCode === opts.triggerKey);\r\n        this.keyCodeIsSideBySideKey = (source.keyCode === opts.triggerSideBySideKey);\r\n        this.hasTriggerModifier = hasModifier(source, opts.triggerModifier);\r\n    }\r\n}\r\nclass ClickLinkOptions {\r\n    constructor(triggerKey, triggerModifier, triggerSideBySideKey, triggerSideBySideModifier) {\r\n        this.triggerKey = triggerKey;\r\n        this.triggerModifier = triggerModifier;\r\n        this.triggerSideBySideKey = triggerSideBySideKey;\r\n        this.triggerSideBySideModifier = triggerSideBySideModifier;\r\n    }\r\n    equals(other) {\r\n        return (this.triggerKey === other.triggerKey\r\n            && this.triggerModifier === other.triggerModifier\r\n            && this.triggerSideBySideKey === other.triggerSideBySideKey\r\n            && this.triggerSideBySideModifier === other.triggerSideBySideModifier);\r\n    }\r\n}\r\nfunction createOptions(multiCursorModifier) {\r\n    if (multiCursorModifier === \'altKey\') {\r\n        if (platform["isMacintosh"]) {\r\n            return new ClickLinkOptions(57 /* Meta */, \'metaKey\', 6 /* Alt */, \'altKey\');\r\n        }\r\n        return new ClickLinkOptions(5 /* Ctrl */, \'ctrlKey\', 6 /* Alt */, \'altKey\');\r\n    }\r\n    if (platform["isMacintosh"]) {\r\n        return new ClickLinkOptions(6 /* Alt */, \'altKey\', 57 /* Meta */, \'metaKey\');\r\n    }\r\n    return new ClickLinkOptions(6 /* Alt */, \'altKey\', 5 /* Ctrl */, \'ctrlKey\');\r\n}\r\nclass clickLinkGesture_ClickLinkGesture extends lifecycle["Disposable"] {\r\n    constructor(editor) {\r\n        super();\r\n        this._onMouseMoveOrRelevantKeyDown = this._register(new common_event["Emitter"]());\r\n        this.onMouseMoveOrRelevantKeyDown = this._onMouseMoveOrRelevantKeyDown.event;\r\n        this._onExecute = this._register(new common_event["Emitter"]());\r\n        this.onExecute = this._onExecute.event;\r\n        this._onCancel = this._register(new common_event["Emitter"]());\r\n        this.onCancel = this._onCancel.event;\r\n        this._editor = editor;\r\n        this._opts = createOptions(this._editor.getOption(69 /* multiCursorModifier */));\r\n        this._lastMouseMoveEvent = null;\r\n        this._hasTriggerKeyOnMouseDown = false;\r\n        this._lineNumberOnMouseDown = 0;\r\n        this._register(this._editor.onDidChangeConfiguration((e) => {\r\n            if (e.hasChanged(69 /* multiCursorModifier */)) {\r\n                const newOpts = createOptions(this._editor.getOption(69 /* multiCursorModifier */));\r\n                if (this._opts.equals(newOpts)) {\r\n                    return;\r\n                }\r\n                this._opts = newOpts;\r\n                this._lastMouseMoveEvent = null;\r\n                this._hasTriggerKeyOnMouseDown = false;\r\n                this._lineNumberOnMouseDown = 0;\r\n                this._onCancel.fire();\r\n            }\r\n        }));\r\n        this._register(this._editor.onMouseMove((e) => this._onEditorMouseMove(new ClickLinkMouseEvent(e, this._opts))));\r\n        this._register(this._editor.onMouseDown((e) => this._onEditorMouseDown(new ClickLinkMouseEvent(e, this._opts))));\r\n        this._register(this._editor.onMouseUp((e) => this._onEditorMouseUp(new ClickLinkMouseEvent(e, this._opts))));\r\n        this._register(this._editor.onKeyDown((e) => this._onEditorKeyDown(new ClickLinkKeyboardEvent(e, this._opts))));\r\n        this._register(this._editor.onKeyUp((e) => this._onEditorKeyUp(new ClickLinkKeyboardEvent(e, this._opts))));\r\n        this._register(this._editor.onMouseDrag(() => this._resetHandler()));\r\n        this._register(this._editor.onDidChangeCursorSelection((e) => this._onDidChangeCursorSelection(e)));\r\n        this._register(this._editor.onDidChangeModel((e) => this._resetHandler()));\r\n        this._register(this._editor.onDidChangeModelContent(() => this._resetHandler()));\r\n        this._register(this._editor.onDidScrollChange((e) => {\r\n            if (e.scrollTopChanged || e.scrollLeftChanged) {\r\n                this._resetHandler();\r\n            }\r\n        }));\r\n    }\r\n    _onDidChangeCursorSelection(e) {\r\n        if (e.selection && e.selection.startColumn !== e.selection.endColumn) {\r\n            this._resetHandler(); // immediately stop this feature if the user starts to select (https://github.com/microsoft/vscode/issues/7827)\r\n        }\r\n    }\r\n    _onEditorMouseMove(mouseEvent) {\r\n        this._lastMouseMoveEvent = mouseEvent;\r\n        this._onMouseMoveOrRelevantKeyDown.fire([mouseEvent, null]);\r\n    }\r\n    _onEditorMouseDown(mouseEvent) {\r\n        // We need to record if we had the trigger key on mouse down because someone might select something in the editor\r\n        // holding the mouse down and then while mouse is down start to press Ctrl/Cmd to start a copy operation and then\r\n        // release the mouse button without wanting to do the navigation.\r\n        // With this flag we prevent goto definition if the mouse was down before the trigger key was pressed.\r\n        this._hasTriggerKeyOnMouseDown = mouseEvent.hasTriggerModifier;\r\n        this._lineNumberOnMouseDown = mouseEvent.target.position ? mouseEvent.target.position.lineNumber : 0;\r\n    }\r\n    _onEditorMouseUp(mouseEvent) {\r\n        const currentLineNumber = mouseEvent.target.position ? mouseEvent.target.position.lineNumber : 0;\r\n        if (this._hasTriggerKeyOnMouseDown && this._lineNumberOnMouseDown && this._lineNumberOnMouseDown === currentLineNumber) {\r\n            this._onExecute.fire(mouseEvent);\r\n        }\r\n    }\r\n    _onEditorKeyDown(e) {\r\n        if (this._lastMouseMoveEvent\r\n            && (e.keyCodeIsTriggerKey // User just pressed Ctrl/Cmd (normal goto definition)\r\n                || (e.keyCodeIsSideBySideKey && e.hasTriggerModifier) // User pressed Ctrl/Cmd+Alt (goto definition to the side)\r\n            )) {\r\n            this._onMouseMoveOrRelevantKeyDown.fire([this._lastMouseMoveEvent, e]);\r\n        }\r\n        else if (e.hasTriggerModifier) {\r\n            this._onCancel.fire(); // remove decorations if user holds another key with ctrl/cmd to prevent accident goto declaration\r\n        }\r\n    }\r\n    _onEditorKeyUp(e) {\r\n        if (e.keyCodeIsTriggerKey) {\r\n            this._onCancel.fire();\r\n        }\r\n    }\r\n    _resetHandler() {\r\n        this._lastMouseMoveEvent = null;\r\n        this._hasTriggerKeyOnMouseDown = false;\r\n        this._onCancel.fire();\r\n    }\r\n}\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/link/goToDefinitionAtPosition.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar goToDefinitionAtPosition_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar goToDefinitionAtPosition_param = (undefined && undefined.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nlet goToDefinitionAtPosition_GotoDefinitionAtPositionEditorContribution = class GotoDefinitionAtPositionEditorContribution {\r\n    constructor(editor, textModelResolverService, modeService) {\r\n        this.textModelResolverService = textModelResolverService;\r\n        this.modeService = modeService;\r\n        this.toUnhook = new lifecycle["DisposableStore"]();\r\n        this.toUnhookForKeyboard = new lifecycle["DisposableStore"]();\r\n        this.linkDecorations = [];\r\n        this.currentWordAtPosition = null;\r\n        this.previousPromise = null;\r\n        this.editor = editor;\r\n        let linkGesture = new clickLinkGesture_ClickLinkGesture(editor);\r\n        this.toUnhook.add(linkGesture);\r\n        this.toUnhook.add(linkGesture.onMouseMoveOrRelevantKeyDown(([mouseEvent, keyboardEvent]) => {\r\n            this.startFindDefinitionFromMouse(mouseEvent, Object(types["withNullAsUndefined"])(keyboardEvent));\r\n        }));\r\n        this.toUnhook.add(linkGesture.onExecute((mouseEvent) => {\r\n            if (this.isEnabled(mouseEvent)) {\r\n                this.gotoDefinition(mouseEvent.target.position, mouseEvent.hasSideBySideModifier).then(() => {\r\n                    this.removeLinkDecorations();\r\n                }, (error) => {\r\n                    this.removeLinkDecorations();\r\n                    Object(errors["onUnexpectedError"])(error);\r\n                });\r\n            }\r\n        }));\r\n        this.toUnhook.add(linkGesture.onCancel(() => {\r\n            this.removeLinkDecorations();\r\n            this.currentWordAtPosition = null;\r\n        }));\r\n    }\r\n    static get(editor) {\r\n        return editor.getContribution(GotoDefinitionAtPositionEditorContribution.ID);\r\n    }\r\n    startFindDefinitionFromCursor(position) {\r\n        // For issue: https://github.com/microsoft/vscode/issues/46257\r\n        // equivalent to mouse move with meta/ctrl key\r\n        // First find the definition and add decorations\r\n        // to the editor to be shown with the content hover widget\r\n        return this.startFindDefinition(position).then(() => {\r\n            // Add listeners for editor cursor move and key down events\r\n            // Dismiss the "extended" editor decorations when the user hides\r\n            // the hover widget. There is no event for the widget itself so these\r\n            // serve as a best effort. After removing the link decorations, the hover\r\n            // widget is clean and will only show declarations per next request.\r\n            this.toUnhookForKeyboard.add(this.editor.onDidChangeCursorPosition(() => {\r\n                this.currentWordAtPosition = null;\r\n                this.removeLinkDecorations();\r\n                this.toUnhookForKeyboard.clear();\r\n            }));\r\n            this.toUnhookForKeyboard.add(this.editor.onKeyDown((e) => {\r\n                if (e) {\r\n                    this.currentWordAtPosition = null;\r\n                    this.removeLinkDecorations();\r\n                    this.toUnhookForKeyboard.clear();\r\n                }\r\n            }));\r\n        });\r\n    }\r\n    startFindDefinitionFromMouse(mouseEvent, withKey) {\r\n        // check if we are active and on a content widget\r\n        if (mouseEvent.target.type === 9 /* CONTENT_WIDGET */ && this.linkDecorations.length > 0) {\r\n            return;\r\n        }\r\n        if (!this.editor.hasModel() || !this.isEnabled(mouseEvent, withKey)) {\r\n            this.currentWordAtPosition = null;\r\n            this.removeLinkDecorations();\r\n            return;\r\n        }\r\n        const position = mouseEvent.target.position;\r\n        this.startFindDefinition(position);\r\n    }\r\n    startFindDefinition(position) {\r\n        var _a;\r\n        // Dispose listeners for updating decorations when using keyboard to show definition hover\r\n        this.toUnhookForKeyboard.clear();\r\n        // Find word at mouse position\r\n        const word = position ? (_a = this.editor.getModel()) === null || _a === void 0 ? void 0 : _a.getWordAtPosition(position) : null;\r\n        if (!word) {\r\n            this.currentWordAtPosition = null;\r\n            this.removeLinkDecorations();\r\n            return Promise.resolve(0);\r\n        }\r\n        // Return early if word at position is still the same\r\n        if (this.currentWordAtPosition && this.currentWordAtPosition.startColumn === word.startColumn && this.currentWordAtPosition.endColumn === word.endColumn && this.currentWordAtPosition.word === word.word) {\r\n            return Promise.resolve(0);\r\n        }\r\n        this.currentWordAtPosition = word;\r\n        // Find definition and decorate word if found\r\n        let state = new core_editorState["EditorState"](this.editor, 4 /* Position */ | 1 /* Value */ | 2 /* Selection */ | 8 /* Scroll */);\r\n        if (this.previousPromise) {\r\n            this.previousPromise.cancel();\r\n            this.previousPromise = null;\r\n        }\r\n        this.previousPromise = Object(common_async["createCancelablePromise"])(token => this.findDefinition(position, token));\r\n        return this.previousPromise.then(results => {\r\n            if (!results || !results.length || !state.validate(this.editor)) {\r\n                this.removeLinkDecorations();\r\n                return;\r\n            }\r\n            // Multiple results\r\n            if (results.length > 1) {\r\n                this.addDecoration(new core_range["Range"](position.lineNumber, word.startColumn, position.lineNumber, word.endColumn), new htmlContent_MarkdownString().appendText(nls["localize"](\'multipleResults\', "Click to show {0} definitions.", results.length)));\r\n            }\r\n            // Single result\r\n            else {\r\n                let result = results[0];\r\n                if (!result.uri) {\r\n                    return;\r\n                }\r\n                this.textModelResolverService.createModelReference(result.uri).then(ref => {\r\n                    if (!ref.object || !ref.object.textEditorModel) {\r\n                        ref.dispose();\r\n                        return;\r\n                    }\r\n                    const { object: { textEditorModel } } = ref;\r\n                    const { startLineNumber } = result.range;\r\n                    if (startLineNumber < 1 || startLineNumber > textEditorModel.getLineCount()) {\r\n                        // invalid range\r\n                        ref.dispose();\r\n                        return;\r\n                    }\r\n                    const previewValue = this.getPreviewValue(textEditorModel, startLineNumber, result);\r\n                    let wordRange;\r\n                    if (result.originSelectionRange) {\r\n                        wordRange = core_range["Range"].lift(result.originSelectionRange);\r\n                    }\r\n                    else {\r\n                        wordRange = new core_range["Range"](position.lineNumber, word.startColumn, position.lineNumber, word.endColumn);\r\n                    }\r\n                    const modeId = this.modeService.getModeIdByFilepathOrFirstLine(textEditorModel.uri);\r\n                    this.addDecoration(wordRange, new htmlContent_MarkdownString().appendCodeblock(modeId ? modeId : \'\', previewValue));\r\n                    ref.dispose();\r\n                });\r\n            }\r\n        }).then(undefined, errors["onUnexpectedError"]);\r\n    }\r\n    getPreviewValue(textEditorModel, startLineNumber, result) {\r\n        let rangeToUse = result.targetSelectionRange ? result.range : this.getPreviewRangeBasedOnBrackets(textEditorModel, startLineNumber);\r\n        const numberOfLinesInRange = rangeToUse.endLineNumber - rangeToUse.startLineNumber;\r\n        if (numberOfLinesInRange >= GotoDefinitionAtPositionEditorContribution.MAX_SOURCE_PREVIEW_LINES) {\r\n            rangeToUse = this.getPreviewRangeBasedOnIndentation(textEditorModel, startLineNumber);\r\n        }\r\n        const previewValue = this.stripIndentationFromPreviewRange(textEditorModel, startLineNumber, rangeToUse);\r\n        return previewValue;\r\n    }\r\n    stripIndentationFromPreviewRange(textEditorModel, startLineNumber, previewRange) {\r\n        const startIndent = textEditorModel.getLineFirstNonWhitespaceColumn(startLineNumber);\r\n        let minIndent = startIndent;\r\n        for (let endLineNumber = startLineNumber + 1; endLineNumber < previewRange.endLineNumber; endLineNumber++) {\r\n            const endIndent = textEditorModel.getLineFirstNonWhitespaceColumn(endLineNumber);\r\n            minIndent = Math.min(minIndent, endIndent);\r\n        }\r\n        const previewValue = textEditorModel.getValueInRange(previewRange).replace(new RegExp(`^\\\\s{${minIndent - 1}}`, \'gm\'), \'\').trim();\r\n        return previewValue;\r\n    }\r\n    getPreviewRangeBasedOnIndentation(textEditorModel, startLineNumber) {\r\n        const startIndent = textEditorModel.getLineFirstNonWhitespaceColumn(startLineNumber);\r\n        const maxLineNumber = Math.min(textEditorModel.getLineCount(), startLineNumber + GotoDefinitionAtPositionEditorContribution.MAX_SOURCE_PREVIEW_LINES);\r\n        let endLineNumber = startLineNumber + 1;\r\n        for (; endLineNumber < maxLineNumber; endLineNumber++) {\r\n            let endIndent = textEditorModel.getLineFirstNonWhitespaceColumn(endLineNumber);\r\n            if (startIndent === endIndent) {\r\n                break;\r\n            }\r\n        }\r\n        return new core_range["Range"](startLineNumber, 1, endLineNumber + 1, 1);\r\n    }\r\n    getPreviewRangeBasedOnBrackets(textEditorModel, startLineNumber) {\r\n        const maxLineNumber = Math.min(textEditorModel.getLineCount(), startLineNumber + GotoDefinitionAtPositionEditorContribution.MAX_SOURCE_PREVIEW_LINES);\r\n        const brackets = [];\r\n        let ignoreFirstEmpty = true;\r\n        let currentBracket = textEditorModel.findNextBracket(new core_position["Position"](startLineNumber, 1));\r\n        while (currentBracket !== null) {\r\n            if (brackets.length === 0) {\r\n                brackets.push(currentBracket);\r\n            }\r\n            else {\r\n                const lastBracket = brackets[brackets.length - 1];\r\n                if (lastBracket.open[0] === currentBracket.open[0] && lastBracket.isOpen && !currentBracket.isOpen) {\r\n                    brackets.pop();\r\n                }\r\n                else {\r\n                    brackets.push(currentBracket);\r\n                }\r\n                if (brackets.length === 0) {\r\n                    if (ignoreFirstEmpty) {\r\n                        ignoreFirstEmpty = false;\r\n                    }\r\n                    else {\r\n                        return new core_range["Range"](startLineNumber, 1, currentBracket.range.endLineNumber + 1, 1);\r\n                    }\r\n                }\r\n            }\r\n            const maxColumn = textEditorModel.getLineMaxColumn(startLineNumber);\r\n            let nextLineNumber = currentBracket.range.endLineNumber;\r\n            let nextColumn = currentBracket.range.endColumn;\r\n            if (maxColumn === currentBracket.range.endColumn) {\r\n                nextLineNumber++;\r\n                nextColumn = 1;\r\n            }\r\n            if (nextLineNumber > maxLineNumber) {\r\n                return new core_range["Range"](startLineNumber, 1, maxLineNumber + 1, 1);\r\n            }\r\n            currentBracket = textEditorModel.findNextBracket(new core_position["Position"](nextLineNumber, nextColumn));\r\n        }\r\n        return new core_range["Range"](startLineNumber, 1, maxLineNumber + 1, 1);\r\n    }\r\n    addDecoration(range, hoverMessage) {\r\n        const newDecorations = {\r\n            range: range,\r\n            options: {\r\n                description: \'goto-definition-link\',\r\n                inlineClassName: \'goto-definition-link\',\r\n                hoverMessage\r\n            }\r\n        };\r\n        this.linkDecorations = this.editor.deltaDecorations(this.linkDecorations, [newDecorations]);\r\n    }\r\n    removeLinkDecorations() {\r\n        if (this.linkDecorations.length > 0) {\r\n            this.linkDecorations = this.editor.deltaDecorations(this.linkDecorations, []);\r\n        }\r\n    }\r\n    isEnabled(mouseEvent, withKey) {\r\n        return this.editor.hasModel() &&\r\n            mouseEvent.isNoneOrSingleMouseDown &&\r\n            (mouseEvent.target.type === 6 /* CONTENT_TEXT */) &&\r\n            (mouseEvent.hasTriggerModifier || (withKey ? withKey.keyCodeIsTriggerKey : false)) &&\r\n            modes["DefinitionProviderRegistry"].has(this.editor.getModel());\r\n    }\r\n    findDefinition(position, token) {\r\n        const model = this.editor.getModel();\r\n        if (!model) {\r\n            return Promise.resolve(null);\r\n        }\r\n        return getDefinitionsAtPosition(model, position, token);\r\n    }\r\n    gotoDefinition(position, openToSide) {\r\n        this.editor.setPosition(position);\r\n        return this.editor.invokeWithinContext((accessor) => {\r\n            const canPeek = !openToSide && this.editor.getOption(77 /* definitionLinkOpensInPeek */) && !this.isInPeekEditor(accessor);\r\n            const action = new goToCommands_DefinitionAction({ openToSide, openInPeek: canPeek, muteMessage: true }, { alias: \'\', label: \'\', id: \'\', precondition: undefined });\r\n            return action.run(accessor, this.editor);\r\n        });\r\n    }\r\n    isInPeekEditor(accessor) {\r\n        const contextKeyService = accessor.get(contextkey["IContextKeyService"]);\r\n        return peekView_PeekContext.inPeekEditor.getValue(contextKeyService);\r\n    }\r\n    dispose() {\r\n        this.toUnhook.dispose();\r\n    }\r\n};\r\ngoToDefinitionAtPosition_GotoDefinitionAtPositionEditorContribution.ID = \'editor.contrib.gotodefinitionatposition\';\r\ngoToDefinitionAtPosition_GotoDefinitionAtPositionEditorContribution.MAX_SOURCE_PREVIEW_LINES = 8;\r\ngoToDefinitionAtPosition_GotoDefinitionAtPositionEditorContribution = goToDefinitionAtPosition_decorate([\r\n    goToDefinitionAtPosition_param(1, resolverService["ITextModelService"]),\r\n    goToDefinitionAtPosition_param(2, services_modeService["IModeService"])\r\n], goToDefinitionAtPosition_GotoDefinitionAtPositionEditorContribution);\r\n\r\nObject(editorExtensions["registerEditorContribution"])(goToDefinitionAtPosition_GotoDefinitionAtPositionEditorContribution.ID, goToDefinitionAtPosition_GotoDefinitionAtPositionEditorContribution);\r\nObject(common_themeService["registerThemingParticipant"])((theme, collector) => {\r\n    const activeLinkForeground = theme.getColor(colorRegistry["editorActiveLinkForeground"]);\r\n    if (activeLinkForeground) {\r\n        collector.addRule(`.monaco-editor .goto-definition-link { color: ${activeLinkForeground} !important; }`);\r\n    }\r\n});\r\n\n// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/contrib/hover/hover.js\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar hover_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar hover_param = (undefined && undefined.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nlet hover_ModesHoverController = class ModesHoverController {\r\n    constructor(_editor, _instantiationService, _openerService, _modeService, _contextKeyService) {\r\n        this._editor = _editor;\r\n        this._instantiationService = _instantiationService;\r\n        this._openerService = _openerService;\r\n        this._modeService = _modeService;\r\n        this._toUnhook = new lifecycle["DisposableStore"]();\r\n        this._isMouseDown = false;\r\n        this._hoverClicked = false;\r\n        this._contentWidget = null;\r\n        this._glyphWidget = null;\r\n        this._hookEvents();\r\n        this._didChangeConfigurationHandler = this._editor.onDidChangeConfiguration((e) => {\r\n            if (e.hasChanged(52 /* hover */)) {\r\n                this._unhookEvents();\r\n                this._hookEvents();\r\n            }\r\n        });\r\n        this._hoverVisibleKey = editorContextKeys["EditorContextKeys"].hoverVisible.bindTo(_contextKeyService);\r\n    }\r\n    static get(editor) {\r\n        return editor.getContribution(ModesHoverController.ID);\r\n    }\r\n    _hookEvents() {\r\n        const hideWidgetsEventHandler = () => this._hideWidgets();\r\n        const hoverOpts = this._editor.getOption(52 /* hover */);\r\n        this._isHoverEnabled = hoverOpts.enabled;\r\n        this._isHoverSticky = hoverOpts.sticky;\r\n        if (this._isHoverEnabled) {\r\n            this._toUnhook.add(this._editor.onMouseDown((e) => this._onEditorMouseDown(e)));\r\n            this._toUnhook.add(this._editor.onMouseUp((e) => this._onEditorMouseUp(e)));\r\n            this._toUnhook.add(this._editor.onMouseMove((e) => this._onEditorMouseMove(e)));\r\n            this._toUnhook.add(this._editor.onKeyDown((e) => this._onKeyDown(e)));\r\n            this._toUnhook.add(this._editor.onDidChangeModelDecorations(() => this._onModelDecorationsChanged()));\r\n        }\r\n        else {\r\n            this._toUnhook.add(this._editor.onMouseMove((e) => this._onEditorMouseMove(e)));\r\n            this._toUnhook.add(this._editor.onKeyDown((e) => this._onKeyDown(e)));\r\n        }\r\n        this._toUnhook.add(this._editor.onMouseLeave(hideWidgetsEventHandler));\r\n        this._toUnhook.add(this._editor.onDidChangeModel(hideWidgetsEventHandler));\r\n        this._toUnhook.add(this._editor.onDidScrollChange((e) => this._onEditorScrollChanged(e)));\r\n    }\r\n    _unhookEvents() {\r\n        this._toUnhook.clear();\r\n    }\r\n    _onModelDecorationsChanged() {\r\n        var _a, _b;\r\n        (_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.onModelDecorationsChanged();\r\n        (_b = this._glyphWidget) === null || _b === void 0 ? void 0 : _b.onModelDecorationsChanged();\r\n    }\r\n    _onEditorScrollChanged(e) {\r\n        if (e.scrollTopChanged || e.scrollLeftChanged) {\r\n            this._hideWidgets();\r\n        }\r\n    }\r\n    _onEditorMouseDown(mouseEvent) {\r\n        this._isMouseDown = true;\r\n        const targetType = mouseEvent.target.type;\r\n        if (targetType === 9 /* CONTENT_WIDGET */ && mouseEvent.target.detail === modesContentHover_ModesContentHoverWidget.ID) {\r\n            this._hoverClicked = true;\r\n            // mouse down on top of content hover widget\r\n            return;\r\n        }\r\n        if (targetType === 12 /* OVERLAY_WIDGET */ && mouseEvent.target.detail === modesGlyphHover_ModesGlyphHoverWidget.ID) {\r\n            // mouse down on top of overlay hover widget\r\n            return;\r\n        }\r\n        if (targetType !== 12 /* OVERLAY_WIDGET */ && mouseEvent.target.detail !== modesGlyphHover_ModesGlyphHoverWidget.ID) {\r\n            this._hoverClicked = false;\r\n        }\r\n        this._hideWidgets();\r\n    }\r\n    _onEditorMouseUp(mouseEvent) {\r\n        this._isMouseDown = false;\r\n    }\r\n    _onEditorMouseMove(mouseEvent) {\r\n        var _a, _b, _c, _d, _e;\r\n        let targetType = mouseEvent.target.type;\r\n        if (this._isMouseDown && this._hoverClicked) {\r\n            return;\r\n        }\r\n        if (this._isHoverSticky && targetType === 9 /* CONTENT_WIDGET */ && mouseEvent.target.detail === modesContentHover_ModesContentHoverWidget.ID) {\r\n            // mouse moved on top of content hover widget\r\n            return;\r\n        }\r\n        if (this._isHoverSticky && !((_b = (_a = mouseEvent.event.browserEvent.view) === null || _a === void 0 ? void 0 : _a.getSelection()) === null || _b === void 0 ? void 0 : _b.isCollapsed)) {\r\n            // selected text within content hover widget\r\n            return;\r\n        }\r\n        if (!this._isHoverSticky && targetType === 9 /* CONTENT_WIDGET */ && mouseEvent.target.detail === modesContentHover_ModesContentHoverWidget.ID\r\n            && ((_c = this._contentWidget) === null || _c === void 0 ? void 0 : _c.isColorPickerVisible())) {\r\n            // though the hover is not sticky, the color picker needs to.\r\n            return;\r\n        }\r\n        if (this._isHoverSticky && targetType === 12 /* OVERLAY_WIDGET */ && mouseEvent.target.detail === modesGlyphHover_ModesGlyphHoverWidget.ID) {\r\n            // mouse moved on top of overlay hover widget\r\n            return;\r\n        }\r\n        if (!this._isHoverEnabled) {\r\n            this._hideWidgets();\r\n            return;\r\n        }\r\n        const contentWidget = this._getOrCreateContentWidget();\r\n        if (contentWidget.maybeShowAt(mouseEvent)) {\r\n            (_d = this._glyphWidget) === null || _d === void 0 ? void 0 : _d.hide();\r\n            return;\r\n        }\r\n        if (targetType === 2 /* GUTTER_GLYPH_MARGIN */ && mouseEvent.target.position) {\r\n            (_e = this._contentWidget) === null || _e === void 0 ? void 0 : _e.hide();\r\n            if (!this._glyphWidget) {\r\n                this._glyphWidget = new modesGlyphHover_ModesGlyphHoverWidget(this._editor, this._modeService, this._openerService);\r\n            }\r\n            this._glyphWidget.startShowingAt(mouseEvent.target.position.lineNumber);\r\n            return;\r\n        }\r\n        this._hideWidgets();\r\n    }\r\n    _onKeyDown(e) {\r\n        if (e.keyCode !== 5 /* Ctrl */ && e.keyCode !== 6 /* Alt */ && e.keyCode !== 57 /* Meta */ && e.keyCode !== 4 /* Shift */) {\r\n            // Do not hide hover when a modifier key is pressed\r\n            this._hideWidgets();\r\n        }\r\n    }\r\n    _hideWidgets() {\r\n        var _a, _b, _c;\r\n        if ((this._isMouseDown && this._hoverClicked && ((_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.isColorPickerVisible()))) {\r\n            return;\r\n        }\r\n        this._hoverClicked = false;\r\n        (_b = this._glyphWidget) === null || _b === void 0 ? void 0 : _b.hide();\r\n        (_c = this._contentWidget) === null || _c === void 0 ? void 0 : _c.hide();\r\n    }\r\n    _getOrCreateContentWidget() {\r\n        if (!this._contentWidget) {\r\n            this._contentWidget = this._instantiationService.createInstance(modesContentHover_ModesContentHoverWidget, this._editor, this._hoverVisibleKey);\r\n        }\r\n        return this._contentWidget;\r\n    }\r\n    isColorPickerVisible() {\r\n        var _a;\r\n        return ((_a = this._contentWidget) === null || _a === void 0 ? void 0 : _a.isColorPickerVisible()) || false;\r\n    }\r\n    showContentHover(range, mode, focus) {\r\n        this._getOrCreateContentWidget().startShowingAtRange(range, mode, focus);\r\n    }\r\n    dispose() {\r\n        var _a, _b;\r\n        this._unhookEvents();\r\n        this._toUnhook.dispose();\r\n        this._didChangeConfigurationHandler.dispose();\r\n        (_a = this._glyphWidget) === null || _a === void 0 ? void 0 : _a.dispose();\r\n        (_b = this._contentWidget) === null || _b === void 0 ? void 0 : _b.dispose();\r\n    }\r\n};\r\nhover_ModesHoverController.ID = \'editor.contrib.hover\';\r\nhover_ModesHoverController = hover_decorate([\r\n    hover_param(1, instantiation["IInstantiationService"]),\r\n    hover_param(2, common_opener["IOpenerService"]),\r\n    hover_param(3, services_modeService["IModeService"]),\r\n    hover_param(4, contextkey["IContextKeyService"])\r\n], hover_ModesHoverController);\r\n\r\nclass hover_ShowHoverAction extends editorExtensions["EditorAction"] {\r\n    constructor() {\r\n        super({\r\n            id: \'editor.action.showHover\',\r\n            label: nls["localize"]({\r\n                key: \'showHover\',\r\n                comment: [\r\n                    \'Label for action that will trigger the showing of a hover in the editor.\',\r\n                    \'This allows for users to show the hover without using the mouse.\'\r\n                ]\r\n            }, "Show Hover"),\r\n            alias: \'Show Hover\',\r\n            precondition: undefined,\r\n            kbOpts: {\r\n                kbExpr: editorContextKeys["EditorContextKeys"].editorTextFocus,\r\n                primary: Object(keyCodes["KeyChord"])(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 39 /* KEY_I */),\r\n                weight: 100 /* EditorContrib */\r\n            }\r\n        });\r\n    }\r\n    run(accessor, editor) {\r\n        if (!editor.hasModel()) {\r\n            return;\r\n        }\r\n        let controller = hover_ModesHoverController.get(editor);\r\n        if (!controller) {\r\n            return;\r\n        }\r\n        const position = editor.getPosition();\r\n        const range = new core_range["Range"](position.lineNumber, position.column, position.lineNumber, position.column);\r\n        const focus = editor.getOption(2 /* accessibilitySupport */) === 2 /* Enabled */;\r\n        controller.showContentHover(range, 1 /* Immediate */, focus);\r\n    }\r\n}\r\nclass hover_ShowDefinitionPreviewHoverAction extends editorExtensions["EditorAction"] {\r\n    constructor() {\r\n        super({\r\n            id: \'editor.action.showDefinitionPreviewHover\',\r\n            label: nls["localize"]({\r\n                key: \'showDefinitionPreviewHover\',\r\n                comment: [\r\n                    \'Label for action that will trigger the showing of definition preview hover in the editor.\',\r\n                    \'This allows for users to show the definition preview hover without using the mouse.\'\r\n                ]\r\n            }, "Show Definition Preview Hover"),\r\n            alias: \'Show Definition Preview Hover\',\r\n            precondition: undefined\r\n        });\r\n    }\r\n    run(accessor, editor) {\r\n        let controller = hover_ModesHoverController.get(editor);\r\n        if (!controller) {\r\n            return;\r\n        }\r\n        const position = editor.getPosition();\r\n        if (!position) {\r\n            return;\r\n        }\r\n        const range = new core_range["Range"](position.lineNumber, position.column, position.lineNumber, position.column);\r\n        const goto = goToDefinitionAtPosition_GotoDefinitionAtPositionEditorContribution.get(editor);\r\n        const promise = goto.startFindDefinitionFromCursor(position);\r\n        promise.then(() => {\r\n            controller.showContentHover(range, 1 /* Immediate */, true);\r\n        });\r\n    }\r\n}\r\nObject(editorExtensions["registerEditorContribution"])(hover_ModesHoverController.ID, hover_ModesHoverController);\r\nObject(editorExtensions["registerEditorAction"])(hover_ShowHoverAction);\r\nObject(editorExtensions["registerEditorAction"])(hover_ShowDefinitionPreviewHoverAction);\r\n// theming\r\nObject(common_themeService["registerThemingParticipant"])((theme, collector) => {\r\n    const editorHoverHighlightColor = theme.getColor(colorRegistry["editorHoverHighlight"]);\r\n    if (editorHoverHighlightColor) {\r\n        collector.addRule(`.monaco-editor .hoverHighlight { background-color: ${editorHoverHighlightColor}; }`);\r\n    }\r\n    const hoverBackground = theme.getColor(colorRegistry["editorHoverBackground"]);\r\n    if (hoverBackground) {\r\n        collector.addRule(`.monaco-editor .monaco-hover { background-color: ${hoverBackground}; }`);\r\n    }\r\n    const hoverBorder = theme.getColor(colorRegistry["editorHoverBorder"]);\r\n    if (hoverBorder) {\r\n        collector.addRule(`.monaco-editor .monaco-hover { border: 1px solid ${hoverBorder}; }`);\r\n        collector.addRule(`.monaco-editor .monaco-hover .hover-row:not(:first-child):not(:empty) { border-top: 1px solid ${hoverBorder.transparent(0.5)}; }`);\r\n        collector.addRule(`.monaco-editor .monaco-hover hr { border-top: 1px solid ${hoverBorder.transparent(0.5)}; }`);\r\n        collector.addRule(`.monaco-editor .monaco-hover hr { border-bottom: 0px solid ${hoverBorder.transparent(0.5)}; }`);\r\n    }\r\n    const link = theme.getColor(colorRegistry["textLinkForeground"]);\r\n    if (link) {\r\n        collector.addRule(`.monaco-editor .monaco-hover a { color: ${link}; }`);\r\n    }\r\n    const linkHover = theme.getColor(colorRegistry["textLinkActiveForeground"]);\r\n    if (linkHover) {\r\n        collector.addRule(`.monaco-editor .monaco-hover a:hover { color: ${linkHover}; }`);\r\n    }\r\n    const hoverForeground = theme.getColor(colorRegistry["editorHoverForeground"]);\r\n    if (hoverForeground) {\r\n        collector.addRule(`.monaco-editor .monaco-hover { color: ${hoverForeground}; }`);\r\n    }\r\n    const actionsBackground = theme.getColor(colorRegistry["editorHoverStatusBarBackground"]);\r\n    if (actionsBackground) {\r\n        collector.addRule(`.monaco-editor .monaco-hover .hover-row .actions { background-color: ${actionsBackground}; }`);\r\n    }\r\n    const codeBackground = theme.getColor(colorRegistry["textCodeBlockBackground"]);\r\n    if (codeBackground) {\r\n        collector.addRule(`.monaco-editor .monaco-hover code { background-color: ${codeBackground}; }`);\r\n    }\r\n});\r\n\n\n//# sourceURL=webpack:///./node_modules/monaco-editor/esm/vs/editor/contrib/hover/hover.js_+_83_modules?')},"./node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/ghostText.css":
/*!******************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/ghostText.css ***!
  \******************************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */function(module,exports,__webpack_require__){eval('var api = __webpack_require__(/*! ../../../../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");\n            var content = __webpack_require__(/*! !../../../../../../css-loader/dist/cjs.js!./ghostText.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/ghostText.css");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === \'string\') {\n              content = [[module.i, content, \'\']];\n            }\n\nvar options = {};\n\noptions.insert = "head";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nmodule.exports = content.locals || {};\n\n//# sourceURL=webpack:///./node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/ghostText.css?')},"./node_modules/monaco-editor/esm/vs/editor/contrib/message/messageController.css":
/*!****************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/contrib/message/messageController.css ***!
  \****************************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */function(module,exports,__webpack_require__){eval('var api = __webpack_require__(/*! ../../../../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");\n            var content = __webpack_require__(/*! !../../../../../../css-loader/dist/cjs.js!./messageController.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/editor/contrib/message/messageController.css");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === \'string\') {\n              content = [[module.i, content, \'\']];\n            }\n\nvar options = {};\n\noptions.insert = "head";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nmodule.exports = content.locals || {};\n\n//# sourceURL=webpack:///./node_modules/monaco-editor/esm/vs/editor/contrib/message/messageController.css?')},"./node_modules/monaco-editor/esm/vs/editor/contrib/peekView/media/peekViewWidget.css":
/*!********************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/contrib/peekView/media/peekViewWidget.css ***!
  \********************************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */function(module,exports,__webpack_require__){eval('var api = __webpack_require__(/*! ../../../../../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");\n            var content = __webpack_require__(/*! !../../../../../../../css-loader/dist/cjs.js!./peekViewWidget.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/editor/contrib/peekView/media/peekViewWidget.css");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === \'string\') {\n              content = [[module.i, content, \'\']];\n            }\n\nvar options = {};\n\noptions.insert = "head";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nmodule.exports = content.locals || {};\n\n//# sourceURL=webpack:///./node_modules/monaco-editor/esm/vs/editor/contrib/peekView/media/peekViewWidget.css?')},"./node_modules/monaco-editor/esm/vs/editor/contrib/snippet/snippetSession.css":
/*!*************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/contrib/snippet/snippetSession.css ***!
  \*************************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */function(module,exports,__webpack_require__){eval('var api = __webpack_require__(/*! ../../../../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");\n            var content = __webpack_require__(/*! !../../../../../../css-loader/dist/cjs.js!./snippetSession.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/editor/contrib/snippet/snippetSession.css");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === \'string\') {\n              content = [[module.i, content, \'\']];\n            }\n\nvar options = {};\n\noptions.insert = "head";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nmodule.exports = content.locals || {};\n\n//# sourceURL=webpack:///./node_modules/monaco-editor/esm/vs/editor/contrib/snippet/snippetSession.css?')},"./node_modules/monaco-editor/esm/vs/editor/contrib/suggest/media/suggest.css":
/*!************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/contrib/suggest/media/suggest.css ***!
  \************************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */function(module,exports,__webpack_require__){eval('var api = __webpack_require__(/*! ../../../../../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");\n            var content = __webpack_require__(/*! !../../../../../../../css-loader/dist/cjs.js!./suggest.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/editor/contrib/suggest/media/suggest.css");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === \'string\') {\n              content = [[module.i, content, \'\']];\n            }\n\nvar options = {};\n\noptions.insert = "head";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nmodule.exports = content.locals || {};\n\n//# sourceURL=webpack:///./node_modules/monaco-editor/esm/vs/editor/contrib/suggest/media/suggest.css?')},"./node_modules/monaco-editor/esm/vs/editor/contrib/wordHighlighter/wordHighlighter.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/contrib/wordHighlighter/wordHighlighter.js ***!
  \*********************************************************************************************/
/*! exports provided: getOccurrencesAtPosition */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getOccurrencesAtPosition", function() { return getOccurrencesAtPosition; });\n/* harmony import */ var _nls_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../nls.js */ "./node_modules/monaco-editor/esm/vs/nls.js");\n/* harmony import */ var _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../base/common/arrays.js */ "./node_modules/monaco-editor/esm/vs/base/common/arrays.js");\n/* harmony import */ var _base_common_async_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../base/common/async.js */ "./node_modules/monaco-editor/esm/vs/base/common/async.js");\n/* harmony import */ var _base_common_cancellation_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../base/common/cancellation.js */ "./node_modules/monaco-editor/esm/vs/base/common/cancellation.js");\n/* harmony import */ var _base_common_errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../base/common/errors.js */ "./node_modules/monaco-editor/esm/vs/base/common/errors.js");\n/* harmony import */ var _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../base/common/lifecycle.js */ "./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js");\n/* harmony import */ var _browser_editorExtensions_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../browser/editorExtensions.js */ "./node_modules/monaco-editor/esm/vs/editor/browser/editorExtensions.js");\n/* harmony import */ var _common_core_range_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../common/core/range.js */ "./node_modules/monaco-editor/esm/vs/editor/common/core/range.js");\n/* harmony import */ var _common_editorContextKeys_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../common/editorContextKeys.js */ "./node_modules/monaco-editor/esm/vs/editor/common/editorContextKeys.js");\n/* harmony import */ var _common_model_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../common/model.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model.js");\n/* harmony import */ var _common_model_textModel_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../common/model/textModel.js */ "./node_modules/monaco-editor/esm/vs/editor/common/model/textModel.js");\n/* harmony import */ var _common_modes_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../common/modes.js */ "./node_modules/monaco-editor/esm/vs/editor/common/modes.js");\n/* harmony import */ var _platform_contextkey_common_contextkey_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../../platform/contextkey/common/contextkey.js */ "./node_modules/monaco-editor/esm/vs/platform/contextkey/common/contextkey.js");\n/* harmony import */ var _platform_theme_common_colorRegistry_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../../platform/theme/common/colorRegistry.js */ "./node_modules/monaco-editor/esm/vs/platform/theme/common/colorRegistry.js");\n/* harmony import */ var _platform_theme_common_themeService_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../../platform/theme/common/themeService.js */ "./node_modules/monaco-editor/esm/vs/platform/theme/common/themeService.js");\n/* harmony import */ var _base_browser_ui_aria_aria_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../../base/browser/ui/aria/aria.js */ "./node_modules/monaco-editor/esm/vs/base/browser/ui/aria/aria.js");\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __param = (undefined && undefined.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst editorWordHighlight = Object(_platform_theme_common_colorRegistry_js__WEBPACK_IMPORTED_MODULE_13__["registerColor"])(\'editor.wordHighlightBackground\', { dark: \'#575757B8\', light: \'#57575740\', hc: null }, _nls_js__WEBPACK_IMPORTED_MODULE_0__["localize"](\'wordHighlight\', \'Background color of a symbol during read-access, like reading a variable. The color must not be opaque so as not to hide underlying decorations.\'), true);\r\nconst editorWordHighlightStrong = Object(_platform_theme_common_colorRegistry_js__WEBPACK_IMPORTED_MODULE_13__["registerColor"])(\'editor.wordHighlightStrongBackground\', { dark: \'#004972B8\', light: \'#0e639c40\', hc: null }, _nls_js__WEBPACK_IMPORTED_MODULE_0__["localize"](\'wordHighlightStrong\', \'Background color of a symbol during write-access, like writing to a variable. The color must not be opaque so as not to hide underlying decorations.\'), true);\r\nconst editorWordHighlightBorder = Object(_platform_theme_common_colorRegistry_js__WEBPACK_IMPORTED_MODULE_13__["registerColor"])(\'editor.wordHighlightBorder\', { light: null, dark: null, hc: _platform_theme_common_colorRegistry_js__WEBPACK_IMPORTED_MODULE_13__["activeContrastBorder"] }, _nls_js__WEBPACK_IMPORTED_MODULE_0__["localize"](\'wordHighlightBorder\', \'Border color of a symbol during read-access, like reading a variable.\'));\r\nconst editorWordHighlightStrongBorder = Object(_platform_theme_common_colorRegistry_js__WEBPACK_IMPORTED_MODULE_13__["registerColor"])(\'editor.wordHighlightStrongBorder\', { light: null, dark: null, hc: _platform_theme_common_colorRegistry_js__WEBPACK_IMPORTED_MODULE_13__["activeContrastBorder"] }, _nls_js__WEBPACK_IMPORTED_MODULE_0__["localize"](\'wordHighlightStrongBorder\', \'Border color of a symbol during write-access, like writing to a variable.\'));\r\nconst overviewRulerWordHighlightForeground = Object(_platform_theme_common_colorRegistry_js__WEBPACK_IMPORTED_MODULE_13__["registerColor"])(\'editorOverviewRuler.wordHighlightForeground\', { dark: \'#A0A0A0CC\', light: \'#A0A0A0CC\', hc: \'#A0A0A0CC\' }, _nls_js__WEBPACK_IMPORTED_MODULE_0__["localize"](\'overviewRulerWordHighlightForeground\', \'Overview ruler marker color for symbol highlights. The color must not be opaque so as not to hide underlying decorations.\'), true);\r\nconst overviewRulerWordHighlightStrongForeground = Object(_platform_theme_common_colorRegistry_js__WEBPACK_IMPORTED_MODULE_13__["registerColor"])(\'editorOverviewRuler.wordHighlightStrongForeground\', { dark: \'#C0A0C0CC\', light: \'#C0A0C0CC\', hc: \'#C0A0C0CC\' }, _nls_js__WEBPACK_IMPORTED_MODULE_0__["localize"](\'overviewRulerWordHighlightStrongForeground\', \'Overview ruler marker color for write-access symbol highlights. The color must not be opaque so as not to hide underlying decorations.\'), true);\r\nconst ctxHasWordHighlights = new _platform_contextkey_common_contextkey_js__WEBPACK_IMPORTED_MODULE_12__["RawContextKey"](\'hasWordHighlights\', false);\r\nfunction getOccurrencesAtPosition(model, position, token) {\r\n    const orderedByScore = _common_modes_js__WEBPACK_IMPORTED_MODULE_11__["DocumentHighlightProviderRegistry"].ordered(model);\r\n    // in order of score ask the occurrences provider\r\n    // until someone response with a good result\r\n    // (good = none empty array)\r\n    return Object(_base_common_async_js__WEBPACK_IMPORTED_MODULE_2__["first"])(orderedByScore.map(provider => () => {\r\n        return Promise.resolve(provider.provideDocumentHighlights(model, position, token))\r\n            .then(undefined, _base_common_errors_js__WEBPACK_IMPORTED_MODULE_4__["onUnexpectedExternalError"]);\r\n    }), _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_1__["isNonEmptyArray"]);\r\n}\r\nclass OccurenceAtPositionRequest {\r\n    constructor(model, selection, wordSeparators) {\r\n        this._wordRange = this._getCurrentWordRange(model, selection);\r\n        this.result = Object(_base_common_async_js__WEBPACK_IMPORTED_MODULE_2__["createCancelablePromise"])(token => this._compute(model, selection, wordSeparators, token));\r\n    }\r\n    _getCurrentWordRange(model, selection) {\r\n        const word = model.getWordAtPosition(selection.getPosition());\r\n        if (word) {\r\n            return new _common_core_range_js__WEBPACK_IMPORTED_MODULE_7__["Range"](selection.startLineNumber, word.startColumn, selection.startLineNumber, word.endColumn);\r\n        }\r\n        return null;\r\n    }\r\n    isValid(model, selection, decorationIds) {\r\n        const lineNumber = selection.startLineNumber;\r\n        const startColumn = selection.startColumn;\r\n        const endColumn = selection.endColumn;\r\n        const currentWordRange = this._getCurrentWordRange(model, selection);\r\n        let requestIsValid = Boolean(this._wordRange && this._wordRange.equalsRange(currentWordRange));\r\n        // Even if we are on a different word, if that word is in the decorations ranges, the request is still valid\r\n        // (Same symbol)\r\n        for (let i = 0, len = decorationIds.length; !requestIsValid && i < len; i++) {\r\n            let range = model.getDecorationRange(decorationIds[i]);\r\n            if (range && range.startLineNumber === lineNumber) {\r\n                if (range.startColumn <= startColumn && range.endColumn >= endColumn) {\r\n                    requestIsValid = true;\r\n                }\r\n            }\r\n        }\r\n        return requestIsValid;\r\n    }\r\n    cancel() {\r\n        this.result.cancel();\r\n    }\r\n}\r\nclass SemanticOccurenceAtPositionRequest extends OccurenceAtPositionRequest {\r\n    _compute(model, selection, wordSeparators, token) {\r\n        return getOccurrencesAtPosition(model, selection.getPosition(), token).then(value => value || []);\r\n    }\r\n}\r\nclass TextualOccurenceAtPositionRequest extends OccurenceAtPositionRequest {\r\n    constructor(model, selection, wordSeparators) {\r\n        super(model, selection, wordSeparators);\r\n        this._selectionIsEmpty = selection.isEmpty();\r\n    }\r\n    _compute(model, selection, wordSeparators, token) {\r\n        return Object(_base_common_async_js__WEBPACK_IMPORTED_MODULE_2__["timeout"])(250, token).then(() => {\r\n            if (!selection.isEmpty()) {\r\n                return [];\r\n            }\r\n            const word = model.getWordAtPosition(selection.getPosition());\r\n            if (!word || word.word.length > 1000) {\r\n                return [];\r\n            }\r\n            const matches = model.findMatches(word.word, true, false, true, wordSeparators, false);\r\n            return matches.map(m => {\r\n                return {\r\n                    range: m.range,\r\n                    kind: _common_modes_js__WEBPACK_IMPORTED_MODULE_11__["DocumentHighlightKind"].Text\r\n                };\r\n            });\r\n        });\r\n    }\r\n    isValid(model, selection, decorationIds) {\r\n        const currentSelectionIsEmpty = selection.isEmpty();\r\n        if (this._selectionIsEmpty !== currentSelectionIsEmpty) {\r\n            return false;\r\n        }\r\n        return super.isValid(model, selection, decorationIds);\r\n    }\r\n}\r\nfunction computeOccurencesAtPosition(model, selection, wordSeparators) {\r\n    if (_common_modes_js__WEBPACK_IMPORTED_MODULE_11__["DocumentHighlightProviderRegistry"].has(model)) {\r\n        return new SemanticOccurenceAtPositionRequest(model, selection, wordSeparators);\r\n    }\r\n    return new TextualOccurenceAtPositionRequest(model, selection, wordSeparators);\r\n}\r\nObject(_browser_editorExtensions_js__WEBPACK_IMPORTED_MODULE_6__["registerModelAndPositionCommand"])(\'_executeDocumentHighlights\', (model, position) => getOccurrencesAtPosition(model, position, _base_common_cancellation_js__WEBPACK_IMPORTED_MODULE_3__["CancellationToken"].None));\r\nclass WordHighlighter {\r\n    constructor(editor, contextKeyService) {\r\n        this.toUnhook = new _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_5__["DisposableStore"]();\r\n        this.workerRequestTokenId = 0;\r\n        this.workerRequestCompleted = false;\r\n        this.workerRequestValue = [];\r\n        this.lastCursorPositionChangeTime = 0;\r\n        this.renderDecorationsTimer = -1;\r\n        this.editor = editor;\r\n        this._hasWordHighlights = ctxHasWordHighlights.bindTo(contextKeyService);\r\n        this._ignorePositionChangeEvent = false;\r\n        this.occurrencesHighlight = this.editor.getOption(71 /* occurrencesHighlight */);\r\n        this.model = this.editor.getModel();\r\n        this.toUnhook.add(editor.onDidChangeCursorPosition((e) => {\r\n            if (this._ignorePositionChangeEvent) {\r\n                // We are changing the position => ignore this event\r\n                return;\r\n            }\r\n            if (!this.occurrencesHighlight) {\r\n                // Early exit if nothing needs to be done!\r\n                // Leave some form of early exit check here if you wish to continue being a cursor position change listener ;)\r\n                return;\r\n            }\r\n            this._onPositionChanged(e);\r\n        }));\r\n        this.toUnhook.add(editor.onDidChangeModelContent((e) => {\r\n            this._stopAll();\r\n        }));\r\n        this.toUnhook.add(editor.onDidChangeConfiguration((e) => {\r\n            let newValue = this.editor.getOption(71 /* occurrencesHighlight */);\r\n            if (this.occurrencesHighlight !== newValue) {\r\n                this.occurrencesHighlight = newValue;\r\n                this._stopAll();\r\n            }\r\n        }));\r\n        this._decorationIds = [];\r\n        this.workerRequestTokenId = 0;\r\n        this.workerRequest = null;\r\n        this.workerRequestCompleted = false;\r\n        this.lastCursorPositionChangeTime = 0;\r\n        this.renderDecorationsTimer = -1;\r\n    }\r\n    hasDecorations() {\r\n        return (this._decorationIds.length > 0);\r\n    }\r\n    restore() {\r\n        if (!this.occurrencesHighlight) {\r\n            return;\r\n        }\r\n        this._run();\r\n    }\r\n    _getSortedHighlights() {\r\n        return _base_common_arrays_js__WEBPACK_IMPORTED_MODULE_1__["coalesce"](this._decorationIds\r\n            .map((id) => this.model.getDecorationRange(id))\r\n            .sort(_common_core_range_js__WEBPACK_IMPORTED_MODULE_7__["Range"].compareRangesUsingStarts));\r\n    }\r\n    moveNext() {\r\n        let highlights = this._getSortedHighlights();\r\n        let index = highlights.findIndex((range) => range.containsPosition(this.editor.getPosition()));\r\n        let newIndex = ((index + 1) % highlights.length);\r\n        let dest = highlights[newIndex];\r\n        try {\r\n            this._ignorePositionChangeEvent = true;\r\n            this.editor.setPosition(dest.getStartPosition());\r\n            this.editor.revealRangeInCenterIfOutsideViewport(dest);\r\n            const word = this._getWord();\r\n            if (word) {\r\n                const lineContent = this.editor.getModel().getLineContent(dest.startLineNumber);\r\n                Object(_base_browser_ui_aria_aria_js__WEBPACK_IMPORTED_MODULE_15__["alert"])(`${lineContent}, ${newIndex + 1} of ${highlights.length} for \'${word.word}\'`);\r\n            }\r\n        }\r\n        finally {\r\n            this._ignorePositionChangeEvent = false;\r\n        }\r\n    }\r\n    moveBack() {\r\n        let highlights = this._getSortedHighlights();\r\n        let index = highlights.findIndex((range) => range.containsPosition(this.editor.getPosition()));\r\n        let newIndex = ((index - 1 + highlights.length) % highlights.length);\r\n        let dest = highlights[newIndex];\r\n        try {\r\n            this._ignorePositionChangeEvent = true;\r\n            this.editor.setPosition(dest.getStartPosition());\r\n            this.editor.revealRangeInCenterIfOutsideViewport(dest);\r\n            const word = this._getWord();\r\n            if (word) {\r\n                const lineContent = this.editor.getModel().getLineContent(dest.startLineNumber);\r\n                Object(_base_browser_ui_aria_aria_js__WEBPACK_IMPORTED_MODULE_15__["alert"])(`${lineContent}, ${newIndex + 1} of ${highlights.length} for \'${word.word}\'`);\r\n            }\r\n        }\r\n        finally {\r\n            this._ignorePositionChangeEvent = false;\r\n        }\r\n    }\r\n    _removeDecorations() {\r\n        if (this._decorationIds.length > 0) {\r\n            // remove decorations\r\n            this._decorationIds = this.editor.deltaDecorations(this._decorationIds, []);\r\n            this._hasWordHighlights.set(false);\r\n        }\r\n    }\r\n    _stopAll() {\r\n        // Remove any existing decorations\r\n        this._removeDecorations();\r\n        // Cancel any renderDecorationsTimer\r\n        if (this.renderDecorationsTimer !== -1) {\r\n            clearTimeout(this.renderDecorationsTimer);\r\n            this.renderDecorationsTimer = -1;\r\n        }\r\n        // Cancel any worker request\r\n        if (this.workerRequest !== null) {\r\n            this.workerRequest.cancel();\r\n            this.workerRequest = null;\r\n        }\r\n        // Invalidate any worker request callback\r\n        if (!this.workerRequestCompleted) {\r\n            this.workerRequestTokenId++;\r\n            this.workerRequestCompleted = true;\r\n        }\r\n    }\r\n    _onPositionChanged(e) {\r\n        // disabled\r\n        if (!this.occurrencesHighlight) {\r\n            this._stopAll();\r\n            return;\r\n        }\r\n        // ignore typing & other\r\n        if (e.reason !== 3 /* Explicit */) {\r\n            this._stopAll();\r\n            return;\r\n        }\r\n        this._run();\r\n    }\r\n    _getWord() {\r\n        let editorSelection = this.editor.getSelection();\r\n        let lineNumber = editorSelection.startLineNumber;\r\n        let startColumn = editorSelection.startColumn;\r\n        return this.model.getWordAtPosition({\r\n            lineNumber: lineNumber,\r\n            column: startColumn\r\n        });\r\n    }\r\n    _run() {\r\n        let editorSelection = this.editor.getSelection();\r\n        // ignore multiline selection\r\n        if (editorSelection.startLineNumber !== editorSelection.endLineNumber) {\r\n            this._stopAll();\r\n            return;\r\n        }\r\n        let startColumn = editorSelection.startColumn;\r\n        let endColumn = editorSelection.endColumn;\r\n        const word = this._getWord();\r\n        // The selection must be inside a word or surround one word at most\r\n        if (!word || word.startColumn > startColumn || word.endColumn < endColumn) {\r\n            this._stopAll();\r\n            return;\r\n        }\r\n        // All the effort below is trying to achieve this:\r\n        // - when cursor is moved to a word, trigger immediately a findOccurrences request\r\n        // - 250ms later after the last cursor move event, render the occurrences\r\n        // - no flickering!\r\n        const workerRequestIsValid = (this.workerRequest && this.workerRequest.isValid(this.model, editorSelection, this._decorationIds));\r\n        // There are 4 cases:\r\n        // a) old workerRequest is valid & completed, renderDecorationsTimer fired\r\n        // b) old workerRequest is valid & completed, renderDecorationsTimer not fired\r\n        // c) old workerRequest is valid, but not completed\r\n        // d) old workerRequest is not valid\r\n        // For a) no action is needed\r\n        // For c), member \'lastCursorPositionChangeTime\' will be used when installing the timer so no action is needed\r\n        this.lastCursorPositionChangeTime = (new Date()).getTime();\r\n        if (workerRequestIsValid) {\r\n            if (this.workerRequestCompleted && this.renderDecorationsTimer !== -1) {\r\n                // case b)\r\n                // Delay the firing of renderDecorationsTimer by an extra 250 ms\r\n                clearTimeout(this.renderDecorationsTimer);\r\n                this.renderDecorationsTimer = -1;\r\n                this._beginRenderDecorations();\r\n            }\r\n        }\r\n        else {\r\n            // case d)\r\n            // Stop all previous actions and start fresh\r\n            this._stopAll();\r\n            let myRequestId = ++this.workerRequestTokenId;\r\n            this.workerRequestCompleted = false;\r\n            this.workerRequest = computeOccurencesAtPosition(this.model, this.editor.getSelection(), this.editor.getOption(116 /* wordSeparators */));\r\n            this.workerRequest.result.then(data => {\r\n                if (myRequestId === this.workerRequestTokenId) {\r\n                    this.workerRequestCompleted = true;\r\n                    this.workerRequestValue = data || [];\r\n                    this._beginRenderDecorations();\r\n                }\r\n            }, _base_common_errors_js__WEBPACK_IMPORTED_MODULE_4__["onUnexpectedError"]);\r\n        }\r\n    }\r\n    _beginRenderDecorations() {\r\n        let currentTime = (new Date()).getTime();\r\n        let minimumRenderTime = this.lastCursorPositionChangeTime + 250;\r\n        if (currentTime >= minimumRenderTime) {\r\n            // Synchronous\r\n            this.renderDecorationsTimer = -1;\r\n            this.renderDecorations();\r\n        }\r\n        else {\r\n            // Asynchronous\r\n            this.renderDecorationsTimer = setTimeout(() => {\r\n                this.renderDecorations();\r\n            }, (minimumRenderTime - currentTime));\r\n        }\r\n    }\r\n    renderDecorations() {\r\n        this.renderDecorationsTimer = -1;\r\n        let decorations = [];\r\n        for (const info of this.workerRequestValue) {\r\n            if (info.range) {\r\n                decorations.push({\r\n                    range: info.range,\r\n                    options: WordHighlighter._getDecorationOptions(info.kind)\r\n                });\r\n            }\r\n        }\r\n        this._decorationIds = this.editor.deltaDecorations(this._decorationIds, decorations);\r\n        this._hasWordHighlights.set(this.hasDecorations());\r\n    }\r\n    static _getDecorationOptions(kind) {\r\n        if (kind === _common_modes_js__WEBPACK_IMPORTED_MODULE_11__["DocumentHighlightKind"].Write) {\r\n            return this._WRITE_OPTIONS;\r\n        }\r\n        else if (kind === _common_modes_js__WEBPACK_IMPORTED_MODULE_11__["DocumentHighlightKind"].Text) {\r\n            return this._TEXT_OPTIONS;\r\n        }\r\n        else {\r\n            return this._REGULAR_OPTIONS;\r\n        }\r\n    }\r\n    dispose() {\r\n        this._stopAll();\r\n        this.toUnhook.dispose();\r\n    }\r\n}\r\nWordHighlighter._WRITE_OPTIONS = _common_model_textModel_js__WEBPACK_IMPORTED_MODULE_10__["ModelDecorationOptions"].register({\r\n    description: \'word-highlight-strong\',\r\n    stickiness: 1 /* NeverGrowsWhenTypingAtEdges */,\r\n    className: \'wordHighlightStrong\',\r\n    overviewRuler: {\r\n        color: Object(_platform_theme_common_themeService_js__WEBPACK_IMPORTED_MODULE_14__["themeColorFromId"])(overviewRulerWordHighlightStrongForeground),\r\n        position: _common_model_js__WEBPACK_IMPORTED_MODULE_9__["OverviewRulerLane"].Center\r\n    }\r\n});\r\nWordHighlighter._TEXT_OPTIONS = _common_model_textModel_js__WEBPACK_IMPORTED_MODULE_10__["ModelDecorationOptions"].register({\r\n    description: \'selection-highlight\',\r\n    stickiness: 1 /* NeverGrowsWhenTypingAtEdges */,\r\n    className: \'selectionHighlight\',\r\n    overviewRuler: {\r\n        color: Object(_platform_theme_common_themeService_js__WEBPACK_IMPORTED_MODULE_14__["themeColorFromId"])(_platform_theme_common_colorRegistry_js__WEBPACK_IMPORTED_MODULE_13__["overviewRulerSelectionHighlightForeground"]),\r\n        position: _common_model_js__WEBPACK_IMPORTED_MODULE_9__["OverviewRulerLane"].Center\r\n    }\r\n});\r\nWordHighlighter._REGULAR_OPTIONS = _common_model_textModel_js__WEBPACK_IMPORTED_MODULE_10__["ModelDecorationOptions"].register({\r\n    description: \'word-highlight\',\r\n    stickiness: 1 /* NeverGrowsWhenTypingAtEdges */,\r\n    className: \'wordHighlight\',\r\n    overviewRuler: {\r\n        color: Object(_platform_theme_common_themeService_js__WEBPACK_IMPORTED_MODULE_14__["themeColorFromId"])(overviewRulerWordHighlightForeground),\r\n        position: _common_model_js__WEBPACK_IMPORTED_MODULE_9__["OverviewRulerLane"].Center\r\n    }\r\n});\r\nlet WordHighlighterContribution = class WordHighlighterContribution extends _base_common_lifecycle_js__WEBPACK_IMPORTED_MODULE_5__["Disposable"] {\r\n    constructor(editor, contextKeyService) {\r\n        super();\r\n        this.wordHighlighter = null;\r\n        const createWordHighlighterIfPossible = () => {\r\n            if (editor.hasModel()) {\r\n                this.wordHighlighter = new WordHighlighter(editor, contextKeyService);\r\n            }\r\n        };\r\n        this._register(editor.onDidChangeModel((e) => {\r\n            if (this.wordHighlighter) {\r\n                this.wordHighlighter.dispose();\r\n                this.wordHighlighter = null;\r\n            }\r\n            createWordHighlighterIfPossible();\r\n        }));\r\n        createWordHighlighterIfPossible();\r\n    }\r\n    static get(editor) {\r\n        return editor.getContribution(WordHighlighterContribution.ID);\r\n    }\r\n    saveViewState() {\r\n        if (this.wordHighlighter && this.wordHighlighter.hasDecorations()) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    moveNext() {\r\n        if (this.wordHighlighter) {\r\n            this.wordHighlighter.moveNext();\r\n        }\r\n    }\r\n    moveBack() {\r\n        if (this.wordHighlighter) {\r\n            this.wordHighlighter.moveBack();\r\n        }\r\n    }\r\n    restoreViewState(state) {\r\n        if (this.wordHighlighter && state) {\r\n            this.wordHighlighter.restore();\r\n        }\r\n    }\r\n    dispose() {\r\n        if (this.wordHighlighter) {\r\n            this.wordHighlighter.dispose();\r\n            this.wordHighlighter = null;\r\n        }\r\n        super.dispose();\r\n    }\r\n};\r\nWordHighlighterContribution.ID = \'editor.contrib.wordHighlighter\';\r\nWordHighlighterContribution = __decorate([\r\n    __param(1, _platform_contextkey_common_contextkey_js__WEBPACK_IMPORTED_MODULE_12__["IContextKeyService"])\r\n], WordHighlighterContribution);\r\nclass WordHighlightNavigationAction extends _browser_editorExtensions_js__WEBPACK_IMPORTED_MODULE_6__["EditorAction"] {\r\n    constructor(next, opts) {\r\n        super(opts);\r\n        this._isNext = next;\r\n    }\r\n    run(accessor, editor) {\r\n        const controller = WordHighlighterContribution.get(editor);\r\n        if (!controller) {\r\n            return;\r\n        }\r\n        if (this._isNext) {\r\n            controller.moveNext();\r\n        }\r\n        else {\r\n            controller.moveBack();\r\n        }\r\n    }\r\n}\r\nclass NextWordHighlightAction extends WordHighlightNavigationAction {\r\n    constructor() {\r\n        super(true, {\r\n            id: \'editor.action.wordHighlight.next\',\r\n            label: _nls_js__WEBPACK_IMPORTED_MODULE_0__["localize"](\'wordHighlight.next.label\', "Go to Next Symbol Highlight"),\r\n            alias: \'Go to Next Symbol Highlight\',\r\n            precondition: ctxHasWordHighlights,\r\n            kbOpts: {\r\n                kbExpr: _common_editorContextKeys_js__WEBPACK_IMPORTED_MODULE_8__["EditorContextKeys"].editorTextFocus,\r\n                primary: 65 /* F7 */,\r\n                weight: 100 /* EditorContrib */\r\n            }\r\n        });\r\n    }\r\n}\r\nclass PrevWordHighlightAction extends WordHighlightNavigationAction {\r\n    constructor() {\r\n        super(false, {\r\n            id: \'editor.action.wordHighlight.prev\',\r\n            label: _nls_js__WEBPACK_IMPORTED_MODULE_0__["localize"](\'wordHighlight.previous.label\', "Go to Previous Symbol Highlight"),\r\n            alias: \'Go to Previous Symbol Highlight\',\r\n            precondition: ctxHasWordHighlights,\r\n            kbOpts: {\r\n                kbExpr: _common_editorContextKeys_js__WEBPACK_IMPORTED_MODULE_8__["EditorContextKeys"].editorTextFocus,\r\n                primary: 1024 /* Shift */ | 65 /* F7 */,\r\n                weight: 100 /* EditorContrib */\r\n            }\r\n        });\r\n    }\r\n}\r\nclass TriggerWordHighlightAction extends _browser_editorExtensions_js__WEBPACK_IMPORTED_MODULE_6__["EditorAction"] {\r\n    constructor() {\r\n        super({\r\n            id: \'editor.action.wordHighlight.trigger\',\r\n            label: _nls_js__WEBPACK_IMPORTED_MODULE_0__["localize"](\'wordHighlight.trigger.label\', "Trigger Symbol Highlight"),\r\n            alias: \'Trigger Symbol Highlight\',\r\n            precondition: ctxHasWordHighlights.toNegated(),\r\n            kbOpts: {\r\n                kbExpr: _common_editorContextKeys_js__WEBPACK_IMPORTED_MODULE_8__["EditorContextKeys"].editorTextFocus,\r\n                primary: 0,\r\n                weight: 100 /* EditorContrib */\r\n            }\r\n        });\r\n    }\r\n    run(accessor, editor, args) {\r\n        const controller = WordHighlighterContribution.get(editor);\r\n        if (!controller) {\r\n            return;\r\n        }\r\n        controller.restoreViewState(true);\r\n    }\r\n}\r\nObject(_browser_editorExtensions_js__WEBPACK_IMPORTED_MODULE_6__["registerEditorContribution"])(WordHighlighterContribution.ID, WordHighlighterContribution);\r\nObject(_browser_editorExtensions_js__WEBPACK_IMPORTED_MODULE_6__["registerEditorAction"])(NextWordHighlightAction);\r\nObject(_browser_editorExtensions_js__WEBPACK_IMPORTED_MODULE_6__["registerEditorAction"])(PrevWordHighlightAction);\r\nObject(_browser_editorExtensions_js__WEBPACK_IMPORTED_MODULE_6__["registerEditorAction"])(TriggerWordHighlightAction);\r\nObject(_platform_theme_common_themeService_js__WEBPACK_IMPORTED_MODULE_14__["registerThemingParticipant"])((theme, collector) => {\r\n    const selectionHighlight = theme.getColor(_platform_theme_common_colorRegistry_js__WEBPACK_IMPORTED_MODULE_13__["editorSelectionHighlight"]);\r\n    if (selectionHighlight) {\r\n        collector.addRule(`.monaco-editor .focused .selectionHighlight { background-color: ${selectionHighlight}; }`);\r\n        collector.addRule(`.monaco-editor .selectionHighlight { background-color: ${selectionHighlight.transparent(0.5)}; }`);\r\n    }\r\n    const wordHighlight = theme.getColor(editorWordHighlight);\r\n    if (wordHighlight) {\r\n        collector.addRule(`.monaco-editor .wordHighlight { background-color: ${wordHighlight}; }`);\r\n    }\r\n    const wordHighlightStrong = theme.getColor(editorWordHighlightStrong);\r\n    if (wordHighlightStrong) {\r\n        collector.addRule(`.monaco-editor .wordHighlightStrong { background-color: ${wordHighlightStrong}; }`);\r\n    }\r\n    const selectionHighlightBorder = theme.getColor(_platform_theme_common_colorRegistry_js__WEBPACK_IMPORTED_MODULE_13__["editorSelectionHighlightBorder"]);\r\n    if (selectionHighlightBorder) {\r\n        collector.addRule(`.monaco-editor .selectionHighlight { border: 1px ${theme.type === \'hc\' ? \'dotted\' : \'solid\'} ${selectionHighlightBorder}; box-sizing: border-box; }`);\r\n    }\r\n    const wordHighlightBorder = theme.getColor(editorWordHighlightBorder);\r\n    if (wordHighlightBorder) {\r\n        collector.addRule(`.monaco-editor .wordHighlight { border: 1px ${theme.type === \'hc\' ? \'dashed\' : \'solid\'} ${wordHighlightBorder}; box-sizing: border-box; }`);\r\n    }\r\n    const wordHighlightStrongBorder = theme.getColor(editorWordHighlightStrongBorder);\r\n    if (wordHighlightStrongBorder) {\r\n        collector.addRule(`.monaco-editor .wordHighlightStrong { border: 1px ${theme.type === \'hc\' ? \'dashed\' : \'solid\'} ${wordHighlightStrongBorder}; box-sizing: border-box; }`);\r\n    }\r\n});\r\n\n\n//# sourceURL=webpack:///./node_modules/monaco-editor/esm/vs/editor/contrib/wordHighlighter/wordHighlighter.js?')},"./node_modules/monaco-editor/esm/vs/editor/contrib/zoneWidget/zoneWidget.css":
/*!************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/contrib/zoneWidget/zoneWidget.css ***!
  \************************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */function(module,exports,__webpack_require__){eval('var api = __webpack_require__(/*! ../../../../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");\n            var content = __webpack_require__(/*! !../../../../../../css-loader/dist/cjs.js!./zoneWidget.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/editor/contrib/zoneWidget/zoneWidget.css");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === \'string\') {\n              content = [[module.i, content, \'\']];\n            }\n\nvar options = {};\n\noptions.insert = "head";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nmodule.exports = content.locals || {};\n\n//# sourceURL=webpack:///./node_modules/monaco-editor/esm/vs/editor/contrib/zoneWidget/zoneWidget.css?')},"./node_modules/monaco-editor/esm/vs/platform/actions/browser/menuEntryActionViewItem.css":
/*!************************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/platform/actions/browser/menuEntryActionViewItem.css ***!
  \************************************************************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */function(module,exports,__webpack_require__){eval('var api = __webpack_require__(/*! ../../../../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");\n            var content = __webpack_require__(/*! !../../../../../../css-loader/dist/cjs.js!./menuEntryActionViewItem.css */ "./node_modules/css-loader/dist/cjs.js!./node_modules/monaco-editor/esm/vs/platform/actions/browser/menuEntryActionViewItem.css");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === \'string\') {\n              content = [[module.i, content, \'\']];\n            }\n\nvar options = {};\n\noptions.insert = "head";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nmodule.exports = content.locals || {};\n\n//# sourceURL=webpack:///./node_modules/monaco-editor/esm/vs/platform/actions/browser/menuEntryActionViewItem.css?')}}]);