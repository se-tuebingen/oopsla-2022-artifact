{"0": {
    "doc": "Top.SystemC.CaptureSets",
    "title": "Top.SystemC.CaptureSets",
    "content": "Support here for Capture Sets, a.k.a a record of free and bound variables tracking which variables are captured by a particualar type. ************************************************** Definition of Capture Sets ************************************************** A captureset -- a pair of free variables and bound variables. Inductive cap : Type := &nbsp;&nbsp;| cset_set : atoms → nats → labels → cap. ************************************************** Constructors ************************************************** Definition empty_cset := cset_set {} {}N {}L. The empty set may be written similarly to informal practice. Notation &quot;{}C\" := &nbsp;&nbsp;empty_cset : metatheory_scope. Singletons Definition cset_fvar (a : atom) := &nbsp;&nbsp;(cset_set (AtomSet.F.singleton a) NatSet.F.empty LabelSet.F.empty). Definition cset_bvar (k : nat) := &nbsp;&nbsp;(cset_set AtomSet.F.empty (NatSet.F.singleton k) LabelSet.F.empty). Definition cset_lvar (a : label) := &nbsp;&nbsp;(cset_set AtomSet.F.empty NatSet.F.empty (LabelSet.F.singleton a)). Definition from_labels (ls : labels) := &nbsp;&nbsp;(cset_set AtomSet.F.empty NatSet.F.empty ls). ************************************************** Selectors ************************************************** Definition cset_fvars (c : cap) : atoms := &nbsp;&nbsp;match c with &nbsp;&nbsp;| cset_set A N R ⇒ A &nbsp;&nbsp;end. Definition cset_bvars (c : cap) : nats := &nbsp;&nbsp;match c with &nbsp;&nbsp;| cset_set A N R ⇒ N &nbsp;&nbsp;end. Definition cset_lvars (c : cap) : labels := &nbsp;&nbsp;match c with &nbsp;&nbsp;| cset_set A N R ⇒ R &nbsp;&nbsp;end. ************************************************** Operations ************************************************** (*&nbsp;Definition&nbsp;cset_lvar&nbsp;(l&nbsp;:&nbsp;atom)&nbsp;:= &nbsp;&nbsp;(cset_set&nbsp;AtomSet.F.empty&nbsp;NatSet.F.empty&nbsp;(AtomSet.F.singleton&nbsp;l)).&nbsp;*) Predicates for determining if a capture set explicity references a variable -- used for determining if a capture set is well formed. Don't use these predicates for determining if a capture set captures a variable, as one needs to also test cset_universal. Definition cset_references_bvar (k : nat) (c : cap) := &nbsp;&nbsp;NatSet.F.In k (cset_bvars c). Definition cset_references_fvar (a : atom) (c : cap) := &nbsp;&nbsp;AtomSet.F.In a (cset_fvars c). Definition cset_references_lvar (a : label) (c : cap) := &nbsp;&nbsp;LabelSet.F.In a (cset_lvars c). Definition cset_references_bvar_dec (k : nat) (c : cap) := &nbsp;&nbsp;NatSet.F.mem k (cset_bvars c). Definition cset_references_fvar_dec (a : atom) (c : cap) := &nbsp;&nbsp;AtomSet.F.mem a (cset_fvars c). Definition cset_references_lvar_dec (a : label) (c : cap) := &nbsp;&nbsp;LabelSet.F.mem a (cset_lvars c). Definition cset_remove_bvar (k : nat) (c : cap) : cap := &nbsp;&nbsp;cset_set (cset_fvars c) (NatSet.F.remove k (cset_bvars c)) (cset_lvars c). Definition cset_remove_fvar (a : atom) (c : cap) : cap := &nbsp;&nbsp;cset_set (AtomSet.F.remove a (cset_fvars c)) (cset_bvars c) (cset_lvars c). Capture set unions are what you'd expect. Definition cset_union (c1 c2 : cap) : cap := &nbsp;&nbsp;cset_set &nbsp;&nbsp;&nbsp;&nbsp;(AtomSet.F.union (cset_fvars c1) (cset_fvars c2)) &nbsp;&nbsp;&nbsp;&nbsp;(NatSet.F.union (cset_bvars c1) (cset_bvars c2)) &nbsp;&nbsp;&nbsp;&nbsp;(LabelSet.F.union (cset_lvars c1) (cset_lvars c2)). Definition cset_subset_dec (C D : cap) := &nbsp;&nbsp;AtomSet.F.subset (cset_fvars C) (cset_fvars D) &nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; NatSet.F.subset (cset_bvars C) (cset_bvars D) &nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; LabelSet.F.subset (cset_lvars C) (cset_lvars D). ************************************************** Logical Predicates ************************************************** Definition cset_empty (c : cap) : Prop := &nbsp;&nbsp;AtomSet.F.Empty (cset_fvars c) ∧ NatSet.F.Empty (cset_bvars c) ∧ LabelSet.F.Empty (cset_lvars c). Definition cset_subset_prop (c : cap) (d : cap) : Prop := &nbsp;&nbsp;AtomSet.F.Subset (cset_fvars c) (cset_fvars d) &nbsp;&nbsp;&nbsp;&nbsp;∧ NatSet.F.Subset (cset_bvars c) (cset_bvars d) &nbsp;&nbsp;&nbsp;&nbsp;∧ LabelSet.F.Subset (cset_lvars c) (cset_lvars d). ************************************************** Properties ************************************************** Section Props. &nbsp;&nbsp;Variable x y a f : atom. &nbsp;&nbsp;Variable l m : label. &nbsp;&nbsp;Variable A A1 A2 : atoms. &nbsp;&nbsp;Variable R R1 R2 : labels. &nbsp;&nbsp;Variable k n : nat. &nbsp;&nbsp;Variable N N1 N2 : nats. &nbsp;&nbsp;Variable C D C1 C2 C3 : cap. &nbsp;&nbsp;Lemma cset_bvar_mem_iff : &nbsp;&nbsp;&nbsp;&nbsp;cset_references_bvar k C ↔ cset_references_bvar_dec k C = true. &nbsp;&nbsp;Lemma cset_fvar_mem_iff : &nbsp;&nbsp;&nbsp;&nbsp;cset_references_fvar a C ↔ cset_references_fvar_dec a C = true. &nbsp;&nbsp;Lemma cset_lvar_mem_iff : &nbsp;&nbsp;&nbsp;&nbsp;cset_references_lvar l C ↔ cset_references_lvar_dec l C = true. &nbsp;&nbsp;Lemma cset_bvar_not_mem_iff : &nbsp;&nbsp;&nbsp;&nbsp;¬ cset_references_bvar k C ↔ cset_references_bvar_dec k C = false. &nbsp;&nbsp;Lemma cset_fvar_not_mem_iff : &nbsp;&nbsp;&nbsp;&nbsp;¬ cset_references_fvar a C ↔ cset_references_fvar_dec a C = false. &nbsp;&nbsp;Lemma cset_lvar_not_mem_iff : &nbsp;&nbsp;&nbsp;&nbsp;¬ cset_references_lvar l C ↔ cset_references_lvar_dec l C = false. &nbsp;&nbsp;Lemma fvars_1 : cset_fvars (cset_set A N R) = A. &nbsp;&nbsp;Lemma bvars_1 : cset_bvars (cset_set A N R) = N. &nbsp;&nbsp;Lemma lvars_1 : cset_lvars (cset_set A N R) = R. &nbsp;&nbsp;Lemma fvars_union_1 : cset_fvars (cset_union C D) = AtomSet.F.union (cset_fvars C) (cset_fvars D). &nbsp;&nbsp;Lemma bvars_union_1 : cset_bvars (cset_union C D) = NatSet.F.union (cset_bvars C) (cset_bvars D). &nbsp;&nbsp;Lemma lvars_union_1 : cset_lvars (cset_union C D) = LabelSet.F.union (cset_lvars C) (cset_lvars D). &nbsp;&nbsp;Lemma remove_fvar_1 : cset_remove_fvar x (cset_set A N R) = (cset_set (AtomSet.F.remove x A) N R). &nbsp;&nbsp;Lemma remove_bvar_1 : cset_remove_bvar k (cset_set A N R) = (cset_set A (NatSet.F.remove k N) R). &nbsp;&nbsp;Lemma mem_bvar_1 : cset_references_bvar k C → cset_references_bvar_dec k C = true. &nbsp;&nbsp;Lemma mem_bvar_2 : cset_references_bvar_dec k C = true → cset_references_bvar k C. &nbsp;&nbsp;Lemma mem_fvar_1 : cset_references_fvar a C → cset_references_fvar_dec a C = true. &nbsp;&nbsp;Lemma mem_fvar_2 : cset_references_fvar_dec a C = true → cset_references_fvar a C. &nbsp;&nbsp;Lemma mem_lvar_1 : cset_references_lvar l C → cset_references_lvar_dec l C = true. &nbsp;&nbsp;Lemma mem_lvar_2 : cset_references_lvar_dec l C = true → cset_references_lvar l C. &nbsp;&nbsp;Lemma In_bvar_1 : k = n → cset_references_bvar k C → cset_references_bvar n C. &nbsp;&nbsp;Lemma In_fvar_1 : a = f → cset_references_fvar a C → cset_references_fvar f C. &nbsp;&nbsp;Lemma In_lvar_1 : l = m → cset_references_lvar l C → cset_references_lvar m C. &nbsp;&nbsp;Lemma Is_empty : cset_empty empty_cset. &nbsp;&nbsp;Lemma union_fvar_1 : cset_references_fvar x (cset_union C D) → cset_references_fvar x C ∨ cset_references_fvar x D. &nbsp;&nbsp;Lemma union_fvar_2 : cset_references_fvar x C → cset_references_fvar x (cset_union C D). &nbsp;&nbsp;Lemma union_fvar_3 : cset_references_fvar x D → cset_references_fvar x (cset_union C D). &nbsp;&nbsp;Lemma union_bvar_1 : cset_references_bvar k (cset_union C D) → cset_references_bvar k C ∨ cset_references_bvar k D. &nbsp;&nbsp;Lemma union_bvar_2 : cset_references_bvar k C → cset_references_bvar k (cset_union C D). &nbsp;&nbsp;Lemma union_bvar_3 : cset_references_bvar k D → cset_references_bvar k (cset_union C D). &nbsp;&nbsp;Lemma union_lvar_1 : cset_references_lvar l (cset_union C D) → cset_references_lvar l C ∨ cset_references_lvar l D. &nbsp;&nbsp;Lemma union_lvar_2 : cset_references_lvar l C → cset_references_lvar l (cset_union C D). &nbsp;&nbsp;Lemma union_lvar_3 : cset_references_lvar l D → cset_references_lvar l (cset_union C D). &nbsp;&nbsp;Lemma union_sub_1 : cset_subset_prop C D → cset_union D C = D. &nbsp;&nbsp;Lemma union_sub_2 : cset_subset_prop C D → D = cset_union D C. &nbsp;&nbsp;Lemma union_subset_distribute_1 : cset_subset_prop C1 C2 → cset_subset_prop (cset_union C1 D) (cset_union C2 D). End Props. (*&nbsp;TODO&nbsp;defined&nbsp;here&nbsp;to&nbsp;avoid&nbsp;all&nbsp;the&nbsp;implicit&nbsp;arguments&nbsp;*) Lemma subset_lvar_1 : ∀ R C l, &nbsp;&nbsp;cset_subset_prop R C → cset_references_lvar l R → cset_references_lvar l C. Lemma from_empty_labels_is_empty : &nbsp;&nbsp;(from_labels {}L) = {}C. (*&nbsp;Some&nbsp;subset&nbsp;properties&nbsp;*) Lemma subset_refl : ∀ C, &nbsp;&nbsp;cset_subset_prop C C. Lemma subset_union_left : ∀ C1 C2, &nbsp;&nbsp;cset_subset_prop C1 (cset_union C1 C2). Lemma subset_union_right : ∀ C1 C2, &nbsp;&nbsp;cset_subset_prop C2 (cset_union C1 C2). Lemma subset_trans : ∀ A B C, &nbsp;&nbsp;cset_subset_prop A B → cset_subset_prop B C → cset_subset_prop A C. (***********) (*&nbsp;Tactics&nbsp;*) (***********) Lemma funion_empty_idempotent : ∀ xs, &nbsp;&nbsp;&nbsp;&nbsp;NatSet.F.union xs {}N = xs. Lemma empty_funion_idempotent : ∀ xs, &nbsp;&nbsp;&nbsp;&nbsp;NatSet.F.union {}N xs = xs. Lemma union_empty_idempotent : ∀ xs, &nbsp;&nbsp;&nbsp;&nbsp;AtomSet.F.union xs {} = xs. Lemma empty_union_idempotent : ∀ xs, &nbsp;&nbsp;&nbsp;&nbsp;AtomSet.F.union {} xs = xs. Lemma lunion_empty_idempotent : ∀ xs, &nbsp;&nbsp;&nbsp;&nbsp;LabelSet.F.union xs {}L = xs. Lemma empty_lunion_idempotent : ∀ xs, &nbsp;&nbsp;&nbsp;&nbsp;LabelSet.F.union {}L xs = xs. Lemma cunion_empty_idempotent : ∀ xs, &nbsp;&nbsp;&nbsp;&nbsp;cset_union xs {}C = xs. Lemma empty_cunion_idempotent : ∀ xs, &nbsp;&nbsp;&nbsp;&nbsp;cset_union {}C xs = xs. Tactic Notation \"csetsimpl\" \"in\" hyp(H) := csetsimplIn H. ************************************************** Locally Namelesss ************************************************** Definition capt (c : cap) : Prop := NatSet.F.Empty (cset_bvars c). Lemma singleton_closed : ∀ f, &nbsp;&nbsp;capt (cset_fvar f). Lemma capt_empty_bvar : ∀ A N R, &nbsp;&nbsp;capt (cset_set A N R) → &nbsp;&nbsp;N = {}N. Opening a capture set with a bound variable dk → c Definition open_cset (k : nat) (c : cap) (d : cap) : cap := &nbsp;&nbsp;if cset_references_bvar_dec k d then &nbsp;&nbsp;&nbsp;&nbsp;cset_union c (cset_remove_bvar k d) &nbsp;&nbsp;else &nbsp;&nbsp;&nbsp;&nbsp;d. Substituting a capture set with a free variable da → c Definition subst_cset (a : atom) (c : cap) (d: cap) : cap := &nbsp;&nbsp;if cset_references_fvar_dec a d then &nbsp;&nbsp;&nbsp;&nbsp;cset_union c (cset_remove_fvar a d) &nbsp;&nbsp;else &nbsp;&nbsp;&nbsp;&nbsp;d. Lemma subst_over_subset : ∀ C1 C2 D x, &nbsp;&nbsp;cset_subset_prop C1 C2 → &nbsp;&nbsp;cset_subset_prop (subst_cset x D C1) (subst_cset x D C2). Lemma subst_subset_intro : ∀ C1 C2 x, &nbsp;&nbsp;(*&nbsp;C1&nbsp;is&nbsp;closed&nbsp;*) &nbsp;&nbsp;capt C1 → &nbsp;&nbsp;cset_subset_prop (cset_fvar x) C2 → &nbsp;&nbsp;cset_subset_prop C1 (subst_cset x C1 C2). Lemma subst_cset_union : ∀ x D C1 C2, &nbsp;&nbsp;subst_cset x D (cset_union C1 C2) = (cset_union (subst_cset x D C1) (subst_cset x D C2)). Lemma subst_cset_singleton : ∀ x C, &nbsp;&nbsp;subst_cset x C (cset_fvar x) = C. Lemma subst_cset_fresh : ∀ x C1 C2, &nbsp;&nbsp;x `notin` (cset_fvars C1) → &nbsp;&nbsp;C1 = subst_cset x C2 C1. Lemma singleton_lvar : ∀ l, &nbsp;&nbsp;cset_references_lvar l (cset_lvar l). Lemma subst_cset_fresh_id : ∀ x X C, &nbsp;&nbsp;x ≠ X → &nbsp;&nbsp;(subst_cset X C (cset_fvar x)) = (cset_fvar x). Lemma subst_cset_union_id : ∀ x y D C1, &nbsp;&nbsp;x ≠ y → &nbsp;&nbsp;subst_cset x D (cset_union C1 (cset_fvar y)) = (cset_union (subst_cset x D C1) (cset_fvar y)). Lemma subst_cset_lvar : ∀ x C l R, &nbsp;&nbsp;cset_references_lvar l R → &nbsp;&nbsp;cset_references_lvar l (subst_cset x C R). Lemma subst_cset_lvar_idempotent : ∀ x C l, &nbsp;&nbsp;(subst_cset x C (cset_lvar l)) = (cset_lvar l). Lemma open_cset_capt : ∀ i C c, &nbsp;&nbsp;capt C → &nbsp;&nbsp;C = open_cset i c C. Lemma subst_cc_intro_rec : ∀ X (C : cap) U k, &nbsp;&nbsp;X `notin` (cset_fvars C) → &nbsp;&nbsp;open_cset k U C = subst_cset X U (open_cset k (cset_fvar X) C). (*&nbsp;unfold&nbsp;subst_cb,&nbsp;subst_cset,&nbsp;cset_references_fvar_dec,&nbsp;cset_fvar,&nbsp;cset_remove_fvar,&nbsp;cset_union.&nbsp;&nbsp; &nbsp;&nbsp;destruct&nbsp;C1;&nbsp;destruct_set_mem&nbsp;X&nbsp;(singleton&nbsp;x)...&nbsp;fsetdec.&nbsp;*) Lemma open_cset_rec_capt_aux : ∀ c j V i U, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;capt V → &nbsp;&nbsp;(*&nbsp;TODO&nbsp;probably,&nbsp;we&nbsp;also&nbsp;want&nbsp;disjointness&nbsp;of&nbsp;labels&nbsp;here?&nbsp;*) &nbsp;&nbsp;(cset_fvars V) `disjoint` (cset_fvars U) → &nbsp;&nbsp;labels_disjoint (cset_lvars V) (cset_lvars U) → &nbsp;&nbsp;open_cset j V c = open_cset i U (open_cset j V c) → &nbsp;&nbsp;c = open_cset i U c. Lemma subst_cset_open_cset_rec : ∀ x k C1 C2 D, &nbsp;&nbsp;capt C1 → &nbsp;&nbsp;subst_cset x C1 (open_cset k C2 D) = open_cset k (subst_cset x C1 C2) (subst_cset x C1 D). ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.CaptureSets.html",
    "relUrl": "/proofs/Top.SystemC.CaptureSets.html"
  },"1": {
    "doc": "Top.SystemC.Definitions",
    "title": "Top.SystemC.Definitions",
    "content": "This file contains the definitions for System C. We include snippets of the paper as images to facilitate comparison. ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Definitions.html",
    "relUrl": "/proofs/Top.SystemC.Definitions.html"
  },"2": {
    "doc": "Top.SystemC.Definitions",
    "title": "Table of Contents",
    "content": "Syntax . | Syntax of Types | Syntax of Terms | . Environments and Signatures Typing . | Expression Typing | Block Typing | Statement Typing | . Operational Semantics . | Values | Machine Redexes | Trivial Reduction | Stacks, Contexts, and their Typing | Abstract Machine | Machine Reduction | Abstract Machine Typing | . ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Definitions.html",
    "relUrl": "/proofs/Top.SystemC.Definitions.html"
  },"3": {
    "doc": "Top.SystemC.Definitions",
    "title": "  Syntax",
    "content": "The definitions here reflect the definitions in Figure 1 from the paper. Please note that we base our proofs on a locally nameless representation. In consequence, there are always two types of variables, free variables (such as typ_fvar) and locally bound variables (such as typ_bvar). Capture sets cap are records, containing sets of free variables, sets of bound variables, and sets of labels. ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Definitions.html",
    "relUrl": "/proofs/Top.SystemC.Definitions.html"
  },"4": {
    "doc": "Top.SystemC.Definitions",
    "title": " Syntax of Types",
    "content": "Here, we define the syntax of types, as defined in Figure 1 in the paper. Value Types . Inductive vtyp : Type := &nbsp;&nbsp;| typ_base : vtyp (*&nbsp;base&nbsp;types&nbsp;*) &nbsp;&nbsp;| typ_capt : btyp → cap → vtyp (*&nbsp;boxed&nbsp;block&nbsp;types&nbsp;*) &nbsp;&nbsp;| typ_fvar : atom → vtyp (*&nbsp;(free)&nbsp;value-type&nbsp;variables&nbsp;*) &nbsp;&nbsp;| typ_bvar : nat → vtyp (*&nbsp;(bound)&nbsp;value-type&nbsp;variables&nbsp;*) Differences to the paper . In the mechanization, we also additionally support value-type polymorphism. Hence, the constructors for type variables (typ_bvar and typ_fvar), which are not present in the paper. Also, we only include one base type typ_base instead of separate base types (as in the paper). Block Types . with btyp : Type := &nbsp;&nbsp;| typ_vfun : vtyp → vtyp → btyp (*&nbsp;function&nbsp;types&nbsp;with&nbsp;value&nbsp;arguments&nbsp;*) &nbsp;&nbsp;| typ_bfun : btyp → vtyp → btyp (*&nbsp;function&nbsp;types&nbsp;with&nbsp;tracked&nbsp;block&nbsp;arguments&nbsp;*) &nbsp;&nbsp;| typ_tfun : btyp → btyp (*&nbsp;type&nbsp;abstractions&nbsp;*) &nbsp;&nbsp;| typ_exc : vtyp → vtyp → btyp (*&nbsp;capability&nbsp;types&nbsp;*) . Differences to the paper . In the paper, we formalize multi-arity function types. Since this is akward to work with in Coq, here, we only mechanize single arity function types. We include two type constructors, typ_vfun for function types with value arguments (e.g. Int → Int), and typ_bfun for function types with block arguments that are always tracked (e.g. (f : Int → Int) → Int). Since in the calculus function arguments are independent of each other, we do not expect any theoretical complications in the setting of a full multi-arity representation. Type constructor typ_exc T1 T2 is a block type that represents capabilities with an effect signature from T1 to T2. To simplify the presentation, in the paper, this is represented as a function type T1 → T2 as for instance can be seen in rule TRY in Figure 2. ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Definitions.html",
    "relUrl": "/proofs/Top.SystemC.Definitions.html"
  },"5": {
    "doc": "Top.SystemC.Definitions",
    "title": " Syntax of Terms",
    "content": "In the following, we define the syntax of expressions, statements, and blocks. Expressions . Inductive exp : Type := &nbsp;&nbsp;| exp_bvar : nat → exp (*&nbsp;(bound)&nbsp;expression&nbsp;variables&nbsp;*) &nbsp;&nbsp;| exp_fvar : atom → exp (*&nbsp;(free)&nbsp;expression&nbsp;variables&nbsp;*) &nbsp;&nbsp;| exp_const : exp (*&nbsp;primitives&nbsp;*) &nbsp;&nbsp;| exp_box : cap → blk → exp (*&nbsp;box&nbsp;introduction&nbsp;*) Differences to the paper . Besides only having one primitive value, expressions are precisely as in the paper. Statements . with stm : Type := &nbsp;&nbsp;| stm_ret : exp → stm (*&nbsp;returning&nbsp;*) &nbsp;&nbsp;| stm_val : vtyp → stm → stm → stm (*&nbsp;sequencing&nbsp;*) &nbsp;&nbsp;| stm_def : cap → btyp → blk → stm → stm (*&nbsp;block&nbsp;definition&nbsp;*) &nbsp;&nbsp;| stm_vapp : blk → exp → stm (*&nbsp;block&nbsp;application&nbsp;(to&nbsp;value&nbsp;arguments)&nbsp;*) &nbsp;&nbsp;| stm_bapp : blk → cap → blk → stm (*&nbsp;block&nbsp;application&nbsp;(to&nbsp;block&nbsp;arguments)&nbsp;*) &nbsp;&nbsp;| stm_try : cap → vtyp → vtyp → stm → stm → stm (*&nbsp;handlers&nbsp;*) &nbsp;&nbsp;| stm_throw : blk → exp → stm (*&nbsp;performing&nbsp;an&nbsp;effect&nbsp;*) &nbsp;&nbsp;| stm_reset : label → cap → stm → stm → stm (*&nbsp;runtime&nbsp;delimiter&nbsp;*) Differences to the paper . Similar to the syntax of types, in the mechanization we have two different forms of application (instead of multi-arity). stm_vapp takes the block to call and an expression (value argument), while stm_bapp takes the block to call, a capture annotation (to avoid implementing capture inference in the mechanization), and a block argument. Similar to block application for blocks the handler construct stm_try C T1 T2 s1 s2 models statements of the form try { f : Exc T1 T2 =&gt; s1 } with { (x: T1, k: (T2 =&gt; R @ C)) =&gt; s2 } That is, the capture annotion C corresponds to the capture set on the continuation k. This can also be seen in Figure 2, rule TRY, but without an explicit annotation on the stm_try. Types T1 and T2 are also explicitly annotated, which is not the case in the paper. Like in Figure 3 of the paper, we also include the syntax for runtime delimiters stm_reset C T1 T2 that model statements of the form #_l { s1 } with { (x: T1, k: (T2 =&gt; R @ C)) =&gt; s2 } Blocks . with blk : Type := &nbsp;&nbsp;| blk_bvar : nat → blk (*&nbsp;(bound)&nbsp;block&nbsp;variables&nbsp;*) &nbsp;&nbsp;| blk_fvar : atom → blk (*&nbsp;(free)&nbsp;block&nbsp;variables&nbsp;*) &nbsp;&nbsp;| blk_vabs : vtyp → stm → blk (*&nbsp;block&nbsp;implementation&nbsp;(with&nbsp;value&nbsp;argument)&nbsp;*) &nbsp;&nbsp;| blk_babs : btyp → stm → blk (*&nbsp;block&nbsp;implementation&nbsp;(with&nbsp;block&nbsp;argument)&nbsp;*) &nbsp;&nbsp;| blk_unbox : exp → blk (*&nbsp;box&nbsp;elimination&nbsp;*) &nbsp;&nbsp;| blk_tabs : blk → blk (*&nbsp;value&nbsp;type&nbsp;abstraction&nbsp;*) &nbsp;&nbsp;| blk_tapp : blk → vtyp → blk (*&nbsp;value&nbsp;type&nbsp;application&nbsp;*) &nbsp;&nbsp;| blk_handler : label → blk (*&nbsp;runtime&nbsp;capability&nbsp;*) . Differences to the paper . Again, as for statements and block types, we have two different forms of abstraction. blk_vabs to abstract over values and blk_babs to abstract over (tracked) blocks. In addition to the paper, we also include term-level syntax to abstract over value types blk_tabs and instantiate polymorphic blocks with value types blk_tapp. The constructor blk_handler corresponds to the cap_l form in the paper and represents runtime capabilities. ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Definitions.html",
    "relUrl": "/proofs/Top.SystemC.Definitions.html"
  },"6": {
    "doc": "Top.SystemC.Definitions",
    "title": " Environments and Signatures",
    "content": " ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Definitions.html",
    "relUrl": "/proofs/Top.SystemC.Definitions.html"
  },"7": {
    "doc": "Top.SystemC.Definitions",
    "title": "Environments",
    "content": "Like in the paper, we use a single environment for value, block, and type abstraction. We formalize environments by representing them as association lists (lists of pairs of keys and values) whose keys are atoms. Instead of having two forms of block bindings, we index them by a coeffect defined below: Inductive coeffect : Type := &nbsp;&nbsp;| tracked : coeffect &nbsp;&nbsp;| capture : cap → coeffect. Basing our mechanization on an existing locally nameless proof, we reuse the infrastructure for environments. Util.Metatheory, Util.Environment, and Util.Signatures libraries provide functions, predicates, tactics, notations and lemmas that simplify working with environments. The Util.Environment library treats environments as lists of type list (atom × A). Since environments map atoms, the type A should encode whether a particular binding is a typing or region assumption. Thus, we instantiate A with the type binding, defined below Inductive binding : Type := &nbsp;&nbsp;(*&nbsp;&nbsp;x&nbsp;:&nbsp;T&nbsp;&nbsp;&nbsp;*) &nbsp;&nbsp;| bind_val : vtyp → binding &nbsp;&nbsp;| bind_blk : btyp → coeffect → binding &nbsp;&nbsp;(*&nbsp;X&nbsp;*) &nbsp;&nbsp;| bind_typ : binding. Notation env := (list (atom × binding)). Notation empty := (@nil (atom × binding)). ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Definitions.html",
    "relUrl": "/proofs/Top.SystemC.Definitions.html"
  },"8": {
    "doc": "Top.SystemC.Definitions",
    "title": "Signatures",
    "content": "As a proof device, each runtime label (Figure 3 in the paper) is associated with a signature (that is the argument type and the result type of an effect operation). The tooling in Util.Signatures is a plain copy of Util.Environment. Inductive signature : Type := &nbsp;&nbsp;(*&nbsp;label&nbsp;:&nbsp;T1&nbsp;(param&nbsp;type)&nbsp;T&nbsp;(result&nbsp;type)*) &nbsp;&nbsp;| bind_sig : vtyp → vtyp → signature. Notation sig := (list (label × signature)). ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Definitions.html",
    "relUrl": "/proofs/Top.SystemC.Definitions.html"
  },"9": {
    "doc": "Top.SystemC.Definitions",
    "title": " Typing",
    "content": "Like in the paper, we model typing as three mutually inductive relations. Note that we use notation C |= D (pronounced \"C admits D\") instead of subset inclusion D ≤ C as it is used in the paper. Notation &quot;C |= D\" := (cset_subset_prop D C) (at level 68). Reserved Notation &quot;E ; Q |-exp e ~: T\" (at level 70, Q at next level). Reserved Notation &quot;E @ R ; Q |-blk b ~: S\" (at level 70, R at next level, Q at next level). Reserved Notation &quot;E @ R ; Q |-stm s ~: T\" (at level 70, R at next level, Q at next level). Note on presentation: we use Gamma for E, and Xi for Q, both in the paper and in coqdoc. ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Definitions.html",
    "relUrl": "/proofs/Top.SystemC.Definitions.html"
  },"10": {
    "doc": "Top.SystemC.Definitions",
    "title": " Expression Typing",
    "content": "Inductive etyping : env → sig → exp → vtyp → Prop := &nbsp;&nbsp;| typing_base : ∀ E Q, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_env E → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_sig Q → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E ; Q |-exp exp_const ~: typ_base &nbsp;&nbsp;| typing_evar : ∀ E Q x T, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_env E → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_sig Q → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds x (bind_val T) E → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E ; Q |-exp (exp_fvar x) ~: T &nbsp;&nbsp;| typing_box : ∀ E Q (C : cap) S1 b, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_cap E C → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(E @ C ; Q |-blk b ~: S1) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E ; Q |-exp (exp_box C b) ~: (typ_capt S1 C) where &quot;E ; Q |-exp e ~: T\" := (etyping E Q e T) Differences to the paper . The three rules directly correspond to rules LIT, VAR, and BOXINTRO in the paper. As can be seen (all) typing judgements in Coq make wellformedness conditions explicit, which are left implicit in the paper. ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Definitions.html",
    "relUrl": "/proofs/Top.SystemC.Definitions.html"
  },"11": {
    "doc": "Top.SystemC.Definitions",
    "title": " Block Typing",
    "content": "with btyping : env → cap → sig → blk → btyp → Prop := &nbsp;&nbsp;| typing_bvar_tracked : ∀ E R Q f S1, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_env E → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_sig Q → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_cap E R → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds f (bind_blk S1 tracked) E → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R |= cset_fvar f → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-blk (blk_fvar f) ~: S1 &nbsp;&nbsp;| typing_bvar_capture : ∀ E R Q f S1 (C : cap), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_env E → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_sig Q → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_cap E R → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R |= C → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds f (bind_blk S1 (capture C)) E → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-blk (blk_fvar f) ~: S1 &nbsp;&nbsp;| typing_unbox : ∀ E R Q e S1 C, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E ; Q |-exp e ~: (typ_capt S1 C) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_cap E R → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R |= C → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-blk (blk_unbox e) ~: S1 &nbsp;&nbsp;| typing_vabs : ∀ L E R Q T1 s T2, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(∀ x : atom, x `notin` L → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;([(x, bind_val T1)] ++ E) @ R ; Q |-stm (open_es s x) ~: T2) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-blk (blk_vabs T1 s) ~: (typ_vfun T1 T2) &nbsp;&nbsp;| typing_babs : ∀ L E R Q S1 s T2, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(∀ x : atom, x `notin` L → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;([(x, bind_blk S1 tracked)] ++ E) @ cset_union R (cset_fvar x) ; Q |-stm (open_cs s x (cset_fvar x)) ~: (open_cvt T2 (cset_fvar x))) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-blk (blk_babs S1 s) ~: (typ_bfun S1 T2) Differences to the paper . Note that we build in subsumption on blocks (rule BSUB in the paper) into the rules as additional premises, instead of having one additional rule. This allows us to omit having to prove inversion of subeffecting. Instead, in SystemC.Substitution.btyping_weaken_restriction we show that rule SUB is admissible (and similar for subsumption on statements). In the paper, we use C for capture sets, but in the mechanization we speak of restrictions and use the metavariable R Rules from the paper map in the following way to the mechanization: . | TRACKED maps to typing_bvar_tracked | TRANSPARENT maps to typing_bvar_capture | BLOCK maps to typing_vabs and typing_babs | BOXELIM maps to typing_unbox | . Additional Rules for Type Polymorphism . &nbsp;&nbsp;| typing_tabs : ∀ L E R Q s T, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(∀ X : atom, X `notin` L → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;([(X, bind_typ)] ++ E) @ R ; Q |-blk (open_tb s X) ~: (open_tbt T X)) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-blk (blk_tabs s) ~: (typ_tfun T) &nbsp;&nbsp;| typing_tapp : ∀ E R Q s T T1, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_vtyp E T1 → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-blk s ~: (typ_tfun T) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-blk (blk_tapp s T1) ~: (open_tbt T T1) Typing Effect Handlers . Like in the other rules, we bake subsumption into this rule. &nbsp;&nbsp;| typing_handler : ∀ E R Q l T1 T, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_env E → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_sig Q → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_cap E R → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_vtyp E T → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;We&nbsp;are&nbsp;allowed&nbsp;to&nbsp;use&nbsp;l:&nbsp;*) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cset_references_lvar l R → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;It&nbsp;has&nbsp;the&nbsp;correct&nbsp;type&nbsp;*) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Signatures.binds l (bind_sig T1 T) Q → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-blk blk_handler l ~: (typ_exc T1 T) where &quot;E @ R ; Q |-blk b ~: S\" := (btyping E R Q b S) ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Definitions.html",
    "relUrl": "/proofs/Top.SystemC.Definitions.html"
  },"12": {
    "doc": "Top.SystemC.Definitions",
    "title": " Statement Typing",
    "content": "with styping : env → cap → sig → stm → vtyp → Prop := &nbsp;&nbsp;| typing_ret : ∀ E R Q e T, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E ; Q |-exp e ~: T → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_cap E R → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-stm (stm_ret e) ~: T &nbsp;&nbsp;| typing_val : ∀ L E R Q b s T1 T2, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-stm b ~: T1 → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(∀ x : atom, x `notin` L → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;([(x, bind_val T1)] ++ E) @ R ; Q |-stm (open_es s x) ~: T2) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-stm (stm_val T1 b s) ~: T2 &nbsp;&nbsp;| typing_def : ∀ L E R Q b s (C : cap) S1 T2, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_cap E C → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ C ; Q |-blk b ~: S1 → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;This&nbsp;is&nbsp;a&nbsp;transparent&nbsp;binding&nbsp;(not&nbsp;tracked),&nbsp;we&nbsp;do&nbsp;not&nbsp;open&nbsp;types.&nbsp;*) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(∀ x : atom, x `notin` L → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;([(x, bind_blk S1 (capture C))] ++ E) @ R ; Q |-stm (open_bs s x) ~: T2) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-stm (stm_def C S1 b s) ~: T2 &nbsp;&nbsp;| typing_vapp : ∀ E R Q b e T1 T2, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-blk b ~: (typ_vfun T1 T2) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E ; Q |-exp e ~: T1 → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-stm (stm_vapp b e) ~: T2 &nbsp;&nbsp;| typing_bapp : ∀ E R Q b1 b2 (C : cap) S1 T2, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R |= C → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_cap E C → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-blk b1 ~: (typ_bfun S1 T2) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ C ; Q |-blk b2 ~: S1 → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-stm (stm_bapp b1 C b2) ~: (open_cvt T2 C) Differences to the paper . The rules correspond to the paper with the following mapping: . | RET maps to typing_ret | VAL maps to typing_val | DEF maps to typing_def | APP maps to typing_vapp and typing_bapp In rule typing_val, for simplicity we do not compute the union, but instead require both restrictions to be the same. This does not affect expressivity, since we can always use subsumption. | . Typing Handling of Effects . &nbsp;&nbsp;| typing_try : ∀ L E R Q C b h T T1 T2, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R |= C → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_cap E C → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_cap E R → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;E,&nbsp;f&nbsp;:&nbsp;(Exc&nbsp;@&nbsp;{*})&nbsp;@&nbsp;C&nbsp;union&nbsp;f&nbsp;|-&nbsp;h&nbsp;:&nbsp;T&nbsp;*) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(∀ f : atom, f `notin` L → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;([(f, bind_blk (typ_exc T2 T1) tracked)] ++ E) @ (cset_union C (cset_fvar f)) ; Q &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|-stm (open_cs b f (cset_fvar f)) ~: T) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;E,&nbsp;x&nbsp;:&nbsp;T1,&nbsp;k&nbsp;:&nbsp;(T2&nbsp;-&gt;&nbsp;T&nbsp;@&nbsp;C)&nbsp;@&nbsp;C&nbsp;|-&nbsp;h&nbsp;:&nbsp;T&nbsp;*) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(∀ (v : atom), v `notin` L → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(∀ (f : atom), f `notin` (L `union` singleton v) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;([(f, bind_blk (typ_vfun T1 T) (capture C))] ++ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(v, bind_val T2)] ++ E) @ C ; Q &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|-stm (open_bs (open_es h v) f) ~: T)) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-stm (stm_try C T2 T1 b h) ~: T Differences to the paper . As mentioned above, handling statements are annotated with a capture set C. Also, we use the special type constructor typ_exc instead of a function type. Otherwise, the definition is a straightforward translation to Coq in locally nameless. The following rule for typing_reset is a variation of typing_try, not binding the capability anymore and with a singleton set {l} instead of C. &nbsp;&nbsp;| typing_reset : ∀ L E R Q C l b h T T1 T2, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R |= C → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_cap E C → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_cap E R → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;We&nbsp;require&nbsp;that&nbsp;the&nbsp;signature&nbsp;of&nbsp;l&nbsp;matches&nbsp;the&nbsp;type&nbsp;at&nbsp;the&nbsp;reset.&nbsp;*) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Signatures.binds l (bind_sig T2 T1) Q → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ (cset_union C (cset_lvar l)) ; Q |-stm b ~: T → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(∀ v : atom, v `notin` L → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(∀ f : atom, f `notin` (L `union` singleton v) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;([(f, bind_blk (typ_vfun T1 T) (capture C))] ++ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(v, bind_val T2)] ++ E) @ C ; Q &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|-stm (open_bs (open_es h v) f) ~: T)) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-stm (stm_reset l C b h) ~: T &nbsp;&nbsp;| typing_throw : ∀ E R Q b e T T1, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-blk b ~: (typ_exc T1 T) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E ; Q |-exp e ~: T1 → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-stm (stm_throw b e) ~: T where &quot;E @ R ; Q |-stm s ~: T\" := (styping E R Q s T). Since we use locally nameless, the definition of typing uses the binds relation from the Environment library (in the typing_var case) and cofinite quantification in the cases involving binders (e.g., typing_vabs, typing_tabs, ...). We have to define our own induction scheme to convince the termination checker Scheme etyping_mutind := Induction for etyping Sort Prop &nbsp;&nbsp;with styping_mutind := Induction for styping Sort Prop &nbsp;&nbsp;with btyping_mutind := Induction for btyping Sort Prop. ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Definitions.html",
    "relUrl": "/proofs/Top.SystemC.Definitions.html"
  },"13": {
    "doc": "Top.SystemC.Definitions",
    "title": " Operational Semantics",
    "content": "As described in the appendix of the paper, we mechanize the operational semantics in form of an abstract machine. However, the operational semantics is of a hybrid form: We only use the abstract machine semantics for statements and only if they affect the evaluation context / stack. For all other \"trivial\" reductions, we use a substitution based semantics with congruence rules. This separation makes it easier in the soundness proof to separate the \"interesting\" cases from the trivial ones. ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Definitions.html",
    "relUrl": "/proofs/Top.SystemC.Definitions.html"
  },"14": {
    "doc": "Top.SystemC.Definitions",
    "title": " Values",
    "content": "Values are defined in the paper in the appendix. Inductive evalue : exp → Prop := &nbsp;&nbsp;| value_const : &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evalue exp_const &nbsp;&nbsp;| value_box : ∀ C b, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bvalue b → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;capt C → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evalue (exp_box C b) with bvalue : blk → Prop := &nbsp;&nbsp;| value_vfun : ∀ T s, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;block (blk_vabs T s) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bvalue (blk_vabs T s) &nbsp;&nbsp;| value_bfun : ∀ S1 s, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;block (blk_babs S1 s) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bvalue (blk_babs S1 s) &nbsp;&nbsp;| value_tfun : ∀ s, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;block (blk_tabs s) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bvalue (blk_tabs s) &nbsp;&nbsp;| value_handler : ∀ l, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bvalue (blk_handler l). ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Definitions.html",
    "relUrl": "/proofs/Top.SystemC.Definitions.html"
  },"15": {
    "doc": "Top.SystemC.Definitions",
    "title": " Machine Redexes",
    "content": "Since we mechanize the operational semantics in terms of an abstract machine, we also define a predicate that describes when a statement can only be reduced in a larger context. Inductive machine_redex : stm → Prop := &nbsp;&nbsp;| redex_ret : ∀ e, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evalue e → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;machine_redex (stm_ret e) &nbsp;&nbsp;| redex_val : ∀ T b s, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;machine_redex (stm_val T b s) &nbsp;&nbsp;| redex_try : ∀ C T1 T b s, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;machine_redex (stm_try C T1 T b s) &nbsp;&nbsp;| redex_reset : ∀ l C b s, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;machine_redex (stm_reset l C b s) &nbsp;&nbsp;| redex_throw : ∀ l e, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evalue e → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;machine_redex (stm_throw (blk_handler l) e). ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Definitions.html",
    "relUrl": "/proofs/Top.SystemC.Definitions.html"
  },"16": {
    "doc": "Top.SystemC.Definitions",
    "title": " Trivial Reduction",
    "content": "Reserved Notation &quot;e1 --&gt;b e2\" (at level 69). Reserved Notation &quot;e1 --&gt;e e2\" (at level 69). Reserved Notation &quot;e1 --&gt;s e2\" (at level 69). Reduction of Blocks . Blocks can always be reduced regardless of the context. In fact, the only reduction is box-unbox elimination (bred_box) and block substitution (bred_box). Inductive bred : blk → blk → Prop := &nbsp;&nbsp;| bred_box : ∀ C b, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blk_unbox (exp_box C b) --&gt;b b &nbsp;&nbsp;| bred_tapp_cong : ∀ b b' T, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b --&gt;b b' → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blk_tapp b T --&gt;b blk_tapp b' T &nbsp;&nbsp;| bred_tapp : ∀ s T, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blk_tapp (blk_tabs s) T --&gt;b (open_tb s T) where &quot;b1 --&gt;b b2\" := (bred b1 b2). Reduction of Expressions . Reduction on expressions is even simpler. Only boxed blocks can be reduced at all. Inductive ered : exp → exp → Prop := &nbsp;&nbsp;| ered_box : ∀ C b b', &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b --&gt;b b' → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(exp_box C b) --&gt;e (exp_box C b') where &quot;e1 --&gt;e e2\" := (ered e1 e2). Reduction of Statements . Inductive sred : stm → stm → Prop := &nbsp;&nbsp;| sred_ret : ∀ e e', &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e --&gt;e e' → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stm_ret e --&gt;s stm_ret e' &nbsp;&nbsp;| sred_vapp_3 : ∀ T s e, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evalue e → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stm_vapp (blk_vabs T s) e --&gt;s (open_es s e) The remaining rules are congruences, omitted in the appendix of the paper. &nbsp;&nbsp;| sred_def_1 : ∀ C S1 b b' s, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b --&gt;b b' → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stm_def C S1 b s --&gt;s stm_def C S1 b' s &nbsp;&nbsp;| sred_def_2 : ∀ C S1 b s, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bvalue b → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stm_def C S1 b s --&gt;s (open_bs s b) &nbsp;&nbsp;| sred_vapp_1 : ∀ b b' e, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b --&gt;b b' → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stm_vapp b e --&gt;s stm_vapp b' e &nbsp;&nbsp;| sred_vapp_2 : ∀ b e e', &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e --&gt;e e' → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stm_vapp b e --&gt;s stm_vapp b e' &nbsp;&nbsp;| sred_bapp_1 : ∀ b1 b1' C b2, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b1 --&gt;b b1' → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stm_bapp b1 C b2 --&gt;s stm_bapp b1' C b2 &nbsp;&nbsp;| sred_bapp_2 : ∀ b1 C b2 b2', &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b2 --&gt;b b2' → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stm_bapp b1 C b2 --&gt;s stm_bapp b1 C b2' &nbsp;&nbsp;| sred_bapp_3 : ∀ S1 s C b2, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bvalue b2 → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stm_bapp (blk_babs S1 s) C b2 --&gt;s (open_cs s b2 C) &nbsp;&nbsp;| sred_throw_1 : ∀ b b' e, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b --&gt;b b' → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stm_throw b e --&gt;s stm_throw b' e &nbsp;&nbsp;| sred_throw_2 : ∀ b e e', &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bvalue b → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e --&gt;e e' → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stm_throw b e --&gt;s stm_throw b e' where &quot;b1 --&gt;s b2\" := (sred b1 b2) . ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Definitions.html",
    "relUrl": "/proofs/Top.SystemC.Definitions.html"
  },"17": {
    "doc": "Top.SystemC.Definitions",
    "title": " Stacks / Contexts",
    "content": "Inductive frame : Type := &nbsp;&nbsp;(*&nbsp;val&nbsp;_&nbsp;:&nbsp;T&nbsp;=&nbsp;;&nbsp;s&nbsp;&nbsp;*) &nbsp;&nbsp;| K : vtyp → stm → frame &nbsp;&nbsp;(*&nbsp;invariant:&nbsp;all&nbsp;elements&nbsp;in&nbsp;cap&nbsp;are&nbsp;bound&nbsp;in&nbsp;the&nbsp;tail&nbsp;of&nbsp;the&nbsp;ctx&nbsp;*) &nbsp;&nbsp;| H : label → cap → stm → frame . We use the following abbreviation to denote runtime stacks Notation ctx := (list frame). The toplevel / empty runtime stack. Notation top := (@nil frame). The following definition extracts labels, bound by the context. Fixpoint bound_labels (c : ctx) : labels := &nbsp;&nbsp;match c with &nbsp;&nbsp;| nil ⇒ {}L &nbsp;&nbsp;| K T s :: c ⇒ bound_labels c &nbsp;&nbsp;| H l C h :: c ⇒ LabelSet.F.union (bound_labels c) (LabelSet.F.singleton l) &nbsp;&nbsp;end. We need to be able to plug an expression into a context. Fixpoint plug (c : ctx) (e : exp) {struct c} : stm := &nbsp;&nbsp;match c with &nbsp;&nbsp;| nil ⇒ stm_ret e &nbsp;&nbsp;| K T s :: c ⇒ stm_val T (plug c e) s &nbsp;&nbsp;| H l C h :: c ⇒ stm_reset l C (plug c e) h &nbsp;&nbsp;end. Reserved Notation &quot;R ; Q |-cnt k ~: T1 ~&gt; T2\" (at level 70, Q at next level). Reserved Notation &quot;R ; Q |-ctx c ~: T\" (at level 70, Q at next level). Context typing . The following definition models the context typing from Appendix A.3 in the paper. It can be thought of as a variant of statement typing, flipped inside-out. typing_ctx C Q K T is parametrized by a set C of capabilities bound in the context, global signatures Q, the context K itself, and the type T at the hole. Inductive typing_ctx : cap → sig → ctx → vtyp → Prop := &nbsp;&nbsp;| typing_ctx_empty : ∀ Q T, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_sig Q → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;empty_cset ; Q |-ctx top ~: T &nbsp;&nbsp;| typing_ctx_frame : ∀ L R Q c T1 T2 s, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R ; Q |-ctx c ~: T2 → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(∀ X : atom, X `notin` L → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(X, bind_val T1)] @ R ; Q |-stm (open_es s X) ~: T2) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R ; Q |-ctx K T1 s :: c ~: T1 &nbsp;&nbsp;| typing_ctx_try : ∀ L R Q l C c T T1 T2 s, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R ; Q |-ctx c ~: T → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R |= C → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_cap empty C → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Signatures.binds l (bind_sig T1 T2) Q → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(∀ v : atom, v `notin` L → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(∀ f : atom, f `notin` (L `union` singleton v) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(f, bind_blk (typ_vfun T2 T) (capture C))] ++ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(v, bind_val T1)] @ C ; Q &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|-stm (open_bs (open_es s v) f) ~: T)) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cset_union C (cset_lvar l) ; Q |-ctx H l C s :: c ~: T where &quot;R ; Q |-ctx K ~: T\" := (typing_ctx R Q K T). Continuation typing . Continuations are reversed contexts, so the typing rules are very similar. The rendering R ; Q |-cnt K ~: T1 ~&gt; T2 shows that continuations K have a function-like type. The hole has type T1 and they are delimited at T2. Inductive typing_cnt : cap → sig → ctx → vtyp → vtyp → Prop := &nbsp;&nbsp;| typing_cnt_empty : ∀ R Q T, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_cap empty R → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_sig Q → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R ; Q |-cnt top ~: T ~&gt; T &nbsp;&nbsp;| typing_cnt_frame : ∀ L R Q c T1 T2 T3 s, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R ; Q |-cnt c ~: T1 ~&gt; T2 → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(∀ X : atom, X `notin` L → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(X, bind_val T2)] @ R ; Q |-stm (open_es s X) ~: T3) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R ; Q |-cnt K T2 s :: c ~: T1 ~&gt; T3 &nbsp;&nbsp;| typing_cnt_handler : ∀ L R Q c l C T T1 T2 T3 h, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_cap empty R → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cset_union C (cset_lvar l) ; Q |-cnt c ~: T1 ~&gt; T2 → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R |= C → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Signatures.binds l (bind_sig T3 T) Q → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(∀ v : atom, v `notin` L → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(∀ f : atom, f `notin` (L `union` singleton v) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(f, bind_blk (typ_vfun T T2) (capture C))] ++ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(v, bind_val T3)] @ C ; Q |-stm (open_bs (open_es h v) f) ~: T2)) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R ; Q |-cnt (H l C h :: c) ~: T1 ~&gt; T2 where &quot;R ; Q |-cnt K ~: T1 ~&gt; T2\" := (typing_cnt R Q K T1 T2). ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Definitions.html",
    "relUrl": "/proofs/Top.SystemC.Definitions.html"
  },"18": {
    "doc": "Top.SystemC.Definitions",
    "title": " Abstract Machine",
    "content": "The abstract machine can be in one of two states. | either we simply step within a context state_step, | or we unwind the stack to search for a delimiter state_wind. | . Inductive state : Type := &nbsp;&nbsp;| state_step (s : stm) (c : ctx) (Q : sig) : state &nbsp;&nbsp;| state_wind (l : label) (v : exp) (c : ctx) (k : ctx) (Q : sig) : state . Notation &quot;〈throw l # v | c • k | Q 〉\" := (state_wind l v c k Q). Notation &quot;〈 s | c | Q 〉\" := (state_step s c Q). Notation &quot;〈 e | Q 〉\" := (state_step (stm_ret e) top Q). Reserved Notation &quot;st1 --&gt; st2\" (at level 69). The following predicate corresponds to values, but for machine states. Inductive done : state → Prop := &nbsp;&nbsp;| done_ret : ∀ Q e, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evalue e → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;done 〈 e | Q 〉 . Reduction Steps . For better comparison, we label the rules with the names from the paper. Inductive step : state → state → Prop := (cong) &nbsp;&nbsp;| step_cong : ∀ Q s s' c, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s --&gt;s s' → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;〈 s | c | Q 〉 --&gt; 〈 s' | c | Q 〉 (pop) &nbsp;&nbsp;| step_pop_1 : ∀ Q v T s c, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evalue v → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;〈 stm_ret v | K T s :: c | Q 〉 --&gt; 〈 open_es s v | c | Q 〉 (ret) &nbsp;&nbsp;| step_pop_2 : ∀ Q v l C s c, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evalue v → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;〈 stm_ret v | H l C s :: c | Q 〉 --&gt; 〈 stm_ret v | c | Q 〉 (push) &nbsp;&nbsp;| step_push : ∀ Q s T b c, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stmt (stm_val T b s) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;〈 stm_val T b s | c | Q 〉 --&gt; 〈 b | K T s :: c | Q 〉 (try) &nbsp;&nbsp;| step_try : ∀ Q s h l C T2 T1 c, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;¬ LabelSet.F.In l (bound_labels c) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;¬ LabelSet.F.In l (Signatures.dom Q) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;〈 stm_try C T2 T1 s h | c | Q 〉--&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;〈 open_cs s (blk_handler l) (cset_lvar l) | H l C h :: c | [(l , bind_sig T2 T1)] ++ Q 〉 (reset) &nbsp;&nbsp;| step_reset : ∀ Q s h l C T1 T c, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Signatures.binds l (bind_sig T1 T) Q → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;〈 stm_reset l C s h | c | Q 〉--&gt; 〈 s | H l C h :: c | Q 〉 (try), switch to search mode &nbsp;&nbsp;| step_throw : ∀ Q l v c, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evalue v → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;〈 stm_throw (blk_handler l) v | c | Q 〉--&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;〈throw l # v | c • top | Q 〉 (unwind) &nbsp;&nbsp;| step_unwind_1 : ∀ Q l v T s c k, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;〈throw l # v | K T s :: c • k | Q 〉--&gt; 〈throw l # v | c • K T s :: k | Q 〉 (forward) &nbsp;&nbsp;| step_unwind_2 : ∀ Q l v l2 C h c k, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l ≠ l2 → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;〈throw l # v | H l2 C h :: c • k | Q 〉--&gt; 〈throw l # v | c • H l2 C h :: k | Q 〉 (handle), switch back to step mode &nbsp;&nbsp;| step_handle : ∀ Q l v T T1 C h c k, &nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;the&nbsp;continuation:&nbsp;(y&nbsp;:&nbsp;T1)&nbsp;=&gt;&nbsp;reset&nbsp;l&nbsp;c&nbsp;h&nbsp;Ey&nbsp;&nbsp;*) &nbsp;&nbsp;&nbsp;&nbsp;Signatures.binds l (bind_sig T T1) Q → &nbsp;&nbsp;&nbsp;&nbsp;〈throw l # v | H l C h :: c • k | Q 〉--&gt; &nbsp;&nbsp;&nbsp;&nbsp;〈 open_bs (open_es h v) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(blk_vabs T1 (plug (H l C h :: k) (exp_bvar 0))) | c | Q 〉 where &quot;st1 --&gt; st2\" := (step st1 st2). Abstract Machine Typing . A machine state is simply by composing the previously defined typing judgements. For typ_state, a the statement has to have the same type T that is expected by the context. Inductive typing_state : state → Prop := &nbsp;&nbsp;| typ_step : ∀ R Q s c T, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R ; Q |-ctx c ~: T → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nil @ R ; Q |-stm s ~: T → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typing_state〈 s | c | Q 〉 For typ_wind the signature bound at label l has to be T3 → T1, the value has to have the expected type T3, and the types of the continuation and stack have to align at T2. &nbsp;&nbsp;| typ_wind : ∀ R Q l v c k T1 T2 T3, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cset_references_lvar l R → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Signatures.binds l (bind_sig T3 T1) Q → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R ; Q |-ctx c ~: T2 → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R ; Q |-cnt k ~: T1 ~&gt; T2 → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nil ; Q |-exp v ~: T3 → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typing_state〈throw l # v | c • k | Q 〉 . ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Definitions.html",
    "relUrl": "/proofs/Top.SystemC.Definitions.html"
  },"19": {
    "doc": "Top.SystemC.Examples",
    "title": "Top.SystemC.Examples",
    "content": "(*&nbsp;Block&nbsp;type&nbsp;*) Parameter S0 : btyp. Parameter S0Wf : wf_btyp empty S0. Parameter S0Type : btype S0. (*&nbsp;Fresh&nbsp;labels&nbsp;(add&nbsp;more&nbsp;eventually)*) Parameter l1 l2 l3 : label. Axiom l1l2 : l1 ≠ l2. Axiom l1l3 : l1 ≠ l3. Axiom l2l3 : l2 ≠ l3. (*&nbsp;(f&nbsp;:&nbsp;S0)&nbsp;=&gt;&nbsp;return&nbsp;box&nbsp;{f}&nbsp;f&nbsp;&nbsp;*) Definition id_ex : blk := &nbsp;&nbsp;blk_babs S0 (stm_ret (exp_box (cset_bvar 0) (blk_bvar 0))). (*&nbsp;(f&nbsp;:&nbsp;S0)&nbsp;-&gt;&nbsp;S0&nbsp;at&nbsp;{f}&nbsp;*) Definition id_ex_typ : btyp := &nbsp;&nbsp;typ_bfun S0 (typ_capt S0 (cset_bvar 0)). Lemma substZeroInSingleton (x : atom): (open_cset 0 (cset_fvar x) (cset_bvar 0)) = (cset_fvar x). (*&nbsp;Since&nbsp;it&nbsp;is&nbsp;closed...&nbsp;*) Lemma substitutionS0 (x : atom) : open_cbt_rec 0 (cset_fvar x) S0 = S0. Definition id_ex_typing : empty @ {}C ; nil |-blk id_ex ~: id_ex_typ. Definition try_return_immediate_typ := &nbsp;&nbsp;typ_base. Definition try_return_param_type := &nbsp;&nbsp;typ_base. Definition try_return_immediate := &nbsp;&nbsp;stm_try {}C try_return_param_type try_return_immediate_typ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stm_ret exp_const) (stm_ret exp_const). Lemma try_return_immediate_typing : empty @ {}C ; nil |-stm try_return_immediate ~: try_return_immediate_typ. Lemma try_return_immediate_s1 : &nbsp;&nbsp;〈 try_return_immediate | top | nil 〉--&gt; &nbsp;&nbsp;〈 (stm_ret exp_const) | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(H l1 {}C (stm_ret exp_const)) :: top | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(l1, bind_sig try_return_param_type try_return_immediate_typ) :: nil 〉. Lemma try_return_immediate_s2 : ∀ Q, &nbsp;&nbsp;〈 (stm_ret exp_const) | (H l1 {}C (stm_ret exp_const)) :: top | Q 〉--&gt; &nbsp;&nbsp;〈 (stm_ret exp_const) | top | Q 〉. Definition try_return_throw_typ := &nbsp;&nbsp;typ_base. Definition try_return_throw_param_typ := &nbsp;&nbsp;typ_base. Definition try_return_throw := &nbsp;&nbsp;stm_try {}C try_return_throw_param_typ try_return_throw_typ (stm_throw (blk_bvar 0) exp_const) (stm_ret exp_const). Lemma try_return_throw_typing : empty @ {}C ; nil |-stm try_return_throw ~: try_return_throw_typ. Lemma try_return_throw_s1 : &nbsp;&nbsp;〈 try_return_throw | top | nil 〉--&gt; &nbsp;&nbsp;〈 (stm_throw (blk_handler l1) exp_const) | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(H l1 {}C (stm_ret exp_const)) :: top | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(l1, bind_sig try_return_throw_param_typ try_return_throw_typ)] 〉. Lemma try_return_throw_s2 : ∀ Q, &nbsp;&nbsp;〈 (stm_throw (blk_handler l1) exp_const) | (H l1 {}C (stm_ret exp_const)) :: top | Q 〉--&gt; &nbsp;&nbsp;〈throw l1 # exp_const | (H l1 {}C (stm_ret exp_const)) :: top • top | Q〉. Lemma try_return_throw_s3 : &nbsp;&nbsp;〈throw l1 # exp_const | (H l1 {}C (stm_ret exp_const)) :: top • top | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(l1, bind_sig try_return_throw_param_typ try_return_throw_typ)]〉--&gt; &nbsp;&nbsp;〈 (stm_ret exp_const) | top | [(l1, bind_sig try_return_throw_param_typ try_return_throw_typ)] 〉 . Definition try_apply_throw_param_typ := typ_base. Definition try_apply_throw_typ := typ_base. Definition try_apply_throw := &nbsp;&nbsp;stm_try {}C try_apply_throw_param_typ try_apply_throw_typ (stm_val typ_base (stm_throw (blk_bvar 0) exp_const) (stm_ret (exp_bvar 0))) &nbsp;&nbsp;&nbsp;&nbsp;(stm_ret (exp_const)). Lemma wf_cap_empty: ∀ E, &nbsp;&nbsp;wf_cap E {}C. Lemma try_apply_throw_typing : &nbsp;&nbsp;empty @ {}C ; nil |-stm try_apply_throw ~: try_apply_throw_typ. Lemma try_apply_throw_s1 : &nbsp;&nbsp;〈 try_apply_throw | top | nil 〉--&gt; &nbsp;&nbsp;〈 (stm_val typ_base (stm_throw (blk_handler l1) (exp_const)) (stm_ret (exp_bvar 0))) &nbsp;&nbsp;&nbsp;&nbsp;| (H l1 {}C (stm_ret exp_const)) :: top &nbsp;&nbsp;&nbsp;&nbsp;| [(l1, bind_sig try_apply_throw_param_typ try_apply_throw_typ)] &nbsp;&nbsp;&nbsp;〉. Lemma try_apply_throw_s2 : &nbsp;&nbsp;〈 (stm_val typ_base (stm_throw (blk_handler l1) exp_const) (stm_ret (exp_bvar 0))) &nbsp;&nbsp;&nbsp;&nbsp;| (H l1 {}C (stm_ret exp_const)) :: top &nbsp;&nbsp;&nbsp;&nbsp;| [(l1, bind_sig try_apply_throw_param_typ try_apply_throw_typ)] &nbsp;&nbsp;〉--&gt; &nbsp;&nbsp;〈 (stm_throw (blk_handler l1) exp_const) &nbsp;&nbsp;&nbsp;&nbsp;| (K typ_base (stm_ret (exp_bvar 0))) :: ((H l1 {}C (stm_ret exp_const)) :: top) &nbsp;&nbsp;&nbsp;&nbsp;| [(l1, bind_sig try_apply_throw_param_typ try_apply_throw_typ)] &nbsp;&nbsp;〉. Lemma try_apply_throw_s3 : &nbsp;&nbsp;〈 (stm_throw (blk_handler l1) exp_const) &nbsp;&nbsp;&nbsp;&nbsp;| (K typ_base (stm_ret (exp_bvar 0))) :: ((H l1 {}C (stm_ret exp_const)) :: top) &nbsp;&nbsp;&nbsp;&nbsp;| [(l1, bind_sig try_apply_throw_param_typ try_apply_throw_typ)] &nbsp;&nbsp;〉--&gt; &nbsp;&nbsp;〈throw l1 # exp_const &nbsp;&nbsp;&nbsp;&nbsp;| (K typ_base (stm_ret (exp_bvar 0))) :: ((H l1 {}C (stm_ret exp_const)) :: top) &nbsp;&nbsp;&nbsp;&nbsp;• top &nbsp;&nbsp;&nbsp;&nbsp;| [(l1, bind_sig try_apply_throw_param_typ try_apply_throw_typ)] &nbsp;&nbsp;〉. Lemma try_apply_throw_s4 : &nbsp;&nbsp;〈throw l1 # exp_const &nbsp;&nbsp;&nbsp;&nbsp;| (K typ_base (stm_ret (exp_bvar 0))) :: ((H l1 {}C (stm_ret exp_const)) :: top) &nbsp;&nbsp;&nbsp;&nbsp;• top &nbsp;&nbsp;&nbsp;&nbsp;| [(l1, bind_sig try_apply_throw_param_typ try_apply_throw_typ)] &nbsp;&nbsp;〉--&gt; &nbsp;&nbsp;〈throw l1 # exp_const &nbsp;&nbsp;&nbsp;&nbsp;| ((H l1 {}C (stm_ret exp_const)) :: top) &nbsp;&nbsp;&nbsp;&nbsp;• (K typ_base (stm_ret (exp_bvar 0))) :: top &nbsp;&nbsp;&nbsp;&nbsp;| [(l1, bind_sig try_apply_throw_param_typ try_apply_throw_typ)] &nbsp;&nbsp;〉. Lemma try_apply_throw_s5 : &nbsp;&nbsp;〈throw l1 # exp_const &nbsp;&nbsp;&nbsp;&nbsp;| ((H l1 {}C (stm_ret exp_const)) :: top) &nbsp;&nbsp;&nbsp;&nbsp;• (K typ_base (stm_ret (exp_bvar 0))) :: top &nbsp;&nbsp;&nbsp;&nbsp;| [(l1, bind_sig try_apply_throw_param_typ try_apply_throw_typ)] &nbsp;&nbsp;〉--&gt; &nbsp;&nbsp;〈 (stm_ret exp_const) &nbsp;&nbsp;&nbsp;&nbsp;| top &nbsp;&nbsp;&nbsp;&nbsp;| [(l1, bind_sig try_apply_throw_param_typ try_apply_throw_typ)] &nbsp;&nbsp;〉. Lemma cset_references_bvar_evidently : ∀ A (t s : A) i, &nbsp;&nbsp;(if cset_references_bvar_dec i (cset_bvar i) then t else s) = t. Lemma cset_references_bvar_evidently_empty : ∀ A (t s : A) i, &nbsp;&nbsp;(if cset_references_bvar_dec i {}C then t else s) = s. Lemma cset_references_bvar_evidently_not : ∀ A (t s : A) i j, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;(if cset_references_bvar_dec i (cset_bvar j) then t else s) = s. Lemma cset_references_bvar_evidently_fvar : ∀ A (t s : A) i x, &nbsp;&nbsp;(if cset_references_bvar_dec i (cset_fvar x) then t else s) = s. Lemma cset_references_bvar_evidently_lvar : ∀ A (t s : A) i l, &nbsp;&nbsp;(if cset_references_bvar_dec i (cset_lvar l) then t else s) = s. Lemma cset_remove_bvar_evidently : ∀ i, cset_remove_bvar i (cset_bvar i) = {}C. Lemma cset_union_empty : ∀ C, cset_union C {}C = C. Definition cap_return_tm := &nbsp;&nbsp;(stm_try {}C typ_base typ_base &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stm_val (typ_capt (typ_vfun typ_base typ_base) (cset_bvar 0)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stm_try (cset_bvar 0) typ_base typ_base &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stm_def (cset_bvar 1) (typ_vfun typ_base typ_base) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(blk_vabs typ_base (stm_throw (blk_bvar 1) exp_const)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stm_ret (exp_box (cset_bvar 2) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(blk_bvar 0)))) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stm_ret (exp_box (cset_bvar 1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(blk_vabs typ_base (stm_ret exp_const))))) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stm_vapp (blk_unbox (exp_bvar 0)) exp_const)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stm_ret exp_const)) . Lemma cap_return_typing1 : &nbsp;&nbsp;(nil @ (cset_lvar l1) ; (l2, bind_sig typ_base typ_base) :: (l1, bind_sig typ_base typ_base) :: nil &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|-blk (blk_vabs typ_base (stm_throw (blk_handler l1) exp_const)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~: (typ_vfun typ_base typ_base)). Lemma cap_return_typing2 : ∀ x, &nbsp;&nbsp;(styping &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((x, bind_blk (typ_vfun typ_base typ_base) (capture (cset_lvar l1))) :: nil) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cset_lvar l1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((l2, bind_sig typ_base typ_base) :: (l1, bind_sig typ_base typ_base) :: nil) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stm_ret (exp_box (cset_lvar l1) (blk_fvar x))) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(typ_capt (typ_vfun typ_base typ_base) (cset_lvar l1))). Lemma wf_cap_union : ∀ E C D, &nbsp;&nbsp;wf_cap E C → &nbsp;&nbsp;wf_cap E D → &nbsp;&nbsp;wf_cap E (cset_union C D). Lemma cap_return_typing0 : ∃ T, &nbsp;&nbsp;(styping nil {}C nil &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cap_return_tm &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T). &nbsp;&nbsp;Lemma wf_sig_nil : wf_sig nil. Qed. (*&nbsp;def&nbsp;C&nbsp;x:&nbsp;S&nbsp;=&nbsp;b;&nbsp;s&nbsp;&nbsp;&nbsp;.=&nbsp;&nbsp;&nbsp;((x&nbsp;:&nbsp;C&nbsp;S)&nbsp;=&gt;&nbsp;s)(box&nbsp;C&nbsp;b)&nbsp;*) Definition sugar_def (C : cap) (S1 : btyp) (b : blk) (s : stm) : stm := &nbsp;&nbsp;(stm_vapp (blk_vabs (typ_capt S1 C) s) (exp_box C b)). Definition sugar_var (x : atom) : blk := &nbsp;&nbsp;&nbsp;&nbsp;(blk_unbox (exp_fvar x)). Lemma sugar_def_typing : ∀ L E R b s (C : cap) Q S1 T2, &nbsp;&nbsp;R |= C → &nbsp;&nbsp;wf_cap E C → &nbsp;&nbsp;wf_cap E R → &nbsp;&nbsp;E @ C ; Q |-blk b ~: S1 → &nbsp;&nbsp;(∀ x : atom, x `notin` L → &nbsp;&nbsp;&nbsp;&nbsp;([(x, bind_val (typ_capt S1 C))] ++ E) @ R ; Q |-stm (open_es s x) ~: T2) → &nbsp;&nbsp;E @ R ; Q |-stm (sugar_def C S1 b s) ~: T2. Lemma sugar_var_typing : ∀ E R f S1 C, &nbsp;&nbsp;wf_env E → &nbsp;&nbsp;wf_cap E R → &nbsp;&nbsp;R |= C → &nbsp;&nbsp;binds f (bind_val (typ_capt S1 C)) E → &nbsp;&nbsp;E @ R ; nil |-blk (sugar_var f) ~: S1. Finally def handleTick(prog : {() =&gt; Int} =&gt; Int) =&gt; Int = val stateFun = try { tick =&gt; val res = prog (tick) in box { prog } ( (s : Int) =&gt; res ) } with { box { prog } ( (s : Int) =&gt; (unbox resume(s))(s + 1) } in (unbox stateFun)(0) Definition handle_tick_term := &nbsp;&nbsp;blk_babs (typ_bfun (typ_exc typ_base typ_base) typ_base) &nbsp;&nbsp;&nbsp;&nbsp;(stm_val (*&nbsp;statefun&nbsp;*) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(typ_capt (typ_vfun typ_base typ_base) (cset_bvar 0)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stm_try (cset_bvar 0) typ_base typ_base &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; body | tick &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stm_val typ_base (stm_bapp (blk_bvar 1) (cset_bvar 0) (blk_bvar 0)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stm_ret (exp_box (cset_bvar 1) (blk_vabs typ_base (stm_ret (exp_bvar 1)))))) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stm_val &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(typ_capt (typ_vfun typ_base typ_base) (cset_bvar 1)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stm_vapp (blk_bvar 0) (exp_bvar 0)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stm_ret &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(exp_box (cset_bvar 1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(blk_vabs typ_base (stm_vapp (blk_unbox (exp_bvar 1)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(exp_bvar 0))))))) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stm_vapp (blk_unbox (exp_bvar 0)) exp_const)). Lemma handle_tick_term_typing : &nbsp;&nbsp;∃ T, empty @ {}C ; nil |-blk handle_tick_term ~: T. ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Examples.html",
    "relUrl": "/proofs/Top.SystemC.Examples.html"
  },"20": {
    "doc": "Top.SystemC.Infrastructure",
    "title": "Top.SystemC.Infrastructure",
    "content": "(*&nbsp;&nbsp;Free&nbsp;Variables&nbsp;*) Fixpoint fv_ee (e : exp) {struct e} : atoms := &nbsp;&nbsp;match e with &nbsp;&nbsp;| exp_bvar i ⇒ {} &nbsp;&nbsp;| exp_fvar x ⇒ singleton x &nbsp;&nbsp;| exp_const ⇒ {} &nbsp;&nbsp;| exp_box C b ⇒ fv_eb b &nbsp;&nbsp;end with fv_es (s : stm) {struct s} : atoms := &nbsp;&nbsp;match s with &nbsp;&nbsp;| stm_ret e ⇒ fv_ee e &nbsp;&nbsp;| stm_val T s1 s2 ⇒ (fv_es s1) `union` (fv_es s2) &nbsp;&nbsp;| stm_def C S1 b s ⇒ (fv_eb b) `union` (fv_es s) &nbsp;&nbsp;| stm_vapp b e ⇒ (fv_eb b) `union` (fv_ee e) &nbsp;&nbsp;| stm_bapp b C g ⇒ (fv_eb b) `union` (fv_eb g) &nbsp;&nbsp;| stm_try C T1 T b g ⇒ (fv_es b) `union` (fv_es g) &nbsp;&nbsp;| stm_reset l C b g ⇒ (fv_es b) `union` (fv_es g) &nbsp;&nbsp;| stm_throw b e ⇒ fv_eb b `union` fv_ee e &nbsp;&nbsp;end with fv_eb (b : blk) {struct b} : atoms := &nbsp;&nbsp;match b with &nbsp;&nbsp;| blk_bvar i ⇒ {} &nbsp;&nbsp;| blk_fvar x ⇒ {} &nbsp;&nbsp;| blk_vabs T s ⇒ fv_es s &nbsp;&nbsp;| blk_babs S1 s ⇒ fv_es s &nbsp;&nbsp;| blk_tabs s ⇒ fv_eb s &nbsp;&nbsp;| blk_tapp s T ⇒ fv_eb s &nbsp;&nbsp;| blk_unbox e ⇒ fv_ee e &nbsp;&nbsp;| blk_handler l ⇒ {} &nbsp;&nbsp;end. (*&nbsp;Block&nbsp;term&nbsp;variables&nbsp;*) Fixpoint fv_be (e : exp) {struct e} : atoms := &nbsp;&nbsp;match e with &nbsp;&nbsp;| exp_bvar i ⇒ {} &nbsp;&nbsp;| exp_fvar x ⇒ {} &nbsp;&nbsp;| exp_const ⇒ {} &nbsp;&nbsp;| exp_box C1 b ⇒ fv_bb b &nbsp;&nbsp;end with fv_bs (s : stm) {struct s} : atoms := &nbsp;&nbsp;match s with &nbsp;&nbsp;| stm_ret e ⇒ fv_be e &nbsp;&nbsp;| stm_val T s1 s2 ⇒ (fv_bs s1) `union` (fv_bs s2) &nbsp;&nbsp;| stm_def C1 S1 b s ⇒ (fv_bb b) `union` (fv_bs s) &nbsp;&nbsp;| stm_vapp b e ⇒ (fv_bb b) `union` (fv_be e) &nbsp;&nbsp;| stm_bapp b C1 g ⇒ (fv_bb b) `union` (fv_bb g) &nbsp;&nbsp;| stm_try C T1 T b g ⇒ (fv_bs b) `union` (fv_bs g) &nbsp;&nbsp;| stm_reset l C b g ⇒ (fv_bs b) `union` (fv_bs g) &nbsp;&nbsp;| stm_throw b e ⇒ fv_bb b `union` fv_be e &nbsp;&nbsp;end with fv_bb (b : blk) {struct b} : atoms := &nbsp;&nbsp;match b with &nbsp;&nbsp;| blk_bvar i ⇒ {} &nbsp;&nbsp;| blk_fvar x ⇒ (singleton x) &nbsp;&nbsp;| blk_vabs T s ⇒ (fv_bs s) &nbsp;&nbsp;| blk_babs S1 s ⇒ (fv_bs s) &nbsp;&nbsp;| blk_tabs s ⇒ fv_bb s &nbsp;&nbsp;| blk_tapp s T ⇒ fv_bb s &nbsp;&nbsp;| blk_unbox e ⇒ (fv_be e) &nbsp;&nbsp;| blk_handler l ⇒ {} &nbsp;&nbsp;end. (*&nbsp;Block&nbsp;type&nbsp;variables&nbsp;*) Fixpoint fv_cvt (T : vtyp) {struct T} : atoms := &nbsp;&nbsp;match T with &nbsp;&nbsp;| typ_base ⇒ {} &nbsp;&nbsp;| typ_capt S1 C1 ⇒ (fv_cbt S1) `union` (cset_fvars C1) &nbsp;&nbsp;| typ_fvar a ⇒ {} &nbsp;&nbsp;| typ_bvar n ⇒ {} &nbsp;&nbsp;end with fv_cbt (S1 : btyp) {struct S1} : atoms := &nbsp;&nbsp;match S1 with &nbsp;&nbsp;| typ_vfun T1 T2 ⇒ (fv_cvt T1) `union` (fv_cvt T2) &nbsp;&nbsp;| typ_bfun S1 T ⇒ (fv_cbt S1) `union` (fv_cvt T) &nbsp;&nbsp;| typ_exc T1 T ⇒ (fv_cvt T1) `union` (fv_cvt T) &nbsp;&nbsp;| typ_tfun T ⇒ (fv_cbt T) &nbsp;&nbsp;end. Fixpoint fv_ce (e : exp) {struct e} : atoms := &nbsp;&nbsp;match e with &nbsp;&nbsp;| exp_bvar i ⇒ {} &nbsp;&nbsp;| exp_fvar x ⇒ {} &nbsp;&nbsp;| exp_const ⇒ {} &nbsp;&nbsp;| exp_box C1 b ⇒ (cset_fvars C1) `union` (fv_cb b) &nbsp;&nbsp;end with fv_cs (s : stm) {struct s} : atoms := &nbsp;&nbsp;match s with &nbsp;&nbsp;| stm_ret e ⇒ (fv_ce e) &nbsp;&nbsp;| stm_val T s1 s2 ⇒ (fv_cvt T) `union` (fv_cs s1) `union` (fv_cs s2) &nbsp;&nbsp;| stm_def C1 S1 b s ⇒ (cset_fvars C1) `union` (fv_cbt S1) `union` (fv_cb b) `union` (fv_cs s) &nbsp;&nbsp;| stm_vapp b e ⇒ (fv_cb b) `union` (fv_ce e) &nbsp;&nbsp;| stm_bapp b C1 g ⇒ (fv_cb b) `union` (cset_fvars C1) `union` (fv_cb g) &nbsp;&nbsp;| stm_try C1 T1 T b g ⇒ (fv_cvt T1) `union` (fv_cvt T) `union` (cset_fvars C1) `union` (fv_cs b) `union` (fv_cs g) &nbsp;&nbsp;| stm_reset l C1 b g ⇒ (cset_fvars C1) `union` (fv_cs b) `union` (fv_cs g) &nbsp;&nbsp;| stm_throw b e ⇒ fv_cb b `union` fv_ce e &nbsp;&nbsp;end with fv_cb (b : blk) {struct b} : atoms := &nbsp;&nbsp;match b with &nbsp;&nbsp;| blk_bvar i ⇒ {} &nbsp;&nbsp;| blk_fvar x ⇒ singleton x &nbsp;&nbsp;| blk_vabs T s ⇒ (fv_cvt T) `union` (fv_cs s) &nbsp;&nbsp;| blk_babs S1 s ⇒ (fv_cbt S1) `union` (fv_cs s) &nbsp;&nbsp;| blk_tabs s ⇒ (fv_cb s) &nbsp;&nbsp;| blk_tapp s T ⇒ (fv_cb s) `union` (fv_cvt T) &nbsp;&nbsp;| blk_unbox e ⇒ (fv_ce e) &nbsp;&nbsp;| blk_handler l ⇒ {} &nbsp;&nbsp;end. Fixpoint fv_tvt (T : vtyp) {struct T} : atoms := match T with &nbsp;&nbsp;| typ_base ⇒ {} &nbsp;&nbsp;| typ_capt S1 C1 ⇒ (fv_tbt S1) &nbsp;&nbsp;| typ_fvar a ⇒ singleton a &nbsp;&nbsp;| typ_bvar n ⇒ {} &nbsp;&nbsp;end with fv_tbt (S1 : btyp) {struct S1} : atoms := &nbsp;&nbsp;match S1 with &nbsp;&nbsp;| typ_vfun T1 T2 ⇒ (fv_tvt T1) `union` (fv_tvt T2) &nbsp;&nbsp;| typ_bfun S1 T ⇒ (fv_tbt S1) `union` (fv_tvt T) &nbsp;&nbsp;| typ_exc T1 T ⇒ (fv_tvt T1) `union` (fv_tvt T) &nbsp;&nbsp;| typ_tfun T ⇒ (fv_tbt T) &nbsp;&nbsp;end. Fixpoint fv_te (e : exp) {struct e} : atoms := &nbsp;&nbsp;match e with &nbsp;&nbsp;| exp_bvar i ⇒ {} &nbsp;&nbsp;| exp_fvar x ⇒ {} &nbsp;&nbsp;| exp_const ⇒ {} &nbsp;&nbsp;| exp_box C b ⇒ fv_tb b &nbsp;&nbsp;end with fv_ts (s : stm) {struct s} : atoms := &nbsp;&nbsp;match s with &nbsp;&nbsp;| stm_ret e ⇒ fv_te e &nbsp;&nbsp;| stm_val T s1 s2 ⇒ (fv_tvt T) `union` (fv_ts s1) `union` (fv_ts s2) &nbsp;&nbsp;| stm_def C S1 b s ⇒ (fv_tbt S1) `union` (fv_tb b) `union` (fv_ts s) &nbsp;&nbsp;| stm_vapp b e ⇒ (fv_tb b) `union` (fv_te e) &nbsp;&nbsp;| stm_bapp b C g ⇒ (fv_tb b) `union` (fv_tb g) &nbsp;&nbsp;| stm_try C T1 T b g ⇒ (fv_tvt T1) `union` (fv_tvt T) `union` (fv_ts b) `union` (fv_ts g) &nbsp;&nbsp;| stm_reset l C b g ⇒ (fv_ts b) `union` (fv_ts g) &nbsp;&nbsp;| stm_throw b e ⇒ fv_tb b `union` fv_te e &nbsp;&nbsp;end with fv_tb (b : blk) {struct b} : atoms := &nbsp;&nbsp;match b with &nbsp;&nbsp;| blk_bvar i ⇒ {} &nbsp;&nbsp;| blk_fvar x ⇒ {} &nbsp;&nbsp;| blk_vabs T s ⇒ fv_tvt T `union` fv_ts s &nbsp;&nbsp;| blk_babs S1 s ⇒ fv_tbt S1 `union` fv_ts s &nbsp;&nbsp;| blk_tabs s ⇒ fv_tb s &nbsp;&nbsp;| blk_tapp s T ⇒ fv_tvt T `union` fv_tb s &nbsp;&nbsp;| blk_unbox e ⇒ fv_te e &nbsp;&nbsp;| blk_handler l ⇒ {} &nbsp;&nbsp;end. Definition fv_bbind (b : binding) : atoms := &nbsp;&nbsp;match b with &nbsp;&nbsp;| bind_val T ⇒ {} &nbsp;&nbsp;| bind_blk s tracked ⇒ (fv_cbt s) &nbsp;&nbsp;| bind_blk s (capture C2) ⇒ (fv_cbt s) `union` (cset_fvars C2) &nbsp;&nbsp;| bind_typ ⇒ {} &nbsp;&nbsp;end. The second step in defining \"pick fresh\" is to define the tactic itself. It is based on the (pick fresh ... for ...) tactic defined in the Atom library. Here, we use gather_atoms to construct the set L rather than leaving it to the user to provide. Thus, invoking (pick fresh x) introduces a new atom x into the current context that is fresh for \"everything\" in the context. Tactic Notation \"pick\" \"fresh\" ident(x) := &nbsp;&nbsp;let L := gather_atoms in (pick fresh x for L). (*&nbsp;***********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Infrastructure.html",
    "relUrl": "/proofs/Top.SystemC.Infrastructure.html"
  },"21": {
    "doc": "Top.SystemC.Infrastructure",
    "title": " The \"pick fresh and apply\" tactic",
    "content": "This tactic is implementation specific only because of its reliance on gather_atoms, which is itself implementation specific. The definition below may be copied between developments without any changes, assuming that the other other developments define an appropriate gather_atoms tactic. For documentation on the tactic on which the one below is based, see the Metatheory library. Tactic Notation &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"pick\" \"fresh\" ident(atom_name) \"and\" \"apply\" constr(lemma) := &nbsp;&nbsp;let L := gather_atoms in &nbsp;&nbsp;pick fresh atom_name excluding L and apply lemma. Lemma subst_ee_intro_rec : ∀ x e u k, &nbsp;&nbsp;x `notin` fv_ee e → &nbsp;&nbsp;open_ee_rec k u e = subst_ee x u (open_ee_rec k (exp_fvar x) e) with subst_es_intro_rec : ∀ x e u k, &nbsp;&nbsp;x `notin` fv_es e → &nbsp;&nbsp;open_es_rec k u e = subst_es x u (open_es_rec k (exp_fvar x) e) with subst_eb_intro_rec : ∀ x e u k, &nbsp;&nbsp;x `notin` fv_eb e → &nbsp;&nbsp;open_eb_rec k u e = subst_eb x u (open_eb_rec k (exp_fvar x) e). Lemma subst_ee_intro : ∀ x e u, &nbsp;&nbsp;x `notin` fv_ee e → &nbsp;&nbsp;open_ee e u = subst_ee x u (open_ee e x) with subst_es_intro : ∀ x e u, &nbsp;&nbsp;x `notin` fv_es e → &nbsp;&nbsp;open_es e u = subst_es x u (open_es e x) with subst_eb_intro : ∀ x e u, &nbsp;&nbsp;x `notin` fv_eb e → &nbsp;&nbsp;open_eb e u = subst_eb x u (open_eb e x). Lemma subst_be_intro_rec : ∀ x e u k, &nbsp;&nbsp;x `notin` fv_be e → &nbsp;&nbsp;open_be_rec k u e = subst_be x u (open_be_rec k (blk_fvar x) e) with subst_bs_intro_rec : ∀ x e u k, &nbsp;&nbsp;x `notin` fv_bs e → &nbsp;&nbsp;open_bs_rec k u e = subst_bs x u (open_bs_rec k (blk_fvar x) e) with subst_bb_intro_rec : ∀ x e u k, &nbsp;&nbsp;x `notin` fv_bb e → &nbsp;&nbsp;open_bb_rec k u e = subst_bb x u (open_bb_rec k (blk_fvar x) e). Lemma subst_be_intro : ∀ x e u, &nbsp;&nbsp;x `notin` fv_be e → &nbsp;&nbsp;open_be e u = subst_be x u (open_be e x) with subst_bs_intro : ∀ x e u, &nbsp;&nbsp;x `notin` fv_bs e → &nbsp;&nbsp;open_bs e u = subst_bs x u (open_bs e x) with subst_bb_intro : ∀ x e u, &nbsp;&nbsp;x `notin` fv_bb e → &nbsp;&nbsp;open_bb e u = subst_bb x u (open_bb e x). Lemma subst_cvt_intro_rec : ∀ X T2 U k, &nbsp;&nbsp;X `notin` fv_cvt T2 → &nbsp;&nbsp;open_cvt_rec k U T2 = subst_cvt X U (open_cvt_rec k (cset_fvar X) T2) with subst_cbt_intro_rec : ∀ X T2 U k, &nbsp;&nbsp;X `notin` fv_cbt T2 → &nbsp;&nbsp;open_cbt_rec k U T2 = subst_cbt X U (open_cbt_rec k (cset_fvar X) T2). Lemma subst_cvt_intro : ∀ X T2 U, &nbsp;&nbsp;X `notin` fv_cvt T2 → &nbsp;&nbsp;open_cvt T2 U = subst_cvt X U (open_cvt T2 (cset_fvar X)) with subst_cbt_intro : ∀ X T2 U, &nbsp;&nbsp;X `notin` fv_cbt T2 → &nbsp;&nbsp;open_cbt T2 U = subst_cbt X U (open_cbt T2 (cset_fvar X)). Lemma subst_ce_intro_rec : ∀ x e u C k, &nbsp;&nbsp;x `notin` fv_ce e → &nbsp;&nbsp;open_ce_rec k u C e = subst_ce x u C (open_ce_rec k x (cset_fvar x) e) with subst_cs_intro_rec : ∀ x e u C k, &nbsp;&nbsp;x `notin` fv_cs e → &nbsp;&nbsp;open_cs_rec k u C e = subst_cs x u C (open_cs_rec k x (cset_fvar x) e) with subst_cb_intro_rec : ∀ x e u C k, &nbsp;&nbsp;x `notin` fv_cb e → &nbsp;&nbsp;open_cb_rec k u C e = subst_cb x u C (open_cb_rec k x (cset_fvar x) e). Lemma subst_ce_intro : ∀ x e u C, &nbsp;&nbsp;x `notin` fv_ce e → &nbsp;&nbsp;open_ce e u C = subst_ce x u C (open_ce e x (cset_fvar x)) with subst_cs_intro : ∀ x e u C, &nbsp;&nbsp;x `notin` fv_cs e → &nbsp;&nbsp;open_cs e u C = subst_cs x u C (open_cs e x (cset_fvar x)) with subst_cb_intro : ∀ x e u C, &nbsp;&nbsp;x `notin` fv_cb e → &nbsp;&nbsp;open_cb e u C = subst_cb x u C (open_cb e x (cset_fvar x)). ************************************ Opening Closed Lemmas The naming scheme of the aux lemmas is: open&lt;EXPR&gt;e_rec j u e = open&lt;CE&gt;rec i P C (open&lt;EXPR&gt;rec j u e) ************************************ Lemma open_cvt_rec_capt_aux : ∀ T j V i U, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;capt V → &nbsp;&nbsp;(cset_fvars V) `disjoint` (cset_fvars U) → &nbsp;&nbsp;labels_disjoint (cset_lvars V) (cset_lvars U) → &nbsp;&nbsp;open_cvt_rec j V T = open_cvt_rec i U (open_cvt_rec j V T) → &nbsp;&nbsp;T = open_cvt_rec i U T with open_cbt_rec_capt_aux : ∀ T j V i U, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;capt V → &nbsp;&nbsp;(cset_fvars V) `disjoint` (cset_fvars U) → &nbsp;&nbsp;labels_disjoint (cset_lvars V) (cset_lvars U) → &nbsp;&nbsp;open_cbt_rec j V T = open_cbt_rec i U (open_cbt_rec j V T) → &nbsp;&nbsp;T = open_cbt_rec i U T. Lemma open_cvt_rec_type_aux : ∀ T j U i C, &nbsp;&nbsp;open_tvt_rec j U T = open_cvt_rec i C (open_tvt_rec j U T) → &nbsp;&nbsp;T = open_cvt_rec i C T with open_cbt_rec_type_aux : ∀ T j U i C, &nbsp;&nbsp;open_tbt_rec j U T = open_cbt_rec i C (open_tbt_rec j U T) → &nbsp;&nbsp;T = open_cbt_rec i C T. Lemma open_cvt_rec_vtype : ∀ T U k, &nbsp;&nbsp;vtype T → &nbsp;&nbsp;T = open_cvt_rec k U T with open_cbt_rec_btype : ∀ T U k, &nbsp;&nbsp;btype T → &nbsp;&nbsp;T = open_cbt_rec k U T. Lemma open_ee_rec_expr_aux : ∀ e j v u i, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;open_ee_rec j v e = open_ee_rec i u (open_ee_rec j v e) → &nbsp;&nbsp;e = open_ee_rec i u e with open_eb_rec_expr_aux : ∀ e j v u i, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;open_eb_rec j v e = open_eb_rec i u (open_eb_rec j v e) → &nbsp;&nbsp;e = open_eb_rec i u e with open_es_rec_expr_aux : ∀ e j v u i, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;open_es_rec j v e = open_es_rec i u (open_es_rec j v e) → &nbsp;&nbsp;e = open_es_rec i u e. Lemma open_ce_rec_capt_aux : ∀ e j v u i (C D : cap), &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;capt C → &nbsp;&nbsp;(cset_fvars C) `disjoint` (cset_fvars D) → &nbsp;&nbsp;labels_disjoint (cset_lvars C) (cset_lvars D) → &nbsp;&nbsp;open_ce_rec j v C e = open_ce_rec i u D (open_ce_rec j v C e) → &nbsp;&nbsp;e = open_ce_rec i u D e with open_cb_rec_capt_aux : ∀ e j v u i (C D : cap), &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;capt C → &nbsp;&nbsp;(cset_fvars C) `disjoint` (cset_fvars D) → &nbsp;&nbsp;labels_disjoint (cset_lvars C) (cset_lvars D) → &nbsp;&nbsp;open_cb_rec j v C e = open_cb_rec i u D (open_cb_rec j v C e) → &nbsp;&nbsp;e = open_cb_rec i u D e with open_cs_rec_capt_aux : ∀ e j v u i (C D : cap), &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;capt C → &nbsp;&nbsp;(cset_fvars C) `disjoint` (cset_fvars D) → &nbsp;&nbsp;labels_disjoint (cset_lvars C) (cset_lvars D) → &nbsp;&nbsp;open_cs_rec j v C e = open_cs_rec i u D (open_cs_rec j v C e) → &nbsp;&nbsp;e = open_cs_rec i u D e. Lemma open_ce_rec_expr_aux : ∀ e j u C i P , &nbsp;&nbsp;open_ee_rec j u e = open_ce_rec i P C (open_ee_rec j u e) → &nbsp;&nbsp;e = open_ce_rec i P C e with open_cb_rec_expr_aux : ∀ e j u C i P , &nbsp;&nbsp;open_eb_rec j u e = open_cb_rec i P C (open_eb_rec j u e) → &nbsp;&nbsp;e = open_cb_rec i P C e with open_cs_rec_expr_aux : ∀ e j u C i P , &nbsp;&nbsp;open_es_rec j u e = open_cs_rec i P C (open_es_rec j u e) → &nbsp;&nbsp;e = open_cs_rec i P C e. Lemma open_ce_rec_type_aux : ∀ e j u C i P , &nbsp;&nbsp;open_te_rec j u e = open_ce_rec i P C (open_te_rec j u e) → &nbsp;&nbsp;e = open_ce_rec i P C e with open_cb_rec_type_aux : ∀ e j u C i P , &nbsp;&nbsp;open_tb_rec j u e = open_cb_rec i P C (open_tb_rec j u e) → &nbsp;&nbsp;e = open_cb_rec i P C e with open_cs_rec_type_aux : ∀ e j u C i P , &nbsp;&nbsp;open_ts_rec j u e = open_cs_rec i P C (open_ts_rec j u e) → &nbsp;&nbsp;e = open_cs_rec i P C e. Lemma open_ee_rec_type_aux : ∀ e j U i f, &nbsp;&nbsp;open_te_rec j U e = open_ee_rec i f (open_te_rec j U e) → &nbsp;&nbsp;e = open_ee_rec i f e with open_eb_rec_type_aux : ∀ e j U i f, &nbsp;&nbsp;open_tb_rec j U e = open_eb_rec i f (open_tb_rec j U e) → &nbsp;&nbsp;e = open_eb_rec i f e with open_es_rec_type_aux : ∀ e j U i f, &nbsp;&nbsp;open_ts_rec j U e = open_es_rec i f (open_ts_rec j U e) → &nbsp;&nbsp;e = open_es_rec i f e. Lemma open_be_rec_type_aux : ∀ e j U i f, &nbsp;&nbsp;open_te_rec j U e = open_be_rec i f (open_te_rec j U e) → &nbsp;&nbsp;e = open_be_rec i f e with open_bb_rec_type_aux : ∀ e j U i f, &nbsp;&nbsp;open_tb_rec j U e = open_bb_rec i f (open_tb_rec j U e) → &nbsp;&nbsp;e = open_bb_rec i f e with open_bs_rec_type_aux : ∀ e j U i f, &nbsp;&nbsp;open_ts_rec j U e = open_bs_rec i f (open_ts_rec j U e) → &nbsp;&nbsp;e = open_bs_rec i f e. Lemma open_be_rec_expr_aux : ∀ e j u i P, &nbsp;&nbsp;open_ee_rec j u e = open_be_rec i P (open_ee_rec j u e) → &nbsp;&nbsp;e = open_be_rec i P e with open_bb_rec_expr_aux : ∀ e j u i P , &nbsp;&nbsp;open_eb_rec j u e = open_bb_rec i P (open_eb_rec j u e) → &nbsp;&nbsp;e = open_bb_rec i P e with open_bs_rec_expr_aux : ∀ e j u i P , &nbsp;&nbsp;open_es_rec j u e = open_bs_rec i P (open_es_rec j u e) → &nbsp;&nbsp;e = open_bs_rec i P e. Lemma open_ce_rec_block_aux : ∀ e j u C i P, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;open_be_rec j u e = open_ce_rec i P C (open_be_rec j u e) → &nbsp;&nbsp;e = open_ce_rec i P C e with open_cb_rec_block_aux : ∀ e j u C i P, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;open_bb_rec j u e = open_cb_rec i P C (open_bb_rec j u e) → &nbsp;&nbsp;e = open_cb_rec i P C e with open_cs_rec_block_aux : ∀ e j u C i P, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;open_bs_rec j u e = open_cs_rec i P C (open_bs_rec j u e) → &nbsp;&nbsp;e = open_cs_rec i P C e. Lemma open_be_rec_capt_aux : ∀ e j u C i P, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;open_ce_rec j u C e = open_be_rec i P (open_ce_rec j u C e) → &nbsp;&nbsp;e = open_be_rec i P e with open_bb_rec_capt_aux : ∀ e j u C i P, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;open_cb_rec j u C e = open_bb_rec i P (open_cb_rec j u C e) → &nbsp;&nbsp;e = open_bb_rec i P e with open_bs_rec_capt_aux : ∀ e j u C i P, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;open_cs_rec j u C e = open_bs_rec i P (open_cs_rec j u C e) → &nbsp;&nbsp;e = open_bs_rec i P e. Lemma open_be_rec_block_aux : ∀ e j u i P, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;open_be_rec j u e = open_be_rec i P (open_be_rec j u e) → &nbsp;&nbsp;e = open_be_rec i P e with open_bb_rec_block_aux : ∀ e j u i P, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;open_bb_rec j u e = open_bb_rec i P (open_bb_rec j u e) → &nbsp;&nbsp;e = open_bb_rec i P e with open_bs_rec_block_aux : ∀ e j u i P, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;open_bs_rec j u e = open_bs_rec i P (open_bs_rec j u e) → &nbsp;&nbsp;e = open_bs_rec i P e. Lemma open_ee_rec_capt_aux : ∀ e j D u i P , &nbsp;&nbsp;open_ce_rec j D u e = open_ee_rec i P (open_ce_rec j D u e) → &nbsp;&nbsp;e = open_ee_rec i P e with open_eb_rec_capt_aux : ∀ e j D u i P , &nbsp;&nbsp;open_cb_rec j D u e = open_eb_rec i P (open_cb_rec j D u e) → &nbsp;&nbsp;e = open_eb_rec i P e with open_es_rec_capt_aux : ∀ e j D u i P , &nbsp;&nbsp;open_cs_rec j D u e = open_es_rec i P (open_cs_rec j D u e) → &nbsp;&nbsp;e = open_es_rec i P e. Lemma open_ee_rec_block_aux : ∀ e j u i P , &nbsp;&nbsp;open_be_rec j u e = open_ee_rec i P (open_be_rec j u e) → &nbsp;&nbsp;e = open_ee_rec i P e with open_eb_rec_block_aux : ∀ e j u i P , &nbsp;&nbsp;open_bb_rec j u e = open_eb_rec i P (open_bb_rec j u e) → &nbsp;&nbsp;e = open_eb_rec i P e with open_es_rec_block_aux : ∀ e j u i P , &nbsp;&nbsp;open_bs_rec j u e = open_es_rec i P (open_bs_rec j u e) → &nbsp;&nbsp;e = open_es_rec i P e. Lemma open_ce_rec_expr : ∀ e U C k, &nbsp;&nbsp;expr e → &nbsp;&nbsp;e = open_ce_rec k U C e with open_cb_rec_block : ∀ e U C k, &nbsp;&nbsp;block e → &nbsp;&nbsp;e = open_cb_rec k U C e with open_cs_rec_stmt : ∀ e U C k, &nbsp;&nbsp;stmt e → &nbsp;&nbsp;e = open_cs_rec k U C e. Lemma open_ee_rec_expr : ∀ e U k, &nbsp;&nbsp;expr e → &nbsp;&nbsp;e = open_ee_rec k U e with open_eb_rec_block : ∀ e U k, &nbsp;&nbsp;block e → &nbsp;&nbsp;e = open_eb_rec k U e with open_es_rec_stmt : ∀ e U k, &nbsp;&nbsp;stmt e → &nbsp;&nbsp;e = open_es_rec k U e. Lemma open_be_rec_expr : ∀ e U k, &nbsp;&nbsp;expr e → &nbsp;&nbsp;e = open_be_rec k U e with open_bb_rec_block : ∀ e U k, &nbsp;&nbsp;block e → &nbsp;&nbsp;e = open_bb_rec k U e with open_bs_rec_stmt : ∀ e U k, &nbsp;&nbsp;stmt e → &nbsp;&nbsp;e = open_bs_rec k U e. ************************************ Substitution / Opening Lemmas ************************************ Lemma subst_ee_open_ee_rec : ∀ e1 e2 x u k, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_ee x u (open_ee_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_ee_rec k (subst_ee x u e2) (subst_ee x u e1) with subst_eb_open_eb_rec : ∀ e1 e2 x u k, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_eb x u (open_eb_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_eb_rec k (subst_ee x u e2) (subst_eb x u e1) with subst_es_open_es_rec : ∀ e1 e2 x u k, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_es x u (open_es_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_es_rec k (subst_ee x u e2) (subst_es x u e1). Lemma subst_ee_open_ee : ∀ e1 e2 x u, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_ee x u (open_ee e1 e2) = &nbsp;&nbsp;&nbsp;&nbsp;open_ee (subst_ee x u e1) (subst_ee x u e2) with subst_eb_open_eb : ∀ e1 e2 x u, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_eb x u (open_eb e1 e2) = &nbsp;&nbsp;&nbsp;&nbsp;open_eb (subst_eb x u e1) (subst_ee x u e2) with subst_es_open_es : ∀ e1 e2 x u, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_es x u (open_es e1 e2) = &nbsp;&nbsp;&nbsp;&nbsp;open_es (subst_es x u e1) (subst_ee x u e2). Lemma subst_ee_open_ee_var : ∀ (x y:atom) u e, &nbsp;&nbsp;y ≠ x → &nbsp;&nbsp;expr u → &nbsp;&nbsp;open_ee (subst_ee x u e) y = subst_ee x u (open_ee e y) with subst_eb_open_eb_var : ∀ (x y:atom) u e, &nbsp;&nbsp;y ≠ x → &nbsp;&nbsp;expr u → &nbsp;&nbsp;open_eb (subst_eb x u e) y = subst_eb x u (open_eb e y) with subst_es_open_es_var : ∀ (x y:atom) u e, &nbsp;&nbsp;y ≠ x → &nbsp;&nbsp;expr u → &nbsp;&nbsp;open_es (subst_es x u e) y = subst_es x u (open_es e y). Lemma subst_ee_open_ce_rec : ∀ e f C x u k, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_ee x u (open_ce_rec k f C e) = &nbsp;&nbsp;&nbsp;&nbsp;open_ce_rec k (subst_eb x u f) C (subst_ee x u e) with subst_eb_open_cb_rec : ∀ e f C x u k, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_eb x u (open_cb_rec k f C e) = &nbsp;&nbsp;&nbsp;&nbsp;open_cb_rec k (subst_eb x u f) C (subst_eb x u e) with subst_es_open_cs_rec : ∀ e f C x u k, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_es x u (open_cs_rec k f C e) = &nbsp;&nbsp;&nbsp;&nbsp;open_cs_rec k (subst_eb x u f) C (subst_es x u e). Lemma subst_ee_open_ce : ∀ e f C x u, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_ee x u (open_ce e f C) = open_ce (subst_ee x u e) (subst_eb x u f) C with subst_eb_open_cb : ∀ e f C x u, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_eb x u (open_cb e f C) = open_cb (subst_eb x u e) (subst_eb x u f) C with subst_es_open_cs : ∀ e f C x u, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_es x u (open_cs e f C) = open_cs (subst_es x u e) (subst_eb x u f) C. Lemma subst_ee_open_ce_var : ∀ e x (y : atom) u, &nbsp;&nbsp;expr u → &nbsp;&nbsp;open_ce (subst_ee x u e) y (cset_fvar y) = subst_ee x u (open_ce e y (cset_fvar y)) with subst_eb_open_cb_var : ∀ e x (y : atom) u, &nbsp;&nbsp;expr u → &nbsp;&nbsp;open_cb (subst_eb x u e) y (cset_fvar y) = subst_eb x u (open_cb e y (cset_fvar y)) with subst_es_open_cs_var : ∀ e x (y : atom) u, &nbsp;&nbsp;expr u → &nbsp;&nbsp;open_cs (subst_es x u e) y (cset_fvar y) = subst_es x u (open_cs e y (cset_fvar y)). Lemma subst_ee_open_be_rec : ∀ e f x u k, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_ee x u (open_be_rec k f e) = &nbsp;&nbsp;&nbsp;&nbsp;open_be_rec k (subst_eb x u f) (subst_ee x u e) with subst_eb_open_bb_rec : ∀ e f x u k, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_eb x u (open_bb_rec k f e) = &nbsp;&nbsp;&nbsp;&nbsp;open_bb_rec k (subst_eb x u f) (subst_eb x u e) with subst_es_open_bs_rec : ∀ e f x u k, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_es x u (open_bs_rec k f e) = &nbsp;&nbsp;&nbsp;&nbsp;open_bs_rec k (subst_eb x u f) (subst_es x u e). Lemma subst_ee_open_be : ∀ e f x u, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_ee x u (open_be e f) = open_be (subst_ee x u e) (subst_eb x u f) with subst_eb_open_bb : ∀ e f x u, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_eb x u (open_bb e f) = open_bb (subst_eb x u e) (subst_eb x u f) with subst_es_open_bs : ∀ e f x u, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_es x u (open_bs e f) = open_bs (subst_es x u e) (subst_eb x u f). Lemma subst_ee_open_be_var : ∀ e x (y : atom) u, &nbsp;&nbsp;expr u → &nbsp;&nbsp;open_be (subst_ee x u e) y = subst_ee x u (open_be e y) with subst_eb_open_bb_var : ∀ e x (y : atom) u, &nbsp;&nbsp;expr u → &nbsp;&nbsp;open_bb (subst_eb x u e) y = subst_eb x u (open_bb e y) with subst_es_open_bs_var : ∀ e x (y : atom) u, &nbsp;&nbsp;expr u → &nbsp;&nbsp;open_bs (subst_es x u e) y = subst_es x u (open_bs e y). Lemma subst_be_open_ee_rec : ∀ e1 e2 Z P k, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_be Z P (open_ee_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_ee_rec k (subst_be Z P e2) (subst_be Z P e1) with subst_bb_open_eb_rec : ∀ e1 e2 Z P k, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_bb Z P (open_eb_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_eb_rec k (subst_be Z P e2) (subst_bb Z P e1) with subst_bs_open_es_rec : ∀ e1 e2 Z P k, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_bs Z P (open_es_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_es_rec k (subst_be Z P e2) (subst_bs Z P e1). Lemma subst_be_open_ee : ∀ e1 e2 Z P, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_be Z P (open_ee e1 e2) = open_ee (subst_be Z P e1) (subst_be Z P e2) with subst_bb_open_eb : ∀ e1 e2 Z P, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_bb Z P (open_eb e1 e2) = open_eb (subst_bb Z P e1) (subst_be Z P e2) with subst_bs_open_es : ∀ e1 e2 Z P, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_bs Z P (open_es e1 e2) = open_es (subst_bs Z P e1) (subst_be Z P e2). Lemma subst_be_open_ee_var : ∀ Z (x:atom) P e, &nbsp;&nbsp;block P → &nbsp;&nbsp;open_ee (subst_be Z P e) x = subst_be Z P (open_ee e x) with subst_bb_open_eb_var : ∀ Z (x:atom) P e, &nbsp;&nbsp;block P → &nbsp;&nbsp;open_eb (subst_bb Z P e) x = subst_bb Z P (open_eb e x) with subst_bs_open_es_var : ∀ Z (x:atom) P e, &nbsp;&nbsp;block P → &nbsp;&nbsp;open_es (subst_bs Z P e) x = subst_bs Z P (open_es e x). Lemma subst_be_open_be_rec : ∀ e1 e2 Z P k, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_be Z P (open_be_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_be_rec k (subst_bb Z P e2) (subst_be Z P e1) with subst_bb_open_bb_rec : ∀ e1 e2 Z P k, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_bb Z P (open_bb_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_bb_rec k (subst_bb Z P e2) (subst_bb Z P e1) with subst_bs_open_bs_rec : ∀ e1 e2 Z P k, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_bs Z P (open_bs_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_bs_rec k (subst_bb Z P e2) (subst_bs Z P e1). Lemma subst_be_open_be : ∀ e1 e2 Z P, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_be Z P (open_be e1 e2) = open_be (subst_be Z P e1) (subst_bb Z P e2) with subst_bb_open_bb : ∀ e1 e2 Z P, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_bb Z P (open_bb e1 e2) = open_bb (subst_bb Z P e1) (subst_bb Z P e2) with subst_bs_open_bs : ∀ e1 e2 Z P, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_bs Z P (open_bs e1 e2) = open_bs (subst_bs Z P e1) (subst_bb Z P e2). Lemma subst_be_open_be_var : ∀ Z (x:atom) P e, &nbsp;&nbsp;Z ≠ x → &nbsp;&nbsp;block P → &nbsp;&nbsp;open_be (subst_be Z P e) x = subst_be Z P (open_be e x) with subst_bb_open_bb_var : ∀ Z (x:atom) P e, &nbsp;&nbsp;Z ≠ x → &nbsp;&nbsp;block P → &nbsp;&nbsp;open_bb (subst_bb Z P e) x = subst_bb Z P (open_bb e x) with subst_bs_open_bs_var : ∀ Z (x:atom) P e, &nbsp;&nbsp;Z ≠ x → &nbsp;&nbsp;block P → &nbsp;&nbsp;open_bs (subst_bs Z P e) x = subst_bs Z P (open_bs e x). Lemma subst_ce_open_ee_rec : ∀ e1 e2 Z P C k, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_ce Z P C (open_ee_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_ee_rec k (subst_ce Z P C e2) (subst_ce Z P C e1) with subst_cb_open_eb_rec : ∀ e1 e2 Z P C k, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_cb Z P C (open_eb_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_eb_rec k (subst_ce Z P C e2) (subst_cb Z P C e1) with subst_cs_open_es_rec : ∀ e1 e2 Z P C k, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_cs Z P C (open_es_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_es_rec k (subst_ce Z P C e2) (subst_cs Z P C e1). Lemma subst_ce_open_ee : ∀ e1 e2 Z P C, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_ce Z P C (open_ee e1 e2) = open_ee (subst_ce Z P C e1) (subst_ce Z P C e2) with subst_cb_open_eb : ∀ e1 e2 Z P C, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_cb Z P C (open_eb e1 e2) = open_eb (subst_cb Z P C e1) (subst_ce Z P C e2) with subst_cs_open_es : ∀ e1 e2 Z P C, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_cs Z P C (open_es e1 e2) = open_es (subst_cs Z P C e1) (subst_ce Z P C e2). Lemma subst_ce_open_ee_var : ∀ Z (x:atom) P C e, &nbsp;&nbsp;block P → &nbsp;&nbsp;open_ee (subst_ce Z P C e) x = subst_ce Z P C (open_ee e x) with subst_cb_open_eb_var : ∀ Z (x:atom) P C e, &nbsp;&nbsp;block P → &nbsp;&nbsp;open_eb (subst_cb Z P C e) x = subst_cb Z P C (open_eb e x) with subst_cs_open_es_var : ∀ Z (x:atom) P C e, &nbsp;&nbsp;block P → &nbsp;&nbsp;open_es (subst_cs Z P C e) x = subst_cs Z P C (open_es e x). Lemma subst_be_open_ce_rec : ∀ e1 e2 Z P C k, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_be Z P (open_ce_rec k e2 C e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_ce_rec k (subst_bb Z P e2) C (subst_be Z P e1) with subst_bb_open_cb_rec : ∀ e1 e2 Z P C k, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_bb Z P (open_cb_rec k e2 C e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_cb_rec k (subst_bb Z P e2) C (subst_bb Z P e1) with subst_bs_open_cs_rec : ∀ e1 e2 Z P C k, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_bs Z P (open_cs_rec k e2 C e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_cs_rec k (subst_bb Z P e2) C (subst_bs Z P e1). Lemma subst_be_open_ce : ∀ e1 e2 Z P C, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_be Z P (open_ce e1 e2 C) = open_ce (subst_be Z P e1) (subst_bb Z P e2) C with subst_bb_open_cb : ∀ e1 e2 Z P C, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_bb Z P (open_cb e1 e2 C) = open_cb (subst_bb Z P e1) (subst_bb Z P e2) C with subst_bs_open_cs : ∀ e1 e2 Z P C, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_bs Z P (open_cs e1 e2 C) = open_cs (subst_bs Z P e1) (subst_bb Z P e2) C. Lemma subst_be_open_ce_var : ∀ Z (x:atom) P e, &nbsp;&nbsp;block P → &nbsp;&nbsp;x ≠ Z → &nbsp;&nbsp;open_ce (subst_be Z P e) x (cset_fvar x) = subst_be Z P (open_ce e x (cset_fvar x)) with subst_bb_open_cb_var : ∀ Z (x:atom) P e, &nbsp;&nbsp;block P → &nbsp;&nbsp;x ≠ Z → &nbsp;&nbsp;open_cb (subst_bb Z P e) x (cset_fvar x) = subst_bb Z P (open_cb e x (cset_fvar x)) with subst_bs_open_cs_var : ∀ Z (x:atom) P e, &nbsp;&nbsp;block P → &nbsp;&nbsp;x ≠ Z → &nbsp;&nbsp;open_cs (subst_bs Z P e) x (cset_fvar x) = subst_bs Z P (open_cs e x (cset_fvar x)). Lemma subst_ce_open_be_rec : ∀ e1 e2 Z P C k, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_ce Z P C (open_be_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_be_rec k (subst_cb Z P C e2) (subst_ce Z P C e1) with subst_cb_open_bb_rec : ∀ e1 e2 Z P C k, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_cb Z P C (open_bb_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_bb_rec k (subst_cb Z P C e2) (subst_cb Z P C e1) with subst_cs_open_bs_rec : ∀ e1 e2 Z P C k, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_cs Z P C (open_bs_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_bs_rec k (subst_cb Z P C e2) (subst_cs Z P C e1). Lemma subst_ce_open_be : ∀ e1 e2 Z P C, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_ce Z P C (open_be e1 e2) = open_be (subst_ce Z P C e1) (subst_cb Z P C e2) with subst_cb_open_bb : ∀ e1 e2 Z P C, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_cb Z P C (open_bb e1 e2) = open_bb (subst_cb Z P C e1) (subst_cb Z P C e2) with subst_cs_open_bs : ∀ e1 e2 Z P C, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_cs Z P C (open_bs e1 e2) = open_bs (subst_cs Z P C e1) (subst_cb Z P C e2). Lemma subst_ce_open_be_var : ∀ Z (x:atom) P C e, &nbsp;&nbsp;block P → &nbsp;&nbsp;x ≠ Z → &nbsp;&nbsp;open_be (subst_ce Z P C e) x = subst_ce Z P C (open_be e x) with subst_cb_open_bb_var : ∀ Z (x:atom) P C e, &nbsp;&nbsp;block P → &nbsp;&nbsp;x ≠ Z → &nbsp;&nbsp;open_bb (subst_cb Z P C e) x = subst_cb Z P C (open_bb e x) with subst_cs_open_bs_var : ∀ Z (x:atom) P C e, &nbsp;&nbsp;block P → &nbsp;&nbsp;x ≠ Z → &nbsp;&nbsp;open_bs (subst_cs Z P C e) x = subst_cs Z P C (open_bs e x). Lemma subst_cvt_open_cvt_rec : ∀ T C1 C2 X k, &nbsp;&nbsp;capt C1 → &nbsp;&nbsp;subst_cvt X C1 (open_cvt_rec k C2 T) = &nbsp;&nbsp;&nbsp;&nbsp;open_cvt_rec k (subst_cset X C1 C2) (subst_cvt X C1 T) with subst_cbt_open_cbt_rec : ∀ T C1 C2 X k, &nbsp;&nbsp;capt C1 → &nbsp;&nbsp;subst_cbt X C1 (open_cbt_rec k C2 T) = &nbsp;&nbsp;&nbsp;&nbsp;open_cbt_rec k (subst_cset X C1 C2) (subst_cbt X C1 T). Lemma subst_cvt_open_cvt : ∀ T C1 C2 X, &nbsp;&nbsp;capt C1 → &nbsp;&nbsp;subst_cvt X C1 (open_cvt T C2) = &nbsp;&nbsp;&nbsp;&nbsp;open_cvt (subst_cvt X C1 T) (subst_cset X C1 C2) with subst_cbt_open_cbt : ∀ T C1 C2 X, &nbsp;&nbsp;capt C1 → &nbsp;&nbsp;subst_cbt X C1 (open_cbt T C2) = &nbsp;&nbsp;&nbsp;&nbsp;open_cbt (subst_cbt X C1 T) (subst_cset X C1 C2). Lemma subst_cvt_open_cvt_var : ∀ T C1 X (x:atom), &nbsp;&nbsp;x ≠ X → &nbsp;&nbsp;capt C1 → &nbsp;&nbsp;subst_cvt X C1 (open_cvt T (cset_fvar x)) = &nbsp;&nbsp;&nbsp;&nbsp;open_cvt (subst_cvt X C1 T) (cset_fvar x) with subst_cbt_open_cbt_var : ∀ T C1 X (x:atom), &nbsp;&nbsp;x ≠ X → &nbsp;&nbsp;capt C1 → &nbsp;&nbsp;subst_cbt X C1 (open_cbt T (cset_fvar x)) = &nbsp;&nbsp;&nbsp;&nbsp;open_cbt (subst_cbt X C1 T) (cset_fvar x). Lemma subst_ce_open_ce_rec : ∀ e1 e2 Z P C D k, &nbsp;&nbsp;block P → &nbsp;&nbsp;capt D → &nbsp;&nbsp;subst_ce Z P D (open_ce_rec k e2 C e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_ce_rec k (subst_cb Z P D e2) (subst_cset Z D C) (subst_ce Z P D e1) with subst_cb_open_cb_rec : ∀ e1 e2 Z P C D k, &nbsp;&nbsp;block P → &nbsp;&nbsp;capt D → &nbsp;&nbsp;subst_cb Z P D (open_cb_rec k e2 C e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_cb_rec k (subst_cb Z P D e2) (subst_cset Z D C) (subst_cb Z P D e1) with subst_cs_open_cs_rec : ∀ e1 e2 Z P C D k, &nbsp;&nbsp;block P → &nbsp;&nbsp;capt D → &nbsp;&nbsp;subst_cs Z P D (open_cs_rec k e2 C e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_cs_rec k (subst_cb Z P D e2) (subst_cset Z D C) (subst_cs Z P D e1). Lemma subst_ce_open_ce : ∀ e1 e2 Z P C D, &nbsp;&nbsp;block P → &nbsp;&nbsp;capt D → &nbsp;&nbsp;subst_ce Z P D (open_ce e1 e2 C) = open_ce (subst_ce Z P D e1) (subst_cb Z P D e2) (subst_cset Z D C) with subst_cb_open_cb : ∀ e1 e2 Z P C D, &nbsp;&nbsp;block P → &nbsp;&nbsp;capt D → &nbsp;&nbsp;subst_cb Z P D (open_cb e1 e2 C) = open_cb (subst_cb Z P D e1) (subst_cb Z P D e2) (subst_cset Z D C) with subst_cs_open_cs : ∀ e1 e2 Z P C D, &nbsp;&nbsp;block P → &nbsp;&nbsp;capt D → &nbsp;&nbsp;subst_cs Z P D (open_cs e1 e2 C) = open_cs (subst_cs Z P D e1) (subst_cb Z P D e2) (subst_cset Z D C). Lemma subst_ce_open_ce_var : ∀ Z (x:atom) P e D, &nbsp;&nbsp;block P → &nbsp;&nbsp;capt D → &nbsp;&nbsp;x ≠ Z → &nbsp;&nbsp;open_ce (subst_ce Z P D e) x (cset_fvar x) = subst_ce Z P D (open_ce e x (cset_fvar x)) with subst_cb_open_cb_var : ∀ Z (x:atom) P e D, &nbsp;&nbsp;block P → &nbsp;&nbsp;capt D → &nbsp;&nbsp;x ≠ Z → &nbsp;&nbsp;open_cb (subst_cb Z P D e) x (cset_fvar x) = subst_cb Z P D (open_cb e x (cset_fvar x)) with subst_cs_open_cs_var : ∀ Z (x:atom) P e D, &nbsp;&nbsp;block P → &nbsp;&nbsp;capt D → &nbsp;&nbsp;x ≠ Z → &nbsp;&nbsp;open_cs (subst_cs Z P D e) x (cset_fvar x) = subst_cs Z P D (open_cs e x (cset_fvar x)). Lemma subst_te_open_ee_rec : ∀ e1 e2 X U k, &nbsp;&nbsp;subst_te X U (open_ee_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_ee_rec k (subst_te X U e2) (subst_te X U e1) with subst_tb_open_eb_rec : ∀ e1 e2 X U k, &nbsp;&nbsp;subst_tb X U (open_eb_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_eb_rec k (subst_te X U e2) (subst_tb X U e1) with subst_ts_open_es_rec : ∀ e1 e2 X U k, &nbsp;&nbsp;subst_ts X U (open_es_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_es_rec k (subst_te X U e2) (subst_ts X U e1). Lemma subst_te_open_ee : ∀ e1 e2 X U, &nbsp;&nbsp;subst_te X U (open_ee e1 e2) = &nbsp;&nbsp;&nbsp;&nbsp;open_ee (subst_te X U e1) (subst_te X U e2) with subst_tb_open_eb : ∀ e1 e2 X U, &nbsp;&nbsp;subst_tb X U (open_eb e1 e2) = &nbsp;&nbsp;&nbsp;&nbsp;open_eb (subst_tb X U e1) (subst_te X U e2) with subst_ts_open_es : ∀ e1 e2 X U, &nbsp;&nbsp;subst_ts X U (open_es e1 e2) = &nbsp;&nbsp;&nbsp;&nbsp;open_es (subst_ts X U e1) (subst_te X U e2). Lemma subst_te_open_be_rec : ∀ e1 e2 X U k, &nbsp;&nbsp;subst_te X U (open_be_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_be_rec k (subst_tb X U e2) (subst_te X U e1) with subst_tb_open_bb_rec : ∀ e1 e2 X U k, &nbsp;&nbsp;subst_tb X U (open_bb_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_bb_rec k (subst_tb X U e2) (subst_tb X U e1) with subst_ts_open_bs_rec : ∀ e1 e2 X U k, &nbsp;&nbsp;subst_ts X U (open_bs_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_bs_rec k (subst_tb X U e2) (subst_ts X U e1). Lemma subst_te_open_be : ∀ e1 e2 X U, &nbsp;&nbsp;subst_te X U (open_be e1 e2) = &nbsp;&nbsp;&nbsp;&nbsp;open_be (subst_te X U e1) (subst_tb X U e2) with subst_tb_open_bb : ∀ e1 e2 X U, &nbsp;&nbsp;subst_tb X U (open_bb e1 e2) = &nbsp;&nbsp;&nbsp;&nbsp;open_bb (subst_tb X U e1) (subst_tb X U e2) with subst_ts_open_bs : ∀ e1 e2 X U, &nbsp;&nbsp;subst_ts X U (open_bs e1 e2) = &nbsp;&nbsp;&nbsp;&nbsp;open_bs (subst_ts X U e1) (subst_tb X U e2). Lemma subst_tvt_intro_rec : ∀ X T U k, &nbsp;&nbsp;X `notin` fv_tvt T → &nbsp;&nbsp;open_tvt_rec k U T = subst_tvt X U (open_tvt_rec k X T) with subst_tbt_intro_rec : ∀ X T U k, &nbsp;&nbsp;X `notin` fv_tbt T → &nbsp;&nbsp;open_tbt_rec k U T = subst_tbt X U (open_tbt_rec k X T). Lemma subst_te_intro_rec : ∀ X e T k, &nbsp;&nbsp;X `notin` fv_te e → &nbsp;&nbsp;open_te_rec k T e = subst_te X T (open_te_rec k X e) with subst_ts_intro_rec : ∀ X e T k, &nbsp;&nbsp;X `notin` fv_ts e → &nbsp;&nbsp;open_ts_rec k T e = subst_ts X T (open_ts_rec k X e) with subst_tb_intro_rec : ∀ X e T k, &nbsp;&nbsp;X `notin` fv_tb e → &nbsp;&nbsp;open_tb_rec k T e = subst_tb X T (open_tb_rec k X e). Lemma subst_be_fresh : ∀ a s1 s2, &nbsp;&nbsp;a `notin` fv_be s2 → &nbsp;&nbsp;subst_be a s1 s2 = s2 with subst_bs_fresh : ∀ a s1 s2, &nbsp;&nbsp;a `notin` fv_bs s2 → &nbsp;&nbsp;subst_bs a s1 s2 = s2 with subst_bb_fresh : ∀ a s1 s2, &nbsp;&nbsp;a `notin` fv_bb s2 → &nbsp;&nbsp;subst_bb a s1 s2 = s2. Lemma subst_ee_fresh : ∀ a s1 s2, &nbsp;&nbsp;a `notin` fv_ee s2 → &nbsp;&nbsp;subst_ee a s1 s2 = s2 with subst_es_fresh : ∀ a s1 s2, &nbsp;&nbsp;a `notin` fv_es s2 → &nbsp;&nbsp;subst_es a s1 s2 = s2 with subst_eb_fresh : ∀ a s1 s2, &nbsp;&nbsp;a `notin` fv_eb s2 → &nbsp;&nbsp;subst_eb a s1 s2 = s2. Lemma subst_ee_through_subst_be : ∀ a1 a2 s1 s2 s, &nbsp;&nbsp;a1 `notin` (fv_eb s1 `union` fv_bb s1 `union` fv_be s2 `union` singleton a2) → &nbsp;&nbsp;a2 `notin` (fv_eb s1 `union` fv_bb s1 `union` fv_be s2 `union` singleton a1) → &nbsp;&nbsp;subst_be a1 s1 (subst_ee a2 s2 s) = subst_ee a2 s2 (subst_be a1 s1 s) with subst_es_through_subst_bs : ∀ a1 a2 s1 s2 s, &nbsp;&nbsp;a1 `notin` (fv_eb s1 `union` fv_bb s1 `union` fv_be s2 `union` singleton a2) → &nbsp;&nbsp;a2 `notin` (fv_eb s1 `union` fv_bb s1 `union` fv_be s2 `union` singleton a1) → &nbsp;&nbsp;subst_bs a1 s1 (subst_es a2 s2 s) = subst_es a2 s2 (subst_bs a1 s1 s) with subst_eb_through_subst_bb : ∀ a1 a2 s1 s2 s, &nbsp;&nbsp;a1 `notin` (fv_eb s1 `union` fv_bb s1 `union` fv_be s2 `union` singleton a2) → &nbsp;&nbsp;a2 `notin` (fv_eb s1 `union` fv_bb s1 `union` fv_be s2 `union` singleton a1) → &nbsp;&nbsp;subst_bb a1 s1 (subst_eb a2 s2 s) = subst_eb a2 s2 (subst_bb a1 s1 s). Lemma subst_tvt_intro : ∀ X T2 U, &nbsp;&nbsp;X `notin` fv_tvt T2 → &nbsp;&nbsp;open_tvt T2 U = subst_tvt X U (open_tvt T2 X) with subst_tbt_intro : ∀ X T2 U, &nbsp;&nbsp;X `notin` fv_tbt T2 → &nbsp;&nbsp;open_tbt T2 U = subst_tbt X U (open_tbt T2 X). Lemma open_tvt_rec_type_aux : ∀ T j V i U, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;open_tvt_rec j V T = open_tvt_rec i U (open_tvt_rec j V T) → &nbsp;&nbsp;T = open_tvt_rec i U T with open_tbt_rec_type_aux : ∀ T j V i U, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;open_tbt_rec j V T = open_tbt_rec i U (open_tbt_rec j V T) → &nbsp;&nbsp;T = open_tbt_rec i U T. Lemma open_tvt_rec_capt_aux : ∀ T j C i U, &nbsp;&nbsp;open_cvt_rec j C T = open_tvt_rec i U (open_cvt_rec j C T) → &nbsp;&nbsp;T = open_tvt_rec i U T with open_tbt_rec_capt_aux : ∀ T j C i U, &nbsp;&nbsp;open_cbt_rec j C T = open_tbt_rec i U (open_cbt_rec j C T) → &nbsp;&nbsp;T = open_tbt_rec i U T. Lemma open_tvt_rec_vtype : ∀ T U k, &nbsp;&nbsp;vtype T → &nbsp;&nbsp;T = open_tvt_rec k U T with open_tbt_rec_btype : ∀ T U k, &nbsp;&nbsp;btype T → &nbsp;&nbsp;T = open_tbt_rec k U T. Lemma subst_tvt_open_tvt_rec : ∀ T1 T2 X P k, &nbsp;&nbsp;vtype P → &nbsp;&nbsp;subst_tvt X P (open_tvt_rec k T2 T1) = &nbsp;&nbsp;&nbsp;&nbsp;open_tvt_rec k (subst_tvt X P T2) (subst_tvt X P T1) with subst_tbt_open_tbt_rec : ∀ T1 T2 X P k, &nbsp;&nbsp;vtype P → &nbsp;&nbsp;subst_tbt X P (open_tbt_rec k T2 T1) = &nbsp;&nbsp;&nbsp;&nbsp;open_tbt_rec k (subst_tvt X P T2) (subst_tbt X P T1). Lemma subst_tvt_open_tvt_var : ∀ (X Y:atom) P T, &nbsp;&nbsp;Y ≠ X → &nbsp;&nbsp;vtype P → &nbsp;&nbsp;open_tvt (subst_tvt X P T) Y = subst_tvt X P (open_tvt T Y) with subst_tbt_open_tbt_var : ∀ (X Y:atom) P T, &nbsp;&nbsp;Y ≠ X → &nbsp;&nbsp;vtype P → &nbsp;&nbsp;open_tbt (subst_tbt X P T) Y = subst_tbt X P (open_tbt T Y). Lemma subst_tvt_open_cvt_rec : ∀ T1 C X P k, &nbsp;&nbsp;vtype P → &nbsp;&nbsp;subst_tvt X P (open_cvt_rec k C T1) = &nbsp;&nbsp;&nbsp;&nbsp;open_cvt_rec k C (subst_tvt X P T1) with subst_tbt_open_cbt_rec : ∀ T1 C X P k, &nbsp;&nbsp;vtype P → &nbsp;&nbsp;subst_tbt X P (open_cbt_rec k C T1) = &nbsp;&nbsp;&nbsp;&nbsp;open_cbt_rec k C (subst_tbt X P T1). Lemma subst_tvt_open_cvt_var : ∀ (X Y:atom) P T, &nbsp;&nbsp;vtype P → &nbsp;&nbsp;open_cvt (subst_tvt X P T) (cset_fvar Y) = &nbsp;&nbsp;&nbsp;&nbsp;subst_tvt X P (open_cvt T (cset_fvar Y)) with subst_tbt_open_cbt_var : ∀ (X Y:atom) P T, &nbsp;&nbsp;vtype P → &nbsp;&nbsp;open_cbt (subst_tbt X P T) (cset_fvar Y) = &nbsp;&nbsp;&nbsp;&nbsp;subst_tbt X P (open_cbt T (cset_fvar Y)). Lemma subst_cvt_fresh : ∀ X C T, &nbsp;&nbsp;X `notin` fv_cvt T → &nbsp;&nbsp;T = subst_cvt X C T with subst_cbt_fresh : ∀ X C T, &nbsp;&nbsp;X `notin` fv_cbt T → &nbsp;&nbsp;T = subst_cbt X C T. Lemma subst_cvt_open_tvt_rec : ∀ T C1 U X k, &nbsp;&nbsp;capt C1 → &nbsp;&nbsp;subst_cvt X C1 (open_tvt_rec k U T) = &nbsp;&nbsp;&nbsp;&nbsp;open_tvt_rec k (subst_cvt X C1 U) (subst_cvt X C1 T) with subst_cbt_open_tbt_rec : ∀ T C1 U X k, &nbsp;&nbsp;capt C1 → &nbsp;&nbsp;subst_cbt X C1 (open_tbt_rec k U T) = &nbsp;&nbsp;&nbsp;&nbsp;open_tbt_rec k (subst_cvt X C1 U) (subst_cbt X C1 T). Lemma subst_cvt_open_tvt : ∀ T C1 U X, &nbsp;&nbsp;capt C1 → &nbsp;&nbsp;subst_cvt X C1 (open_tvt T U) = &nbsp;&nbsp;&nbsp;&nbsp;open_tvt (subst_cvt X C1 T) (subst_cvt X C1 U) with subst_cbt_open_tbt : ∀ T C1 U X, &nbsp;&nbsp;capt C1 → &nbsp;&nbsp;subst_cbt X C1 (open_tbt T U) = &nbsp;&nbsp;&nbsp;&nbsp;open_tbt (subst_cbt X C1 T) (subst_cvt X C1 U). Lemma subst_cvt_open_tvt_var : ∀ T C1 X Y, &nbsp;&nbsp;Y ≠ X → &nbsp;&nbsp;capt C1 → &nbsp;&nbsp;subst_cvt X C1 (open_tvt T Y) = &nbsp;&nbsp;&nbsp;&nbsp;open_tvt (subst_cvt X C1 T) Y with subst_cbt_open_tbt_var : ∀ T C1 X Y, &nbsp;&nbsp;Y ≠ X → &nbsp;&nbsp;capt C1 → &nbsp;&nbsp;subst_cbt X C1 (open_tbt T Y) = &nbsp;&nbsp;&nbsp;&nbsp;open_tbt (subst_cbt X C1 T) Y. Lemma subst_tvt_open_cvt : ∀ T1 C X P, &nbsp;&nbsp;vtype P → &nbsp;&nbsp;subst_tvt X P (open_cvt T1 C) = &nbsp;&nbsp;&nbsp;&nbsp;open_cvt (subst_tvt X P T1) C with subst_tbt_open_cbt : ∀ T1 C X P, &nbsp;&nbsp;vtype P → &nbsp;&nbsp;subst_tbt X P (open_cbt T1 C) = &nbsp;&nbsp;&nbsp;&nbsp;open_cbt (subst_tbt X P T1) C. Lemma subst_te_open_ce_rec : ∀ e1 e2 C X U k, &nbsp;&nbsp;vtype U → &nbsp;&nbsp;subst_te X U (open_ce_rec k e2 C e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_ce_rec k (subst_tb X U e2) C (subst_te X U e1) with subst_tb_open_cb_rec : ∀ e1 e2 C X U k, &nbsp;&nbsp;vtype U → &nbsp;&nbsp;subst_tb X U (open_cb_rec k e2 C e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_cb_rec k (subst_tb X U e2) C (subst_tb X U e1) with subst_ts_open_cs_rec : ∀ e1 e2 C X U k, &nbsp;&nbsp;vtype U → &nbsp;&nbsp;subst_ts X U (open_cs_rec k e2 C e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_cs_rec k (subst_tb X U e2) C (subst_ts X U e1). Lemma subst_te_open_ce : ∀ e1 e2 C X U, &nbsp;&nbsp;vtype U → &nbsp;&nbsp;subst_te X U (open_ce e1 e2 C) = &nbsp;&nbsp;&nbsp;&nbsp;open_ce (subst_te X U e1) (subst_tb X U e2) C with subst_tb_open_cb : ∀ e1 e2 C X U, &nbsp;&nbsp;vtype U → &nbsp;&nbsp;subst_tb X U (open_cb e1 e2 C) = &nbsp;&nbsp;&nbsp;&nbsp;open_cb (subst_tb X U e1) (subst_tb X U e2) C with subst_ts_open_cs : ∀ e1 e2 C X U, &nbsp;&nbsp;vtype U → &nbsp;&nbsp;subst_ts X U (open_cs e1 e2 C) = &nbsp;&nbsp;&nbsp;&nbsp;open_cs (subst_ts X U e1) (subst_tb X U e2) C. Lemma subst_tvt_open_tvt : ∀ T1 T2 X P, &nbsp;&nbsp;vtype P → &nbsp;&nbsp;subst_tvt X P (open_tvt T1 T2) = &nbsp;&nbsp;&nbsp;&nbsp;open_tvt (subst_tvt X P T1) (subst_tvt X P T2) with subst_tbt_open_tbt : ∀ T1 T2 X P, &nbsp;&nbsp;vtype P → &nbsp;&nbsp;subst_tbt X P (open_tbt T1 T2) = &nbsp;&nbsp;&nbsp;&nbsp;open_tbt (subst_tbt X P T1) (subst_tvt X P T2). Lemma subst_tvt_fresh : ∀ X U T, &nbsp;&nbsp;X `notin` fv_tvt T → &nbsp;&nbsp;T = subst_tvt X U T with subst_tbt_fresh : ∀ X U T, &nbsp;&nbsp;X `notin` fv_tbt T → &nbsp;&nbsp;T = subst_tbt X U T. Lemma subst_te_intro : ∀ x e u, &nbsp;&nbsp;x `notin` fv_te e → &nbsp;&nbsp;open_te e u = subst_te x u (open_te e x) with subst_ts_intro : ∀ x e u, &nbsp;&nbsp;x `notin` fv_ts e → &nbsp;&nbsp;open_ts e u = subst_ts x u (open_ts e x) with subst_tb_intro : ∀ x e u, &nbsp;&nbsp;x `notin` fv_tb e → &nbsp;&nbsp;open_tb e u = subst_tb x u (open_tb e x). Lemma subst_te_open_te_rec : ∀ e1 W X U k, &nbsp;&nbsp;vtype U → &nbsp;&nbsp;subst_te X U (open_te_rec k W e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_te_rec k (subst_tvt X U W) (subst_te X U e1) with subst_tb_open_tb_rec : ∀ e1 W X U k, &nbsp;&nbsp;vtype U → &nbsp;&nbsp;subst_tb X U (open_tb_rec k W e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_tb_rec k (subst_tvt X U W) (subst_tb X U e1) with subst_ts_open_ts_rec : ∀ e1 W X U k, &nbsp;&nbsp;vtype U → &nbsp;&nbsp;subst_ts X U (open_ts_rec k W e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_ts_rec k (subst_tvt X U W) (subst_ts X U e1). Lemma subst_te_open_te : ∀ e1 W X U, &nbsp;&nbsp;vtype U → &nbsp;&nbsp;subst_te X U (open_te e1 W) = &nbsp;&nbsp;&nbsp;&nbsp;open_te (subst_te X U e1) (subst_tvt X U W) with subst_tb_open_tb : ∀ e1 W X U, &nbsp;&nbsp;vtype U → &nbsp;&nbsp;subst_tb X U (open_tb e1 W) = &nbsp;&nbsp;&nbsp;&nbsp;open_tb (subst_tb X U e1) (subst_tvt X U W) with subst_ts_open_ts : ∀ e1 W X U, &nbsp;&nbsp;vtype U → &nbsp;&nbsp;subst_ts X U (open_ts e1 W) = &nbsp;&nbsp;&nbsp;&nbsp;open_ts (subst_ts X U e1) (subst_tvt X U W). Lemma open_te_rec_expr_aux : ∀ e j v T i, &nbsp;&nbsp;open_ee_rec j v e = open_te_rec i T (open_ee_rec j v e) → &nbsp;&nbsp;e = open_te_rec i T e with open_tb_rec_expr_aux : ∀ e j v T i, &nbsp;&nbsp;open_eb_rec j v e = open_tb_rec i T (open_eb_rec j v e) → &nbsp;&nbsp;e = open_tb_rec i T e with open_ts_rec_expr_aux : ∀ e j v T i, &nbsp;&nbsp;open_es_rec j v e = open_ts_rec i T (open_es_rec j v e) → &nbsp;&nbsp;e = open_ts_rec i T e. Lemma open_te_rec_block_aux : ∀ e j v T i, &nbsp;&nbsp;open_be_rec j v e = open_te_rec i T (open_be_rec j v e) → &nbsp;&nbsp;e = open_te_rec i T e with open_tb_rec_block_aux : ∀ e j v T i, &nbsp;&nbsp;open_bb_rec j v e = open_tb_rec i T (open_bb_rec j v e) → &nbsp;&nbsp;e = open_tb_rec i T e with open_ts_rec_block_aux : ∀ e j v T i, &nbsp;&nbsp;open_bs_rec j v e = open_ts_rec i T (open_bs_rec j v e) → &nbsp;&nbsp;e = open_ts_rec i T e. Lemma open_te_rec_capt_aux : ∀ e j C v T i, &nbsp;&nbsp;open_ce_rec j v C e = open_te_rec i T (open_ce_rec j v C e) → &nbsp;&nbsp;e = open_te_rec i T e with open_tb_rec_capt_aux : ∀ e j C v T i, &nbsp;&nbsp;open_cb_rec j v C e = open_tb_rec i T (open_cb_rec j v C e) → &nbsp;&nbsp;e = open_tb_rec i T e with open_ts_rec_capt_aux : ∀ e j C v T i, &nbsp;&nbsp;open_cs_rec j v C e = open_ts_rec i T (open_cs_rec j v C e) → &nbsp;&nbsp;e = open_ts_rec i T e. Lemma open_te_rec_type_aux : ∀ e j U T i, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;open_te_rec j U e = open_te_rec i T (open_te_rec j U e) → &nbsp;&nbsp;e = open_te_rec i T e with open_tb_rec_type_aux : ∀ e j U T i, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;open_tb_rec j U e = open_tb_rec i T (open_tb_rec j U e) → &nbsp;&nbsp;e = open_tb_rec i T e with open_ts_rec_type_aux : ∀ e j U T i, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;open_ts_rec j U e = open_ts_rec i T (open_ts_rec j U e) → &nbsp;&nbsp;e = open_ts_rec i T e. Lemma open_te_rec_expr : ∀ k T e, &nbsp;&nbsp;expr e → &nbsp;&nbsp;e = open_te_rec k T e with open_ts_rec_stmt : ∀ k T e, &nbsp;&nbsp;stmt e → &nbsp;&nbsp;e = open_ts_rec k T e with open_tb_rec_block : ∀ k T e, &nbsp;&nbsp;block e → &nbsp;&nbsp;e = open_tb_rec k T e. Lemma subst_ee_open_te_rec : ∀ e T x u k, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_ee x u (open_te_rec k T e) = &nbsp;&nbsp;&nbsp;&nbsp;open_te_rec k T (subst_ee x u e) with subst_eb_open_tb_rec : ∀ e T x u k, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_eb x u (open_tb_rec k T e) = &nbsp;&nbsp;&nbsp;&nbsp;open_tb_rec k T (subst_eb x u e) with subst_es_open_ts_rec : ∀ e T x u k, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_es x u (open_ts_rec k T e) = &nbsp;&nbsp;&nbsp;&nbsp;open_ts_rec k T (subst_es x u e). Lemma subst_ee_open_te: ∀ e T x u, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_ee x u (open_te e T) = &nbsp;&nbsp;&nbsp;&nbsp;open_te (subst_ee x u e) T with subst_eb_open_tb : ∀ e T x u, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_eb x u (open_tb e T) = &nbsp;&nbsp;&nbsp;&nbsp;open_tb (subst_eb x u e) T with subst_es_open_ts: ∀ e T x u, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_es x u (open_ts e T) = &nbsp;&nbsp;&nbsp;&nbsp;open_ts (subst_es x u e) T. Lemma subst_ee_open_te_var : ∀ (x y:atom) u e, &nbsp;&nbsp;y ≠ x → &nbsp;&nbsp;expr u → &nbsp;&nbsp;open_te (subst_ee x u e) y = subst_ee x u (open_te e y) with subst_eb_open_tb_var : ∀ (x y:atom) u e, &nbsp;&nbsp;y ≠ x → &nbsp;&nbsp;expr u → &nbsp;&nbsp;open_tb (subst_eb x u e) y = subst_eb x u (open_tb e y) with subst_es_open_ts_var : ∀ (x y:atom) u e, &nbsp;&nbsp;y ≠ x → &nbsp;&nbsp;expr u → &nbsp;&nbsp;open_ts (subst_es x u e) y = subst_es x u (open_ts e y). Lemma subst_be_open_te_rec : ∀ e T x u k, &nbsp;&nbsp;block u → &nbsp;&nbsp;subst_be x u (open_te_rec k T e) = &nbsp;&nbsp;&nbsp;&nbsp;open_te_rec k T (subst_be x u e) with subst_bb_open_tb_rec : ∀ e T x u k, &nbsp;&nbsp;block u → &nbsp;&nbsp;subst_bb x u (open_tb_rec k T e) = &nbsp;&nbsp;&nbsp;&nbsp;open_tb_rec k T (subst_bb x u e) with subst_bs_open_ts_rec : ∀ e T x u k, &nbsp;&nbsp;block u → &nbsp;&nbsp;subst_bs x u (open_ts_rec k T e) = &nbsp;&nbsp;&nbsp;&nbsp;open_ts_rec k T (subst_bs x u e). Lemma subst_be_open_te: ∀ e T x u, &nbsp;&nbsp;block u → &nbsp;&nbsp;subst_be x u (open_te e T) = &nbsp;&nbsp;&nbsp;&nbsp;open_te (subst_be x u e) T with subst_bb_open_tb : ∀ e T x u, &nbsp;&nbsp;block u → &nbsp;&nbsp;subst_bb x u (open_tb e T) = &nbsp;&nbsp;&nbsp;&nbsp;open_tb (subst_bb x u e) T with subst_bs_open_ts: ∀ e T x u, &nbsp;&nbsp;block u → &nbsp;&nbsp;subst_bs x u (open_ts e T) = &nbsp;&nbsp;&nbsp;&nbsp;open_ts (subst_bs x u e) T. Lemma subst_be_open_te_var : ∀ (x y:atom) u e, &nbsp;&nbsp;y ≠ x → &nbsp;&nbsp;block u → &nbsp;&nbsp;open_te (subst_be x u e) y = subst_be x u (open_te e y) with subst_bb_open_tb_var : ∀ (x y:atom) u e, &nbsp;&nbsp;y ≠ x → &nbsp;&nbsp;block u → &nbsp;&nbsp;open_tb (subst_bb x u e) y = subst_bb x u (open_tb e y) with subst_bs_open_ts_var : ∀ (x y:atom) u e, &nbsp;&nbsp;y ≠ x → &nbsp;&nbsp;block u → &nbsp;&nbsp;open_ts (subst_bs x u e) y = subst_bs x u (open_ts e y). Lemma subst_ce_open_te_rec : ∀ e T x u C k, &nbsp;&nbsp;capt C → &nbsp;&nbsp;block u → &nbsp;&nbsp;subst_ce x u C (open_te_rec k T e) = &nbsp;&nbsp;&nbsp;&nbsp;open_te_rec k (subst_cvt x C T) (subst_ce x u C e) with subst_cb_open_tb_rec : ∀ e T x u C k, &nbsp;&nbsp;capt C → &nbsp;&nbsp;block u → &nbsp;&nbsp;subst_cb x u C (open_tb_rec k T e) = &nbsp;&nbsp;&nbsp;&nbsp;open_tb_rec k (subst_cvt x C T) (subst_cb x u C e) with subst_cs_open_ts_rec : ∀ e T x u C k, &nbsp;&nbsp;capt C → &nbsp;&nbsp;block u → &nbsp;&nbsp;subst_cs x u C (open_ts_rec k T e) = &nbsp;&nbsp;&nbsp;&nbsp;open_ts_rec k (subst_cvt x C T) (subst_cs x u C e). Lemma subst_ce_open_te: ∀ e T x u C, &nbsp;&nbsp;capt C → &nbsp;&nbsp;block u → &nbsp;&nbsp;subst_ce x u C (open_te e T) = &nbsp;&nbsp;&nbsp;&nbsp;open_te (subst_ce x u C e) (subst_cvt x C T) with subst_cb_open_tb : ∀ e T x u C, &nbsp;&nbsp;capt C → &nbsp;&nbsp;block u → &nbsp;&nbsp;subst_cb x u C (open_tb e T) = &nbsp;&nbsp;&nbsp;&nbsp;open_tb (subst_cb x u C e) (subst_cvt x C T) with subst_cs_open_ts: ∀ e T x u C, &nbsp;&nbsp;capt C → &nbsp;&nbsp;block u → &nbsp;&nbsp;subst_cs x u C (open_ts e T) = &nbsp;&nbsp;&nbsp;&nbsp;open_ts (subst_cs x u C e) (subst_cvt x C T). Lemma subst_ce_open_te_var : ∀ (x y:atom) u e C, &nbsp;&nbsp;y ≠ x → &nbsp;&nbsp;capt C → &nbsp;&nbsp;block u → &nbsp;&nbsp;open_te (subst_ce x u C e) y = subst_ce x u C (open_te e y) with subst_cb_open_tb_var : ∀ (x y:atom) u e C, &nbsp;&nbsp;y ≠ x → &nbsp;&nbsp;capt C → &nbsp;&nbsp;block u → &nbsp;&nbsp;open_tb (subst_cb x u C e) y = subst_cb x u C (open_tb e y) with subst_cs_open_ts_var : ∀ (x y:atom) u e C, &nbsp;&nbsp;y ≠ x → &nbsp;&nbsp;capt C → &nbsp;&nbsp;block u → &nbsp;&nbsp;open_ts (subst_cs x u C e) y = subst_cs x u C (open_ts e y). ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Infrastructure.html",
    "relUrl": "/proofs/Top.SystemC.Infrastructure.html"
  },"22": {
    "doc": "Top.SystemC.Lemmas",
    "title": "Top.SystemC.Lemmas",
    "content": "(*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Lemmas.html",
    "relUrl": "/proofs/Top.SystemC.Lemmas.html"
  },"23": {
    "doc": "Top.SystemC.Lemmas",
    "title": " Properties of wf_typ",
    "content": "If a type is well-formed in an environment, then it is locally closed. Lemma capt_from_wf_cap : ∀ E T, &nbsp;&nbsp;wf_cap E T → capt T. Lemma vtype_from_wf_vtyp : ∀ E T, &nbsp;&nbsp;wf_vtyp E T → vtype T with btype_from_wf_btyp : ∀ E T, &nbsp;&nbsp;wf_btyp E T → btype T. The remaining properties are analogous to the properties that we need to show for the typing relations. Lemma wf_cap_subset : ∀ E R R0, &nbsp;&nbsp;R |= R0 → &nbsp;&nbsp;wf_cap E R → &nbsp;&nbsp;wf_cap E R0. Lemma wf_cap_weakening : ∀ T E F G, &nbsp;&nbsp;wf_cap (G ++ E) T → &nbsp;&nbsp;ok (G ++ F ++ E) → &nbsp;&nbsp;wf_cap (G ++ F ++ E) T. Lemma wf_cap_weaken_head : ∀ T E F, &nbsp;&nbsp;wf_cap E T → &nbsp;&nbsp;ok (F ++ E) → &nbsp;&nbsp;wf_cap (F ++ E) T. Lemma wf_cap_bind_head : ∀ E R x S1, &nbsp;&nbsp;ok ([(x, bind_blk S1 tracked)] ++ E) → &nbsp;&nbsp;wf_cap E R → &nbsp;&nbsp;wf_cap ([(x, bind_blk S1 tracked)] ++ E) (cset_union R (cset_fvar x)). Lemma wf_cap_lvar : ∀ E l, &nbsp;&nbsp;wf_cap E (cset_lvar l). Lemma wf_cap_labels : ∀ E c, &nbsp;&nbsp;wf_cap E (from_labels (bound_labels c)). Lemma wf_vtyp_weakening : ∀ T E F G, &nbsp;&nbsp;wf_vtyp (G ++ E) T → &nbsp;&nbsp;ok (G ++ F ++ E) → &nbsp;&nbsp;wf_vtyp (G ++ F ++ E) T with wf_btyp_weakening : ∀ T E F G, &nbsp;&nbsp;wf_btyp (G ++ E) T → &nbsp;&nbsp;ok (G ++ F ++ E) → &nbsp;&nbsp;wf_btyp (G ++ F ++ E) T. Lemma wf_vtyp_weaken_head : ∀ T E F, &nbsp;&nbsp;wf_vtyp E T → &nbsp;&nbsp;ok (F ++ E) → &nbsp;&nbsp;wf_vtyp (F ++ E) T with wf_btyp_weaken_head : ∀ T E F, &nbsp;&nbsp;wf_btyp E T → &nbsp;&nbsp;ok (F ++ E) → &nbsp;&nbsp;wf_btyp (F ++ E) T. Lemma wf_cap_strengthening : ∀ E F x U T, &nbsp;wf_cap (F ++ [(x, bind_val U)] ++ E) T → &nbsp;wf_cap (F ++ E) T. Lemma wf_vtyp_strengthening : ∀ E F x U T, &nbsp;wf_vtyp (F ++ [(x, bind_val U)] ++ E) T → &nbsp;wf_vtyp (F ++ E) T with wf_btyp_strengthening : ∀ E F x U T, &nbsp;&nbsp;wf_btyp (F ++ [(x, bind_val U)] ++ E) T → &nbsp;&nbsp;wf_btyp (F ++ E) T. Lemma wf_cap_strengthening_blk : ∀ E F x U C T, &nbsp;wf_cap (F ++ [(x, bind_blk U (capture C))] ++ E) T → &nbsp;wf_cap (F ++ E) T. Lemma wf_cap_strengthening_typ : ∀ E F X T, &nbsp;wf_cap (F ++ [(X, bind_typ)] ++ E) T → &nbsp;wf_cap (F ++ E) T. Lemma wf_vtyp_strengthening_blk : ∀ E F x U C T, &nbsp;wf_vtyp (F ++ [(x, bind_blk U (capture C))] ++ E) T → &nbsp;wf_vtyp (F ++ E) T with wf_btyp_strengthening_blk : ∀ E F x U C T, &nbsp;&nbsp;wf_btyp (F ++ [(x, bind_blk U (capture C))] ++ E) T → &nbsp;&nbsp;wf_btyp (F ++ E) T. Lemma wf_cap_strengthening_blk_tracked : ∀ E F x U T, &nbsp;&nbsp;x `notin` cset_fvars T → &nbsp;&nbsp;wf_cap (F ++ [(x, bind_blk U tracked)] ++ E) T → &nbsp;&nbsp;wf_cap (F ++ E) T. Lemma notin_fvars_open_cset : ∀ x k T C, &nbsp;&nbsp;x `notin` (cset_fvars T `union` cset_fvars C) → &nbsp;&nbsp;x `notin` cset_fvars (open_cset k T C). Lemma notin_fv_cvt_open_cvt : ∀ x k T C, &nbsp;&nbsp;x `notin` (fv_cvt T `union` cset_fvars C) → &nbsp;&nbsp;x `notin` fv_cvt (open_cvt_rec k C T) with notin_fv_cbt_open_cbt : ∀ x k T C, &nbsp;&nbsp;x `notin` (fv_cbt T `union` cset_fvars C) → &nbsp;&nbsp;x `notin` fv_cbt (open_cbt_rec k C T). Lemma notin_fv_cvt_open_tvt : ∀ x k T U, &nbsp;&nbsp;x `notin` (fv_cvt T `union` fv_cvt U) → &nbsp;&nbsp;x `notin` (fv_cvt (open_tvt_rec k U T)) with notin_fv_cbt_open_tbt : ∀ x k T U, &nbsp;&nbsp;x `notin` (fv_cbt T `union` fv_cvt U) → &nbsp;&nbsp;x `notin` (fv_cbt (open_tbt_rec k U T)). Lemma wf_vtyp_strengthening_blk_tracked : ∀ E F x U T, &nbsp;x `notin` fv_cvt T → &nbsp;wf_vtyp (F ++ [(x, bind_blk U tracked)] ++ E) T → &nbsp;wf_vtyp (F ++ E) T with wf_btyp_strengthening_blk_tracked : ∀ E F x U T, &nbsp;&nbsp;x `notin` fv_cbt T → &nbsp;&nbsp;wf_btyp (F ++ [(x, bind_blk U tracked)] ++ E) T → &nbsp;&nbsp;wf_btyp (F ++ E) T. Lemma wf_cap_subst_tracked : ∀ F E U Z P T, &nbsp;&nbsp;wf_cap (F ++ [(Z, bind_blk U tracked)] ++ E) T → &nbsp;&nbsp;wf_cap E P → &nbsp;&nbsp;ok (map (subst_bbind Z P) F ++ E) → &nbsp;&nbsp;wf_cap (map (subst_bbind Z P) F ++ E) (subst_cset Z P T). Lemma wf_vtyp_subst_tracked : ∀ F E Z U C T, &nbsp;&nbsp;wf_vtyp (F ++ [(Z, bind_blk U tracked)] ++ E) T → &nbsp;&nbsp;wf_cap E C → &nbsp;&nbsp;ok (map (subst_bbind Z C) F ++ E) → &nbsp;&nbsp;ok (F ++ [(Z, bind_blk U tracked)] ++ E) → &nbsp;&nbsp;wf_vtyp (map (subst_bbind Z C) F ++ E) (subst_cvt Z C T) with wf_btyp_subst_tracked : ∀ F E Z U C T, &nbsp;&nbsp;wf_btyp (F ++ [(Z, bind_blk U tracked)] ++ E) T → &nbsp;&nbsp;wf_cap E C → &nbsp;&nbsp;ok (map (subst_bbind Z C) F ++ E) → &nbsp;&nbsp;ok (F ++ [(Z, bind_blk U tracked)] ++ E) → &nbsp;&nbsp;wf_btyp (map (subst_bbind Z C) F ++ E) (subst_cbt Z C T). (*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Lemmas.html",
    "relUrl": "/proofs/Top.SystemC.Lemmas.html"
  },"24": {
    "doc": "Top.SystemC.Lemmas",
    "title": " Properties of wf_env and wf_typ",
    "content": "Lemma ok_from_wf_env : ∀ E, &nbsp;&nbsp;wf_env E → &nbsp;&nbsp;ok E. We add ok_from_wf_env as a hint here since it helps blur the distinction between wf_env and ok in proofs. The lemmas in the Environment library use ok, whereas here we naturally have (or can easily show) the stronger wf_env. Thus, ok_from_wf_env serves as a bridge that allows us to use the environments library. Lemma wf_vtyp_from_binds_typ : ∀ x U E, &nbsp;&nbsp;wf_env E → &nbsp;&nbsp;binds x (bind_val U) E → &nbsp;&nbsp;wf_vtyp E U. Lemma wf_vtyp_from_wf_env_typ : ∀ x T E, &nbsp;&nbsp;wf_env ([(x, bind_val T)] ++ E) → &nbsp;&nbsp;wf_vtyp E T. Lemma wf_btyp_from_binds_blk : ∀ x U Q E, &nbsp;&nbsp;wf_env E → &nbsp;&nbsp;binds x (bind_blk U Q) E → &nbsp;&nbsp;wf_btyp E U. Lemma wf_btyp_from_wf_env_blk : ∀ x T Q E, &nbsp;&nbsp;wf_env ([(x, bind_blk T Q)] ++ E) → &nbsp;&nbsp;wf_btyp E T. Lemma wf_vtyp_from_sig_binds : ∀ Q l T1 T, &nbsp;&nbsp;wf_sig Q → &nbsp;&nbsp;Signatures.binds l (bind_sig T1 T) Q → &nbsp;&nbsp;wf_vtyp empty T. Lemma wf_vtyp_from_sig_binds_val : ∀ Q l T1 T, &nbsp;&nbsp;wf_sig Q → &nbsp;&nbsp;Signatures.binds l (bind_sig T1 T) Q → &nbsp;&nbsp;wf_vtyp empty T1. (*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Lemmas.html",
    "relUrl": "/proofs/Top.SystemC.Lemmas.html"
  },"25": {
    "doc": "Top.SystemC.Lemmas",
    "title": " Properties of wf_env",
    "content": "These properties are analogous to the properties that we need to show for the typing relations. Lemma wf_env_tail : ∀ E F, &nbsp;&nbsp;wf_env (F ++ E) → &nbsp;&nbsp;wf_env E. Lemma wf_env_strengthening : ∀ x T E F, &nbsp;&nbsp;wf_env (F ++ [(x, bind_val T)] ++ E) → &nbsp;&nbsp;wf_env (F ++ E). Lemma wf_env_strengthening_blk : ∀ x S1 C E F, &nbsp;&nbsp;wf_env (F ++ [(x, bind_blk S1 (capture C))] ++ E) → &nbsp;&nbsp;wf_env (F ++ E). Lemma wf_env_subst_tracked : ∀ x U E F C, &nbsp;&nbsp;wf_env (F ++ [(x, bind_blk U tracked)] ++ E) → &nbsp;&nbsp;wf_cap E C → &nbsp;&nbsp;wf_env (map (subst_bbind x C) F ++ E). (*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Lemmas.html",
    "relUrl": "/proofs/Top.SystemC.Lemmas.html"
  },"26": {
    "doc": "Top.SystemC.Lemmas",
    "title": " Environment is unchanged by substitution for a fresh name",
    "content": "Lemma notin_fv_cap_wf : ∀ E (X : atom) C, &nbsp;&nbsp;wf_cap E C → &nbsp;&nbsp;X `notin` dom E → &nbsp;&nbsp;X `notin` cset_fvars C. Lemma notin_cset_fvars_open_cset : ∀ (Y X : atom) k c, &nbsp;&nbsp;X `notin` cset_fvars (open_cset k (cset_fvar Y) c) → &nbsp;&nbsp;X `notin` cset_fvars c. Lemma notin_fv_cvt_open_cvt_rec : ∀ (Y X : atom) k T, &nbsp;&nbsp;X `notin` fv_cvt (open_cvt_rec k (cset_fvar Y) T) → &nbsp;&nbsp;X `notin` fv_cvt T with notin_fv_cbt_open_cbt_rec : ∀ (Y X : atom) k T, &nbsp;&nbsp;X `notin` fv_cbt (open_cbt_rec k (cset_fvar Y) T) → &nbsp;&nbsp;X `notin` fv_cbt T. Lemma notin_fv_cvt_open_tvt_rec : ∀ (Y X : atom) k T, &nbsp;&nbsp;X `notin` fv_cvt (open_tvt_rec k Y T) → &nbsp;&nbsp;X `notin` fv_cvt T with notin_fv_cbt_open_tbt_rec : ∀ (Y X : atom) k T, &nbsp;&nbsp;X `notin` fv_cbt (open_tbt_rec k Y T) → &nbsp;&nbsp;X `notin` fv_cbt T. Lemma notin_fv_cvt_wf : ∀ E (X : atom) T, &nbsp;&nbsp;wf_vtyp E T → &nbsp;&nbsp;X `notin` dom E → &nbsp;&nbsp;X `notin` fv_cvt T with notin_fv_cbt_wf : ∀ E (X : atom) T, &nbsp;&nbsp;wf_btyp E T → &nbsp;&nbsp;X `notin` dom E → &nbsp;&nbsp;X `notin` fv_cbt T. Lemma subst_cvt_fresh_wf_vtyp : ∀ T x C, &nbsp;&nbsp;wf_vtyp empty T → &nbsp;&nbsp;T = subst_cvt x C T. Lemma wf_cset_in_dom : ∀ E C, &nbsp;&nbsp;wf_cap E C → &nbsp;&nbsp;cset_fvars C `subset` dom E. Lemma map_subst_cvt_id : ∀ G Z P, &nbsp;&nbsp;wf_env G → &nbsp;&nbsp;Z `notin` dom G → &nbsp;&nbsp;G = map (subst_bbind Z P) G. Lemma notin_union_split : ∀ x a1 a2, &nbsp;&nbsp;x `notin` (a1 `union` a2) ↔ x `notin` a1 ∧ x `notin` a2. Lemma notin_fv_ee_opened_ee : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_ee s1 → &nbsp;&nbsp;x `notin` fv_ee s2 → &nbsp;&nbsp;x `notin` fv_ee (open_ee_rec k s2 s1) with notin_fv_es_opened_es : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_es s1 → &nbsp;&nbsp;x `notin` fv_ee s2 → &nbsp;&nbsp;x `notin` fv_es (open_es_rec k s2 s1) with notin_fv_eb_opened_eb : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_eb s1 → &nbsp;&nbsp;x `notin` fv_ee s2 → &nbsp;&nbsp;x `notin` fv_eb (open_eb_rec k s2 s1). Lemma notin_fv_be_opened_be : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_be s1 → &nbsp;&nbsp;x `notin` fv_bb s2 → &nbsp;&nbsp;x `notin` fv_be (open_be_rec k s2 s1) with notin_fv_bs_opened_bs : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_bs s1 → &nbsp;&nbsp;x `notin` fv_bb s2 → &nbsp;&nbsp;x `notin` fv_bs (open_bs_rec k s2 s1) with notin_fv_bb_opened_bb : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_bb s1 → &nbsp;&nbsp;x `notin` fv_bb s2 → &nbsp;&nbsp;x `notin` fv_bb (open_bb_rec k s2 s1). Lemma notin_fv_be_opened_ee : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_be s1 → &nbsp;&nbsp;x `notin` fv_be s2 → &nbsp;&nbsp;x `notin` fv_be (open_ee_rec k s2 s1) with notin_fv_bs_opened_es : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_bs s1 → &nbsp;&nbsp;x `notin` fv_be s2 → &nbsp;&nbsp;x `notin` fv_bs (open_es_rec k s2 s1) with notin_fv_bb_opened_eb : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_bb s1 → &nbsp;&nbsp;x `notin` fv_be s2 → &nbsp;&nbsp;x `notin` fv_bb (open_eb_rec k s2 s1). Lemma notin_fv_ee_open_ce : ∀ x k s1 C s2, &nbsp;&nbsp;x `notin` fv_ee (open_ce_rec k s2 C s1) → &nbsp;&nbsp;x `notin` fv_ee s1 with notin_fv_es_open_cs : ∀ x k s1 C s2, &nbsp;&nbsp;x `notin` fv_es (open_cs_rec k s2 C s1) → &nbsp;&nbsp;x `notin` fv_es s1 with notin_fv_eb_open_cb : ∀ x k s1 C s2, &nbsp;&nbsp;x `notin` fv_eb (open_cb_rec k s2 C s1) → &nbsp;&nbsp;x `notin` fv_eb s1. Lemma notin_fv_be_open_ce : ∀ x k s1 C s2, &nbsp;&nbsp;x `notin` fv_be (open_ce_rec k s2 C s1) → &nbsp;&nbsp;x `notin` fv_be s1 with notin_fv_bs_open_cs : ∀ x k s1 C s2, &nbsp;&nbsp;x `notin` fv_bs (open_cs_rec k s2 C s1) → &nbsp;&nbsp;x `notin` fv_bs s1 with notin_fv_bb_open_cb : ∀ x k s1 C s2, &nbsp;&nbsp;x `notin` fv_bb (open_cb_rec k s2 C s1) → &nbsp;&nbsp;x `notin` fv_bb s1. Lemma notin_fv_ee_open_ee : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_ee (open_ee_rec k s2 s1) → &nbsp;&nbsp;x `notin` fv_ee s1 with notin_fv_es_open_es : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_es (open_es_rec k s2 s1) → &nbsp;&nbsp;x `notin` fv_es s1 with notin_fv_eb_open_eb : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_eb (open_eb_rec k s2 s1) → &nbsp;&nbsp;x `notin` fv_eb s1. Lemma notin_fv_be_open_ee : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_be (open_ee_rec k s2 s1) → &nbsp;&nbsp;x `notin` fv_be s1 with notin_fv_bs_open_es : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_bs (open_es_rec k s2 s1) → &nbsp;&nbsp;x `notin` fv_bs s1 with notin_fv_bb_open_eb : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_bb (open_eb_rec k s2 s1) → &nbsp;&nbsp;x `notin` fv_bb s1. Lemma notin_fv_be_open_be : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_be (open_be_rec k s2 s1) → &nbsp;&nbsp;x `notin` fv_be s1 with notin_fv_bs_open_bs : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_bs (open_bs_rec k s2 s1) → &nbsp;&nbsp;x `notin` fv_bs s1 with notin_fv_bb_open_bb : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_bb (open_bb_rec k s2 s1) → &nbsp;&nbsp;x `notin` fv_bb s1. Lemma notin_fv_ee_open_be : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_ee (open_be_rec k s2 s1) → &nbsp;&nbsp;x `notin` fv_ee s1 with notin_fv_es_open_bs : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_es (open_bs_rec k s2 s1) → &nbsp;&nbsp;x `notin` fv_es s1 with notin_fv_eb_open_bb : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_eb (open_bb_rec k s2 s1) → &nbsp;&nbsp;x `notin` fv_eb s1. Lemma notin_fv_ee_open_te : ∀ x k T s, &nbsp;&nbsp;x `notin` fv_ee (open_te_rec k T s) → &nbsp;&nbsp;x `notin` fv_ee s with notin_fv_es_open_ts : ∀ x k T s, &nbsp;&nbsp;x `notin` fv_es (open_ts_rec k T s) → &nbsp;&nbsp;x `notin` fv_es s with notin_fv_eb_open_tb : ∀ x k T s, &nbsp;&nbsp;x `notin` fv_eb (open_tb_rec k T s) → &nbsp;&nbsp;x `notin` fv_eb s. Lemma notin_fv_ee_etyping : ∀ E Q e T x, &nbsp;&nbsp;E ; Q |-exp e ~: T → &nbsp;&nbsp;x `notin` dom E → &nbsp;&nbsp;x `notin` fv_ee e with notin_fv_es_styping : ∀ E R Q e T x, &nbsp;&nbsp;E @ R ; Q |-stm e ~: T → &nbsp;&nbsp;x `notin` dom E → &nbsp;&nbsp;x `notin` fv_es e with notin_fv_eb_btyping : ∀ E R Q e T x, &nbsp;&nbsp;E @ R ; Q |-blk e ~: T → &nbsp;&nbsp;x `notin` dom E → &nbsp;&nbsp;x `notin` fv_eb e. Lemma notin_fv_be_open_te : ∀ x k T s, &nbsp;&nbsp;x `notin` fv_be (open_te_rec k T s) → &nbsp;&nbsp;x `notin` fv_be s with notin_fv_bs_open_ts : ∀ x k T s, &nbsp;&nbsp;x `notin` fv_bs (open_ts_rec k T s) → &nbsp;&nbsp;x `notin` fv_bs s with notin_fv_bb_open_tb : ∀ x k T s, &nbsp;&nbsp;x `notin` fv_bb (open_tb_rec k T s) → &nbsp;&nbsp;x `notin` fv_bb s. Lemma notin_fv_be_etyping : ∀ E Q e T x, &nbsp;&nbsp;E ; Q |-exp e ~: T → &nbsp;&nbsp;x `notin` dom E → &nbsp;&nbsp;x `notin` fv_be e with notin_fv_bs_styping : ∀ E R Q e T x, &nbsp;&nbsp;E @ R ; Q |-stm e ~: T → &nbsp;&nbsp;x `notin` dom E → &nbsp;&nbsp;x `notin` fv_bs e with notin_fv_bb_btyping : ∀ E R Q e T x, &nbsp;&nbsp;E @ R ; Q |-blk e ~: T → &nbsp;&nbsp;x `notin` dom E → &nbsp;&nbsp;x `notin` fv_bb e. Lemma notin_fv_tvt_open_cvt_rec : ∀ (Y X : atom) k T, &nbsp;&nbsp;X `notin` fv_tvt (open_cvt_rec k (cset_fvar Y) T) → &nbsp;&nbsp;X `notin` fv_tvt T with notin_fv_tbt_open_cbt_rec : ∀ (Y X : atom) k T, &nbsp;&nbsp;X `notin` fv_tbt (open_cbt_rec k (cset_fvar Y) T) → &nbsp;&nbsp;X `notin` fv_tbt T. Lemma notin_fv_tvt_open_tvt_rec : ∀ (Y X : atom) k T, &nbsp;&nbsp;X `notin` fv_tvt (open_tvt_rec k Y T) → &nbsp;&nbsp;X `notin` fv_tvt T with notin_fv_tbt_open_tbt_rec : ∀ (Y X : atom) k T, &nbsp;&nbsp;X `notin` fv_tbt (open_tbt_rec k Y T) → &nbsp;&nbsp;X `notin` fv_tbt T. Lemma notin_fv_tvt_wf : ∀ E (X : atom) T, &nbsp;&nbsp;wf_vtyp E T → &nbsp;&nbsp;X `notin` dom E → &nbsp;&nbsp;X `notin` fv_tvt T with notin_fv_tbt_wf : ∀ E (X : atom) T, &nbsp;&nbsp;wf_btyp E T → &nbsp;&nbsp;X `notin` dom E → &nbsp;&nbsp;X `notin` fv_tbt T. Lemma map_subst_tbind_id : ∀ G Z P, &nbsp;&nbsp;wf_env G → &nbsp;&nbsp;Z `notin` dom G → &nbsp;&nbsp;G = map (subst_tbind Z P) G. Lemma wf_cap_subst_tbind : ∀ F E Z P C, &nbsp;&nbsp;wf_cap (F ++ [(Z, bind_typ)] ++ E) C → &nbsp;&nbsp;wf_vtyp E P → &nbsp;&nbsp;ok (F ++ E) → &nbsp;&nbsp;wf_cap (map (subst_tbind Z P) F ++ E) C. Lemma wf_vtyp_subst_tbind : ∀ F E Z P T, &nbsp;&nbsp;wf_vtyp (F ++ [(Z, bind_typ)] ++ E) T → &nbsp;&nbsp;wf_vtyp E P → &nbsp;&nbsp;ok (F ++ E) → &nbsp;&nbsp;wf_vtyp (map (subst_tbind Z P) F ++ E) (subst_tvt Z P T) with wf_btyp_subst_tbind : ∀ F E Z P T, &nbsp;&nbsp;wf_btyp (F ++ [(Z, bind_typ)] ++ E) T → &nbsp;&nbsp;wf_vtyp E P → &nbsp;&nbsp;ok (F ++ E) → &nbsp;&nbsp;wf_btyp (map (subst_tbind Z P) F ++ E) (subst_tbt Z P T). Lemma wf_env_subst_tbind : ∀ X U E F, &nbsp;&nbsp;wf_env (F ++ [(X, bind_typ)] ++ E) → &nbsp;&nbsp;wf_vtyp E U → &nbsp;&nbsp;wf_env (map (subst_tbind X U) F ++ E). Lemma wf_typ_open : ∀ E U T, &nbsp;&nbsp;ok E → &nbsp;&nbsp;wf_btyp E (typ_tfun T) → &nbsp;&nbsp;wf_vtyp E U → &nbsp;&nbsp;wf_btyp E (open_tbt T U). (*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Lemmas.html",
    "relUrl": "/proofs/Top.SystemC.Lemmas.html"
  },"27": {
    "doc": "Top.SystemC.Lemmas",
    "title": " Regularity of relations",
    "content": "Lemma etyping_regular : ∀ E Q e T, &nbsp;&nbsp;E ; Q |-exp e ~: T → &nbsp;&nbsp;wf_env E ∧ expr e ∧ wf_vtyp E T ∧ wf_sig Q with btyping_regular : ∀ E R Q (b : blk) S, &nbsp;&nbsp;E @ R ; Q |-blk b ~: S → &nbsp;&nbsp;wf_env E ∧ block b ∧ wf_btyp E S ∧ wf_cap E R ∧ wf_sig Q with styping_regular : ∀ E R Q s T, &nbsp;&nbsp;E @ R ; Q |-stm s ~: T → &nbsp;&nbsp;wf_env E ∧ stmt s ∧ wf_vtyp E T ∧ wf_cap E R ∧ wf_sig Q. Lemma typing_ctx_regular : ∀ R Q c T, &nbsp;&nbsp;(R ; Q |-ctx c ~: T) → &nbsp;&nbsp;wf_cap empty R ∧ wf_sig Q. Lemma typing_cnt_regular : ∀ C Q c S T, &nbsp;&nbsp;(C ; Q |-cnt c ~: S ~&gt; T) → &nbsp;&nbsp;wf_cap empty C ∧ wf_sig Q. (*&nbsp;***********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Lemmas.html",
    "relUrl": "/proofs/Top.SystemC.Lemmas.html"
  },"28": {
    "doc": "Top.SystemC.Lemmas",
    "title": " Automation",
    "content": "The lemma ok_from_wf_env was already added above as a hint since it helps blur the distinction between wf_env and ok in proofs. As currently stated, the regularity lemmas are ill-suited to be used with auto and eauto since they end in conjunctions. Even if we were, for example, to split sub_regularity into three separate lemmas, the resulting lemmas would be usable only by eauto and there is no guarantee that eauto would be able to find proofs effectively. Thus, the hints below apply the regularity lemmas and type_from_wf_typ to discharge goals about local closure and well-formedness, but in such a way as to minimize proof search. The first hint introduces an wf_env fact into the context. It works well when combined with the lemmas relating wf_env and wf_typ. We choose to use those lemmas explicitly via (auto using ...) tactics rather than add them as hints. When used this way, the explicitness makes the proof more informative rather than more cluttered (with useless details). The other three hints try outright to solve their respective goals. Extra Lemmas using automation concerning plug Lemma notin_fv_es_plug : ∀ k e R C T1 T2 x, &nbsp;&nbsp;R ; C |-cnt k ~: T1 ~&gt; T2 → &nbsp;&nbsp;x `notin` fv_ee e → &nbsp;&nbsp;x `notin` fv_es (plug k e). Lemma notin_fv_bs_plug : ∀ k e R C T1 T2 x, &nbsp;&nbsp;R ; C |-cnt k ~: T1 ~&gt; T2 → &nbsp;&nbsp;x `notin` fv_be e → &nbsp;&nbsp;x `notin` fv_bs (plug k e). ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Lemmas.html",
    "relUrl": "/proofs/Top.SystemC.Lemmas.html"
  },"29": {
    "doc": "Top.SystemC.Soundness",
    "title": "Top.SystemC.Soundness",
    "content": " ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Soundness.html",
    "relUrl": "/proofs/Top.SystemC.Soundness.html"
  },"30": {
    "doc": "Top.SystemC.Soundness",
    "title": "Soundness",
    "content": "The proof of soundness is split the following aspects: . | Substitution. See file SystemC.Substitution. For instance etyping_through_subst_ee shows that substituting an expression in an expression preserves expression-typing, and styping_through_subst_bs shows that substituting a block into a statement preserves statement-typing). | Plugging. Lemma 3.4 in the paper is proven (in a variation) by unwind_step. | Preservation. We show type preservation of reducing statements (preservation_stmt) and machine states (preservation_step). | Progress. We show type progress for statements (progress_stmt) and machine states (progress_step). | . ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Soundness.html",
    "relUrl": "/proofs/Top.SystemC.Soundness.html"
  },"31": {
    "doc": "Top.SystemC.Soundness",
    "title": " Context Plugging",
    "content": "This helper lemma is important: it says that given a continuation and some variable x, plugging the variable in the position of the hole is well-typed. This lemma roughly corresponds to Lemma 3.6 in the paper. Lemma unwind_step : ∀ L Q x C T1 T2 k, &nbsp;&nbsp;wf_vtyp empty T1 → &nbsp;&nbsp;wf_cap empty C → &nbsp;&nbsp;C ; Q |-cnt k ~: T1 ~&gt; T2 → &nbsp;&nbsp;x `notin` L → &nbsp;&nbsp;[(x, bind_val T1)] @ C ; Q |-stm (plug k x) ~: T2. Helper lemma showing that plug doesn't introduce binders. Lemma plugging : ∀ (x : atom) k C Q T1 T2, &nbsp;&nbsp;C ; Q |-cnt k ~: T1 ~&gt; T2 → &nbsp;&nbsp;open_es (plug k 0) x = plug k x. ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Soundness.html",
    "relUrl": "/proofs/Top.SystemC.Soundness.html"
  },"32": {
    "doc": "Top.SystemC.Soundness",
    "title": " Preservation",
    "content": "As discussed in SystemC.Definitions, the operational semantics of SystemC is mechanized as an abstract machine, separating redexes that depend on the evaulation context from those that do not. In consequence, the preservation Theorem 3.4 from the paper, maps to two separate theorems in the mechanization: . | preservation_stmt shows that reducing statement regardless of the context preserves the type. | preservation_step shows that stepping from one state to another preserves the typability of the machine state. | . Further more, the pure reductions for expressions (preservation_expr) and blocks (preservation_block) also preserve types, correspondingly. Lemma preservation_block : ∀ E R Q b b' S1, &nbsp;&nbsp;btyping E R Q b S1 → &nbsp;&nbsp;bred b b' → &nbsp;&nbsp;btyping E R Q b' S1. Lemma preservation_expr : ∀ E Q b b' S1, &nbsp;&nbsp;etyping E Q b S1 → &nbsp;&nbsp;ered b b' → &nbsp;&nbsp;etyping E Q b' S1. Lemma preservation_stmt : ∀ E R Q s s' T, &nbsp;&nbsp;styping E R Q s T → &nbsp;&nbsp;sred s s' → &nbsp;&nbsp;styping E R Q s' T. Lemma preservation_step : ∀ s1 s2, &nbsp;&nbsp;typing_state s1 → &nbsp;&nbsp;s1 --&gt; s2 → &nbsp;&nbsp;typing_state s2. ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Soundness.html",
    "relUrl": "/proofs/Top.SystemC.Soundness.html"
  },"33": {
    "doc": "Top.SystemC.Soundness",
    "title": " Progress",
    "content": "Like with preservation, for progress, we have two lemmas: . | progress_stmt shows that a well-typed statement can take a step | progress_step shows that a well-typed machine can take a step | . ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Soundness.html",
    "relUrl": "/proofs/Top.SystemC.Soundness.html"
  },"34": {
    "doc": "Top.SystemC.Soundness",
    "title": "Canonical forms",
    "content": "We start by proving the usual canonical forms lemmas. Lemma canonical_form_tabs : ∀ e T R Q, &nbsp;&nbsp;bvalue e → &nbsp;&nbsp;btyping empty R Q e (typ_tfun T) → &nbsp;&nbsp;∃ e1, e = blk_tabs e1. Lemma canonical_form_vabs : ∀ e U1 U2 R Q, &nbsp;&nbsp;bvalue e → &nbsp;&nbsp;btyping empty R Q e (typ_vfun U1 U2) → &nbsp;&nbsp;∃ V, ∃ e1, e = blk_vabs V e1. Lemma canonical_form_babs : ∀ e U1 U2 R Q, &nbsp;&nbsp;bvalue e → &nbsp;&nbsp;btyping empty R Q e (typ_bfun U1 U2) → &nbsp;&nbsp;∃ V, ∃ e1, e = blk_babs V e1. Lemma canonical_form_box : ∀ e R Q C, &nbsp;&nbsp;evalue e → &nbsp;&nbsp;etyping empty Q e (typ_capt R C) → &nbsp;&nbsp;∃ s, e = exp_box C s. Note that due to the slightly different representation of capability-types, we also have canonical forms for those Lemma canonical_form_exc : ∀ b R Q T1 T, &nbsp;&nbsp;bvalue b → &nbsp;&nbsp;empty @ R ; Q |-blk b ~: (typ_exc T1 T) → &nbsp;&nbsp;∃ l, b = blk_handler l ∧ Signatures.binds l (bind_sig T1 T) Q. ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Soundness.html",
    "relUrl": "/proofs/Top.SystemC.Soundness.html"
  },"35": {
    "doc": "Top.SystemC.Soundness",
    "title": "Progress",
    "content": "Lemma progress_block : ∀ b S1 R Q, &nbsp;&nbsp;empty @ R ; Q |-blk b ~: S1 → &nbsp;&nbsp;bvalue b ∨ ∃ b', b --&gt;b b'. Lemma progress_expr : ∀ Q e T, &nbsp;&nbsp;empty ; Q |-exp e ~: T → &nbsp;&nbsp;evalue e ∨ ∃ e', e --&gt;e e'. Lemma progress_stmt : ∀ s T R Q, &nbsp;&nbsp;empty @ R ; Q |-stm s ~: T → &nbsp;&nbsp;machine_redex s ∨ ∃ s', s --&gt;s s'. Lemma progress_step : ∀ s1, &nbsp;&nbsp;typing_state s1 → &nbsp;&nbsp;done s1 ∨ ∃ s2, s1 --&gt; s2. ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Soundness.html",
    "relUrl": "/proofs/Top.SystemC.Soundness.html"
  },"36": {
    "doc": "Top.SystemC.Substitution",
    "title": "Top.SystemC.Substitution",
    "content": "(*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Substitution.html",
    "relUrl": "/proofs/Top.SystemC.Substitution.html"
  },"37": {
    "doc": "Top.SystemC.Substitution",
    "title": "Weakening (5)",
    "content": "Lemma etyping_weakening : ∀ E F G Q e T, &nbsp;&nbsp;etyping (G ++ E) Q e T → &nbsp;&nbsp;wf_env (G ++ F ++ E) → &nbsp;&nbsp;etyping (G ++ F ++ E) Q e T with btyping_weakening : ∀ E F G R Q e T, &nbsp;&nbsp;btyping (G ++ E) R Q e T → &nbsp;&nbsp;wf_env (G ++ F ++ E) → &nbsp;&nbsp;btyping (G ++ F ++ E) R Q e T with styping_weakening : ∀ E F G R Q e T, &nbsp;&nbsp;styping (G ++ E) R Q e T → &nbsp;&nbsp;wf_env (G ++ F ++ E) → &nbsp;&nbsp;styping (G ++ F ++ E) R Q e T. Lemma restriction_transitive : ∀ C1 C2 C3, &nbsp;&nbsp;C1 |= C2 → &nbsp;&nbsp;C2 |= C3 → &nbsp;&nbsp;C1 |= C3. Here we show that capture subsumption on blocks and statements is admissible. Lemma btyping_weaken_restriction : ∀ C E R Q b S1, &nbsp;&nbsp;R |= C → &nbsp;&nbsp;wf_cap E R → &nbsp;&nbsp;E @ C ; Q |-blk b ~: S1 → &nbsp;&nbsp;E @ R ; Q |-blk b ~: S1 with styping_weaken_restriction : ∀ C E R Q s T, &nbsp;&nbsp;R |= C → &nbsp;&nbsp;wf_cap E R → &nbsp;&nbsp;E @ C ; Q |-stm s ~: T → &nbsp;&nbsp;E @ R ; Q |-stm s ~: T. (************************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Substitution.html",
    "relUrl": "/proofs/Top.SystemC.Substitution.html"
  },"38": {
    "doc": "Top.SystemC.Substitution",
    "title": "Substitution preserves typing (8)",
    "content": "Lemma etyping_through_subst_ee : ∀ U E F Q x T e u, &nbsp;&nbsp;etyping (F ++ [(x, bind_val U)] ++ E) Q e T → &nbsp;&nbsp;etyping E Q u U → &nbsp;&nbsp;etyping (F ++ E) Q (subst_ee x u e) T with btyping_through_subst_eb : ∀ U E F R Q x T e u, &nbsp;&nbsp;btyping (F ++ [(x, bind_val U)] ++ E) R Q e T → &nbsp;&nbsp;etyping E Q u U → &nbsp;&nbsp;btyping (F ++ E) R Q (subst_eb x u e) T with styping_through_subst_es : ∀ U E F R Q x T e u, &nbsp;&nbsp;styping (F ++ [(x, bind_val U)] ++ E) R Q e T → &nbsp;&nbsp;etyping E Q u U → &nbsp;&nbsp;styping (F ++ E) R Q (subst_es x u e) T. (*&nbsp;Monomorphic&nbsp;blocks&nbsp;*) Lemma etyping_through_subst_be : ∀ U C E F Q x T e u, &nbsp;&nbsp;etyping (F ++ [(x, bind_blk U (capture C))] ++ E) Q e T → &nbsp;&nbsp;btyping E C Q u U → &nbsp;&nbsp;etyping (F ++ E) Q (subst_be x u e) T with btyping_through_subst_bb : ∀ U C E F R Q x T e u, &nbsp;&nbsp;btyping (F ++ [(x, bind_blk U (capture C))] ++ E) R Q e T → &nbsp;&nbsp;btyping E C Q u U → &nbsp;&nbsp;btyping (F ++ E) R Q (subst_bb x u e) T with styping_through_subst_bs : ∀ U C E F R Q x T e u, &nbsp;&nbsp;styping (F ++ [(x, bind_blk U (capture C))] ++ E) R Q e T → &nbsp;&nbsp;btyping E C Q u U → &nbsp;&nbsp;styping (F ++ E) R Q (subst_bs x u e) T. (*&nbsp;polymorphic&nbsp;blocks&nbsp;*) Lemma etyping_through_subst_ce : ∀ (C : cap) U E F Q x T e u, &nbsp;&nbsp;etyping (F ++ [(x, bind_blk U tracked)] ++ E) Q e T → &nbsp;&nbsp;wf_cap E C → &nbsp;&nbsp;btyping E C Q u U → &nbsp;&nbsp;etyping (map (subst_bbind x C) F ++ E) Q (subst_ce x u C e) (subst_cvt x C T) with btyping_through_subst_cb : ∀ (C : cap) U E F R Q x T e u, &nbsp;&nbsp;btyping (F ++ [(x, bind_blk U tracked)] ++ E) R Q e T → &nbsp;&nbsp;wf_cap E C → &nbsp;&nbsp;btyping E C Q u U → &nbsp;&nbsp;btyping (map (subst_bbind x C) F ++ E) (subst_cset x C R) Q (subst_cb x u C e) (subst_cbt x C T) with styping_through_subst_cs : ∀ (C : cap) U E F R Q x T e u, &nbsp;&nbsp;styping (F ++ [(x, bind_blk U tracked)] ++ E) R Q e T → &nbsp;&nbsp;wf_cap E C → &nbsp;&nbsp;btyping E C Q u U → &nbsp;&nbsp;styping (map (subst_bbind x C) F ++ E) (subst_cset x C R) Q (subst_cs x u C e) (subst_cvt x C T). Lemma typing_through_subst_t_ : ∀ U E Q X, (∀ E_ Q_ e T, &nbsp;&nbsp;etyping E_ Q_ e T → &nbsp;&nbsp;(∀ F, E_ = F ++ [(X, bind_typ)] ++ E → &nbsp;&nbsp;&nbsp;Q_ = Q → &nbsp;&nbsp;&nbsp;wf_vtyp E U → &nbsp;&nbsp;&nbsp;etyping ((map (subst_tbind X U) F) ++ E) Q (subst_te X U e) (subst_tvt X U T))) ∧ (∀ E_ R Q_ e T, &nbsp;&nbsp;styping E_ R Q_ e T → &nbsp;&nbsp;(∀ F, E_ = F ++ [(X, bind_typ)] ++ E → &nbsp;&nbsp;&nbsp;Q_ = Q → &nbsp;&nbsp;&nbsp;wf_vtyp E U → &nbsp;&nbsp;&nbsp;styping ((map (subst_tbind X U) F) ++ E) R Q (subst_ts X U e) (subst_tvt X U T))) ∧ (∀ E_ R Q_ e T, &nbsp;&nbsp;btyping E_ R Q_ e T → &nbsp;&nbsp;(∀ F, E_ = F ++ [(X, bind_typ)] ++ E → &nbsp;&nbsp;&nbsp;Q_ = Q → &nbsp;&nbsp;&nbsp;wf_vtyp E U → &nbsp;&nbsp;&nbsp;btyping ((map (subst_tbind X U) F) ++ E) R Q (subst_tb X U e) (subst_tbt X U T))). etyping styping btyping Lemma etyping_through_subst_te: ∀ U E F Q X e T, &nbsp;&nbsp;wf_vtyp E U → &nbsp;&nbsp;etyping (F ++ [(X, bind_typ)] ++ E) Q e T → &nbsp;&nbsp;etyping ((map (subst_tbind X U) F) ++ E) Q (subst_te X U e) (subst_tvt X U T). Lemma styping_through_subst_ts : ∀ U E F R Q X e T, &nbsp;&nbsp;wf_vtyp E U → &nbsp;&nbsp;styping (F ++ [(X, bind_typ)] ++ E) R Q e T → &nbsp;&nbsp;styping ((map (subst_tbind X U) F) ++ E) R Q (subst_ts X U e) (subst_tvt X U T). Lemma btyping_through_subst_tb : ∀ U E F R Q X e T, &nbsp;&nbsp;wf_vtyp E U → &nbsp;&nbsp;btyping (F ++ [(X, bind_typ)] ++ E) R Q e T → &nbsp;&nbsp;btyping ((map (subst_tbind X U) F) ++ E) R Q (subst_tb X U e) (subst_tbt X U T). ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Substitution.html",
    "relUrl": "/proofs/Top.SystemC.Substitution.html"
  },"39": {
    "doc": "Top.Util.AdditionalTactics",
    "title": "Top.Util.AdditionalTactics",
    "content": "A library of additional tactics. (*&nbsp;***********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.AdditionalTactics.html",
    "relUrl": "/proofs/Top.Util.AdditionalTactics.html"
  },"40": {
    "doc": "Top.Util.AdditionalTactics",
    "title": "Extensions of the standard library",
    "content": "\"remember c as x in |-\" replaces the term c by the identifier x in the conclusion of the current goal and introduces the hypothesis x=c into the context. This tactic differs from a similar one in the standard library in that the replacmement is made only in the conclusion of the goal; the context is left unchanged. Tactic Notation \"remember\" constr(c) \"as\" ident(x) \"in\" \"|-\" := &nbsp;&nbsp;let x := fresh x in &nbsp;&nbsp;let H := fresh \"Heq\" x in &nbsp;&nbsp;(set (x := c); assert (H : x = c) by reflexivity; clearbody x). \"unsimpl E\" replaces all occurence of X by E, where X is the result that tactic simpl would give when used to evaluate E. Tactic Notation \"unsimpl\" constr(E) := &nbsp;&nbsp;let F := (eval simpl in E) in change F with E. The following tactic calls the apply tactic with the first hypothesis that succeeds, \"first\" meaning the hypothesis that comes earlist in the context (i.e., higher up in the list). (*&nbsp;***********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.AdditionalTactics.html",
    "relUrl": "/proofs/Top.Util.AdditionalTactics.html"
  },"41": {
    "doc": "Top.Util.AdditionalTactics",
    "title": "Variations on auto",
    "content": "The auto× and eauto× tactics are intended to be \"stronger\" versions of the auto and eauto tactics. Similar to auto and eauto, they each take an optional \"depth\" argument. Note that if we declare these tactics using a single string, e.g., \"auto*\", then the resulting tactics are unusable since they fail to parse. Tactic Notation \"auto\" \"*\" := &nbsp;&nbsp;try solve [ congruence | auto | intuition auto ]. Tactic Notation \"auto\" \"*\" integer(n) := &nbsp;&nbsp;try solve [ congruence | auto n | intuition (auto n) ]. Tactic Notation \"eauto\" \"*\" := &nbsp;&nbsp;try solve [ congruence | eauto | intuition eauto ]. Tactic Notation \"eauto\" \"*\" integer(n) := &nbsp;&nbsp;try solve [ congruence | eauto n | intuition (eauto n) ]. (*&nbsp;***********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.AdditionalTactics.html",
    "relUrl": "/proofs/Top.Util.AdditionalTactics.html"
  },"42": {
    "doc": "Top.Util.AdditionalTactics",
    "title": "Delineating cases in proofs",
    "content": "This section was taken from the POPLmark Wiki ( http://alliance.seas.upenn.edu/~plclub/cgi-bin/poplmark/ ). ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.AdditionalTactics.html",
    "relUrl": "/proofs/Top.Util.AdditionalTactics.html"
  },"43": {
    "doc": "Top.Util.AdditionalTactics",
    "title": "Tactic definitions",
    "content": "Tactic Notation \"assert_eq\" ident(x) constr(v) := &nbsp;&nbsp;let H := fresh in &nbsp;&nbsp;assert (x = v) as H by reflexivity; &nbsp;&nbsp;clear H. Tactic Notation \"Case_aux\" ident(x) constr(name) := &nbsp;&nbsp;first [ &nbsp;&nbsp;&nbsp;&nbsp;set (x := name); move_to_top x &nbsp;&nbsp;| assert_eq x name &nbsp;&nbsp;| fail 1 \"because we are working on a different case.\" ]. ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.AdditionalTactics.html",
    "relUrl": "/proofs/Top.Util.AdditionalTactics.html"
  },"44": {
    "doc": "Top.Util.AdditionalTactics",
    "title": "Example",
    "content": "One mode of use for the above tactics is to wrap Coq's induction tactic such that automatically inserts \"case\" markers into each branch of the proof. For example: Tactic Notation \"induction\" \"nat\" ident(n) := induction n; [ Case \"O\" | Case \"S\" ]. Tactic Notation \"sub\" \"induction\" \"nat\" ident(n) := induction n; [ SCase \"O\" | SCase \"S\" ]. Tactic Notation \"sub\" \"sub\" \"induction\" \"nat\" ident(n) := induction n; [ SSCase \"O\" | SSCase \"S\" ]. If you use such customized versions of the induction tactics, then the Case tactic will verify that you are working on the case that you think you are. You may also use the Case tactic with the standard version of induction, in which case no verification is done. ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.AdditionalTactics.html",
    "relUrl": "/proofs/Top.Util.AdditionalTactics.html"
  },"45": {
    "doc": "Top.Util.Atom",
    "title": "Top.Util.Atom",
    "content": "Support for atoms, i.e., objects with decidable equality. We provide here the ability to generate an atom fresh for any finite collection, e.g., the lemma atom_fresh_for_set, and a tactic to pick an atom fresh for the current proof context. Authors: Arthur Charguéraud and Brian Aydemir. Implementation note: In older versions of Coq, OrderedTypeEx redefines decimal constants to be integers and not natural numbers. The following scope declaration is intended to address this issue. In newer versions of Coq, the declaration should be benign. (*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Atom.html",
    "relUrl": "/proofs/Top.Util.Atom.html"
  },"46": {
    "doc": "Top.Util.Atom",
    "title": "Definition",
    "content": "Atoms are structureless objects such that we can always generate one fresh from a finite collection. Equality on atoms is eq and decidable. We use Coq's module system to make abstract the implementation of atoms. The Export AtomImpl line below allows us to refer to the type atom and its properties without having to qualify everything with \"AtomImpl.\". Module Type ATOM. &nbsp;&nbsp;Parameter atom : Set. &nbsp;&nbsp;Parameter atom_fresh_for_list : &nbsp;&nbsp;&nbsp;&nbsp;∀ (xs : list atom), {x : atom | ¬ List.In x xs}. &nbsp;&nbsp;Declare Module Atom_as_OT : UsualOrderedType with Definition t := atom. &nbsp;&nbsp;Parameter eq_atom_dec : ∀ x y : atom, {x = y} + {x ≠ y}. End ATOM. The implementation of the above interface is hidden for documentation purposes. Module AtomImpl : ATOM. End AtomImpl. (*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Atom.html",
    "relUrl": "/proofs/Top.Util.Atom.html"
  },"47": {
    "doc": "Top.Util.Atom",
    "title": "Finite sets of atoms",
    "content": "(*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Atom.html",
    "relUrl": "/proofs/Top.Util.Atom.html"
  },"48": {
    "doc": "Top.Util.Atom",
    "title": "Definitions",
    "content": "Module AtomSet : FiniteSets.S with Module E := Atom_as_OT := &nbsp;&nbsp;FiniteSets.Make Atom_as_OT. The type atoms is the type of finite sets of atoms. Notation atoms := AtomSet.F.t. Basic operations on finite sets of atoms are available, in the remainder of this file, without qualification. We use Import instead of Export in order to avoid unnecessary namespace pollution. We instantiate two modules which provide useful lemmas and tactics work working with finite sets of atoms. Module AtomSetDecide := FSetDecide.Decide AtomSet.F. Module AtomSetNotin := FSetNotin.Notin AtomSet.F. Module AtomSetFacts := FSetFacts.Facts AtomSet.F. Module AtomSetProperties := FSetProperties.Properties AtomSet.F. (*&nbsp;***********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Atom.html",
    "relUrl": "/proofs/Top.Util.Atom.html"
  },"49": {
    "doc": "Top.Util.Atom",
    "title": "Tactics for working with finite sets of atoms",
    "content": "The tactic fsetdec is a general purpose decision procedure for solving facts about finite sets of atoms. The tactic notin_simpl simplifies all hypotheses of the form (~ In x F), where F is constructed from the empty set, singleton sets, and unions. The tactic notin_solve, solves goals of the form (~ In x F), where F is constructed from the empty set, singleton sets, and unions. The goal must be provable from hypothesis of the form simplified by notin_simpl. (*&nbsp;***********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Atom.html",
    "relUrl": "/proofs/Top.Util.Atom.html"
  },"50": {
    "doc": "Top.Util.Atom",
    "title": "Lemmas for working with finite sets of atoms",
    "content": "We make some lemmas about finite sets of atoms available without qualification by using abbreviations. Notation eq_if_Equal := AtomSet.eq_if_Equal. Notation notin_empty := AtomSetNotin.notin_empty. Notation notin_singleton := AtomSetNotin.notin_singleton. Notation notin_singleton_rw := AtomSetNotin.notin_singleton_rw. Notation notin_union := AtomSetNotin.notin_union. (*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Atom.html",
    "relUrl": "/proofs/Top.Util.Atom.html"
  },"51": {
    "doc": "Top.Util.Atom",
    "title": "Additional properties",
    "content": "One can generate an atom fresh for a given finite set of atoms. Lemma atom_fresh_for_set : ∀ L : atoms, { x : atom | ¬ In x L }. (*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Atom.html",
    "relUrl": "/proofs/Top.Util.Atom.html"
  },"52": {
    "doc": "Top.Util.Atom",
    "title": "Additional tactics",
    "content": "(*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Atom.html",
    "relUrl": "/proofs/Top.Util.Atom.html"
  },"53": {
    "doc": "Top.Util.Atom",
    "title": " Picking a fresh atom",
    "content": "We define three tactics which, when combined, provide a simple mechanism for picking a fresh atom. We demonstrate their use below with an example, the example_pick_fresh tactic. (gather_atoms_with F) returns the union of (F x), where x ranges over all objects in the context such that (F x) is well typed. The return type of F should be atoms. The complexity of this tactic is due to the fact that there is no support in Ltac for folding a function over the context. (beautify_fset V) takes a set V built as a union of finite sets and returns the same set with empty sets removed and union operations associated to the right. Duplicate sets are also removed from the union. The tactic (pick fresh Y for L) takes a finite set of atoms L and a fresh name Y, and adds to the context an atom with name Y and a proof that (~ In Y L), i.e., that Y is fresh for L. The tactic will fail if Y is already declared in the context. Tactic Notation \"pick\" \"fresh\" ident(Y) \"for\" constr(L) := &nbsp;&nbsp;let Fr := fresh \"Fr\" in &nbsp;&nbsp;let L := beautify_fset L in &nbsp;&nbsp;(destruct (atom_fresh_for_set L) as [Y Fr]). (*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Atom.html",
    "relUrl": "/proofs/Top.Util.Atom.html"
  },"54": {
    "doc": "Top.Util.Atom",
    "title": "Demonstration",
    "content": "The example_pick_fresh tactic below illustrates the general pattern for using the above three tactics to define a tactic which picks a fresh atom. The pattern is as follows: . | Repeatedly invoke gather_atoms_with, using functions with different argument types each time. | Union together the result of the calls, and invoke (pick fresh ... for ...) with that union of sets. | . Lemma example_pick_fresh_use : ∀ (x y z : atom) (L1 L2 L3: atoms), True. Proof. &nbsp;&nbsp;intros x y z L1 L2 L3. example_pick_fresh k. At this point in the proof, we have a new atom k and a hypothesis Fr : ¬ In k (union L1 (union L2 (union L3 (union (singleton x) (union (singleton y) (singleton z)))))). &nbsp;&nbsp;trivial. Qed. Definition disjoint (xs : atoms) (ys: atoms) : Prop := &nbsp;&nbsp;AtomSet.F.Empty (AtomSet.F.inter xs ys). Notation &quot;a `disjoint` b\" := (disjoint a b) (at level 1) : metatheory_scope. ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Atom.html",
    "relUrl": "/proofs/Top.Util.Atom.html"
  },"55": {
    "doc": "Top.Util.Environment",
    "title": "Top.Util.Environment",
    "content": "Operations, lemmas, and tactics for working with environments, association lists whose keys are atoms. Unless stated otherwise, implicit arguments will not be declared by default. Authors: Brian Aydemir and Arthur Charguéraud, with help from Aaron Bohannon, Benjamin Pierce, Jeffrey Vaughan, Dimitrios Vytiniotis, Stephanie Weirich, and Steve Zdancewic. : . | Overview | Functions on environments | Relations on environments | Properties of operations | Automation and tactics (I) | Properties of well-formedness and freshness | Properties of binds | Automation and tactics (II) | Additional properties of binds | Automation and tactics (III) | . (*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Environment.html",
    "relUrl": "/proofs/Top.Util.Environment.html"
  },"56": {
    "doc": "Top.Util.Environment",
    "title": " Overview",
    "content": "An environment is a list of pairs, where the first component of each pair is an atom. We view the second component of each pair as being bound to the first component. In a well-formed environment, there is at most one binding for any given atom. Bindings at the head of the list are \"more recent\" than bindings toward the tail of the list, and we view an environment as growing on the left, i.e., at its head. We normally work only with environments built up from the following: the empty list, one element lists, and concatenations of two lists. This seems to be more convenient in practice. For example, we don't need to distinguish between consing on a binding and concatenating a binding, a difference that Coq's tactics can be sensitive to. However, basic definitions are by induction on the usual structure of lists (nil and cons). To make it convenient to write one element lists, we define a special notation. Note that this notation is local to this particular library, to allow users to use alternate notations if they desire. Notation &quot;[ x ]\" := (cons x nil). In the remainder of this library, we define a number of operations, lemmas, and tactics that simplify working with environments. (*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Environment.html",
    "relUrl": "/proofs/Top.Util.Environment.html"
  },"57": {
    "doc": "Top.Util.Environment",
    "title": " Functions on environments",
    "content": "Implicit arguments will be declared by default for the definitions in this section. Section Definitions. Variables A B : Type. The domain of an environment is the set of atoms that it maps. Fixpoint dom (E : list (atom × A)) : atoms := &nbsp;&nbsp;match E with &nbsp;&nbsp;| nil ⇒ empty &nbsp;&nbsp;| (x, _) :: E' ⇒ union (singleton x) (dom E') &nbsp;&nbsp;end. map applies a function to all bindings in the environment. Fixpoint map (f : A → B) (E : list (atom × A)) : list (atom × B) := &nbsp;&nbsp;match E with &nbsp;&nbsp;| nil ⇒ nil &nbsp;&nbsp;| (x, V) :: E' ⇒ (x, f V) :: map f E' &nbsp;&nbsp;end. get returns the value bound to the given atom in an environment or None if the given atom is not bound. If the atom has multiple bindings, the one nearest to the head of the environment is returned. Fixpoint get (x : atom) (E : list (atom × A)) : option A := &nbsp;&nbsp;match E with &nbsp;&nbsp;| nil ⇒ None &nbsp;&nbsp;| (y,a) :: E' ⇒ if eq_atom_dec x y then Some a else get x E' &nbsp;&nbsp;end. End Definitions. (*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Environment.html",
    "relUrl": "/proofs/Top.Util.Environment.html"
  },"58": {
    "doc": "Top.Util.Environment",
    "title": " Relations on environments",
    "content": "Implicit arguments will be declared by default for the definitions in this section. Section Relations. Variable A : Type. An environment is well-formed if and only if each atom is bound at most once. Inductive ok : list (atom × A) → Prop := &nbsp;&nbsp;| ok_nil : &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ok nil &nbsp;&nbsp;| ok_cons : ∀ (E : list (atom × A)) (x : atom) (a : A), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ok E → ¬ In x (dom E) → ok ((x, a) :: E). An environment E contains a binding from x to b, denoted (binds x b E), if and only if the most recent binding for x is mapped to b. Definition binds x b (E : list (atom × A)) := &nbsp;&nbsp;get x E = Some b. End Relations. (*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Environment.html",
    "relUrl": "/proofs/Top.Util.Environment.html"
  },"59": {
    "doc": "Top.Util.Environment",
    "title": " Properties of operations",
    "content": "Section OpProperties. Variable A B : Type. Implicit Types E F : list (atom × A). Implicit Types a b : A. ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Environment.html",
    "relUrl": "/proofs/Top.Util.Environment.html"
  },"60": {
    "doc": "Top.Util.Environment",
    "title": "Facts about concatenation",
    "content": "Lemma concat_nil : ∀ E, &nbsp;&nbsp;E ++ nil = E. Lemma nil_concat : ∀ E, &nbsp;&nbsp;nil ++ E = E. Lemma concat_assoc : ∀ E F G, &nbsp;&nbsp;(G ++ F) ++ E = G ++ (F ++ E). ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Environment.html",
    "relUrl": "/proofs/Top.Util.Environment.html"
  },"61": {
    "doc": "Top.Util.Environment",
    "title": "map commutes with environment-building operations",
    "content": "Lemma map_nil : ∀ (f : A → B), &nbsp;&nbsp;map f nil = nil. Lemma map_single : ∀ (f : A → B) y b, &nbsp;&nbsp;map f [(y,b)] = [(y, f b)]. Lemma map_push : ∀ (f : A → B) y b E, &nbsp;&nbsp;map f ([(y,b)] ++ E) = [(y, f b)] ++ map f E. Lemma map_concat : ∀ (f : A → B) E F, &nbsp;&nbsp;map f (F ++ E) = (map f F) ++ (map f E). ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Environment.html",
    "relUrl": "/proofs/Top.Util.Environment.html"
  },"62": {
    "doc": "Top.Util.Environment",
    "title": "Facts about the domain of an environment",
    "content": "Lemma dom_nil : &nbsp;&nbsp;@dom A nil = empty. Lemma dom_single : ∀ x a, &nbsp;&nbsp;dom [(x,a)] = singleton x. Lemma dom_push : ∀ x a E, &nbsp;&nbsp;dom ([(x,a)] ++ E) = union (singleton x) (dom E). Lemma dom_concat : ∀ E F, &nbsp;&nbsp;dom (F ++ E) = union (dom F) (dom E). Lemma dom_map : ∀ (f : A → B) E, &nbsp;&nbsp;dom (map f E) = dom E. ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Environment.html",
    "relUrl": "/proofs/Top.Util.Environment.html"
  },"63": {
    "doc": "Top.Util.Environment",
    "title": "Other trivial rewrites",
    "content": "Lemma cons_concat_assoc : ∀ x a E F, &nbsp;&nbsp;&nbsp;((x, a) :: E) ++ F = (x, a) :: (E ++ F). End OpProperties. (*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Environment.html",
    "relUrl": "/proofs/Top.Util.Environment.html"
  },"64": {
    "doc": "Top.Util.Environment",
    "title": " Automation and tactics (I)",
    "content": " ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Environment.html",
    "relUrl": "/proofs/Top.Util.Environment.html"
  },"65": {
    "doc": "Top.Util.Environment",
    "title": "simpl_env",
    "content": "The simpl_env tactic can be used to put environments in the standardized form described above, with the additional properties that concatenation is associated to the right and empty environments are removed. Similar to the simpl tactic, we define \"in ×\" and \"in H\" variants of simpl_env. Definition singleton_list (A : Type) (x : atom × A) := x :: nil. Lemma cons_concat : ∀ (A : Type) (E : list (atom × A)) x a, &nbsp;&nbsp;(x, a) :: E = singleton_list A (x, a) ++ E. Lemma map_singleton_list : ∀ (A B : Type) (f : A → B) y b, &nbsp;&nbsp;map f (singleton_list A (y,b)) = [(y, f b)]. Lemma dom_singleton_list : ∀ (A : Type) (x : atom) (a : A), &nbsp;&nbsp;dom (singleton_list A (x,a)) = singleton x. Tactic Notation \"simpl_env\" \"in\" hyp(H) := &nbsp;&nbsp;simpl_env_change_aux; &nbsp;&nbsp;autorewrite with rew_env in H; &nbsp;&nbsp;unfold singleton_list in ×. Tactic Notation \"simpl_env\" \"in\" \"*\" := &nbsp;&nbsp;simpl_env_change_aux; &nbsp;&nbsp;autorewrite with rew_env in *; &nbsp;&nbsp;unfold singleton_list in ×. ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Environment.html",
    "relUrl": "/proofs/Top.Util.Environment.html"
  },"66": {
    "doc": "Top.Util.Environment",
    "title": "rewrite_env",
    "content": "The tactic (rewrite_env E) replaces an environment in the conclusion of the goal with E. Suitability for replacement is determined by whether simpl_env can put E and the chosen environment in the same normal form, up to convertability in Coq. We also define a \"in H\" variant that performs the replacement in a hypothesis H. Tactic Notation \"rewrite_env\" constr(E) := &nbsp;&nbsp;match goal with &nbsp;&nbsp;&nbsp;&nbsp;|- context[?x] ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;change x with E &nbsp;&nbsp;&nbsp;&nbsp;|- context[?x] ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace x with E; [ | try reflexivity; simpl_env; reflexivity ] &nbsp;&nbsp;end. Tactic Notation \"rewrite_env\" constr(E) \"in\" hyp(H) := &nbsp;&nbsp;match type of H with &nbsp;&nbsp;&nbsp;&nbsp;| context[?x] ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;change x with E in H &nbsp;&nbsp;&nbsp;&nbsp;| context[?x] ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace x with E in H; [ | try reflexivity; simpl_env; reflexivity ] &nbsp;&nbsp;end. ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Environment.html",
    "relUrl": "/proofs/Top.Util.Environment.html"
  },"67": {
    "doc": "Top.Util.Environment",
    "title": "Hints",
    "content": "(*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Environment.html",
    "relUrl": "/proofs/Top.Util.Environment.html"
  },"68": {
    "doc": "Top.Util.Environment",
    "title": " Properties of well-formedness and freshness",
    "content": "Section OkProperties. Variable A B : Type. Implicit Types E F : list (atom × A). Implicit Types a b : A. Facts about when an environment is well-formed. Lemma ok_push : ∀ (E : list (atom × A)) (x : atom) (a : A), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ok E → ¬ In x (dom E) → ok ([(x, a)] ++ E). Lemma ok_singleton : ∀ x a, &nbsp;&nbsp;ok [(x,a)]. Lemma ok_remove_mid : ∀ F E G, &nbsp;&nbsp;ok (G ++ F ++ E) → ok (G ++ E). Lemma ok_remove_mid_cons : ∀ x a E G, &nbsp;&nbsp;ok (G ++ (x, a) :: E) → &nbsp;&nbsp;ok (G ++ E). Lemma ok_map : ∀ E (f : A → B), &nbsp;&nbsp;ok E → ok (map f E). Lemma ok_map_app_l : ∀ E F (f : A → A), &nbsp;&nbsp;ok (F ++ E) → ok (map f F ++ E). A binding in the middle of an environment has an atom fresh from all bindings before and after it. Lemma fresh_mid_tail : ∀ E F x a, &nbsp;&nbsp;ok (F ++ [(x,a)] ++ E) → ¬ In x (dom E). Lemma fresh_mid_head : ∀ E F x a, &nbsp;&nbsp;ok (F ++ [(x,a)] ++ E) → ¬ In x (dom F). End OkProperties. (*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Environment.html",
    "relUrl": "/proofs/Top.Util.Environment.html"
  },"69": {
    "doc": "Top.Util.Environment",
    "title": " Properties of binds",
    "content": "Section BindsProperties. Variable A B : Type. Implicit Types E F : list (atom × A). Implicit Types a b : A. ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Environment.html",
    "relUrl": "/proofs/Top.Util.Environment.html"
  },"70": {
    "doc": "Top.Util.Environment",
    "title": "Introduction forms for binds",
    "content": "The following properties allow one to view binds as an inductively defined predicate. This is the preferred way of working with the relation. Lemma binds_singleton : ∀ x a, &nbsp;&nbsp;binds x a [(x,a)]. Lemma binds_tail : ∀ x a E F, &nbsp;&nbsp;binds x a E → ¬ In x (dom F) → binds x a (F ++ E). Lemma binds_head : ∀ x a E F, &nbsp;&nbsp;binds x a F → binds x a (F ++ E). ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Environment.html",
    "relUrl": "/proofs/Top.Util.Environment.html"
  },"71": {
    "doc": "Top.Util.Environment",
    "title": "Case analysis on binds",
    "content": "Lemma binds_concat_inv : ∀ x a E F, &nbsp;&nbsp;binds x a (F ++ E) → (¬ In x (dom F) ∧ binds x a E) ∨ (binds x a F). Lemma binds_singleton_inv : ∀ x y a b, &nbsp;&nbsp;binds x a [(y,b)] → x = y ∧ a = b. ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Environment.html",
    "relUrl": "/proofs/Top.Util.Environment.html"
  },"72": {
    "doc": "Top.Util.Environment",
    "title": "Retrieving bindings from an environment",
    "content": "Lemma binds_mid : ∀ x a E F, &nbsp;&nbsp;ok (F ++ [(x,a)] ++ E) → binds x a (F ++ [(x,a)] ++ E). Lemma binds_mid_eq : ∀ z a b E F, &nbsp;&nbsp;binds z a (F ++ [(z,b)] ++ E) → ok (F ++ [(z,b)] ++ E) → a = b. Lemma binds_mid_eq_cons : ∀ x a b E F, &nbsp;&nbsp;binds x a (F ++ (x,b) :: E) → &nbsp;&nbsp;ok (F ++ (x,b) :: E) → &nbsp;&nbsp;a = b. End BindsProperties. (*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Environment.html",
    "relUrl": "/proofs/Top.Util.Environment.html"
  },"73": {
    "doc": "Top.Util.Environment",
    "title": " Automation and tactics (II)",
    "content": " ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Environment.html",
    "relUrl": "/proofs/Top.Util.Environment.html"
  },"74": {
    "doc": "Top.Util.Environment",
    "title": "Hints",
    "content": " ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Environment.html",
    "relUrl": "/proofs/Top.Util.Environment.html"
  },"75": {
    "doc": "Top.Util.Environment",
    "title": "binds_get",
    "content": "The tactic (binds_get H) takes a hypothesis H of the form (binds x a (F ++ [(x,b)] ++ E)) and introduces the equality a=b into the context. Then, the tactic checks if the equality is discriminable and otherwise tries substituting b for a. The auto tactic is used to show that (ok (F ++ [(x,b)] ++ E)), which is needed to prove the equality a=b from H. ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Environment.html",
    "relUrl": "/proofs/Top.Util.Environment.html"
  },"76": {
    "doc": "Top.Util.Environment",
    "title": "binds_cases",
    "content": "The tactic (binds_case H) performs a case analysis on an hypothesis H of the form (binds x a E). There will be one subgoal for each component of E that x could be bound in, and each subgoal will have appropriate freshness conditions on x. Some attempts are made to automatically discharge contradictory cases. (*&nbsp;***********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Environment.html",
    "relUrl": "/proofs/Top.Util.Environment.html"
  },"77": {
    "doc": "Top.Util.Environment",
    "title": " Additional properties of binds",
    "content": "The following lemmas are proven in manner that should be independent of the concrete definition of binds. Section AdditionalBindsProperties. Variable A B : Type. Implicit Types E F : list (atom × A). Implicit Types a b : A. Lemmas about the relationship between binds and the domain of an environment. Lemma binds_In : ∀ a x E, &nbsp;&nbsp;binds x a E → In x (dom E). Lemma binds_fresh : ∀ x a E, &nbsp;&nbsp;¬ In x (dom E) → ¬ binds x a E. Additional lemmas for showing that a binding is in an environment. Lemma binds_map : ∀ x a (f : A → B) E, &nbsp;&nbsp;binds x a E → binds x (f a) (map f E). Lemma binds_concat_ok : ∀ x a E F, &nbsp;&nbsp;binds x a E → ok (F ++ E) → binds x a (F ++ E). Lemma binds_weaken : ∀ x a E F G, &nbsp;&nbsp;binds x a (G ++ E) → &nbsp;&nbsp;ok (G ++ F ++ E) → &nbsp;&nbsp;binds x a (G ++ F ++ E). Lemma binds_weaken_at_head : ∀ x a F G, &nbsp;&nbsp;binds x a G → &nbsp;&nbsp;ok (F ++ G) → &nbsp;&nbsp;binds x a (F ++ G). Lemma binds_remove_mid : ∀ x y a b F G, &nbsp;&nbsp;binds x a (F ++ [(y,b)] ++ G) → &nbsp;&nbsp;x ≠ y → &nbsp;&nbsp;binds x a (F ++ G). Lemma binds_remove_mid_cons : ∀ x y a b E G, &nbsp;&nbsp;binds x a (G ++ (y, b) :: E) → &nbsp;&nbsp;x ≠ y → &nbsp;&nbsp;binds x a (G ++ E). End AdditionalBindsProperties. (*&nbsp;***********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Environment.html",
    "relUrl": "/proofs/Top.Util.Environment.html"
  },"78": {
    "doc": "Top.Util.Environment",
    "title": " Automation and tactics (III)",
    "content": " ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Environment.html",
    "relUrl": "/proofs/Top.Util.Environment.html"
  },"79": {
    "doc": "Top.Util.FSetDecide",
    "title": "Top.Util.FSetDecide",
    "content": "(**************************************************************) (*&nbsp;FSetDecide.v&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*) (*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*) (*&nbsp;Author:&nbsp;Aaron&nbsp;Bohannon&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*) (**************************************************************) This file implements a decision procedure for a certain class of propositions involving finite sets. Module Decide (Import M : S). ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.FSetDecide.html",
    "relUrl": "/proofs/Top.Util.FSetDecide.html"
  },"80": {
    "doc": "Top.Util.FSetDecide",
    "title": "Overview",
    "content": "This functor defines the tactic fsetdec, which will solve any valid goal of the form forall s1 ... sn, forall x1 ... xm, P1 -&gt; ... -&gt; Pk -&gt; P . where P's are defined by the grammar: P ::= | Q | Empty F | Subset F F' | Equal F F' Q ::= | E.eq X X' | In X F | Q /\\ Q' | Q \\/ Q' | Q -&gt; Q' | Q &lt;-&gt; Q' | ~ Q | True | False F ::= | S | empty | singleton X | add X F | remove X F | union F F' | inter F F' | diff F F' X ::= x1 | ... | xm S ::= s1 | ... | sn . The tactic will also work on some goals that vary slightly from the above form: . | The variables and hypotheses may be mixed in any order and may have already been introduced into the context. Moreover, there may be additional, unrelated hypotheses mixed in (these will be ignored). | A conjunction of hypotheses will be handled as easily as separate hypotheses, i.e., P1 ∧ P2 → P can be solved iff P1 → P2 → P can be solved. | fsetdec should solve any goal if the FSet-related hypotheses are contradictory. | fsetdec will first perform any necessary zeta and beta reductions and will invoke subst to eliminate any Coq equalities between finite sets or their elements. | If E.eq is convertible with Coq's equality, it will not matter which one is used in the hypotheses or conclusion. | The tactic can solve goals where the finite sets or set elements are expressed by Coq terms that are more complicated than variables. However, non-local definitions are not expanded, and Coq equalities between non-variable terms are not used. For example, this goal will be solved: forall (f : t -&gt; t), forall (g : elt -&gt; elt), forall (s1 s2 : t), forall (x1 x2 : elt), Equal s1 (f s2) -&gt; E.eq x1 (g (g x2)) -&gt; In x1 s1 -&gt; In (g (g x2)) (f s2) . This one will not be solved: forall (f : t -&gt; t), forall (g : elt -&gt; elt), forall (s1 s2 : t), forall (x1 x2 : elt), Equal s1 (f s2) -&gt; E.eq x1 (g x2) -&gt; In x1 s1 -&gt; g x2 = g (g x2) -&gt; In (g (g x2)) (f s2) . | . ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.FSetDecide.html",
    "relUrl": "/proofs/Top.Util.FSetDecide.html"
  },"81": {
    "doc": "Top.Util.FSetDecide",
    "title": "Facts and Tactics for Propositional Logic",
    "content": "These lemmas and tactics are in a module so that they do not affect the namespace if you import the enclosing module Decide. &nbsp;&nbsp;Module FSetLogicalFacts. ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.FSetDecide.html",
    "relUrl": "/proofs/Top.Util.FSetDecide.html"
  },"82": {
    "doc": "Top.Util.FSetDecide",
    "title": "Lemmas and Tactics About Decidable Propositions",
    "content": "XXX: The lemma dec_iff should have been included in Decidable.v. Some form of the solve_decidable tactics below would also make sense in Decidable.v. &nbsp;&nbsp;&nbsp;&nbsp;Lemma dec_iff : ∀ P Q : Prop, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decidable P → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decidable Q → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decidable (P ↔ Q). With this hint database, we can leverage auto to check decidability of propositions. solve_decidable using lib will solve goals about the decidability of a proposition, assisted by an auxiliary database of lemmas. The database is intended to contain lemmas stating the decidability of base propositions, (e.g., the decidability of equality on a particular inductive type). &nbsp;&nbsp;&nbsp;&nbsp;Tactic Notation \"solve_decidable\" \"using\" ident(db) := &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match goal with &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- decidable ?P ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;solve [ auto 100 with decidable_prop db ] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end. &nbsp;&nbsp;&nbsp;&nbsp;Tactic Notation \"solve_decidable\" := &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;solve_decidable using core. ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.FSetDecide.html",
    "relUrl": "/proofs/Top.Util.FSetDecide.html"
  },"83": {
    "doc": "Top.Util.FSetDecide",
    "title": "Propositional Equivalences Involving Negation",
    "content": "These are all written with the unfolded form of negation, since I am not sure if setoid rewriting will always perform conversion. Eliminating Negations . We begin with lemmas that, when read from left to right, can be understood as ways to eliminate uses of not. &nbsp;&nbsp;&nbsp;&nbsp;Lemma not_true_iff : &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(True → False) ↔ False. &nbsp;&nbsp;&nbsp;&nbsp;Lemma not_false_iff : &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(False → False) ↔ True. &nbsp;&nbsp;&nbsp;&nbsp;Lemma not_not_iff : ∀ P : Prop, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decidable P → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(((P → False) → False) ↔ P). &nbsp;&nbsp;&nbsp;&nbsp;Lemma contrapositive : ∀ P Q : Prop, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decidable P → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(((P → False) → (Q → False)) ↔ (Q → P)). &nbsp;&nbsp;&nbsp;&nbsp;Lemma or_not_l_iff_1 : ∀ P Q : Prop, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decidable P → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((P → False) ∨ Q ↔ (P → Q)). &nbsp;&nbsp;&nbsp;&nbsp;Lemma or_not_l_iff_2 : ∀ P Q : Prop, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decidable Q → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((P → False) ∨ Q ↔ (P → Q)). &nbsp;&nbsp;&nbsp;&nbsp;Lemma or_not_r_iff_1 : ∀ P Q : Prop, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decidable P → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(P ∨ (Q → False) ↔ (Q → P)). &nbsp;&nbsp;&nbsp;&nbsp;Lemma or_not_r_iff_2 : ∀ P Q : Prop, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decidable Q → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(P ∨ (Q → False) ↔ (Q → P)). &nbsp;&nbsp;&nbsp;&nbsp;Lemma imp_not_l : ∀ P Q : Prop, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decidable P → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(((P → False) → Q) ↔ (P ∨ Q)). Moving Negations Around . We have four lemmas that, when read from left to right, describe how to push negations toward the leaves of a proposition and, when read from right to left, describe how to pull negations toward the top of a proposition. &nbsp;&nbsp;&nbsp;&nbsp;Lemma not_or_iff : ∀ P Q : Prop, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(P ∨ Q → False) ↔ (P → False) ∧ (Q → False). &nbsp;&nbsp;&nbsp;&nbsp;Lemma not_and_iff : ∀ P Q : Prop, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(P ∧ Q → False) ↔ (P → Q → False). &nbsp;&nbsp;&nbsp;&nbsp;Lemma not_imp_iff : ∀ P Q : Prop, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decidable P → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(((P → Q) → False) ↔ P ∧ (Q → False)). &nbsp;&nbsp;&nbsp;&nbsp;Lemma not_imp_rev_iff : ∀ P Q : Prop, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decidable P → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(((P → Q) → False) ↔ (Q → False) ∧ P). ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.FSetDecide.html",
    "relUrl": "/proofs/Top.Util.FSetDecide.html"
  },"84": {
    "doc": "Top.Util.FSetDecide",
    "title": "Tactics for Negations",
    "content": "&nbsp;&nbsp;&nbsp;&nbsp;Tactic Notation \"fold\" \"any\" \"not\" := &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repeat ( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match goal with &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| H: context [?P → False] |- _ ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fold (¬ P) in H &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- context [?P → False] ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fold (¬ P) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end). push not using db will pushes all negations to the leaves of propositions in the goal, using the lemmas in db to assist in checking the decidability of the propositions involved. If using db is omitted, then core will be used. Additional versions are provided to manipulate the hypotheses or the hypotheses and goal together. XXX: This tactic and the similar subsequent ones should have been defined using autorewrite. However, there is a bug in the order that Coq generates subgoals when rewriting using a setoid. In order to work around this bug, these tactics had to be written out in an explicit way. When the bug is fixed these tactics will break!! &nbsp;&nbsp;&nbsp;&nbsp;Tactic Notation \"push\" \"not\" \"using\" ident(db) := &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unfold not, iff; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repeat ( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match goal with &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; simplification by not_true_iff &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- context [True → False] ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite not_true_iff &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; simplification by not_false_iff &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- context [False → False] ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite not_false_iff &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; simplification by not_not_iff &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- context [(?P → False) → False] ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite (not_not_iff P); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ solve_decidable using db | ] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; simplification by contrapositive &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- context [(?P → False) → (?Q → False)] ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite (contrapositive P Q); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ solve_decidable using db | ] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; simplification by or_not_l_iff_1/2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- context [(?P → False) ∨ ?Q] ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rewrite (or_not_l_iff_1 P Q); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ solve_decidable using db | ]) || &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rewrite (or_not_l_iff_2 P Q); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ solve_decidable using db | ]) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; simplification by or_not_r_iff_1/2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- context [?P ∨ (?Q → False)] ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rewrite (or_not_r_iff_1 P Q); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ solve_decidable using db | ]) || &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rewrite (or_not_r_iff_2 P Q); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ solve_decidable using db | ]) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; simplification by imp_not_l &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- context [(?P → False) → ?Q] ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite (imp_not_l P Q); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ solve_decidable using db | ] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rewriting by not_or_iff &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- context [?P ∨ ?Q → False] ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite (not_or_iff P Q) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rewriting by not_and_iff &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- context [?P ∧ ?Q → False] ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite (not_and_iff P Q) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rewriting by not_imp_iff &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- context [(?P → ?Q) → False] ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite (not_imp_iff P Q); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ solve_decidable using db | ] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fold any not. &nbsp;&nbsp;&nbsp;&nbsp;Tactic Notation \"push\" \"not\" := &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push not using core. &nbsp;&nbsp;&nbsp;&nbsp;Tactic Notation &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"push\" \"not\" \"in\" \"*\" \"|-\" \"using\" ident(db) := &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unfold not, iff in × |-; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repeat ( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match goal with &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; simplification by not_true_iff &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| H: context [True → False] |- _ ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite not_true_iff in H &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; simplification by not_false_iff &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| H: context [False → False] |- _ ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite not_false_iff in H &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; simplification by not_not_iff &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| H: context [(?P → False) → False] |- _ ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite (not_not_iff P) in H; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ | solve_decidable using db ] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; simplification by contrapositive &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| H: context [(?P → False) → (?Q → False)] |- _ ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite (contrapositive P Q) in H; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ | solve_decidable using db ] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; simplification by or_not_l_iff_1/2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| H: context [(?P → False) ∨ ?Q] |- _ ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rewrite (or_not_l_iff_1 P Q) in H; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ | solve_decidable using db ]) || &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rewrite (or_not_l_iff_2 P Q) in H; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ | solve_decidable using db ]) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; simplification by or_not_r_iff_1/2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| H: context [?P ∨ (?Q → False)] |- _ ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rewrite (or_not_r_iff_1 P Q) in H; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ | solve_decidable using db ]) || &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rewrite (or_not_r_iff_2 P Q) in H; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ | solve_decidable using db ]) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; simplification by imp_not_l &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| H: context [(?P → False) → ?Q] |- _ ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite (imp_not_l P Q) in H; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ | solve_decidable using db ] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rewriting by not_or_iff &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| H: context [?P ∨ ?Q → False] |- _ ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite (not_or_iff P Q) in H &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rewriting by not_and_iff &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| H: context [?P ∧ ?Q → False] |- _ ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite (not_and_iff P Q) in H &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rewriting by not_imp_iff &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| H: context [(?P → ?Q) → False] |- _ ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite (not_imp_iff P Q) in H; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ | solve_decidable using db ] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fold any not. &nbsp;&nbsp;&nbsp;&nbsp;Tactic Notation \"push\" \"not\" \"in\" \"*\" \"|-\" := &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push not in × |- using core. &nbsp;&nbsp;&nbsp;&nbsp;Tactic Notation \"push\" \"not\" \"in\" \"*\" \"using\" ident(db) := &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push not using db; push not in × |- using db. &nbsp;&nbsp;&nbsp;&nbsp;Tactic Notation \"push\" \"not\" \"in\" \"*\" := &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push not in × using core. A simple test case to see how this works. &nbsp;&nbsp;&nbsp;&nbsp;Lemma test_push : ∀ P Q R : Prop, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decidable P → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decidable Q → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(¬ True) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(¬ False) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(¬ ¬ P) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(¬ (P ∧ Q) → ¬ R) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((P ∧ Q) ∨ ¬ R) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(¬ (P ∧ Q) ∨ R) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(R ∨ ¬ (P ∧ Q)) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(¬ R ∨ (P ∧ Q)) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(¬ P → R) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(¬ ((R → P) ∨ (R → Q))) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(¬ (P ∧ R)) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(¬ (P → R)) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;True. pull not using db will pull as many negations as possible toward the top of the propositions in the goal, using the lemmas in db to assist in checking the decidability of the propositions involved. If using db is omitted, then core will be used. Additional versions are provided to manipulate the hypotheses or the hypotheses and goal together. &nbsp;&nbsp;&nbsp;&nbsp;Tactic Notation \"pull\" \"not\" \"using\" ident(db) := &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unfold not, iff; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repeat ( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match goal with &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; simplification by not_true_iff &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- context [True → False] ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite not_true_iff &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; simplification by not_false_iff &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- context [False → False] ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite not_false_iff &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; simplification by not_not_iff &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- context [(?P → False) → False] ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite (not_not_iff P); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ solve_decidable using db | ] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; simplification by contrapositive &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- context [(?P → False) → (?Q → False)] ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite (contrapositive P Q); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ solve_decidable using db | ] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; simplification by or_not_l_iff_1/2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- context [(?P → False) ∨ ?Q] ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rewrite (or_not_l_iff_1 P Q); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ solve_decidable using db | ]) || &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rewrite (or_not_l_iff_2 P Q); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ solve_decidable using db | ]) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; simplification by or_not_r_iff_1/2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- context [?P ∨ (?Q → False)] ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rewrite (or_not_r_iff_1 P Q); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ solve_decidable using db | ]) || &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rewrite (or_not_r_iff_2 P Q); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ solve_decidable using db | ]) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; simplification by imp_not_l &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- context [(?P → False) → ?Q] ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite (imp_not_l P Q); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ solve_decidable using db | ] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rewriting by not_or_iff &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- context [(?P → False) ∧ (?Q → False)] ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite &lt;- (not_or_iff P Q) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rewriting by not_and_iff &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- context [?P → ?Q → False] ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite &lt;- (not_and_iff P Q) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rewriting by not_imp_iff &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- context [?P ∧ (?Q → False)] ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite &lt;- (not_imp_iff P Q); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ solve_decidable using db | ] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rewriting by not_imp_rev_iff &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|- context [(?Q → False) ∧ ?P] ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite &lt;- (not_imp_rev_iff P Q); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ solve_decidable using db | ] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fold any not. &nbsp;&nbsp;&nbsp;&nbsp;Tactic Notation \"pull\" \"not\" := &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pull not using core. &nbsp;&nbsp;&nbsp;&nbsp;Tactic Notation &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"pull\" \"not\" \"in\" \"*\" \"|-\" \"using\" ident(db) := &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unfold not, iff in × |-; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repeat ( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match goal with &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; simplification by not_true_iff &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| H: context [True → False] |- _ ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite not_true_iff in H &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; simplification by not_false_iff &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| H: context [False → False] |- _ ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite not_false_iff in H &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; simplification by not_not_iff &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| H: context [(?P → False) → False] |- _ ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite (not_not_iff P) in H; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ | solve_decidable using db ] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; simplification by contrapositive &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| H: context [(?P → False) → (?Q → False)] |- _ ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite (contrapositive P Q) in H; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ | solve_decidable using db ] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; simplification by or_not_l_iff_1/2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| H: context [(?P → False) ∨ ?Q] |- _ ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rewrite (or_not_l_iff_1 P Q) in H; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ | solve_decidable using db ]) || &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rewrite (or_not_l_iff_2 P Q) in H; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ | solve_decidable using db ]) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; simplification by or_not_r_iff_1/2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| H: context [?P ∨ (?Q → False)] |- _ ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rewrite (or_not_r_iff_1 P Q) in H; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ | solve_decidable using db ]) || &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rewrite (or_not_r_iff_2 P Q) in H; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ | solve_decidable using db ]) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; simplification by imp_not_l &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| H: context [(?P → False) → ?Q] |- _ ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite (imp_not_l P Q) in H; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ | solve_decidable using db ] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rewriting by not_or_iff &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| H: context [(?P → False) ∧ (?Q → False)] |- _ ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite &lt;- (not_or_iff P Q) in H &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rewriting by not_and_iff &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| H: context [?P → ?Q → False] |- _ ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite &lt;- (not_and_iff P Q) in H &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rewriting by not_imp_iff &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| H: context [?P ∧ (?Q → False)] |- _ ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite &lt;- (not_imp_iff P Q) in H; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ | solve_decidable using db ] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rewriting by not_imp_rev_iff &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| H: context [(?Q → False) ∧ ?P] |- _ ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite &lt;- (not_imp_rev_iff P Q) in H; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ | solve_decidable using db ] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fold any not. &nbsp;&nbsp;&nbsp;&nbsp;Tactic Notation \"pull\" \"not\" \"in\" \"*\" \"|-\" := &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pull not in × |- using core. &nbsp;&nbsp;&nbsp;&nbsp;Tactic Notation \"pull\" \"not\" \"in\" \"*\" \"using\" ident(db) := &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pull not using db; pull not in × |- using db. &nbsp;&nbsp;&nbsp;&nbsp;Tactic Notation \"pull\" \"not\" \"in\" \"*\" := &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pull not in × using core. A simple test case to see how this works. &nbsp;&nbsp;&nbsp;&nbsp;Lemma test_pull : ∀ P Q R : Prop, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decidable P → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decidable Q → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(¬ True) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(¬ False) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(¬ ¬ P) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(¬ (P ∧ Q) → ¬ R) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((P ∧ Q) ∨ ¬ R) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(¬ (P ∧ Q) ∨ R) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(R ∨ ¬ (P ∧ Q)) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(¬ R ∨ (P ∧ Q)) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(¬ P → R) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(¬ (R → P) ∧ ¬ (R → Q)) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(¬ P ∨ ¬ R) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(P ∧ ¬ R) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(¬ R ∧ P) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;True. &nbsp;&nbsp;End FSetLogicalFacts. ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.FSetDecide.html",
    "relUrl": "/proofs/Top.Util.FSetDecide.html"
  },"85": {
    "doc": "Top.Util.FSetDecide",
    "title": "Auxiliary Tactics",
    "content": "Again, these lemmas and tactics are in a module so that they do not affect the namespace if you import the enclosing module Decide. &nbsp;&nbsp;Module FSetDecideAuxiliary. ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.FSetDecide.html",
    "relUrl": "/proofs/Top.Util.FSetDecide.html"
  },"86": {
    "doc": "Top.Util.FSetDecide",
    "title": "Generic Tactics",
    "content": "We begin by defining a few generic, useful tactics. if t then t1 else t2 executes t and, if it does not fail, then t1 will be applied to all subgoals produced. If t fails, then t2 is executed. &nbsp;&nbsp;&nbsp;&nbsp;Tactic Notation &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"if\" tactic(t) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"then\" tactic(t1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"else\" tactic(t2) := &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;first [ t; first [ t1 | fail 2 ] | t2 ]. prop P holds by t succeeds (but does not modify the goal or context) if the proposition P can be proved by t in the current context. Otherwise, the tactic fails. &nbsp;&nbsp;&nbsp;&nbsp;Tactic Notation \"prop\" constr(P) \"holds\" \"by\" tactic(t) := &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let H := fresh in &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert P as H by t; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clear H. This tactic acts just like assert ... by ... but will fail if the context already contains the proposition. &nbsp;&nbsp;&nbsp;&nbsp;Tactic Notation \"assert\" \"new\" constr(e) \"by\" tactic(t) := &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match goal with &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| H: e |- _ ⇒ fail 1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| _ ⇒ assert e by t &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end. subst++ is similar to subst except that . | it never fails (as subst does on recursive equations), | it substitutes locally defined variable for their definitions, | it performs beta reductions everywhere, which may arise after substituting a locally defined function for its definition. | . &nbsp;&nbsp;&nbsp;&nbsp;Tactic Notation \"subst\" \"++\" := &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repeat ( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match goal with &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| x : _ |- _ ⇒ subst x &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cbv zeta beta in ×. If you have a negated goal and H is a negated hypothesis, then contra H exchanges your goal and H, removing the negations. (Just like swap but reuses the same name. decompose records calls decompose record H on every relevant hypothesis H. &nbsp;&nbsp;&nbsp;&nbsp;Tactic Notation \"decompose\" \"records\" := &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repeat ( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;match goal with &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| H: _ |- _ ⇒ progress (decompose record H); clear H &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end). ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.FSetDecide.html",
    "relUrl": "/proofs/Top.Util.FSetDecide.html"
  },"87": {
    "doc": "Top.Util.FSetDecide",
    "title": "Discarding Irrelevant Hypotheses",
    "content": "We will want to clear the context of any non-FSet-related hypotheses in order to increase the speed of the tactic. To do this, we will need to be able to decide which are relevant. We do this by making a simple inductive definition classifying the propositions of interest. &nbsp;&nbsp;&nbsp;&nbsp;Inductive FSet_elt_Prop : Prop → Prop := &nbsp;&nbsp;&nbsp;&nbsp;| eq_Prop : ∀ (S : Set) (x y : S), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FSet_elt_Prop (x = y) &nbsp;&nbsp;&nbsp;&nbsp;| eq_elt_prop : ∀ x y, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FSet_elt_Prop (E.eq x y) &nbsp;&nbsp;&nbsp;&nbsp;| In_elt_prop : ∀ x s, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FSet_elt_Prop (In x s) &nbsp;&nbsp;&nbsp;&nbsp;| True_elt_prop : &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FSet_elt_Prop True &nbsp;&nbsp;&nbsp;&nbsp;| False_elt_prop : &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FSet_elt_Prop False &nbsp;&nbsp;&nbsp;&nbsp;| conj_elt_prop : ∀ P Q, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FSet_elt_Prop P → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FSet_elt_Prop Q → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FSet_elt_Prop (P ∧ Q) &nbsp;&nbsp;&nbsp;&nbsp;| disj_elt_prop : ∀ P Q, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FSet_elt_Prop P → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FSet_elt_Prop Q → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FSet_elt_Prop (P ∨ Q) &nbsp;&nbsp;&nbsp;&nbsp;| impl_elt_prop : ∀ P Q, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FSet_elt_Prop P → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FSet_elt_Prop Q → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FSet_elt_Prop (P → Q) &nbsp;&nbsp;&nbsp;&nbsp;| not_elt_prop : ∀ P, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FSet_elt_Prop P → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FSet_elt_Prop (¬ P). &nbsp;&nbsp;&nbsp;&nbsp;Inductive FSet_Prop : Prop → Prop := &nbsp;&nbsp;&nbsp;&nbsp;| elt_FSet_Prop : ∀ P, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FSet_elt_Prop P → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FSet_Prop P &nbsp;&nbsp;&nbsp;&nbsp;| Empty_FSet_Prop : ∀ s, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FSet_Prop (Empty s) &nbsp;&nbsp;&nbsp;&nbsp;| Subset_FSet_Prop : ∀ s1 s2, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FSet_Prop (Subset s1 s2) &nbsp;&nbsp;&nbsp;&nbsp;| Equal_FSet_Prop : ∀ s1 s2, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FSet_Prop (Equal s1 s2). Here is the tactic that will throw away hypotheses that are not useful (for the intended scope of the fsetdec tactic). ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.FSetDecide.html",
    "relUrl": "/proofs/Top.Util.FSetDecide.html"
  },"88": {
    "doc": "Top.Util.FSetDecide",
    "title": "Turning Set Operators into Propositional Connectives",
    "content": "The lemmas from FSetFacts will be used to break down set operations into propositional formulas built over the predicates In and E.eq applied only to variables. We are going to use them with autorewrite. &nbsp;&nbsp;&nbsp;&nbsp;Module F := FSetFacts.Facts M. ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.FSetDecide.html",
    "relUrl": "/proofs/Top.Util.FSetDecide.html"
  },"89": {
    "doc": "Top.Util.FSetDecide",
    "title": "Decidability of FSet Propositions",
    "content": "In is decidable. &nbsp;&nbsp;&nbsp;&nbsp;Module D := DepOfNodep M. &nbsp;&nbsp;&nbsp;&nbsp;Lemma dec_In : ∀ x s, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decidable (In x s). E.eq is decidable. &nbsp;&nbsp;&nbsp;&nbsp;Module OTE := MOT_to_OT E. &nbsp;&nbsp;&nbsp;&nbsp;Lemma dec_eq : ∀ (x y : E.t), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decidable (E.eq x y). The hint database FSet_decidability will be given to the push_neg tactic from the module Negation. ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.FSetDecide.html",
    "relUrl": "/proofs/Top.Util.FSetDecide.html"
  },"90": {
    "doc": "Top.Util.FSetDecide",
    "title": "Normalizing Propositions About Equality",
    "content": "We have to deal with the fact that E.eq may be convertible with Coq's equality. Thus, we will find the following tactics useful to replace one form with the other everywhere. The next tactic, Logic_eq_to_E_eq, mentions the term E.t; thus, we must ensure that E.t is used in favor of any other convertible but syntactically distinct term. These two tactics take us from Coq's built-in equality to E.eq (and vice versa) when possible. This tactic works like the built-in tactic subst, but at the level of set element equality (which may not be the convertible with Coq's equality). ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.FSetDecide.html",
    "relUrl": "/proofs/Top.Util.FSetDecide.html"
  },"91": {
    "doc": "Top.Util.FSetDecide",
    "title": "Considering Decidability of Base Propositions",
    "content": "This tactic adds assertions about the decidability of E.eq and In to the context. This is necessary for the completeness of the fsetdec tactic. However, in order to minimize the cost of proof search, we should be careful to not add more than we need. Once negations have been pushed to the leaves of the propositions, we only need to worry about decidability for those base propositions that appear in a negated form. ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.FSetDecide.html",
    "relUrl": "/proofs/Top.Util.FSetDecide.html"
  },"92": {
    "doc": "Top.Util.FSetDecide",
    "title": "Handling Empty, Subset, and Equal",
    "content": "This tactic instantiates universally quantified hypotheses (which arise from the unfolding of Empty, Subset, and Equal) for each of the set element expressions that is involved in some membership or equality fact. Then it throws away those hypotheses, which should no longer be needed. ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.FSetDecide.html",
    "relUrl": "/proofs/Top.Util.FSetDecide.html"
  },"93": {
    "doc": "Top.Util.FSetDecide",
    "title": "The Core fsetdec Auxiliary Tactics",
    "content": "Here is the crux of the proof search. Recursion through intuition! (This will terminate if I correctly understand the behavior of intuition.) If we add unfold Empty, Subset, Equal in *; intros; to the beginning of this tactic, it will satisfy the same specification as the fsetdec tactic; however, it will be much slower than necessary without the pre-processing done by the wrapper tactic fsetdec. &nbsp;&nbsp;End FSetDecideAuxiliary. ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.FSetDecide.html",
    "relUrl": "/proofs/Top.Util.FSetDecide.html"
  },"94": {
    "doc": "Top.Util.FSetDecide",
    "title": "The fsetdec Tactic",
    "content": "Here is the top-level tactic (the only one intended for clients of this library). It's specification is given at the top of the file. ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.FSetDecide.html",
    "relUrl": "/proofs/Top.Util.FSetDecide.html"
  },"95": {
    "doc": "Top.Util.FSetDecide",
    "title": "Examples",
    "content": "&nbsp;&nbsp;Module FSetDecideTestCases. &nbsp;&nbsp;&nbsp;&nbsp;Lemma test_eq_trans_1 : ∀ x y z s, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E.eq x y → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;¬ ¬ E.eq z y → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In x s → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In z s. &nbsp;&nbsp;&nbsp;&nbsp;Lemma test_eq_trans_2 : ∀ x y z r s, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In x (singleton y) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;¬ In z r → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;¬ ¬ In z (add y r) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In x s → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In z s. &nbsp;&nbsp;&nbsp;&nbsp;Lemma test_eq_neq_trans_1 : ∀ w x y z s, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E.eq x w → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;¬ ¬ E.eq x y → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;¬ E.eq y z → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In w s → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In w (remove z s). &nbsp;&nbsp;&nbsp;&nbsp;Lemma test_eq_neq_trans_2 : ∀ w x y z r1 r2 s, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In x (singleton w) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;¬ In x r1 → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In x (add y r1) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In y r2 → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In y (remove z r2) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In w s → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In w (remove z s). &nbsp;&nbsp;&nbsp;&nbsp;Lemma test_In_singleton : ∀ x, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In x (singleton x). &nbsp;&nbsp;&nbsp;&nbsp;Lemma test_Subset_add_remove : ∀ x s, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s [&lt;=] (add x (remove x s)). &nbsp;&nbsp;&nbsp;&nbsp;Lemma test_eq_disjunction : ∀ w x y z, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In w (add x (add y (singleton z))) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E.eq w x ∨ E.eq w y ∨ E.eq w z. &nbsp;&nbsp;&nbsp;&nbsp;Lemma test_not_In_disj : ∀ x y s1 s2 s3 s4, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;¬ In x (union s1 (union s2 (union s3 (add y s4)))) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;¬ (In x s1 ∨ In x s4 ∨ E.eq y x). &nbsp;&nbsp;&nbsp;&nbsp;Lemma test_not_In_conj : ∀ x y s1 s2 s3 s4, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;¬ In x (union s1 (union s2 (union s3 (add y s4)))) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;¬ In x s1 ∧ ¬ In x s4 ∧ ¬ E.eq y x. &nbsp;&nbsp;&nbsp;&nbsp;Lemma test_iff_conj : ∀ a x s s', &nbsp;&nbsp;&nbsp;&nbsp;(In a s' ↔ E.eq x a ∨ In a s) → &nbsp;&nbsp;&nbsp;&nbsp;(In a s' ↔ In a (add x s)). &nbsp;&nbsp;&nbsp;&nbsp;Lemma test_set_ops_1 : ∀ x q r s, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(singleton x) [&lt;=] s → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Empty (union q r) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Empty (inter (diff s q) (diff s r)) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;¬ In x s. &nbsp;&nbsp;&nbsp;&nbsp;Lemma eq_chain_test : ∀ x1 x2 x3 x4 s1 s2 s3 s4, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Empty s1 → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In x2 (add x1 s1) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In x3 s2 → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;¬ In x3 (remove x2 s2) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;¬ In x4 s3 → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In x4 (add x3 s3) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In x1 s4 → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Subset (add x4 s4) s4. &nbsp;&nbsp;&nbsp;&nbsp;Lemma test_too_complex : ∀ x y z r s, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E.eq x y → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(In x (singleton y) → r [&lt;=] s) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In z r → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In z s. fsetdec is not intended to solve this directly. &nbsp;&nbsp;&nbsp;&nbsp;Lemma function_test_1 : &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;∀ (f : t → t), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;∀ (g : elt → elt), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;∀ (s1 s2 : t), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;∀ (x1 x2 : elt), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equal s1 (f s2) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E.eq x1 (g (g x2)) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In x1 s1 → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In (g (g x2)) (f s2). &nbsp;&nbsp;&nbsp;&nbsp;Lemma function_test_2 : &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;∀ (f : t → t), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;∀ (g : elt → elt), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;∀ (s1 s2 : t), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;∀ (x1 x2 : elt), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equal s1 (f s2) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E.eq x1 (g x2) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In x1 s1 → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g x2 = g (g x2) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In (g (g x2)) (f s2). fsetdec is not intended to solve this directly. &nbsp;&nbsp;End FSetDecideTestCases. End Decide. ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.FSetDecide.html",
    "relUrl": "/proofs/Top.Util.FSetDecide.html"
  },"96": {
    "doc": "Top.Util.FSetNotin",
    "title": "Top.Util.FSetNotin",
    "content": "Lemmas and tactics for working with and solving goals related to non-membership in finite sets. The main tactic of interest here is notin_solve. Authors: Arthur Charguéraud and Brian Aydemir. (*&nbsp;***********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.FSetNotin.html",
    "relUrl": "/proofs/Top.Util.FSetNotin.html"
  },"97": {
    "doc": "Top.Util.FSetNotin",
    "title": "Implementation",
    "content": "Module Notin (X : FSetInterface.S). (*&nbsp;***********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.FSetNotin.html",
    "relUrl": "/proofs/Top.Util.FSetNotin.html"
  },"98": {
    "doc": "Top.Util.FSetNotin",
    "title": "Facts about set (non-)membership",
    "content": "Lemma in_singleton : ∀ x, &nbsp;&nbsp;In x (singleton x). Lemma notin_empty : ∀ x, &nbsp;&nbsp;¬ In x empty. Lemma notin_union : ∀ x E F, &nbsp;&nbsp;¬ In x E → ¬ In x F → ¬ In x (union E F). Lemma elim_notin_union : ∀ x E F, &nbsp;&nbsp;¬ In x (union E F) → (¬ In x E) ∧ (¬ In x F). Lemma notin_singleton : ∀ x y, &nbsp;&nbsp;¬ E.eq x y → ¬ In x (singleton y). Lemma elim_notin_singleton : ∀ x y, &nbsp;&nbsp;¬ In x (singleton y) → ¬ E.eq x y. Lemma elim_notin_singleton' : ∀ x y, &nbsp;&nbsp;¬ In x (singleton y) → x ≠ y. Lemma notin_singleton_swap : ∀ x y, &nbsp;&nbsp;¬ In x (singleton y) → ¬ In y (singleton x). (*&nbsp;***********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.FSetNotin.html",
    "relUrl": "/proofs/Top.Util.FSetNotin.html"
  },"99": {
    "doc": "Top.Util.FSetNotin",
    "title": "Rewriting non-membership facts",
    "content": "Lemma notin_singleton_rw : ∀ x y, &nbsp;&nbsp;¬ In x (singleton y) ↔ ¬ E.eq x y. (*&nbsp;***********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.FSetNotin.html",
    "relUrl": "/proofs/Top.Util.FSetNotin.html"
  },"100": {
    "doc": "Top.Util.FSetNotin",
    "title": "Tactics",
    "content": "The tactic notin_simpl_hyps destructs all hypotheses of the form (~ In x E), where E is built using only empty, union, and singleton. The tactic notin_solve solves goals of them form (x ≠ y) and (~ In x E) that are provable from hypotheses of the form destructed by notin_simpl_hyps. (*&nbsp;***********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.FSetNotin.html",
    "relUrl": "/proofs/Top.Util.FSetNotin.html"
  },"101": {
    "doc": "Top.Util.FSetNotin",
    "title": "Examples and test cases",
    "content": "Lemma test_notin_solve_1 : ∀ x E F G, &nbsp;&nbsp;¬ In x (union E F) → ¬ In x G → ¬ In x (union E G). Lemma test_notin_solve_2 : ∀ x y E F G, &nbsp;&nbsp;¬ In x (union E (union (singleton y) F)) → ¬ In x G → &nbsp;&nbsp;¬ In x (singleton y) ∧ ¬ In y (singleton x). Lemma test_notin_solve_3 : ∀ x y, &nbsp;&nbsp;¬ E.eq x y → ¬ In x (singleton y) ∧ ¬ In y (singleton x). Lemma test_notin_solve_4 : ∀ x y E F G, &nbsp;&nbsp;¬ In x (union E (union (singleton x) F)) → ¬ In y G. Lemma test_notin_solve_5 : ∀ x y E F, &nbsp;&nbsp;¬ In x (union E (union (singleton y) F)) → ¬ In y E → &nbsp;&nbsp;¬ E.eq y x ∧ ¬ E.eq x y. End Notin. ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.FSetNotin.html",
    "relUrl": "/proofs/Top.Util.FSetNotin.html"
  },"102": {
    "doc": "Top.Util.FiniteSets",
    "title": "Top.Util.FiniteSets",
    "content": "A library for finite sets with extensional equality. Author: Brian Aydemir. (*&nbsp;***********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.FiniteSets.html",
    "relUrl": "/proofs/Top.Util.FiniteSets.html"
  },"103": {
    "doc": "Top.Util.FiniteSets",
    "title": "Interface",
    "content": "The following interface wraps the standard library's finite set interface with an additional property: extensional equality. Module Type S. &nbsp;&nbsp;Declare Module E : UsualOrderedType. &nbsp;&nbsp;Declare Module F : FSetInterface.S with Module E := E. &nbsp;&nbsp;Parameter eq_if_Equal : &nbsp;&nbsp;&nbsp;&nbsp;∀ s s' : F.t, F.Equal s s' → s = s'. End S. (*&nbsp;***********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.FiniteSets.html",
    "relUrl": "/proofs/Top.Util.FiniteSets.html"
  },"104": {
    "doc": "Top.Util.FiniteSets",
    "title": "Implementation",
    "content": "For documentation purposes, we hide the implementation of a functor implementing the above interface. We note only that the implementation here assumes (as an axiom) that proof irrelevance holds. Module Make (X : UsualOrderedType) &lt;: S with Module E := X. End Make. ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.FiniteSets.html",
    "relUrl": "/proofs/Top.Util.FiniteSets.html"
  },"105": {
    "doc": "Top.Util.Label",
    "title": "Top.Util.Label",
    "content": "Support for atoms, i.e., objects with decidable equality. We provide here the ability to generate an atom fresh for any finite collection, e.g., the lemma atom_fresh_for_set, and a tactic to pick an atom fresh for the current proof context. Authors: Arthur Charguéraud and Brian Aydemir. Implementation note: In older versions of Coq, OrderedTypeEx redefines decimal constants to be integers and not natural numbers. The following scope declaration is intended to address this issue. In newer versions of Coq, the declaration should be benign. (*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Label.html",
    "relUrl": "/proofs/Top.Util.Label.html"
  },"106": {
    "doc": "Top.Util.Label",
    "title": "Definition",
    "content": "Labels are structureless objects such that we can always generate one fresh from a finite collection. Equality on labels is eq and decidable. We use Coq's module system to make abstract the implementation of labels. The Export LabelImpl line below allows us to refer to the type atom and its properties without having to qualify everything with \"LabelImpl.\". Module Type LABEL. &nbsp;&nbsp;Parameter label : Set. &nbsp;&nbsp;Parameter label_fresh_for_list : &nbsp;&nbsp;&nbsp;&nbsp;∀ (xs : list label), {x : label | ¬ List.In x xs}. &nbsp;&nbsp;Declare Module Label_as_OT : UsualOrderedType with Definition t := label. &nbsp;&nbsp;Parameter eq_label_dec : ∀ x y : label, {x = y} + {x ≠ y}. End LABEL. The implementation of the above interface is hidden for documentation purposes. Module LabelImpl : LABEL. End LabelImpl. (*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Label.html",
    "relUrl": "/proofs/Top.Util.Label.html"
  },"107": {
    "doc": "Top.Util.Label",
    "title": "Finite sets of labels",
    "content": "(*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Label.html",
    "relUrl": "/proofs/Top.Util.Label.html"
  },"108": {
    "doc": "Top.Util.Label",
    "title": "Definitions",
    "content": "Module LabelSet : FiniteSets.S with Module E := Label_as_OT := &nbsp;&nbsp;FiniteSets.Make Label_as_OT. The type labels is the type of finite sets of labels. Notation labels := LabelSet.F.t. Notation &quot;{}L\" := &nbsp;&nbsp;LabelSet.F.empty : metatheory_scope. Basic operations on finite sets of labels are available, in the remainder of this file, without qualification. We use Import instead of Export in order to avoid unnecessary namespace pollution. We instantiate two modules which provide useful lemmas and tactics work working with finite sets of labels. Module LabelSetDecide := FSetDecide.Decide LabelSet.F. Module LabelSetNotin := FSetNotin.Notin LabelSet.F. Module LabelSetFacts := FSetFacts.Facts LabelSet.F. Module LabelSetProperties := FSetProperties.Properties LabelSet.F. (*&nbsp;***********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Label.html",
    "relUrl": "/proofs/Top.Util.Label.html"
  },"109": {
    "doc": "Top.Util.Label",
    "title": "Tactics for working with finite sets of labels",
    "content": "The tactic fsetdec is a general purpose decision procedure for solving facts about finite sets of labels. The tactic notin_simpl simplifies all hypotheses of the form (~ In x F), where F is constructed from the empty set, singleton sets, and unions. The tactic notin_solve, solves goals of the form (~ In x F), where F is constructed from the empty set, singleton sets, and unions. The goal must be provable from hypothesis of the form simplified by notin_simpl. (*&nbsp;***********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Label.html",
    "relUrl": "/proofs/Top.Util.Label.html"
  },"110": {
    "doc": "Top.Util.Label",
    "title": "Lemmas for working with finite sets of labels",
    "content": "We make some lemmas about finite sets of labels available without qualification by using abbreviations. Notation leq_if_Equal := LabelSet.eq_if_Equal. Notation lnotin_empty := LabelSetNotin.notin_empty. Notation lnotin_singleton := LabelSetNotin.notin_singleton. Notation lnotin_singleton_rw := LabelSetNotin.notin_singleton_rw. Notation lnotin_union := LabelSetNotin.notin_union. (*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Label.html",
    "relUrl": "/proofs/Top.Util.Label.html"
  },"111": {
    "doc": "Top.Util.Label",
    "title": "Additional properties",
    "content": "One can generate an label fresh for a given finite set of labels. Lemma label_fresh_for_set : ∀ L : labels, { x : label | ¬ In x L }. (*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Label.html",
    "relUrl": "/proofs/Top.Util.Label.html"
  },"112": {
    "doc": "Top.Util.Label",
    "title": "Additional tactics",
    "content": "(*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Label.html",
    "relUrl": "/proofs/Top.Util.Label.html"
  },"113": {
    "doc": "Top.Util.Label",
    "title": " Picking a fresh label",
    "content": "We define three tactics which, when combined, provide a simple mechanism for picking a fresh label. We demonstrate their use below with an example, the example_pick_fresh tactic. (gather_labels_with F) returns the union of (F x), where x ranges over all objects in the context such that (F x) is well typed. The return type of F should be labels. The complexity of this tactic is due to the fact that there is no support in Ltac for folding a function over the context. (beautify_lset V) takes a set V built as a union of finite sets and returns the same set with empty sets removed and union operations associated to the right. Duplicate sets are also removed from the union. The tactic (pick fresh Y for L) takes a finite set of labels L and a fresh name Y, and adds to the context an label with name Y and a proof that (~ In Y L), i.e., that Y is fresh for L. The tactic will fail if Y is already declared in the context. Tactic Notation \"pick\" \"fresh\" \"label\" ident(Y) \"for\" constr(L) := &nbsp;&nbsp;let Fr := fresh \"Fr\" in &nbsp;&nbsp;let L := beautify_lset L in &nbsp;&nbsp;(destruct (label_fresh_for_set L) as [Y Fr]). (*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Label.html",
    "relUrl": "/proofs/Top.Util.Label.html"
  },"114": {
    "doc": "Top.Util.Label",
    "title": "Demonstration",
    "content": "The example_pick_fresh tactic below illustrates the general pattern for using the above three tactics to define a tactic which picks a fresh label. The pattern is as follows: . | Repeatedly invoke gather_labels_with, using functions with different argument types each time. | Union together the result of the calls, and invoke (pick fresh ... for ...) with that union of sets. | . Lemma example_pick_fresh_use : ∀ (x y z : label) (L1 L2 L3: labels), True. Proof. &nbsp;&nbsp;intros x y z L1 L2 L3. example_pick_fresh k. At this point in the proof, we have a new label k and a hypothesis Fr : ¬ In k (union L1 (union L2 (union L3 (union (singleton x) (union (singleton y) (singleton z)))))). &nbsp;&nbsp;trivial. Qed. Notation &quot;x =l= y\" := (eq_label_dec x y) (at level 67) : metatheory_scope. Definition labels_disjoint (xs : labels) (ys: labels) : Prop := &nbsp;&nbsp;LabelSet.F.Empty (LabelSet.F.inter xs ys). ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Label.html",
    "relUrl": "/proofs/Top.Util.Label.html"
  },"115": {
    "doc": "Top.Util.ListFacts",
    "title": "Top.Util.ListFacts",
    "content": "Assorted facts about lists. Author: Brian Aydemir. Implicit arguments are declared by default in this library. (*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.ListFacts.html",
    "relUrl": "/proofs/Top.Util.ListFacts.html"
  },"116": {
    "doc": "Top.Util.ListFacts",
    "title": "List membership",
    "content": "Lemma not_in_cons : &nbsp;&nbsp;∀ (A : Type) (ys : list A) x y, &nbsp;&nbsp;x ≠ y → ¬ In x ys → ¬ In x (y :: ys). Lemma not_In_app : &nbsp;&nbsp;∀ (A : Type) (xs ys : list A) x, &nbsp;&nbsp;¬ In x xs → ¬ In x ys → ¬ In x (xs ++ ys). Lemma elim_not_In_cons : &nbsp;&nbsp;∀ (A : Type) (y : A) (ys : list A) (x : A), &nbsp;&nbsp;¬ In x (y :: ys) → x ≠ y ∧ ¬ In x ys. Lemma elim_not_In_app : &nbsp;&nbsp;∀ (A : Type) (xs ys : list A) (x : A), &nbsp;&nbsp;¬ In x (xs ++ ys) → ¬ In x xs ∧ ¬ In x ys. (*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.ListFacts.html",
    "relUrl": "/proofs/Top.Util.ListFacts.html"
  },"117": {
    "doc": "Top.Util.ListFacts",
    "title": "List inclusion",
    "content": "Lemma incl_nil : &nbsp;&nbsp;∀ (A : Type) (xs : list A), incl nil xs. Lemma incl_trans : &nbsp;&nbsp;∀ (A : Type) (xs ys zs : list A), &nbsp;&nbsp;incl xs ys → incl ys zs → incl xs zs. Lemma In_incl : &nbsp;&nbsp;∀ (A : Type) (x : A) (ys zs : list A), &nbsp;&nbsp;In x ys → incl ys zs → In x zs. Lemma elim_incl_cons : &nbsp;&nbsp;∀ (A : Type) (x : A) (xs zs : list A), &nbsp;&nbsp;incl (x :: xs) zs → In x zs ∧ incl xs zs. Lemma elim_incl_app : &nbsp;&nbsp;∀ (A : Type) (xs ys zs : list A), &nbsp;&nbsp;incl (xs ++ ys) zs → incl xs zs ∧ incl ys zs. (*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.ListFacts.html",
    "relUrl": "/proofs/Top.Util.ListFacts.html"
  },"118": {
    "doc": "Top.Util.ListFacts",
    "title": "Setoid facts",
    "content": "Lemma InA_iff_In : &nbsp;&nbsp;∀ (A : Set) x xs, InA (@eq A) x xs ↔ In x xs. (*&nbsp;*********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.ListFacts.html",
    "relUrl": "/proofs/Top.Util.ListFacts.html"
  },"119": {
    "doc": "Top.Util.ListFacts",
    "title": "Equality proofs for lists",
    "content": "Section EqRectList. Variable A : Type. Variable eq_A_dec : ∀ (x y : A), {x = y} + {x ≠ y}. Lemma eq_rect_eq_list : &nbsp;&nbsp;∀ (p : list A) (Q : list A → Type) (x : Q p) (h : p = p), &nbsp;&nbsp;eq_rect p Q x p h = x. End EqRectList. (*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.ListFacts.html",
    "relUrl": "/proofs/Top.Util.ListFacts.html"
  },"120": {
    "doc": "Top.Util.ListFacts",
    "title": "Decidable sorting and uniqueness of proofs",
    "content": "Section DecidableSorting. Variable A : Set. Variable leA : relation A. Hypothesis leA_dec : ∀ x y, {leA x y} + {¬ leA x y}. Theorem lelistA_dec : &nbsp;&nbsp;∀ a xs, {lelistA leA a xs} + {¬ lelistA leA a xs}. Theorem sort_dec : &nbsp;&nbsp;∀ xs, {sort leA xs} + {¬ sort leA xs}. Section UniqueSortingProofs. &nbsp;&nbsp;Hypothesis eq_A_dec : ∀ (x y : A), {x = y} + {x ≠ y}. &nbsp;&nbsp;Hypothesis leA_unique : ∀ (x y : A) (p q : leA x y), p = q. &nbsp;&nbsp;Scheme lelistA_ind' := Induction for lelistA Sort Prop. &nbsp;&nbsp;Scheme sort_ind' := Induction for sort Sort Prop. &nbsp;&nbsp;Theorem lelistA_unique : &nbsp;&nbsp;&nbsp;&nbsp;∀ (x : A) (xs : list A) (p q : lelistA leA x xs), p = q. &nbsp;&nbsp;Theorem sort_unique : &nbsp;&nbsp;&nbsp;&nbsp;∀ (xs : list A) (p q : sort leA xs), p = q. End UniqueSortingProofs. End DecidableSorting. (*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.ListFacts.html",
    "relUrl": "/proofs/Top.Util.ListFacts.html"
  },"121": {
    "doc": "Top.Util.ListFacts",
    "title": "Equality on sorted lists",
    "content": "Section Equality_ext. Variable A : Type. Variable ltA : relation A. Hypothesis ltA_trans : ∀ x y z, ltA x y → ltA y z → ltA x z. Hypothesis ltA_not_eqA : ∀ x y, ltA x y → x ≠ y. Hypothesis ltA_eqA : ∀ x y z, ltA x y → y = z → ltA x z. Hypothesis eqA_ltA : ∀ x y z, x = y → ltA y z → ltA x z. Notation Inf := (lelistA ltA). Notation Sort := (sort ltA). Lemma strictorder_irrel : &nbsp;&nbsp;∀ a, (complement ltA) a a. Instance strictorder_ltA : StrictOrder ltA := { &nbsp;&nbsp;&nbsp;StrictOrder_Irreflexive := strictorder_irrel; &nbsp;&nbsp;&nbsp;StrictOrder_Transitive := ltA_trans }. Lemma not_InA_if_Sort_Inf : &nbsp;&nbsp;∀ xs a, Sort xs → Inf a xs → ¬ InA (@eq A) a xs. Lemma Sort_eq_head : &nbsp;&nbsp;∀ x xs y ys, &nbsp;&nbsp;Sort (x :: xs) → &nbsp;&nbsp;Sort (y :: ys) → &nbsp;&nbsp;(∀ a, InA (@eq A) a (x :: xs) ↔ InA (@eq A) a (y :: ys)) → &nbsp;&nbsp;x = y. Lemma Sort_InA_eq_ext : &nbsp;&nbsp;∀ xs ys, &nbsp;&nbsp;Sort xs → &nbsp;&nbsp;Sort ys → &nbsp;&nbsp;(∀ a, InA (@eq A) a xs ↔ InA (@eq A) a ys) → &nbsp;&nbsp;xs = ys. End Equality_ext. ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.ListFacts.html",
    "relUrl": "/proofs/Top.Util.ListFacts.html"
  },"122": {
    "doc": "Top.Util.Nat",
    "title": "Top.Util.Nat",
    "content": "Helpers, defining a set of natural numbers. Module Type NATSET. &nbsp;&nbsp;Declare Module OT : UsualOrderedType with Definition t := nat. &nbsp;&nbsp;Parameter eq_nat_dec : ∀ x y : nat, {x = y} + {x ≠ y}. End NATSET. The implementation of the above interface is hidden for documentation purposes. Module NatSetImpl : NATSET. End NatSetImpl. Defining a set of Natural Numbers. Module NatSet : FiniteSets.S with Module E := NatSetImpl.OT := &nbsp;&nbsp;FiniteSets.Make NatSetImpl.OT. The type nats is the type of finite sets of nats. Notation nats := NatSet.F.t. Notation &quot;{}N\" := &nbsp;&nbsp;NatSet.F.empty : metatheory_scope. We instantiate two modules which provide useful lemmas and tactics work working with finite sets of atoms. Module NatSetDecide := FSetDecide.Decide NatSet.F. Module NatSetNotin := FSetNotin.Notin NatSet.F. Module NatSetFacts := FSetFacts.Facts NatSet.F. Module NatSetProperties := FSetProperties.Properties NatSet.F. (*&nbsp;***********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Nat.html",
    "relUrl": "/proofs/Top.Util.Nat.html"
  },"123": {
    "doc": "Top.Util.Nat",
    "title": "Tactics for working with finite sets of nats",
    "content": "The tactic fnsetdec is a general purpose decision procedure for solving facts about finite sets of atoms. The tactic notin_simpl simplifies all hypotheses of the form (~ In x F), where F is constructed from the empty set, singleton sets, and unions. The tactic notin_solve, solves goals of the form (~ In x F), where F is constructed from the empty set, singleton sets, and unions. The goal must be provable from hypothesis of the form simplified by notin_simpl. ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Nat.html",
    "relUrl": "/proofs/Top.Util.Nat.html"
  },"124": {
    "doc": "Top.Util.Signatures",
    "title": "Top.Util.Signatures",
    "content": "Operations, lemmas, and tactics for working with environments, association lists whose keys are labels. Unless stated otherwise, implicit arguments will not be declared by default. Authors: Brian Aydemir and Arthur Charguéraud, with help from Aaron Bohannon, Benjamin Pierce, Jeffrey Vaughan, Dimitrios Vytiniotis, Stephanie Weirich, and Steve Zdancewic. : . | Overview | Functions on environments | Relations on environments | Properties of operations | Automation and tactics (I) | Properties of well-formedness and freshness | Properties of binds | Automation and tactics (II) | Additional properties of binds | Automation and tactics (III) | . (*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Signatures.html",
    "relUrl": "/proofs/Top.Util.Signatures.html"
  },"125": {
    "doc": "Top.Util.Signatures",
    "title": " Overview",
    "content": "In the remainder of this library, we define a number of operations, lemmas, and tactics that simplify working with environments. Notation &quot;[ x ]\" := (cons x nil). Module Signatures. (*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Signatures.html",
    "relUrl": "/proofs/Top.Util.Signatures.html"
  },"126": {
    "doc": "Top.Util.Signatures",
    "title": " Functions on environments",
    "content": "Implicit arguments will be declared by default for the definitions in this section. Section Definitions. Variables A B : Type. The domain of an environment is the set of labels that it maps. Fixpoint dom (E : list (label × A)) : labels := &nbsp;&nbsp;match E with &nbsp;&nbsp;| nil ⇒ empty &nbsp;&nbsp;| (x, _) :: E' ⇒ union (singleton x) (dom E') &nbsp;&nbsp;end. map applies a function to all bindings in the environment. Fixpoint map (f : A → B) (E : list (label × A)) : list (label × B) := &nbsp;&nbsp;match E with &nbsp;&nbsp;| nil ⇒ nil &nbsp;&nbsp;| (x, V) :: E' ⇒ (x, f V) :: map f E' &nbsp;&nbsp;end. get returns the value bound to the given label in an environment or None if the given label is not bound. If the label has multiple bindings, the one nearest to the head of the environment is returned. Fixpoint get (x : label) (E : list (label × A)) : option A := &nbsp;&nbsp;match E with &nbsp;&nbsp;| nil ⇒ None &nbsp;&nbsp;| (y,a) :: E' ⇒ if eq_label_dec x y then Some a else get x E' &nbsp;&nbsp;end. End Definitions. (*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Signatures.html",
    "relUrl": "/proofs/Top.Util.Signatures.html"
  },"127": {
    "doc": "Top.Util.Signatures",
    "title": " Relations on environments",
    "content": "Implicit arguments will be declared by default for the definitions in this section. Section Relations. Variable A : Type. An environment is well-formed if and only if each label is bound at most once. Inductive ok : list (label × A) → Prop := &nbsp;&nbsp;| ok_nil : &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ok nil &nbsp;&nbsp;| ok_cons : ∀ (E : list (label × A)) (x : label) (a : A), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ok E → ¬ In x (dom E) → ok ((x, a) :: E). An environment E contains a binding from x to b, denoted (binds x b E), if and only if the most recent binding for x is mapped to b. Definition binds x b (E : list (label × A)) := &nbsp;&nbsp;get x E = Some b. End Relations. (*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Signatures.html",
    "relUrl": "/proofs/Top.Util.Signatures.html"
  },"128": {
    "doc": "Top.Util.Signatures",
    "title": " Properties of operations",
    "content": "Section OpProperties. Variable A B : Type. Implicit Types E F : list (label × A). Implicit Types a b : A. ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Signatures.html",
    "relUrl": "/proofs/Top.Util.Signatures.html"
  },"129": {
    "doc": "Top.Util.Signatures",
    "title": "Facts about concatenation",
    "content": "Lemma concat_nil : ∀ E, &nbsp;&nbsp;E ++ nil = E. Lemma nil_concat : ∀ E, &nbsp;&nbsp;nil ++ E = E. Lemma concat_assoc : ∀ E F G, &nbsp;&nbsp;(G ++ F) ++ E = G ++ (F ++ E). ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Signatures.html",
    "relUrl": "/proofs/Top.Util.Signatures.html"
  },"130": {
    "doc": "Top.Util.Signatures",
    "title": "map commutes with environment-building operations",
    "content": "Lemma map_nil : ∀ (f : A → B), &nbsp;&nbsp;map f nil = nil. Lemma map_single : ∀ (f : A → B) y b, &nbsp;&nbsp;map f [(y,b)] = [(y, f b)]. Lemma map_push : ∀ (f : A → B) y b E, &nbsp;&nbsp;map f ([(y,b)] ++ E) = [(y, f b)] ++ map f E. Lemma map_concat : ∀ (f : A → B) E F, &nbsp;&nbsp;map f (F ++ E) = (map f F) ++ (map f E). ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Signatures.html",
    "relUrl": "/proofs/Top.Util.Signatures.html"
  },"131": {
    "doc": "Top.Util.Signatures",
    "title": "Facts about the domain of an environment",
    "content": "Lemma dom_nil : &nbsp;&nbsp;@dom A nil = empty. Lemma dom_single : ∀ x a, &nbsp;&nbsp;dom [(x,a)] = singleton x. Lemma dom_push : ∀ x a E, &nbsp;&nbsp;dom ([(x,a)] ++ E) = union (singleton x) (dom E). Lemma dom_concat : ∀ E F, &nbsp;&nbsp;dom (F ++ E) = union (dom F) (dom E). Lemma dom_map : ∀ (f : A → B) E, &nbsp;&nbsp;dom (map f E) = dom E. ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Signatures.html",
    "relUrl": "/proofs/Top.Util.Signatures.html"
  },"132": {
    "doc": "Top.Util.Signatures",
    "title": "Other trivial rewrites",
    "content": "Lemma cons_concat_assoc : ∀ x a E F, &nbsp;&nbsp;&nbsp;((x, a) :: E) ++ F = (x, a) :: (E ++ F). End OpProperties. (*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Signatures.html",
    "relUrl": "/proofs/Top.Util.Signatures.html"
  },"133": {
    "doc": "Top.Util.Signatures",
    "title": " Automation and tactics (I)",
    "content": " ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Signatures.html",
    "relUrl": "/proofs/Top.Util.Signatures.html"
  },"134": {
    "doc": "Top.Util.Signatures",
    "title": "simpl_env",
    "content": "The simpl_env tactic can be used to put environments in the standardized form described above, with the additional properties that concatenation is associated to the right and empty environments are removed. Similar to the simpl tactic, we define \"in ×\" and \"in H\" variants of simpl_env. Definition singleton_list (A : Type) (x : label × A) := x :: nil. Lemma cons_concat : ∀ (A : Type) (E : list (label × A)) x a, &nbsp;&nbsp;(x, a) :: E = singleton_list A (x, a) ++ E. Lemma map_singleton_list : ∀ (A B : Type) (f : A → B) y b, &nbsp;&nbsp;map f (singleton_list A (y,b)) = [(y, f b)]. Lemma dom_singleton_list : ∀ (A : Type) (x : label) (a : A), &nbsp;&nbsp;dom (singleton_list A (x,a)) = singleton x. Tactic Notation \"simpl_env\" \"in\" hyp(H) := &nbsp;&nbsp;simpl_env_change_aux; &nbsp;&nbsp;autorewrite with rew_env in H; &nbsp;&nbsp;unfold singleton_list in ×. Tactic Notation \"simpl_env\" \"in\" \"*\" := &nbsp;&nbsp;simpl_env_change_aux; &nbsp;&nbsp;autorewrite with rew_env in *; &nbsp;&nbsp;unfold singleton_list in ×. ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Signatures.html",
    "relUrl": "/proofs/Top.Util.Signatures.html"
  },"135": {
    "doc": "Top.Util.Signatures",
    "title": "rewrite_env",
    "content": "The tactic (rewrite_env E) replaces an environment in the conclusion of the goal with E. Suitability for replacement is determined by whether simpl_env can put E and the chosen environment in the same normal form, up to convertability in Coq. We also define a \"in H\" variant that performs the replacement in a hypothesis H. Tactic Notation \"rewrite_env\" constr(E) := &nbsp;&nbsp;match goal with &nbsp;&nbsp;&nbsp;&nbsp;|- context[?x] ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;change x with E &nbsp;&nbsp;&nbsp;&nbsp;|- context[?x] ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace x with E; [ | try reflexivity; simpl_env; reflexivity ] &nbsp;&nbsp;end. Tactic Notation \"rewrite_env\" constr(E) \"in\" hyp(H) := &nbsp;&nbsp;match type of H with &nbsp;&nbsp;&nbsp;&nbsp;| context[?x] ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;change x with E in H &nbsp;&nbsp;&nbsp;&nbsp;| context[?x] ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace x with E in H; [ | try reflexivity; simpl_env; reflexivity ] &nbsp;&nbsp;end. ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Signatures.html",
    "relUrl": "/proofs/Top.Util.Signatures.html"
  },"136": {
    "doc": "Top.Util.Signatures",
    "title": "Hints",
    "content": "(*&nbsp; TODO&nbsp;adding&nbsp;this&nbsp;hint&nbsp;globally&nbsp;causes&nbsp;lsetdec&nbsp;to&nbsp;not&nbsp;terminate... Hint&nbsp;Extern&nbsp;1&nbsp;(~&nbsp;In&nbsp;_&nbsp;_)&nbsp;=&gt;&nbsp;simpl_env&nbsp;in&nbsp;*;&nbsp;lsetdec&nbsp;:&nbsp;core.&nbsp;*) (*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Signatures.html",
    "relUrl": "/proofs/Top.Util.Signatures.html"
  },"137": {
    "doc": "Top.Util.Signatures",
    "title": " Properties of well-formedness and freshness",
    "content": "Section OkProperties. Variable A B : Type. Implicit Types E F : list (label × A). Implicit Types a b : A. Facts about when an environment is well-formed. Lemma ok_push : ∀ (E : list (label × A)) (x : label) (a : A), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ok E → ¬ In x (dom E) → ok ([(x, a)] ++ E). Lemma ok_singleton : ∀ x a, &nbsp;&nbsp;ok [(x,a)]. Lemma ok_remove_mid : ∀ F E G, &nbsp;&nbsp;ok (G ++ F ++ E) → ok (G ++ E). Lemma ok_remove_mid_cons : ∀ x a E G, &nbsp;&nbsp;ok (G ++ (x, a) :: E) → &nbsp;&nbsp;ok (G ++ E). Lemma ok_map : ∀ E (f : A → B), &nbsp;&nbsp;ok E → ok (map f E). Lemma ok_map_app_l : ∀ E F (f : A → A), &nbsp;&nbsp;ok (F ++ E) → ok (map f F ++ E). A binding in the middle of an environment has an label fresh from all bindings before and after it. Lemma fresh_mid_tail : ∀ E F x a, &nbsp;&nbsp;ok (F ++ [(x,a)] ++ E) → ¬ In x (dom E). Lemma fresh_mid_head : ∀ E F x a, &nbsp;&nbsp;ok (F ++ [(x,a)] ++ E) → ¬ In x (dom F). End OkProperties. (*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Signatures.html",
    "relUrl": "/proofs/Top.Util.Signatures.html"
  },"138": {
    "doc": "Top.Util.Signatures",
    "title": " Properties of binds",
    "content": "Section BindsProperties. Variable A B : Type. Implicit Types E F : list (label × A). Implicit Types a b : A. ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Signatures.html",
    "relUrl": "/proofs/Top.Util.Signatures.html"
  },"139": {
    "doc": "Top.Util.Signatures",
    "title": "Introduction forms for binds",
    "content": "The following properties allow one to view binds as an inductively defined predicate. This is the preferred way of working with the relation. Lemma binds_singleton : ∀ x a, &nbsp;&nbsp;binds x a [(x,a)]. Lemma binds_tail : ∀ x a E F, &nbsp;&nbsp;binds x a E → ¬ In x (dom F) → binds x a (F ++ E). Lemma binds_head : ∀ x a E F, &nbsp;&nbsp;binds x a F → binds x a (F ++ E). ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Signatures.html",
    "relUrl": "/proofs/Top.Util.Signatures.html"
  },"140": {
    "doc": "Top.Util.Signatures",
    "title": "Case analysis on binds",
    "content": "Lemma binds_concat_inv : ∀ x a E F, &nbsp;&nbsp;binds x a (F ++ E) → (¬ In x (dom F) ∧ binds x a E) ∨ (binds x a F). Lemma binds_singleton_inv : ∀ x y a b, &nbsp;&nbsp;binds x a [(y,b)] → x = y ∧ a = b. ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Signatures.html",
    "relUrl": "/proofs/Top.Util.Signatures.html"
  },"141": {
    "doc": "Top.Util.Signatures",
    "title": "Retrieving bindings from an environment",
    "content": "Lemma binds_mid : ∀ x a E F, &nbsp;&nbsp;ok (F ++ [(x,a)] ++ E) → binds x a (F ++ [(x,a)] ++ E). Lemma binds_mid_eq : ∀ z a b E F, &nbsp;&nbsp;binds z a (F ++ [(z,b)] ++ E) → ok (F ++ [(z,b)] ++ E) → a = b. Lemma binds_mid_eq_cons : ∀ x a b E F, &nbsp;&nbsp;binds x a (F ++ (x,b) :: E) → &nbsp;&nbsp;ok (F ++ (x,b) :: E) → &nbsp;&nbsp;a = b. End BindsProperties. (*&nbsp;**********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Signatures.html",
    "relUrl": "/proofs/Top.Util.Signatures.html"
  },"142": {
    "doc": "Top.Util.Signatures",
    "title": " Automation and tactics (II)",
    "content": " ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Signatures.html",
    "relUrl": "/proofs/Top.Util.Signatures.html"
  },"143": {
    "doc": "Top.Util.Signatures",
    "title": "Hints",
    "content": " ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Signatures.html",
    "relUrl": "/proofs/Top.Util.Signatures.html"
  },"144": {
    "doc": "Top.Util.Signatures",
    "title": "binds_get",
    "content": "The tactic (binds_get H) takes a hypothesis H of the form (binds x a (F ++ [(x,b)] ++ E)) and introduces the equality a=b into the context. Then, the tactic checks if the equality is discriminable and otherwise tries substituting b for a. The auto tactic is used to show that (ok (F ++ [(x,b)] ++ E)), which is needed to prove the equality a=b from H. ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Signatures.html",
    "relUrl": "/proofs/Top.Util.Signatures.html"
  },"145": {
    "doc": "Top.Util.Signatures",
    "title": "binds_cases",
    "content": "The tactic (binds_case H) performs a case analysis on an hypothesis H of the form (binds x a E). There will be one subgoal for each component of E that x could be bound in, and each subgoal will have appropriate freshness conditions on x. Some attempts are made to automatically discharge contradictory cases. (*&nbsp;***********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Signatures.html",
    "relUrl": "/proofs/Top.Util.Signatures.html"
  },"146": {
    "doc": "Top.Util.Signatures",
    "title": " Additional properties of binds",
    "content": "The following lemmas are proven in manner that should be independent of the concrete definition of binds. Section AdditionalBindsProperties. Variable A B : Type. Implicit Types E F : list (label × A). Implicit Types a b : A. Lemmas about the relationship between binds and the domain of an environment. Lemma binds_In : ∀ a x E, &nbsp;&nbsp;binds x a E → In x (dom E). Lemma binds_fresh : ∀ x a E, &nbsp;&nbsp;¬ In x (dom E) → ¬ binds x a E. Additional lemmas for showing that a binding is in an environment. Lemma binds_map : ∀ x a (f : A → B) E, &nbsp;&nbsp;binds x a E → binds x (f a) (map f E). Lemma binds_concat_ok : ∀ x a E F, &nbsp;&nbsp;binds x a E → ok (F ++ E) → binds x a (F ++ E). Lemma binds_weaken : ∀ x a E F G, &nbsp;&nbsp;binds x a (G ++ E) → &nbsp;&nbsp;ok (G ++ F ++ E) → &nbsp;&nbsp;binds x a (G ++ F ++ E). Lemma binds_weaken_at_head : ∀ x a F G, &nbsp;&nbsp;binds x a G → &nbsp;&nbsp;ok (F ++ G) → &nbsp;&nbsp;binds x a (F ++ G). Lemma binds_remove_mid : ∀ x y a b F G, &nbsp;&nbsp;binds x a (F ++ [(y,b)] ++ G) → &nbsp;&nbsp;x ≠ y → &nbsp;&nbsp;binds x a (F ++ G). Lemma binds_remove_mid_cons : ∀ x y a b E G, &nbsp;&nbsp;binds x a (G ++ (y, b) :: E) → &nbsp;&nbsp;x ≠ y → &nbsp;&nbsp;binds x a (G ++ E). End AdditionalBindsProperties. (*&nbsp;***********************************************************************&nbsp;*) ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Signatures.html",
    "relUrl": "/proofs/Top.Util.Signatures.html"
  },"147": {
    "doc": "Top.Util.Signatures",
    "title": " Automation and tactics (III)",
    "content": "(*&nbsp; Hint&nbsp;Resolve&nbsp;binds_map&nbsp;binds_concat_ok&nbsp;binds_weaken&nbsp;binds_weaken_at_head&nbsp;:&nbsp;core. Hint&nbsp;Immediate&nbsp;binds_remove_mid&nbsp;binds_remove_mid_cons&nbsp;:&nbsp;core.&nbsp;*) End Signatures. Tactic Notation \"srewrite_env\" constr(E) := &nbsp;&nbsp;match goal with &nbsp;&nbsp;&nbsp;&nbsp;|- context[?x] ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;change x with E &nbsp;&nbsp;&nbsp;&nbsp;|- context[?x] ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace x with E; [ | try reflexivity; Signatures.simpl_env; reflexivity ] &nbsp;&nbsp;end. Tactic Notation \"srewrite_env\" constr(E) \"in\" hyp(H) := &nbsp;&nbsp;match type of H with &nbsp;&nbsp;&nbsp;&nbsp;| context[?x] ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;change x with E in H &nbsp;&nbsp;&nbsp;&nbsp;| context[?x] ⇒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace x with E in H; [ | try reflexivity; Signatures.simpl_env; reflexivity ] &nbsp;&nbsp;end. ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Signatures.html",
    "relUrl": "/proofs/Top.Util.Signatures.html"
  },"148": {
    "doc": "Top.Util.Taktiks",
    "title": "Top.Util.Taktiks",
    "content": "Borrowed from https://gitlab.mpi-sws.org/iris/stdpp/-/blob/master/theories/tactics.v The tactic select pat tac finds the last (i.e., bottommost) hypothesis matching pat and passes it to the continuation tac. Its main advantage over using match goal with directly is that it is shorter. If pat matches multiple hypotheses and tac fails, then select tac will not backtrack on subsequent matching hypotheses. The tactic select is written in CPS and does not return the name of the hypothesis due to limitations in the Ltac1 tactic runtime (see https://gitter.im/coq/coq?at=5e96c82f85b01628f04bbb89). Tactic Notation \"select\" open_constr(pat) tactic3(tac) := &nbsp;&nbsp;lazymatch goal with &nbsp;&nbsp; Before running tac on the hypothesis H we must first unify the pattern pat with the term it matched against. This forces every evar coming from pat (and in particular from the holes _ it contains and from the implicit arguments it uses) to be instantiated. If we do not do so then shelved goals are produced for every such evar. &nbsp;&nbsp;| H : pat |- _ ⇒ let T := (type of H) in unify T pat; tac H &nbsp;&nbsp;end. select_revert reverts the first hypothesis matching pat. Tactic Notation \"revert\" \"select\" open_constr(pat) := select pat (fun H ⇒ revert H). Tactic Notation \"rename\" \"select\" open_constr(pat) \"into\" ident(name) := &nbsp;&nbsp;select pat (fun H ⇒ rename H into name). Tactic Notation \"inversion\" \"select\" open_constr(pat) := &nbsp;&nbsp;select pat (fun H ⇒ inversion H). Tactic Notation \"destruct\" \"select\" open_constr(pat) := &nbsp;&nbsp;select pat (fun H ⇒ destruct H). Tactic Notation \"destruct\" \"select\" open_constr(pat) \"as\" simple_intropattern(destruct_pat) := &nbsp;&nbsp;select pat (fun H ⇒ destruct H as destruct_pat). Tactic Notation \"solve\" \"using\" \"assumption\" \"and\" tactic3(tac) := &nbsp;&nbsp;solve_using_assumption tac. ",
    "url": "/oopsla-2022-artifact/proofs/Top.Util.Taktiks.html",
    "relUrl": "/proofs/Top.Util.Taktiks.html"
  },"149": {
    "doc": "Boxing and Unboxing",
    "title": "Boxing and Unboxing",
    "content": "As we observed earlier, by default functions and capabilites are second class – they cannot be returned nor stored in mutable cells and can only be passed as second-class parameters to other functions. We can lift this restriction by boxing these functions and capabilities, reifying the set of captured capabilites from the binder to the type. interface Greeter { def sayHello(): Unit } def myGreeter() { try { // boxing a capability and storing it in a mutable variable var capturedGreeter = box greeter; // unboxing requires `greeter` to be in scope def user() { (unbox capturedGreeter).sayHello() } // automatic boxing of `user`, stored in a value binder val firstClassUser: () =&gt; Unit at {greeter} = user; // automatic unboxing of firstClassUser firstClassUser() } with greeter : Greeter { def sayHello() { println(\"Hello World!\"); resume(()) } } } . Here, we box greeter to store it in the mutable cell capturedGreeter. Note that System C supports automatic boxing and unboxing, and we could have omitted box. We can also explicitly annotate the expected capability set as box {greeter} greeter. In the function user, we unbox the captured first-class block and call sayHello. The fact that we unbox it is reflected in the inferred capability set annotated on user. Boxed values act as normal first-class values in System C until unboxed. In particular, they can be passed as values to value-polymorphic functions. def invoke[T](v : T){f : (T) =&gt; Unit}: Unit { f(v) } def indirectMyGreeter { greeter: Greeter }: Unit { val capturedGreeter = box greeter; invoke(capturedGreeter){ (f : Greeter at { greeter }) =&gt; f.sayHello() } } . Hovering over capturedGreeter shows how the capture is reflected in the type. ",
    "url": "/oopsla-2022-artifact/boxing/",
    "relUrl": "/boxing/"
  },"150": {
    "doc": "Boxing and Unboxing",
    "title": "Reasoning about Purity",
    "content": "Boxes reflect capture of tracked variables in their types. Let us assume the following function in the standard library: . // def setTimeout(callback: () =&gt; Unit at {}, duration: Int): Unit . Its implementation uses the FFI to JavaScript. System C is implemented as a compiler to JavaScript and requires a monadic runtime. The value passed to the JavaScript builtin window.setTimeout should not make use of any control effects or effect handlers since it will be called later outside of all possible handlers. To express this, we require the callback to be “pure” (i.e. () =&gt; Unit at {}). We can still use the unsafe println function, as illustrated in the following example . setTimeout(box { () =&gt; println(\"Hello after 2 seconds!\") }, 2000) . ",
    "url": "/oopsla-2022-artifact/boxing/#reasoning-about-purity",
    "relUrl": "/boxing/#reasoning-about-purity"
  },"151": {
    "doc": "Capabilities",
    "title": "Capabilities and Effects",
    "content": " ",
    "url": "/oopsla-2022-artifact/capability/#capabilities-and-effects",
    "relUrl": "/capability/#capabilities-and-effects"
  },"152": {
    "doc": "Capabilities",
    "title": "Interfaces",
    "content": "Capability (and effect) types in System C are introduced with the interface keyword. For example, the following introduces the capability type Greeter which has an operation sayHello associated with it. interface Greeter { def sayHello(): Unit } . To use it, we can require an instance of the Greeter capability type: . def useGreeter { g: Greeter } { g.sayHello() } . Notice how interfaces and capabilities are block types enclosed in curly braces. They are second-class. Finally, to actually call useGreeter, we need to handle it with a concrete handler which implements the Greeter interface and produces an concrete instance of the Greeter interface: . def myGreeter() { try { useGreeter {greeter} } with greeter: Greeter { def sayHello() { println(\"Hello World!\"); resume(()) } } } . System C features effect handlers: after printing \"Hello World\", we resume evaluation at the point of the call to sayHello. myGreeter() . Side-Effects . While capabilities can be used to precisely track side effects, in our draft implementation we chose to expose the (unsafe) builtin function println, which is not tracked. We can simply track access to the console by defining: . interface Console { def println(msg: String): Unit } def myFunction { console: Console } { console.println(\"hello\"); def nested() { console.println(\"world\") } nested() } . Type checking the example we can see that for nested, we infer a capability set of {console}. ",
    "url": "/oopsla-2022-artifact/capability/#interfaces",
    "relUrl": "/capability/#interfaces"
  },"153": {
    "doc": "Capabilities",
    "title": "Using Multiple Effects and Capabilities",
    "content": "A capability type can have more than one operation, and these operations can also return values; for example: . interface Bank { def debit(amount: Int): Unit def credit(amount: Int): Unit def balance(): Int } . Here is a small example which implements the Bank interface: . def simpleAccount(): Unit { var balance = 0; try { bank.debit(10); bank.credit(5); println(bank.balance()) } with bank: Bank { def debit(amount: Int) { balance = balance - amount; resume(()) } def credit(amount: Int) { balance = balance + amount; resume(()) } def balance() { resume(balance) } } } . We can abstract over the handler for Bank and also add exceptions, for example, when you would overdraft your account. interface AccountExc { def outOfMoney[A](): A } def account[T] { exc: AccountExc } { prog: {Bank} =&gt; T } : T { var balance = 0; try { prog {bank} } with bank : Bank { def debit(amount : Int) { if (amount &gt; balance) { exc.outOfMoney() } else { balance = balance - amount; resume(()) } } def credit(amount : Int) { balance = balance + amount; resume(()) } def balance() { resume(balance) } } } def userProgram(): Unit { try { account {exc} { {bank:Bank} =&gt; bank.credit(10); bank.debit(5); println(bank.balance()) } } with exc: AccountExc { def outOfMoney[A]() { println(\"Too bad.\") } } } . userProgram() . You can try changing the argument of debit from 5 to something larger then 10 and then rerun the program. ",
    "url": "/oopsla-2022-artifact/capability/#using-multiple-effects-and-capabilities",
    "relUrl": "/capability/#using-multiple-effects-and-capabilities"
  },"154": {
    "doc": "Capabilities",
    "title": "Polymorphism through Second Class Capabilities",
    "content": "System C supports effect polymorphism through capability polymorphism. For example, here is a function which calls a second function which may perform some effectful operation. def invoke { f : () =&gt; Unit }: Unit { f() } def useInvoke() { try { invoke { () =&gt; useGreeter {greeter} } } with greeter: Greeter { def sayHello() { println(\"Hello World from useInvoke!\"); resume(()) } } } . Contextual effect polymorphism means: In the block passed to invoke, we can simply use any capability that is lexically in scope. useInvoke() . This seems unsafe – what if f escaped? However, it cannot, as by default, capabilities in System C are second class – that is, they can only be passed as parameters and never returned. Moreover, functions which close over second class capabilities have the capability recorded on their binding, and by default, functions themselves are second class. Syntatically, second-class (block) parameters are denoted by {} instead of (). def otherInvoke() { try { // here inner closes over greeter, which is recorded on the binding def inner() { greeter.sayHello() } inner() } with greeter : Greeter { def sayHello() { println(\"Hello World from useInvoke!\"); resume(()) } } } . ",
    "url": "/oopsla-2022-artifact/capability/#polymorphism-through-second-class-capabilities",
    "relUrl": "/capability/#polymorphism-through-second-class-capabilities"
  },"155": {
    "doc": "Capabilities",
    "title": "Transparent wrapping and aliasing",
    "content": "Finally, capabilities and blocks can be bound to different names. However, our type system records which tracked capabilities each block binder closes over, effectively performing some form of aliasing analysis. For example, for aliased capabilities, we can bind greeter to checker but the binding for checker still reflects the underlying bound capability: . def boundInvoke() { try { def checker1 = greeter; def checker2 = { () =&gt; greeter.sayHello() }; checker1.sayHello() } with greeter : Greeter { def sayHello() { println(\"Hello World from useInvoke!\"); resume(()) } } } . ",
    "url": "/oopsla-2022-artifact/capability/#transparent-wrapping-and-aliasing",
    "relUrl": "/capability/#transparent-wrapping-and-aliasing"
  },"156": {
    "doc": "Capabilities",
    "title": "Capability-sets on Continuations",
    "content": "Here is a more complex example with nested effect handlers that illustrates how capability sets on continuations are computed. def continuations() { try { try { try { g1.sayHello(); g3.sayHello() } with g3 : Greeter { // here the capability set on f is {g1, g2}, since the program closes over // g1 and the handler closes over g2. def sayHello() { val f = resume; g2.sayHello(); f(()) } } } with g2 : Greeter { // here the capability set on g is {g1}, since the handler itself closes // over g1 def sayHello() { val g = resume; g1.sayHello(); g(()) } } } with g1 : Greeter { // here the capability set on h is empty, since neither the handled // program, nor the body of sayHello close over anything: def sayHello() { val h = resume; // even in this nested handler, the continuation has capability {}, // since the program doesn't close over anything and the handler only // closes over the outer continuation h, which itself has set {}. try { () } with g4: Greeter { def sayHello() { val i = resume; h(()); i(()) }} } } } . ",
    "url": "/oopsla-2022-artifact/capability/#capability-sets-on-continuations",
    "relUrl": "/capability/#capability-sets-on-continuations"
  },"157": {
    "doc": "Capabilities",
    "title": "Capabilities",
    "content": " ",
    "url": "/oopsla-2022-artifact/capability/",
    "relUrl": "/capability/"
  },"158": {
    "doc": "Case Studies",
    "title": "Case Studies",
    "content": "Here we report on (additional) examples that illustrate the expressivity of System C. ",
    "url": "/oopsla-2022-artifact/casestudies.html",
    "relUrl": "/casestudies.html"
  },"159": {
    "doc": "Tutorial",
    "title": "Tutorial of System C",
    "content": "In this interactive demo we will take you through a brief introduction to System C and a quick tour of its features. You can find all examples from the paper on this page. Editors . In general, you will find a lot of small code snippets that can you can typecheck and run in the browser. For example, this is a program that prints out “Hello World!”. Try clicking typecheck and run to load the editor (this can take a while the first time). def sayHello(): Unit { println(\"Hello World!\") } . The editor comes with basic support for System C – try hovering over println! . You can also modify the program and then click typecheck and run again to run the typechecker. Alternatively, in the editor you can also use the keybinding &lt;CTRL+Enter&gt; on Windows or &lt;CMD+Enter&gt; on MacOS. REPLs . Sometimes you will also find REPL windows. To run the code example, just click the run button! . sayHello() . Like with other editors, you can freely change the REPL input. Since REPLs are always single-line, you can simply press &lt;ENTER&gt; instead of clicking run. ",
    "url": "/oopsla-2022-artifact/tutorial/#tutorial-of-system-c",
    "relUrl": "/tutorial/#tutorial-of-system-c"
  },"160": {
    "doc": "Tutorial",
    "title": "Tutorial",
    "content": " ",
    "url": "/oopsla-2022-artifact/tutorial/",
    "relUrl": "/tutorial/"
  },"161": {
    "doc": "Proofs",
    "title": "Proofs",
    "content": "Disclaimer Not all proof-files are equally well documented. For the artifact, we carefully prepared the following files, which we recommend to look at. ",
    "url": "/oopsla-2022-artifact/proofs/",
    "relUrl": "/proofs/"
  },"162": {
    "doc": "Proofs",
    "title": "Definitions of Syntax, Typing, and Semantics",
    "content": "In file Top.SystemC.Definitions.html, you can inspect the Coq definitions and compare them with the paper’s definition. ",
    "url": "/oopsla-2022-artifact/proofs/#definitions-of-syntax-typing-and-semantics",
    "relUrl": "/proofs/#definitions-of-syntax-typing-and-semantics"
  },"163": {
    "doc": "Proofs",
    "title": "Main Theorems",
    "content": "File Top.SystemC.Soundness.html lists the main theorems. ",
    "url": "/oopsla-2022-artifact/proofs/#main-theorems",
    "relUrl": "/proofs/#main-theorems"
  },"164": {
    "doc": "Home",
    "title": "Effects, Capabilities, and Boxes",
    "content": "Welcome to our artifact website! . Our artifact consists of the following components: . | Coq Proofs. We documented our Coq proofs, highlighting the most important aspects and contrasting the definitions with the paper. We recommend you look at the definitions as well as at the theorems. | Interactive Demo. This website contains additional casestudies, examples from the paper, and additional explanation on capabilities and boxing. All examples can be typechecked and edited in the browser! . | . ",
    "url": "/oopsla-2022-artifact/#effects-capabilities-and-boxes",
    "relUrl": "/#effects-capabilities-and-boxes"
  },"165": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "/oopsla-2022-artifact/",
    "relUrl": "/"
  },"166": {
    "doc": "Basics",
    "title": "Basics",
    "content": "System C supports basic datatypes, such as numbers, strings, functions, and booleans. def hello(): Unit { val one = 1; val hello = \"Hello\"; val check = true; println(hello) } . In addition to these basic datatypes, it also has support for inductive datatypes; for example: . type Color { Red() Green() Blue() } . You can try it out! . println(Red()) . As usual, datatypes can also take type parameteres and be recursive: . type Pair[A, B] { Pair(fst: A, snd: B) } type List[A] { Cons(head: A, tail: List[A]) Nil() } . Datatypes can be destructed using pattern matching: . def doPair() { Pair(1, 2) match { case Pair(x, y) =&gt; println(x + y) }; val z = Pair(Pair(1, 2), 3) match { case Pair(Pair(x, y), z) =&gt; x + y + z }; println(z); // this is shorthand for Cons(1, Cons(2, Cons(3, Nil()))) val l = [1, 2, 3]; val z1 = l match { case Nil() =&gt; 0 case Cons(x, tl) =&gt; x + 1 }; println(z1); () } . doPair() . ",
    "url": "/oopsla-2022-artifact/intro/",
    "relUrl": "/intro/"
  },"167": {
    "doc": "Paper Examples",
    "title": "Examples from the Paper",
    "content": "Here we include executable variants of all examples from the paper. ",
    "url": "/oopsla-2022-artifact/paper.html#examples-from-the-paper",
    "relUrl": "/paper.html#examples-from-the-paper"
  },"168": {
    "doc": "Paper Examples",
    "title": "Paper Examples",
    "content": " ",
    "url": "/oopsla-2022-artifact/paper.html",
    "relUrl": "/paper.html"
  },"169": {
    "doc": "Use and Mention",
    "title": "Distinguishing between Use and Mention",
    "content": "As observed by Colin Gordon (2020), one issue with capability-based effect systems is that they often fail to distinguish between the actual usage of a capability from when a capability is simply mentioned or passed through a section of code. Consider the following example, where we are given two capabilities, one for reading from and one for writing to a cell in memory: . interface Write[T] { def write(value: T): Unit def read(): T } interface Read[T] { def read(): T } def fork(pureFunction: () =&gt; Unit at {}): Unit { () } def mereMention[T] { x : Read[T] } { y: Write[T] } { fork(box { () =&gt; // here we mention `y`, but do not really \"use\" it. def z1(v: T) { y.write(v) } // same here. val z2 = box { () =&gt; y.read() }; () }); () } . In more traditional capability systems we would observe that the boxed blocked passed to fork captures the write capability y and hence could not be parallelized safely. However, as the only mentions of y are (1) behind a function z1, which is never called and (2) an inert boxed value z2, System C can safely conclude that we do not actually use the y capability and can safely call fork. This is indiciated by the type assigned to it, which is () =&gt; Unit at {} – a boxed thunk which requires no capability at usage (unboxing). This example might be perhaps a bit contrived, but System C also deals with similar problems that come up in real life. Consider an example due to Gordon; we have a UI, for which computation which modifies the UI must take place on dedicated UI threads. interface UI { def use(): Unit } interface Field { def setLabel(text: String): Unit } def application { ui : UI } { def field = new Field { def setLabel(text: String) { ui.use() } }; def forkThread(run: () =&gt; Unit at {}): Unit { return () } def forkUIThread(run: () =&gt; Unit at {ui}): Unit { return () } forkThread({() =&gt; val tmp = 42; // some expensive computation forkUIThread({() =&gt; field.setLabel(\"The result is \" ++ show(tmp)) }) }); () } . Here, we are given a global UI capability which must be passed through a background worker thread before it is used to report the final result on the UI thread. The intermediate thread must not use the UI capability. A more traditional capability system would conservatively approximate that the function passed to forkThread closes over field, which in turn closes over ui. In contrast, System C is able to accurately observe that it never uses it and hence can be safely run. ",
    "url": "/oopsla-2022-artifact/casestudies/passthrough.html#distinguishing-between-use-and-mention",
    "relUrl": "/casestudies/passthrough.html#distinguishing-between-use-and-mention"
  },"170": {
    "doc": "Use and Mention",
    "title": "Use and Mention",
    "content": " ",
    "url": "/oopsla-2022-artifact/casestudies/passthrough.html",
    "relUrl": "/casestudies/passthrough.html"
  },"171": {
    "doc": "Region-based Local State",
    "title": "Local Backtrackable State",
    "content": "Since System C features effect handlers and multiple resumptions, mutable state needs to be used with care. Take the following standard handler for ambiguity that runs explores all possible choices. interface Amb { def flip(): Boolean } def allChoices { prog : {Amb} =&gt; Unit }: Unit { try { prog {amb} } with amb: Amb { def flip() { resume(true); resume(false) } } } . If we declare the mutable variable outside of the handler for ambiguity, changes should be persisted across different explored alternatives: . def stateExample1() { var x = 1; allChoices { {amb: Amb} =&gt; if (amb.flip()) { x = 2 } else { () }; println(x) } } . stateExample1() . whereas, if we declare the mutable variable within the handler for ambiguity, it should perform backtracking: . def stateExample2() { allChoices { {amb: Amb} =&gt; var x = 1; if (amb.flip()) { x = 2 } else { () }; println(x) } } . stateExample2() . In order to achieve this correct backtracking behaviour, state is allocated on the stack, captured together with the continuation and restored on resumption. ",
    "url": "/oopsla-2022-artifact/casestudies/regions.html#local-backtrackable-state",
    "relUrl": "/casestudies/regions.html#local-backtrackable-state"
  },"172": {
    "doc": "Region-based Local State",
    "title": "Regions",
    "content": "In fact, all local mutable variables are allocated in corresponding regions. The regions become visible, when trying to close over the references: . def stateExample1b() { var x = 1; val closure = box { () =&gt; x }; () } . The inferred capability set for closure is {stateExample1b}. This illustrates that x is allocated in a region associated with the current function definition. We could also make this more explicit as: . def stateExample1c() { region r { var x in r = 1; val closure = box { () =&gt; x }; () } } . Now, the inferred capability set at closure is {r}. Regions are second-class and can be passed to functions: . def newCounter {pool: Region} { var state in pool = 0; return box { () =&gt; println(state); state = state + 1 } } . Hovering over newCounter, we can see that the inferred return type is () =&gt; Unit at {pool}. That is, we return a function that closes over the region that we passed to it. Let us allocate a fresh region and use the above defined function: . def stateExample3() { region pool { val c1 = newCounter {pool}; val c2 = newCounter {pool}; c1(); c1(); c2(); c1(); c2() } } . stateExample3() . ",
    "url": "/oopsla-2022-artifact/casestudies/regions.html#regions",
    "relUrl": "/casestudies/regions.html#regions"
  },"173": {
    "doc": "Region-based Local State",
    "title": "Backtrackable Regions",
    "content": "Of course the two concepts can be combined and regions show the correct backtracking behavior. def exampleProgram {amb:Amb} {reg:Region} { var x in reg = 1; if (amb.flip()) { x = 2 } else { () }; println(x) } def stateExample4() { region pool { allChoices { {amb: Amb} =&gt; exampleProgram {amb} {pool} } } } . stateExample4() . and nested the other way around: . def stateExample5() { allChoices { {amb: Amb} =&gt; region pool { exampleProgram {amb} {pool} } } } . stateExample5() . ",
    "url": "/oopsla-2022-artifact/casestudies/regions.html#backtrackable-regions",
    "relUrl": "/casestudies/regions.html#backtrackable-regions"
  },"174": {
    "doc": "Region-based Local State",
    "title": "Region-based Local State",
    "content": " ",
    "url": "/oopsla-2022-artifact/casestudies/regions.html",
    "relUrl": "/casestudies/regions.html"
  },"175": {
    "doc": "Scheduling (with continuations and mutable cells)",
    "title": "Scheduling Tasks and Continuations",
    "content": "Writing a safe, co-operatively threaded scheduler in an effect safe manner can be hard, as it requires treating continuations as first-class values. Continuations might indirectly close over other capabilities and we want to prevent that capabilities leave their defining scope indirectly through continuations. System C can safely express this though – the following is a skeleton of a scheduler. import immutable/list // we first draft a naive implementation of a queue def emptyQueue[T]() { Nil[T]() } def enqueue[T](q: List[T], el: T): List[T] { Cons(el, q) } def nonEmpty[T](q: List[T]) { size(q) &gt; 0 } def dequeue[T](q: List[T]) { reverse(q) match { case Nil() =&gt; panic[(List[T], T)](\"Empty queue\") case Cons(hd, tl) =&gt; (reverse(tl), hd) }} // now we define the interface of our scheduler interface Proc { def fork(): Boolean } // and implement the scheduler itself def schedule { p: { Proc } =&gt; Unit }: Unit { // \"processes\" spawned by fork are stored in this local mutable cell var q: List[() =&gt; Unit at {p, schedule}] = emptyQueue(); // we run the program with our own scheduler try { p {proc} } with proc: Proc { // forking enqueues the continuation twice def fork() { q = enqueue(q, box { () =&gt; resume(true) }); q = enqueue(q, box { () =&gt; resume(false) }) } }; // finally, while there are continuations, we dequeue and force them while (nonEmpty(q)) { dequeue(q) match { case (rest, k) =&gt; // this \"type-ascription\" is necessary due to our preliminary // implementation of local type inference for matches val k2: () =&gt; Unit at {p, schedule} = k; q = rest; // force the continuation (unbox k2)() } } } // Example using the scheduler interface Exc { def abort(): Unit } def example() { try { schedule { {p:Proc} =&gt; if (p.fork()) { println(\"(1)\"); if (p.fork()) { println(\"(2)\"); exc.abort() } else { println(\"(3)\") } } else { println(\"(4)\") } } } with exc: Exc { def abort() { println(\"aborted\") }} } . Note how the use of local mutable state is safely encapsulated in function schedule, which does not close over anything. We can run the above example, which forks two threads and aborts with an outer capability: . example() . Here, schedule takes in a program which expects a given Proc capability. As this program is a second-class argument, it can use additional capabilities that are not reflected in its type (but are on its binder) due to System C’s contextual effect polymorphism. In particular, these capabilities may be captured on the continuation term resume. However, as those capabilities are second class, they cannot leak through the resumption and the entire program is safe – in particular, the resumption cannot leak even though it is stored in the mutable cell q, as q is second-class itself and valid only within the context of the scheduler region. In the example above, calling exc.abort() not only terminates one “thread”, but the scheduler as a whole. This is the expected behavior: The handler for exceptions is located outside of the scheduler and thus the continuation captured and discarded by abort also includes the scheduler itself. ",
    "url": "/oopsla-2022-artifact/casestudies/scheduler.html#scheduling-tasks-and-continuations",
    "relUrl": "/casestudies/scheduler.html#scheduling-tasks-and-continuations"
  },"176": {
    "doc": "Scheduling (with continuations and mutable cells)",
    "title": "Scheduling (with continuations and mutable cells)",
    "content": " ",
    "url": "/oopsla-2022-artifact/casestudies/scheduler.html",
    "relUrl": "/casestudies/scheduler.html"
  },"177": {
    "doc": "Section 1",
    "title": "Section 1",
    "content": "Section 1 – Introduction . interface Exc { def throw(msg: String): Unit } type File { FileHandle(id: Int) } def eachLine(file: File) { f: String =&gt; Unit }: Unit { () } def open(path: String) {exc:Exc}: File { FileHandle(0) } def process(path: String) {exc1: Exc}: Unit { def abort(): Unit { exc1.throw(\"processing aborted\") } try { eachLine(open(path){exc2}) { (line: String) =&gt; abort() } } with exc2: Exc { def throw(msg: String) { () }} } . ",
    "url": "/oopsla-2022-artifact/paper/section1.html",
    "relUrl": "/paper/section1.html"
  },"178": {
    "doc": "Section 2",
    "title": "Section 2 – Global Capabilities",
    "content": "interface Exc { def throw(msg: String): Unit } interface Console { def println[A](a: A): Unit } interface Time { def now(): Int } // console and time are \"global\" -- that is, module wide capabilities def globalCapabilities { console: Console } { time: Time }: Unit { def sayTime() { console.println(\"The current time is: \" ++ show(time.now())) } // other blocks closing only over console or time def sayHello() { console.println(\"Hello!\") } def currentTime() { time.now() } def repeat(n: Int) { f: () =&gt; Unit }: Unit { if (n == 0) { () } else { f(); repeat(n - 1) {f} } } repeat(3) { () =&gt; console.println(\"Hello!\") }; repeat(3) { () =&gt; sayTime() }; def parallelWrong { f: () =&gt; Unit } { g: () =&gt; Unit }: Unit { () } // this wrong definition admits the following call: parallelWrong { () =&gt; console.println(\"Hello, \") } { () =&gt; console.println(\"world!\") }; // \"correct\" specification def parallel(f: () =&gt; Unit at {}, g: () =&gt; Unit at {}): Unit { () } // try commenting out the below call to see type errors // parallel( // box { () =&gt; console.println(\"Hello, \") }, // box { () =&gt; console.println(\"world!\") }); // same here, this is illtyped: // val firstClassWrong = box {} { () =&gt; console.println(\"Hello, \") }; val firstClassInfer = box { () =&gt; sayTime() }; def sayTimeThrice(): Unit { repeat(3) { () =&gt; sayTime() } } // 2.1.4 Capability Polymorphism def repeater { f: () =&gt; Unit }: (Int) =&gt; Unit at { f } { return box { (n: Int) =&gt; repeat(n) {f} } } val repeatTime = repeater { sayTime }; // some more variants illustrating closure and capability sets val b = sayTime; val n = repeater { () =&gt; sayTime() }; val n1 = repeater { sayTime }; val b2 : () =&gt; Unit at {console, time} = box { () =&gt; (unbox n)(3) }; val b3 = n(3); val b4 = { () =&gt; n(3) }; val r = repeater { b }; () } . Support Code for Running Examples . def run[T] { prog : {Console} {Time} =&gt; T }: T { try { prog {console} {time} } with console: Console { def println[A](msg: A) { println(msg); resume(()) } } with time: Time { def now() { resume(timestamp()) } } } . We can run the above examples . run {globalCapabilities} . ",
    "url": "/oopsla-2022-artifact/paper/section2.html#section-2--global-capabilities",
    "relUrl": "/paper/section2.html#section-2--global-capabilities"
  },"179": {
    "doc": "Section 2",
    "title": "Section 2 – Local Capabilities and Effect Handlers",
    "content": "interface Stopwatch { def elapsed(): Int } def localCapabilities { console: Console } { time: Time }: Unit { try { console.println(\"hello\"); exc.throw(\"world\"); console.println(\"done\") } with exc: Exc { def throw(msg: String) { console.println(msg ++ \"!\") } }; // uncomment the following example to see a type error: // try { return (box exc) } with exc: Exc { def throw(msg: String) { () } }; () } . Again, we can run the above examples: . run {localCapabilities} . ",
    "url": "/oopsla-2022-artifact/paper/section2.html#section-2--local-capabilities-and-effect-handlers",
    "relUrl": "/paper/section2.html#section-2--local-capabilities-and-effect-handlers"
  },"180": {
    "doc": "Section 2",
    "title": "Example 2.1",
    "content": "interface FileHandle { def readByte(pos: Int): Int } def withFile[T](path: String) { prog: {FileHandle} =&gt; T }: T { try { prog {fh} } with fh: FileHandle { def readByte(pos: Int) { resume(pos + 42) } } } def fileExample() { withFile(\"A.txt\") { {fileA: FileHandle} =&gt; val offsetReader : Int =&gt; Int at {fileA} = withFile(\"B.txt\") { {fileB: FileHandle} =&gt; val offset = fileB.readByte(0); return box { (pos: Int) =&gt; fileA.readByte(pos + offset) } }; (unbox offsetReader)(10) } } . Running the example will print 92 (0 + 42 + 42 + 10). fileExample() . ",
    "url": "/oopsla-2022-artifact/paper/section2.html#example-21",
    "relUrl": "/paper/section2.html#example-21"
  },"181": {
    "doc": "Section 2",
    "title": "Effect Handlers",
    "content": "def effectHandlers { console: Console } { time: Time }: Unit { val before = time.now(); try { def report(t: Int) { console.println(show(t) ++ \"ms\") } report(watch.elapsed()); report(watch.elapsed()); report(watch.elapsed()) } with watch: Stopwatch { def elapsed() { // we can observe the capture of `resume` by boxing it: val k = box resume; resume(time.now() - before) } } } . run {effectHandlers} . ",
    "url": "/oopsla-2022-artifact/paper/section2.html#effect-handlers",
    "relUrl": "/paper/section2.html#effect-handlers"
  },"182": {
    "doc": "Section 2",
    "title": "Section 2",
    "content": " ",
    "url": "/oopsla-2022-artifact/paper/section2.html",
    "relUrl": "/paper/section2.html"
  },"183": {
    "doc": "Section 4",
    "title": "Section 4.2 – Mutable State",
    "content": "interface State[S] { def get(): S def set(v: S): Unit } def handleState[S, R](init: S) { prog: {State[S]} =&gt; R }: R { val stateFun: S =&gt; R at {prog} = try { val res = prog { state }; return box {prog} { (s: S) =&gt; res } } with state: State[S] { def get() { box { (s: S) =&gt; (unbox resume(s))(s) } } def set(v: S) { box { (_: S) =&gt; (unbox resume(()))(v) } } }; return (unbox stateFun)(init) } . handleState(0) { {s: State[Int]} =&gt; println(s.get()); s.set(2); println(s.get()) } . For more details on regions, also see the corresponding regions case study. def regions1() { region r { var x in r = 42; val t = x; x = (t + 1) } } . def regions2() { region r { var x in r = 42; val f: () =&gt; Int at {r} = box { () =&gt; x }; (unbox f)() } } . regions2() . ",
    "url": "/oopsla-2022-artifact/paper/section4.html#section-42--mutable-state",
    "relUrl": "/paper/section4.html#section-42--mutable-state"
  },"184": {
    "doc": "Section 4",
    "title": "Example 4.1",
    "content": "See the scheduler case study . ",
    "url": "/oopsla-2022-artifact/paper/section4.html#example-41",
    "relUrl": "/paper/section4.html#example-41"
  },"185": {
    "doc": "Section 4",
    "title": "Section 4.4 – Effect Handlers and Object Orientation",
    "content": "Similar examples can be found in the regions case study. Support code to run the example from Section 2. interface Console { def println[A](a: A): Unit } def run[T] { prog : {Console} =&gt; T }: T { try { prog {console} } with console: Console { def println[A](msg: A) { println(msg); resume(()) } } } . interface Counter { def inc(): Unit def get(): Int } def counterExample { console: Console }: Unit { def makeCounter { pool: Region }: Counter at {pool, console} { var count in pool = 0; def c = new Counter { def inc() { console.println(count); count = count + 1 } def get() { count } }; return box c } region r { val c1 = makeCounter {r}; val c2 = makeCounter {r}; c1.inc(); c1.inc(); c2.inc(); console.println(c1.get()); console.println(c2.get()) } } . run {counterExample} . ",
    "url": "/oopsla-2022-artifact/paper/section4.html#section-44--effect-handlers-and-object-orientation",
    "relUrl": "/paper/section4.html#section-44--effect-handlers-and-object-orientation"
  },"186": {
    "doc": "Section 4",
    "title": "Section 4",
    "content": " ",
    "url": "/oopsla-2022-artifact/paper/section4.html",
    "relUrl": "/paper/section4.html"
  }
}
