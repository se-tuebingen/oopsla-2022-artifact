{"0": {
    "doc": "CaptureSets",
    "title": "Top.SystemC.CaptureSets",
    "content": "The source of this file can be found on Github. This file implements Capture Sets, a.k.a a record of free and bound variables, captured by a particular value. ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.CaptureSets.html",
    "relUrl": "/proofs/Top.SystemC.CaptureSets.html"
  },"1": {
    "doc": "CaptureSets",
    "title": "Definition of Capture Sets",
    "content": "A captureset -- a record of: . | free variables (atoms) | bound variables (nats) | and runtime labels (labels) | . Inductive cap : Type := &nbsp;&nbsp;| cset_set : atoms → nats → labels → cap. ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.CaptureSets.html",
    "relUrl": "/proofs/Top.SystemC.CaptureSets.html"
  },"2": {
    "doc": "CaptureSets",
    "title": "Smart Constructors",
    "content": "Definition empty_cset := cset_set {} {}N {}L. The empty set may be written similarly to informal practice. Notation &quot;{}C\" := empty_cset : metatheory_scope. Singleton Sets . Definition cset_fvar (a : atom) := &nbsp;&nbsp;(cset_set (AtomSet.F.singleton a) NatSet.F.empty LabelSet.F.empty). Definition cset_bvar (k : nat) := &nbsp;&nbsp;(cset_set AtomSet.F.empty (NatSet.F.singleton k) LabelSet.F.empty). Definition cset_lvar (a : label) := &nbsp;&nbsp;(cset_set AtomSet.F.empty NatSet.F.empty (LabelSet.F.singleton a)). Definition from_labels (ls : labels) := &nbsp;&nbsp;(cset_set AtomSet.F.empty NatSet.F.empty ls). ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.CaptureSets.html",
    "relUrl": "/proofs/Top.SystemC.CaptureSets.html"
  },"3": {
    "doc": "CaptureSets",
    "title": "Selectors",
    "content": "Definition cset_fvars (c : cap) : atoms := &nbsp;&nbsp;match c with &nbsp;&nbsp;| cset_set A N R ⇒ A &nbsp;&nbsp;end. Definition cset_bvars (c : cap) : nats := &nbsp;&nbsp;match c with &nbsp;&nbsp;| cset_set A N R ⇒ N &nbsp;&nbsp;end. Definition cset_lvars (c : cap) : labels := &nbsp;&nbsp;match c with &nbsp;&nbsp;| cset_set A N R ⇒ R &nbsp;&nbsp;end. ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.CaptureSets.html",
    "relUrl": "/proofs/Top.SystemC.CaptureSets.html"
  },"4": {
    "doc": "CaptureSets",
    "title": "Operations",
    "content": "Predicates for determining if a capture set explicity references a variable -- used for determining if a capture set is well formed. Don't use these predicates for determining if a capture set captures a variable, as one needs to also test cset_universal. Definition cset_references_bvar (k : nat) (c : cap) := &nbsp;&nbsp;NatSet.F.In k (cset_bvars c). Definition cset_references_fvar (a : atom) (c : cap) := &nbsp;&nbsp;AtomSet.F.In a (cset_fvars c). Definition cset_references_lvar (a : label) (c : cap) := &nbsp;&nbsp;LabelSet.F.In a (cset_lvars c). Definition cset_references_bvar_dec (k : nat) (c : cap) := &nbsp;&nbsp;NatSet.F.mem k (cset_bvars c). Definition cset_references_fvar_dec (a : atom) (c : cap) := &nbsp;&nbsp;AtomSet.F.mem a (cset_fvars c). Definition cset_references_lvar_dec (a : label) (c : cap) := &nbsp;&nbsp;LabelSet.F.mem a (cset_lvars c). Definition cset_remove_bvar (k : nat) (c : cap) : cap := &nbsp;&nbsp;cset_set (cset_fvars c) (NatSet.F.remove k (cset_bvars c)) (cset_lvars c). Definition cset_remove_fvar (a : atom) (c : cap) : cap := &nbsp;&nbsp;cset_set (AtomSet.F.remove a (cset_fvars c)) (cset_bvars c) (cset_lvars c). Capture set unions are what you'd expect. Definition cset_union (c1 c2 : cap) : cap := &nbsp;&nbsp;cset_set &nbsp;&nbsp;&nbsp;&nbsp;(AtomSet.F.union (cset_fvars c1) (cset_fvars c2)) &nbsp;&nbsp;&nbsp;&nbsp;(NatSet.F.union (cset_bvars c1) (cset_bvars c2)) &nbsp;&nbsp;&nbsp;&nbsp;(LabelSet.F.union (cset_lvars c1) (cset_lvars c2)). Definition cset_subset_dec (C D : cap) := &nbsp;&nbsp;AtomSet.F.subset (cset_fvars C) (cset_fvars D) &nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; NatSet.F.subset (cset_bvars C) (cset_bvars D) &nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; LabelSet.F.subset (cset_lvars C) (cset_lvars D). ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.CaptureSets.html",
    "relUrl": "/proofs/Top.SystemC.CaptureSets.html"
  },"5": {
    "doc": "CaptureSets",
    "title": "Logical Predicates",
    "content": "Definition cset_empty (c : cap) : Prop := &nbsp;&nbsp;AtomSet.F.Empty (cset_fvars c) ∧ NatSet.F.Empty (cset_bvars c) ∧ LabelSet.F.Empty (cset_lvars c). Definition cset_subset_prop (c : cap) (d : cap) : Prop := &nbsp;&nbsp;AtomSet.F.Subset (cset_fvars c) (cset_fvars d) &nbsp;&nbsp;&nbsp;&nbsp;∧ NatSet.F.Subset (cset_bvars c) (cset_bvars d) &nbsp;&nbsp;&nbsp;&nbsp;∧ LabelSet.F.Subset (cset_lvars c) (cset_lvars d). ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.CaptureSets.html",
    "relUrl": "/proofs/Top.SystemC.CaptureSets.html"
  },"6": {
    "doc": "CaptureSets",
    "title": "Properties",
    "content": "Section Props. &nbsp;&nbsp;Variable x y a f : atom. &nbsp;&nbsp;Variable l m : label. &nbsp;&nbsp;Variable A A1 A2 : atoms. &nbsp;&nbsp;Variable R R1 R2 : labels. &nbsp;&nbsp;Variable k n : nat. &nbsp;&nbsp;Variable N N1 N2 : nats. &nbsp;&nbsp;Variable C D C1 C2 C3 : cap. &nbsp;&nbsp;Lemma cset_bvar_mem_iff : &nbsp;&nbsp;&nbsp;&nbsp;cset_references_bvar k C ↔ cset_references_bvar_dec k C = true. &nbsp;&nbsp;Lemma cset_fvar_mem_iff : &nbsp;&nbsp;&nbsp;&nbsp;cset_references_fvar a C ↔ cset_references_fvar_dec a C = true. &nbsp;&nbsp;Lemma cset_lvar_mem_iff : &nbsp;&nbsp;&nbsp;&nbsp;cset_references_lvar l C ↔ cset_references_lvar_dec l C = true. &nbsp;&nbsp;Lemma cset_bvar_not_mem_iff : &nbsp;&nbsp;&nbsp;&nbsp;¬ cset_references_bvar k C ↔ cset_references_bvar_dec k C = false. &nbsp;&nbsp;Lemma cset_fvar_not_mem_iff : &nbsp;&nbsp;&nbsp;&nbsp;¬ cset_references_fvar a C ↔ cset_references_fvar_dec a C = false. &nbsp;&nbsp;Lemma cset_lvar_not_mem_iff : &nbsp;&nbsp;&nbsp;&nbsp;¬ cset_references_lvar l C ↔ cset_references_lvar_dec l C = false. &nbsp;&nbsp;Lemma fvars_1 : cset_fvars (cset_set A N R) = A. &nbsp;&nbsp;Lemma bvars_1 : cset_bvars (cset_set A N R) = N. &nbsp;&nbsp;Lemma lvars_1 : cset_lvars (cset_set A N R) = R. &nbsp;&nbsp;Lemma fvars_union_1 : cset_fvars (cset_union C D) = AtomSet.F.union (cset_fvars C) (cset_fvars D). &nbsp;&nbsp;Lemma bvars_union_1 : cset_bvars (cset_union C D) = NatSet.F.union (cset_bvars C) (cset_bvars D). &nbsp;&nbsp;Lemma lvars_union_1 : cset_lvars (cset_union C D) = LabelSet.F.union (cset_lvars C) (cset_lvars D). &nbsp;&nbsp;Lemma remove_fvar_1 : cset_remove_fvar x (cset_set A N R) = (cset_set (AtomSet.F.remove x A) N R). &nbsp;&nbsp;Lemma remove_bvar_1 : cset_remove_bvar k (cset_set A N R) = (cset_set A (NatSet.F.remove k N) R). &nbsp;&nbsp;Lemma mem_bvar_1 : cset_references_bvar k C → cset_references_bvar_dec k C = true. &nbsp;&nbsp;Lemma mem_bvar_2 : cset_references_bvar_dec k C = true → cset_references_bvar k C. &nbsp;&nbsp;Lemma mem_fvar_1 : cset_references_fvar a C → cset_references_fvar_dec a C = true. &nbsp;&nbsp;Lemma mem_fvar_2 : cset_references_fvar_dec a C = true → cset_references_fvar a C. &nbsp;&nbsp;Lemma mem_lvar_1 : cset_references_lvar l C → cset_references_lvar_dec l C = true. &nbsp;&nbsp;Lemma mem_lvar_2 : cset_references_lvar_dec l C = true → cset_references_lvar l C. &nbsp;&nbsp;Lemma In_bvar_1 : k = n → cset_references_bvar k C → cset_references_bvar n C. &nbsp;&nbsp;Lemma In_fvar_1 : a = f → cset_references_fvar a C → cset_references_fvar f C. &nbsp;&nbsp;Lemma In_lvar_1 : l = m → cset_references_lvar l C → cset_references_lvar m C. &nbsp;&nbsp;Lemma Is_empty : cset_empty empty_cset. &nbsp;&nbsp;Lemma union_fvar_1 : cset_references_fvar x (cset_union C D) → cset_references_fvar x C ∨ cset_references_fvar x D. &nbsp;&nbsp;Lemma union_fvar_2 : cset_references_fvar x C → cset_references_fvar x (cset_union C D). &nbsp;&nbsp;Lemma union_fvar_3 : cset_references_fvar x D → cset_references_fvar x (cset_union C D). &nbsp;&nbsp;Lemma union_bvar_1 : cset_references_bvar k (cset_union C D) → cset_references_bvar k C ∨ cset_references_bvar k D. &nbsp;&nbsp;Lemma union_bvar_2 : cset_references_bvar k C → cset_references_bvar k (cset_union C D). &nbsp;&nbsp;Lemma union_bvar_3 : cset_references_bvar k D → cset_references_bvar k (cset_union C D). &nbsp;&nbsp;Lemma union_lvar_1 : cset_references_lvar l (cset_union C D) → cset_references_lvar l C ∨ cset_references_lvar l D. &nbsp;&nbsp;Lemma union_lvar_2 : cset_references_lvar l C → cset_references_lvar l (cset_union C D). &nbsp;&nbsp;Lemma union_lvar_3 : cset_references_lvar l D → cset_references_lvar l (cset_union C D). &nbsp;&nbsp;Lemma union_sub_1 : cset_subset_prop C D → cset_union D C = D. &nbsp;&nbsp;Lemma union_sub_2 : cset_subset_prop C D → D = cset_union D C. &nbsp;&nbsp;Lemma union_subset_distribute_1 : cset_subset_prop C1 C2 → cset_subset_prop (cset_union C1 D) (cset_union C2 D). End Props. (*&nbsp;TODO&nbsp;defined&nbsp;here&nbsp;to&nbsp;avoid&nbsp;all&nbsp;the&nbsp;implicit&nbsp;arguments&nbsp;*) Lemma subset_lvar_1 : ∀ R C l, &nbsp;&nbsp;cset_subset_prop R C → cset_references_lvar l R → cset_references_lvar l C. Lemma from_empty_labels_is_empty : &nbsp;&nbsp;(from_labels {}L) = {}C. (*&nbsp;***&nbsp;Some&nbsp;subset&nbsp;properties&nbsp;*) Lemma subset_refl : ∀ C, &nbsp;&nbsp;cset_subset_prop C C. Lemma subset_union_left : ∀ C1 C2, &nbsp;&nbsp;cset_subset_prop C1 (cset_union C1 C2). Lemma subset_union_right : ∀ C1 C2, &nbsp;&nbsp;cset_subset_prop C2 (cset_union C1 C2). Lemma subset_trans : ∀ A B C, &nbsp;&nbsp;cset_subset_prop A B → cset_subset_prop B C → cset_subset_prop A C. ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.CaptureSets.html",
    "relUrl": "/proofs/Top.SystemC.CaptureSets.html"
  },"7": {
    "doc": "CaptureSets",
    "title": "Locally Namelesss",
    "content": "Definition capt (c : cap) : Prop := NatSet.F.Empty (cset_bvars c). Lemma singleton_closed : ∀ f, &nbsp;&nbsp;capt (cset_fvar f). Lemma capt_empty_bvar : ∀ A N R, &nbsp;&nbsp;capt (cset_set A N R) → &nbsp;&nbsp;N = {}N. Opening a capture set with a bound variable dk → c Definition open_cset (k : nat) (c : cap) (d : cap) : cap := &nbsp;&nbsp;if cset_references_bvar_dec k d then &nbsp;&nbsp;&nbsp;&nbsp;cset_union c (cset_remove_bvar k d) &nbsp;&nbsp;else &nbsp;&nbsp;&nbsp;&nbsp;d. Substituting a capture set with a free variable da → c Definition subst_cset (a : atom) (c : cap) (d: cap) : cap := &nbsp;&nbsp;if cset_references_fvar_dec a d then &nbsp;&nbsp;&nbsp;&nbsp;cset_union c (cset_remove_fvar a d) &nbsp;&nbsp;else &nbsp;&nbsp;&nbsp;&nbsp;d. Lemma subst_over_subset : ∀ C1 C2 D x, &nbsp;&nbsp;cset_subset_prop C1 C2 → &nbsp;&nbsp;cset_subset_prop (subst_cset x D C1) (subst_cset x D C2). Lemma subst_subset_intro : ∀ C1 C2 x, &nbsp;&nbsp;(*&nbsp;C1&nbsp;is&nbsp;closed&nbsp;*) &nbsp;&nbsp;capt C1 → &nbsp;&nbsp;cset_subset_prop (cset_fvar x) C2 → &nbsp;&nbsp;cset_subset_prop C1 (subst_cset x C1 C2). Lemma subst_cset_union : ∀ x D C1 C2, &nbsp;&nbsp;subst_cset x D (cset_union C1 C2) = (cset_union (subst_cset x D C1) (subst_cset x D C2)). Lemma subst_cset_singleton : ∀ x C, &nbsp;&nbsp;subst_cset x C (cset_fvar x) = C. Lemma subst_cset_fresh : ∀ x C1 C2, &nbsp;&nbsp;x `notin` (cset_fvars C1) → &nbsp;&nbsp;C1 = subst_cset x C2 C1. Lemma singleton_lvar : ∀ l, &nbsp;&nbsp;cset_references_lvar l (cset_lvar l). Lemma subst_cset_fresh_id : ∀ x X C, &nbsp;&nbsp;x ≠ X → &nbsp;&nbsp;(subst_cset X C (cset_fvar x)) = (cset_fvar x). Lemma subst_cset_union_id : ∀ x y D C1, &nbsp;&nbsp;x ≠ y → &nbsp;&nbsp;subst_cset x D (cset_union C1 (cset_fvar y)) = (cset_union (subst_cset x D C1) (cset_fvar y)). Lemma subst_cset_lvar : ∀ x C l R, &nbsp;&nbsp;cset_references_lvar l R → &nbsp;&nbsp;cset_references_lvar l (subst_cset x C R). Lemma subst_cset_lvar_idempotent : ∀ x C l, &nbsp;&nbsp;(subst_cset x C (cset_lvar l)) = (cset_lvar l). Lemma open_cset_capt : ∀ i C c, &nbsp;&nbsp;capt C → &nbsp;&nbsp;C = open_cset i c C. Lemma subst_cc_intro_rec : ∀ X (C : cap) U k, &nbsp;&nbsp;X `notin` (cset_fvars C) → &nbsp;&nbsp;open_cset k U C = subst_cset X U (open_cset k (cset_fvar X) C). Lemma open_cset_rec_capt_aux : ∀ c j V i U, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;capt V → &nbsp;&nbsp;(cset_fvars V) `disjoint` (cset_fvars U) → &nbsp;&nbsp;labels_disjoint (cset_lvars V) (cset_lvars U) → &nbsp;&nbsp;open_cset j V c = open_cset i U (open_cset j V c) → &nbsp;&nbsp;c = open_cset i U c. Lemma subst_cset_open_cset_rec : ∀ x k C1 C2 D, &nbsp;&nbsp;capt C1 → &nbsp;&nbsp;subst_cset x C1 (open_cset k C2 D) = open_cset k (subst_cset x C1 C2) (subst_cset x C1 D). ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.CaptureSets.html",
    "relUrl": "/proofs/Top.SystemC.CaptureSets.html"
  },"8": {
    "doc": "CaptureSets",
    "title": "CaptureSets",
    "content": " ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.CaptureSets.html",
    "relUrl": "/proofs/Top.SystemC.CaptureSets.html"
  },"9": {
    "doc": "Definitions",
    "title": "Top.SystemC.Definitions",
    "content": "The source of this file can be found on Github. This file contains the definitions for System C. We include snippets of the paper as images to facilitate comparison. ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Definitions.html",
    "relUrl": "/proofs/Top.SystemC.Definitions.html"
  },"10": {
    "doc": "Definitions",
    "title": "Table of Contents",
    "content": "Syntax . | Syntax of Types | Syntax of Terms | . Environments and Signatures Typing . | Expression Typing | Block Typing | Statement Typing | . Operational Semantics . | Values | Machine Redexes | Trivial Reduction | Stacks, Contexts, and their Typing | Abstract Machine | Machine Reduction | Abstract Machine Typing | . ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Definitions.html",
    "relUrl": "/proofs/Top.SystemC.Definitions.html"
  },"11": {
    "doc": "Definitions",
    "title": "  Syntax",
    "content": "The definitions here reflect the definitions in Figure 1 from the paper. Please note that we base our proofs on a locally nameless representation. In consequence, there are always two types of variables, free variables (such as typ_fvar) and locally bound variables (such as typ_bvar). Capture sets cap are records, containing sets of free variables, sets of bound variables, and sets of labels. ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Definitions.html",
    "relUrl": "/proofs/Top.SystemC.Definitions.html"
  },"12": {
    "doc": "Definitions",
    "title": " Syntax of Types",
    "content": "Here, we define the syntax of types, as defined in Figure 1 in the paper. Value Types . Inductive vtyp : Type := &nbsp;&nbsp;| typ_base : vtyp (*&nbsp;base&nbsp;types&nbsp;*) &nbsp;&nbsp;| typ_capt : btyp → cap → vtyp (*&nbsp;boxed&nbsp;block&nbsp;types&nbsp;*) &nbsp;&nbsp;| typ_fvar : atom → vtyp (*&nbsp;(free)&nbsp;value-type&nbsp;variables&nbsp;*) &nbsp;&nbsp;| typ_bvar : nat → vtyp (*&nbsp;(bound)&nbsp;value-type&nbsp;variables&nbsp;*) Differences to the paper . In the mechanization, we also additionally support value-type polymorphism. Hence, the constructors for type variables (typ_bvar and typ_fvar), which are not present in the paper. Also, we only include one base type typ_base instead of separate base types (as in the paper). Block Types . with btyp : Type := &nbsp;&nbsp;| typ_vfun : vtyp → vtyp → btyp (*&nbsp;function&nbsp;types&nbsp;with&nbsp;value&nbsp;arguments&nbsp;*) &nbsp;&nbsp;| typ_bfun : btyp → vtyp → btyp (*&nbsp;function&nbsp;types&nbsp;with&nbsp;tracked&nbsp;block&nbsp;arguments&nbsp;*) &nbsp;&nbsp;| typ_tfun : btyp → btyp (*&nbsp;type&nbsp;abstractions&nbsp;*) &nbsp;&nbsp;| typ_exc : vtyp → vtyp → btyp (*&nbsp;capability&nbsp;types&nbsp;*) . Differences to the paper . In the paper, we formalize multi-arity function types. Since this is akward to work with in Coq, here, we only mechanize single arity function types. We include two type constructors, typ_vfun for function types with value arguments (e.g. Int → Int), and typ_bfun for function types with block arguments that are always tracked (e.g. (f : Int → Int) → Int). Since in the calculus function arguments are independent of each other, we do not expect any theoretical complications in the setting of a full multi-arity representation. Type constructor typ_exc T1 T2 is a block type that represents capabilities with an effect signature from T1 to T2. To simplify the presentation, in the paper, this is represented as a function type T1 → T2 as for instance can be seen in rule TRY in Figure 2. ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Definitions.html",
    "relUrl": "/proofs/Top.SystemC.Definitions.html"
  },"13": {
    "doc": "Definitions",
    "title": " Syntax of Terms",
    "content": "In the following, we define the syntax of expressions, statements, and blocks. Expressions . Inductive exp : Type := &nbsp;&nbsp;| exp_bvar : nat → exp (*&nbsp;(bound)&nbsp;expression&nbsp;variables&nbsp;*) &nbsp;&nbsp;| exp_fvar : atom → exp (*&nbsp;(free)&nbsp;expression&nbsp;variables&nbsp;*) &nbsp;&nbsp;| exp_const : exp (*&nbsp;primitives&nbsp;*) &nbsp;&nbsp;| exp_box : cap → blk → exp (*&nbsp;box&nbsp;introduction&nbsp;*) Differences to the paper . Besides only having one primitive value, expressions are precisely as in the paper. Statements . with stm : Type := &nbsp;&nbsp;| stm_ret : exp → stm (*&nbsp;returning&nbsp;*) &nbsp;&nbsp;| stm_val : vtyp → stm → stm → stm (*&nbsp;sequencing&nbsp;*) &nbsp;&nbsp;| stm_def : cap → btyp → blk → stm → stm (*&nbsp;block&nbsp;definition&nbsp;*) &nbsp;&nbsp;| stm_vapp : blk → exp → stm (*&nbsp;block&nbsp;application&nbsp;(to&nbsp;value&nbsp;arguments)&nbsp;*) &nbsp;&nbsp;| stm_bapp : blk → cap → blk → stm (*&nbsp;block&nbsp;application&nbsp;(to&nbsp;block&nbsp;arguments)&nbsp;*) &nbsp;&nbsp;| stm_try : cap → vtyp → vtyp → stm → stm → stm (*&nbsp;handlers&nbsp;*) &nbsp;&nbsp;| stm_throw : blk → exp → stm (*&nbsp;performing&nbsp;an&nbsp;effect&nbsp;*) &nbsp;&nbsp;| stm_reset : label → cap → stm → stm → stm (*&nbsp;runtime&nbsp;delimiter&nbsp;*) Differences to the paper . Similar to the syntax of types, in the mechanization we have two different forms of application (instead of multi-arity). stm_vapp takes the block to call and an expression (value argument), while stm_bapp takes the block to call, a capture annotation (to avoid implementing capture inference in the mechanization), and a block argument. Similar to block application for blocks the handler construct stm_try C T1 T2 s1 s2 models statements of the form try { f : Exc T1 T2 =&gt; s1 } with { (x: T1, k: (T2 =&gt; R @ C)) =&gt; s2 } That is, the capture annotion C corresponds to the capture set on the continuation k. This can also be seen in Figure 2, rule TRY, but without an explicit annotation on the stm_try. Types T1 and T2 are also explicitly annotated, which is not the case in the paper. Like in Figure 3 of the paper, we also include the syntax for runtime delimiters stm_reset C T1 T2 that model statements of the form #_l { s1 } with { (x: T1, k: (T2 =&gt; R @ C)) =&gt; s2 } Blocks . with blk : Type := &nbsp;&nbsp;| blk_bvar : nat → blk (*&nbsp;(bound)&nbsp;block&nbsp;variables&nbsp;*) &nbsp;&nbsp;| blk_fvar : atom → blk (*&nbsp;(free)&nbsp;block&nbsp;variables&nbsp;*) &nbsp;&nbsp;| blk_vabs : vtyp → stm → blk (*&nbsp;block&nbsp;implementation&nbsp;(with&nbsp;value&nbsp;argument)&nbsp;*) &nbsp;&nbsp;| blk_babs : btyp → stm → blk (*&nbsp;block&nbsp;implementation&nbsp;(with&nbsp;block&nbsp;argument)&nbsp;*) &nbsp;&nbsp;| blk_unbox : exp → blk (*&nbsp;box&nbsp;elimination&nbsp;*) &nbsp;&nbsp;| blk_tabs : blk → blk (*&nbsp;value&nbsp;type&nbsp;abstraction&nbsp;*) &nbsp;&nbsp;| blk_tapp : blk → vtyp → blk (*&nbsp;value&nbsp;type&nbsp;application&nbsp;*) &nbsp;&nbsp;| blk_handler : label → blk (*&nbsp;runtime&nbsp;capability&nbsp;*) . Differences to the paper . Again, as for statements and block types, we have two different forms of abstraction. blk_vabs to abstract over values and blk_babs to abstract over (tracked) blocks. In addition to the paper, we also include term-level syntax to abstract over value types blk_tabs and instantiate polymorphic blocks with value types blk_tapp. The constructor blk_handler corresponds to the cap_l form in the paper and represents runtime capabilities. ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Definitions.html",
    "relUrl": "/proofs/Top.SystemC.Definitions.html"
  },"14": {
    "doc": "Definitions",
    "title": " Environments and Signatures",
    "content": " ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Definitions.html",
    "relUrl": "/proofs/Top.SystemC.Definitions.html"
  },"15": {
    "doc": "Definitions",
    "title": "Environments",
    "content": "Like in the paper, we use a single environment for value, block, and type abstraction. We formalize environments by representing them as association lists (lists of pairs of keys and values) whose keys are atoms. Instead of having two forms of block bindings, we index them by a coeffect defined below: Inductive coeffect : Type := &nbsp;&nbsp;| tracked : coeffect &nbsp;&nbsp;| capture : cap → coeffect. Basing our mechanization on an existing locally nameless proof, we reuse the infrastructure for environments. Util.Metatheory, Util.Environment, and Util.Signatures libraries provide functions, predicates, tactics, notations and lemmas that simplify working with environments. The Util.Environment library treats environments as lists of type list (atom × A). Since environments map atoms, the type A should encode whether a particular binding is a typing or region assumption. Thus, we instantiate A with the type binding, defined below Inductive binding : Type := &nbsp;&nbsp;(*&nbsp;&nbsp;x&nbsp;:&nbsp;T&nbsp;&nbsp;&nbsp;*) &nbsp;&nbsp;| bind_val : vtyp → binding &nbsp;&nbsp;| bind_blk : btyp → coeffect → binding &nbsp;&nbsp;(*&nbsp;X&nbsp;*) &nbsp;&nbsp;| bind_typ : binding. Notation env := (list (atom × binding)). Notation empty := (@nil (atom × binding)). ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Definitions.html",
    "relUrl": "/proofs/Top.SystemC.Definitions.html"
  },"16": {
    "doc": "Definitions",
    "title": "Signatures",
    "content": "As a proof device, each runtime label (Figure 3 in the paper) is associated with a signature (that is the argument type and the result type of an effect operation). The tooling in Util.Signatures is a plain copy of Util.Environment. Inductive signature : Type := &nbsp;&nbsp;(*&nbsp;label&nbsp;:&nbsp;T1&nbsp;(param&nbsp;type)&nbsp;T&nbsp;(result&nbsp;type)*) &nbsp;&nbsp;| bind_sig : vtyp → vtyp → signature. Notation sig := (list (label × signature)). ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Definitions.html",
    "relUrl": "/proofs/Top.SystemC.Definitions.html"
  },"17": {
    "doc": "Definitions",
    "title": " Typing",
    "content": "Like in the paper, we model typing as three mutually inductive relations. Note that we use notation C |= D (pronounced \"C admits D\") instead of subset inclusion D ≤ C as it is used in the paper. Notation &quot;C |= D\" := (cset_subset_prop D C) (at level 68). Reserved Notation &quot;E ; Q |-exp e ~: T\" (at level 70, Q at next level). Reserved Notation &quot;E @ R ; Q |-blk b ~: S\" (at level 70, R at next level, Q at next level). Reserved Notation &quot;E @ R ; Q |-stm s ~: T\" (at level 70, R at next level, Q at next level). Note on presentation: we use Gamma for E, and Xi for Q, both in the paper and in coqdoc. ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Definitions.html",
    "relUrl": "/proofs/Top.SystemC.Definitions.html"
  },"18": {
    "doc": "Definitions",
    "title": " Expression Typing",
    "content": "Inductive etyping : env → sig → exp → vtyp → Prop := &nbsp;&nbsp;| typing_base : ∀ E Q, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_env E → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_sig Q → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E ; Q |-exp exp_const ~: typ_base &nbsp;&nbsp;| typing_evar : ∀ E Q x T, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_env E → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_sig Q → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds x (bind_val T) E → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E ; Q |-exp (exp_fvar x) ~: T &nbsp;&nbsp;| typing_box : ∀ E Q (C : cap) S1 b, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_cap E C → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(E @ C ; Q |-blk b ~: S1) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E ; Q |-exp (exp_box C b) ~: (typ_capt S1 C) where &quot;E ; Q |-exp e ~: T\" := (etyping E Q e T) Differences to the paper . The three rules directly correspond to rules LIT, VAR, and BOXINTRO in the paper. As can be seen (all) typing judgements in Coq make wellformedness conditions explicit, which are left implicit in the paper. ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Definitions.html",
    "relUrl": "/proofs/Top.SystemC.Definitions.html"
  },"19": {
    "doc": "Definitions",
    "title": " Block Typing",
    "content": "with btyping : env → cap → sig → blk → btyp → Prop := &nbsp;&nbsp;| typing_bvar_tracked : ∀ E R Q f S1, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_env E → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_sig Q → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_cap E R → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds f (bind_blk S1 tracked) E → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R |= cset_fvar f → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-blk (blk_fvar f) ~: S1 &nbsp;&nbsp;| typing_bvar_capture : ∀ E R Q f S1 (C : cap), &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_env E → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_sig Q → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_cap E R → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R |= C → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds f (bind_blk S1 (capture C)) E → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-blk (blk_fvar f) ~: S1 &nbsp;&nbsp;| typing_unbox : ∀ E R Q e S1 C, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E ; Q |-exp e ~: (typ_capt S1 C) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_cap E R → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R |= C → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-blk (blk_unbox e) ~: S1 &nbsp;&nbsp;| typing_vabs : ∀ L E R Q T1 s T2, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(∀ x : atom, x `notin` L → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;([(x, bind_val T1)] ++ E) @ R ; Q |-stm (open_es s x) ~: T2) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-blk (blk_vabs T1 s) ~: (typ_vfun T1 T2) &nbsp;&nbsp;| typing_babs : ∀ L E R Q S1 s T2, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(∀ x : atom, x `notin` L → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;([(x, bind_blk S1 tracked)] ++ E) @ cset_union R (cset_fvar x) ; Q |-stm (open_cs s x (cset_fvar x)) ~: (open_cvt T2 (cset_fvar x))) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-blk (blk_babs S1 s) ~: (typ_bfun S1 T2) Differences to the paper . Note that we build in subsumption on blocks (rule BSUB in the paper) into the rules as additional premises, instead of having one additional rule. This allows us to omit having to prove inversion of subeffecting. Instead, in SystemC.Substitution.btyping_weaken_restriction we show that rule SUB is admissible (and similar for subsumption on statements). In the paper, we use C for capture sets, but in the mechanization we speak of restrictions and use the metavariable R Rules from the paper map in the following way to the mechanization: . | TRACKED maps to typing_bvar_tracked | TRANSPARENT maps to typing_bvar_capture | BLOCK maps to typing_vabs and typing_babs | BOXELIM maps to typing_unbox | . Additional Rules for Type Polymorphism . &nbsp;&nbsp;| typing_tabs : ∀ L E R Q s T, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(∀ X : atom, X `notin` L → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;([(X, bind_typ)] ++ E) @ R ; Q |-blk (open_tb s X) ~: (open_tbt T X)) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-blk (blk_tabs s) ~: (typ_tfun T) &nbsp;&nbsp;| typing_tapp : ∀ E R Q s T T1, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_vtyp E T1 → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-blk s ~: (typ_tfun T) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-blk (blk_tapp s T1) ~: (open_tbt T T1) Typing Effect Handlers . Like in the other rules, we bake subsumption into this rule. &nbsp;&nbsp;| typing_handler : ∀ E R Q l T1 T, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_env E → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_sig Q → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_cap E R → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_vtyp E T → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;We&nbsp;are&nbsp;allowed&nbsp;to&nbsp;use&nbsp;l:&nbsp;*) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cset_references_lvar l R → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;It&nbsp;has&nbsp;the&nbsp;correct&nbsp;type&nbsp;*) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Signatures.binds l (bind_sig T1 T) Q → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-blk blk_handler l ~: (typ_exc T1 T) where &quot;E @ R ; Q |-blk b ~: S\" := (btyping E R Q b S) ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Definitions.html",
    "relUrl": "/proofs/Top.SystemC.Definitions.html"
  },"20": {
    "doc": "Definitions",
    "title": " Statement Typing",
    "content": "with styping : env → cap → sig → stm → vtyp → Prop := &nbsp;&nbsp;| typing_ret : ∀ E R Q e T, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E ; Q |-exp e ~: T → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_cap E R → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-stm (stm_ret e) ~: T &nbsp;&nbsp;| typing_val : ∀ L E R Q b s T1 T2, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-stm b ~: T1 → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(∀ x : atom, x `notin` L → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;([(x, bind_val T1)] ++ E) @ R ; Q |-stm (open_es s x) ~: T2) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-stm (stm_val T1 b s) ~: T2 &nbsp;&nbsp;| typing_def : ∀ L E R Q b s (C : cap) S1 T2, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_cap E C → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ C ; Q |-blk b ~: S1 → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;This&nbsp;is&nbsp;a&nbsp;transparent&nbsp;binding&nbsp;(not&nbsp;tracked),&nbsp;we&nbsp;do&nbsp;not&nbsp;open&nbsp;types.&nbsp;*) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(∀ x : atom, x `notin` L → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;([(x, bind_blk S1 (capture C))] ++ E) @ R ; Q |-stm (open_bs s x) ~: T2) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-stm (stm_def C S1 b s) ~: T2 &nbsp;&nbsp;| typing_vapp : ∀ E R Q b e T1 T2, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-blk b ~: (typ_vfun T1 T2) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E ; Q |-exp e ~: T1 → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-stm (stm_vapp b e) ~: T2 &nbsp;&nbsp;| typing_bapp : ∀ E R Q b1 b2 (C : cap) S1 T2, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R |= C → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_cap E C → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-blk b1 ~: (typ_bfun S1 T2) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ C ; Q |-blk b2 ~: S1 → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-stm (stm_bapp b1 C b2) ~: (open_cvt T2 C) Differences to the paper . The rules correspond to the paper with the following mapping: . | RET maps to typing_ret | VAL maps to typing_val | DEF maps to typing_def | APP maps to typing_vapp and typing_bapp In rule typing_val, for simplicity we do not compute the union, but instead require both restrictions to be the same. This does not affect expressivity, since we can always use subsumption. | . Typing Handling of Effects . &nbsp;&nbsp;| typing_try : ∀ L E R Q C b h T T1 T2, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R |= C → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_cap E C → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_cap E R → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;E,&nbsp;f&nbsp;:&nbsp;(Exc&nbsp;@&nbsp;{*})&nbsp;@&nbsp;C&nbsp;union&nbsp;f&nbsp;|-&nbsp;h&nbsp;:&nbsp;T&nbsp;*) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(∀ f : atom, f `notin` L → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;([(f, bind_blk (typ_exc T2 T1) tracked)] ++ E) @ (cset_union C (cset_fvar f)) ; Q &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|-stm (open_cs b f (cset_fvar f)) ~: T) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;E,&nbsp;x&nbsp;:&nbsp;T1,&nbsp;k&nbsp;:&nbsp;(T2&nbsp;-&gt;&nbsp;T&nbsp;@&nbsp;C)&nbsp;@&nbsp;C&nbsp;|-&nbsp;h&nbsp;:&nbsp;T&nbsp;*) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(∀ (v : atom), v `notin` L → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(∀ (f : atom), f `notin` (L `union` singleton v) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;([(f, bind_blk (typ_vfun T1 T) (capture C))] ++ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(v, bind_val T2)] ++ E) @ C ; Q &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|-stm (open_bs (open_es h v) f) ~: T)) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-stm (stm_try C T2 T1 b h) ~: T Differences to the paper . As mentioned above, handling statements are annotated with a capture set C. Also, we use the special type constructor typ_exc instead of a function type. Otherwise, the definition is a straightforward translation to Coq in locally nameless. The following rule for typing_reset is a variation of typing_try, not binding the capability anymore and with a singleton set {l} instead of C. &nbsp;&nbsp;| typing_reset : ∀ L E R Q C l b h T T1 T2, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R |= C → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_cap E C → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_cap E R → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;We&nbsp;require&nbsp;that&nbsp;the&nbsp;signature&nbsp;of&nbsp;l&nbsp;matches&nbsp;the&nbsp;type&nbsp;at&nbsp;the&nbsp;reset.&nbsp;*) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Signatures.binds l (bind_sig T2 T1) Q → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ (cset_union C (cset_lvar l)) ; Q |-stm b ~: T → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(∀ v : atom, v `notin` L → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(∀ f : atom, f `notin` (L `union` singleton v) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;([(f, bind_blk (typ_vfun T1 T) (capture C))] ++ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(v, bind_val T2)] ++ E) @ C ; Q &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|-stm (open_bs (open_es h v) f) ~: T)) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-stm (stm_reset l C b h) ~: T &nbsp;&nbsp;| typing_throw : ∀ E R Q b e T T1, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-blk b ~: (typ_exc T1 T) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E ; Q |-exp e ~: T1 → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E @ R ; Q |-stm (stm_throw b e) ~: T where &quot;E @ R ; Q |-stm s ~: T\" := (styping E R Q s T). Since we use locally nameless, the definition of typing uses the binds relation from the Environment library (in the typing_var case) and cofinite quantification in the cases involving binders (e.g., typing_vabs, typing_tabs, ...). We have to define our own induction scheme to convince the termination checker Scheme etyping_mutind := Induction for etyping Sort Prop &nbsp;&nbsp;with styping_mutind := Induction for styping Sort Prop &nbsp;&nbsp;with btyping_mutind := Induction for btyping Sort Prop. ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Definitions.html",
    "relUrl": "/proofs/Top.SystemC.Definitions.html"
  },"21": {
    "doc": "Definitions",
    "title": " Operational Semantics",
    "content": "As described in the appendix of the paper, we mechanize the operational semantics in form of an abstract machine. However, the operational semantics is of a hybrid form: We only use the abstract machine semantics for statements and only if they affect the evaluation context / stack. For all other \"trivial\" reductions, we use a substitution based semantics with congruence rules. This separation makes it easier in the soundness proof to separate the \"interesting\" cases from the trivial ones. ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Definitions.html",
    "relUrl": "/proofs/Top.SystemC.Definitions.html"
  },"22": {
    "doc": "Definitions",
    "title": " Values",
    "content": "Values are defined in the paper in the appendix. Inductive evalue : exp → Prop := &nbsp;&nbsp;| value_const : &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evalue exp_const &nbsp;&nbsp;| value_box : ∀ C b, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bvalue b → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;capt C → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evalue (exp_box C b) with bvalue : blk → Prop := &nbsp;&nbsp;| value_vfun : ∀ T s, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;block (blk_vabs T s) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bvalue (blk_vabs T s) &nbsp;&nbsp;| value_bfun : ∀ S1 s, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;block (blk_babs S1 s) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bvalue (blk_babs S1 s) &nbsp;&nbsp;| value_tfun : ∀ s, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;block (blk_tabs s) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bvalue (blk_tabs s) &nbsp;&nbsp;| value_handler : ∀ l, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bvalue (blk_handler l). ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Definitions.html",
    "relUrl": "/proofs/Top.SystemC.Definitions.html"
  },"23": {
    "doc": "Definitions",
    "title": " Machine Redexes",
    "content": "Since we mechanize the operational semantics in terms of an abstract machine, we also define a predicate that describes when a statement can only be reduced in a larger context. Inductive machine_redex : stm → Prop := &nbsp;&nbsp;| redex_ret : ∀ e, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evalue e → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;machine_redex (stm_ret e) &nbsp;&nbsp;| redex_val : ∀ T b s, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;machine_redex (stm_val T b s) &nbsp;&nbsp;| redex_try : ∀ C T1 T b s, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;machine_redex (stm_try C T1 T b s) &nbsp;&nbsp;| redex_reset : ∀ l C b s, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;machine_redex (stm_reset l C b s) &nbsp;&nbsp;| redex_throw : ∀ l e, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evalue e → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;machine_redex (stm_throw (blk_handler l) e). ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Definitions.html",
    "relUrl": "/proofs/Top.SystemC.Definitions.html"
  },"24": {
    "doc": "Definitions",
    "title": " Trivial Reduction",
    "content": "Reserved Notation &quot;e1 --&gt;b e2\" (at level 69). Reserved Notation &quot;e1 --&gt;e e2\" (at level 69). Reserved Notation &quot;e1 --&gt;s e2\" (at level 69). Reduction of Blocks . Blocks can always be reduced regardless of the context. In fact, the only reduction is box-unbox elimination (bred_box) and block substitution (bred_box). Inductive bred : blk → blk → Prop := &nbsp;&nbsp;| bred_box : ∀ C b, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blk_unbox (exp_box C b) --&gt;b b &nbsp;&nbsp;| bred_tapp_cong : ∀ b b' T, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b --&gt;b b' → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blk_tapp b T --&gt;b blk_tapp b' T &nbsp;&nbsp;| bred_tapp : ∀ s T, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blk_tapp (blk_tabs s) T --&gt;b (open_tb s T) where &quot;b1 --&gt;b b2\" := (bred b1 b2). Reduction of Expressions . Reduction on expressions is even simpler. Only boxed blocks can be reduced at all. Inductive ered : exp → exp → Prop := &nbsp;&nbsp;| ered_box : ∀ C b b', &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b --&gt;b b' → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(exp_box C b) --&gt;e (exp_box C b') where &quot;e1 --&gt;e e2\" := (ered e1 e2). Reduction of Statements . Inductive sred : stm → stm → Prop := &nbsp;&nbsp;| sred_ret : ∀ e e', &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e --&gt;e e' → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stm_ret e --&gt;s stm_ret e' &nbsp;&nbsp;| sred_vapp_3 : ∀ T s e, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evalue e → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stm_vapp (blk_vabs T s) e --&gt;s (open_es s e) The remaining rules are congruences, omitted in the appendix of the paper. &nbsp;&nbsp;| sred_def_1 : ∀ C S1 b b' s, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b --&gt;b b' → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stm_def C S1 b s --&gt;s stm_def C S1 b' s &nbsp;&nbsp;| sred_def_2 : ∀ C S1 b s, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bvalue b → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stm_def C S1 b s --&gt;s (open_bs s b) &nbsp;&nbsp;| sred_vapp_1 : ∀ b b' e, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b --&gt;b b' → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stm_vapp b e --&gt;s stm_vapp b' e &nbsp;&nbsp;| sred_vapp_2 : ∀ b e e', &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e --&gt;e e' → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stm_vapp b e --&gt;s stm_vapp b e' &nbsp;&nbsp;| sred_bapp_1 : ∀ b1 b1' C b2, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b1 --&gt;b b1' → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stm_bapp b1 C b2 --&gt;s stm_bapp b1' C b2 &nbsp;&nbsp;| sred_bapp_2 : ∀ b1 C b2 b2', &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b2 --&gt;b b2' → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stm_bapp b1 C b2 --&gt;s stm_bapp b1 C b2' &nbsp;&nbsp;| sred_bapp_3 : ∀ S1 s C b2, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bvalue b2 → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stm_bapp (blk_babs S1 s) C b2 --&gt;s (open_cs s b2 C) &nbsp;&nbsp;| sred_throw_1 : ∀ b b' e, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b --&gt;b b' → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stm_throw b e --&gt;s stm_throw b' e &nbsp;&nbsp;| sred_throw_2 : ∀ b e e', &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bvalue b → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e --&gt;e e' → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stm_throw b e --&gt;s stm_throw b e' where &quot;b1 --&gt;s b2\" := (sred b1 b2) . ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Definitions.html",
    "relUrl": "/proofs/Top.SystemC.Definitions.html"
  },"25": {
    "doc": "Definitions",
    "title": " Stacks / Contexts",
    "content": "Inductive frame : Type := &nbsp;&nbsp;(*&nbsp;val&nbsp;_&nbsp;:&nbsp;T&nbsp;=&nbsp;;&nbsp;s&nbsp;&nbsp;*) &nbsp;&nbsp;| K : vtyp → stm → frame &nbsp;&nbsp;(*&nbsp;invariant:&nbsp;all&nbsp;elements&nbsp;in&nbsp;cap&nbsp;are&nbsp;bound&nbsp;in&nbsp;the&nbsp;tail&nbsp;of&nbsp;the&nbsp;ctx&nbsp;*) &nbsp;&nbsp;| H : label → cap → stm → frame . We use the following abbreviation to denote runtime stacks Notation ctx := (list frame). The toplevel / empty runtime stack. Notation top := (@nil frame). The following definition extracts labels, bound by the context. Fixpoint bound_labels (c : ctx) : labels := &nbsp;&nbsp;match c with &nbsp;&nbsp;| nil ⇒ {}L &nbsp;&nbsp;| K T s :: c ⇒ bound_labels c &nbsp;&nbsp;| H l C h :: c ⇒ LabelSet.F.union (bound_labels c) (LabelSet.F.singleton l) &nbsp;&nbsp;end. We need to be able to plug an expression into a context. Fixpoint plug (c : ctx) (e : exp) {struct c} : stm := &nbsp;&nbsp;match c with &nbsp;&nbsp;| nil ⇒ stm_ret e &nbsp;&nbsp;| K T s :: c ⇒ stm_val T (plug c e) s &nbsp;&nbsp;| H l C h :: c ⇒ stm_reset l C (plug c e) h &nbsp;&nbsp;end. Reserved Notation &quot;R ; Q |-cnt k ~: T1 ~&gt; T2\" (at level 70, Q at next level). Reserved Notation &quot;R ; Q |-ctx c ~: T\" (at level 70, Q at next level). Context typing . The following definition models the context typing from Appendix A.3 in the paper. It can be thought of as a variant of statement typing, flipped inside-out. typing_ctx C Q K T is parametrized by a set C of capabilities bound in the context, global signatures Q, the context K itself, and the type T at the hole. Inductive typing_ctx : cap → sig → ctx → vtyp → Prop := &nbsp;&nbsp;| typing_ctx_empty : ∀ Q T, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_sig Q → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;empty_cset ; Q |-ctx top ~: T &nbsp;&nbsp;| typing_ctx_frame : ∀ L R Q c T1 T2 s, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R ; Q |-ctx c ~: T2 → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(∀ X : atom, X `notin` L → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(X, bind_val T1)] @ R ; Q |-stm (open_es s X) ~: T2) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R ; Q |-ctx K T1 s :: c ~: T1 &nbsp;&nbsp;| typing_ctx_try : ∀ L R Q l C c T T1 T2 s, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R ; Q |-ctx c ~: T → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R |= C → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_cap empty C → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Signatures.binds l (bind_sig T1 T2) Q → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(∀ v : atom, v `notin` L → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(∀ f : atom, f `notin` (L `union` singleton v) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(f, bind_blk (typ_vfun T2 T) (capture C))] ++ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(v, bind_val T1)] @ C ; Q &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|-stm (open_bs (open_es s v) f) ~: T)) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cset_union C (cset_lvar l) ; Q |-ctx H l C s :: c ~: T where &quot;R ; Q |-ctx K ~: T\" := (typing_ctx R Q K T). Continuation typing . Continuations are reversed contexts, so the typing rules are very similar. The rendering R ; Q |-cnt K ~: T1 ~&gt; T2 shows that continuations K have a function-like type. The hole has type T1 and they are delimited at T2. Inductive typing_cnt : cap → sig → ctx → vtyp → vtyp → Prop := &nbsp;&nbsp;| typing_cnt_empty : ∀ R Q T, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_cap empty R → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_sig Q → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R ; Q |-cnt top ~: T ~&gt; T &nbsp;&nbsp;| typing_cnt_frame : ∀ L R Q c T1 T2 T3 s, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R ; Q |-cnt c ~: T1 ~&gt; T2 → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(∀ X : atom, X `notin` L → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(X, bind_val T2)] @ R ; Q |-stm (open_es s X) ~: T3) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R ; Q |-cnt K T2 s :: c ~: T1 ~&gt; T3 &nbsp;&nbsp;| typing_cnt_handler : ∀ L R Q c l C T T1 T2 T3 h, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wf_cap empty R → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cset_union C (cset_lvar l) ; Q |-cnt c ~: T1 ~&gt; T2 → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R |= C → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Signatures.binds l (bind_sig T3 T) Q → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(∀ v : atom, v `notin` L → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(∀ f : atom, f `notin` (L `union` singleton v) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(f, bind_blk (typ_vfun T T2) (capture C))] ++ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(v, bind_val T3)] @ C ; Q |-stm (open_bs (open_es h v) f) ~: T2)) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R ; Q |-cnt (H l C h :: c) ~: T1 ~&gt; T2 where &quot;R ; Q |-cnt K ~: T1 ~&gt; T2\" := (typing_cnt R Q K T1 T2). ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Definitions.html",
    "relUrl": "/proofs/Top.SystemC.Definitions.html"
  },"26": {
    "doc": "Definitions",
    "title": " Abstract Machine",
    "content": "The abstract machine can be in one of two states. | either we simply step within a context state_step, | or we unwind the stack to search for a delimiter state_wind. | . Inductive state : Type := &nbsp;&nbsp;| state_step (s : stm) (c : ctx) (Q : sig) : state &nbsp;&nbsp;| state_wind (l : label) (v : exp) (c : ctx) (k : ctx) (Q : sig) : state . Notation &quot;〈throw l # v | c • k | Q 〉\" := (state_wind l v c k Q). Notation &quot;〈 s | c | Q 〉\" := (state_step s c Q). Notation &quot;〈 e | Q 〉\" := (state_step (stm_ret e) top Q). Reserved Notation &quot;st1 --&gt; st2\" (at level 69). The following predicate corresponds to values, but for machine states. Inductive done : state → Prop := &nbsp;&nbsp;| done_ret : ∀ Q e, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evalue e → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;done 〈 e | Q 〉 . Reduction Steps . For better comparison, we label the rules with the names from the paper. Inductive step : state → state → Prop := (cong) &nbsp;&nbsp;| step_cong : ∀ Q s s' c, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s --&gt;s s' → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;〈 s | c | Q 〉 --&gt; 〈 s' | c | Q 〉 (pop) &nbsp;&nbsp;| step_pop_1 : ∀ Q v T s c, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evalue v → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;〈 stm_ret v | K T s :: c | Q 〉 --&gt; 〈 open_es s v | c | Q 〉 (ret) &nbsp;&nbsp;| step_pop_2 : ∀ Q v l C s c, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evalue v → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;〈 stm_ret v | H l C s :: c | Q 〉 --&gt; 〈 stm_ret v | c | Q 〉 (push) &nbsp;&nbsp;| step_push : ∀ Q s T b c, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stmt (stm_val T b s) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;〈 stm_val T b s | c | Q 〉 --&gt; 〈 b | K T s :: c | Q 〉 (try) &nbsp;&nbsp;| step_try : ∀ Q s h l C T2 T1 c, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;¬ LabelSet.F.In l (bound_labels c) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;¬ LabelSet.F.In l (Signatures.dom Q) → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;〈 stm_try C T2 T1 s h | c | Q 〉--&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;〈 open_cs s (blk_handler l) (cset_lvar l) | H l C h :: c | [(l , bind_sig T2 T1)] ++ Q 〉 (reset) &nbsp;&nbsp;| step_reset : ∀ Q s h l C T1 T c, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Signatures.binds l (bind_sig T1 T) Q → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;〈 stm_reset l C s h | c | Q 〉--&gt; 〈 s | H l C h :: c | Q 〉 (try), switch to search mode &nbsp;&nbsp;| step_throw : ∀ Q l v c, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evalue v → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;〈 stm_throw (blk_handler l) v | c | Q 〉--&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;〈throw l # v | c • top | Q 〉 (unwind) &nbsp;&nbsp;| step_unwind_1 : ∀ Q l v T s c k, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;〈throw l # v | K T s :: c • k | Q 〉--&gt; 〈throw l # v | c • K T s :: k | Q 〉 (forward) &nbsp;&nbsp;| step_unwind_2 : ∀ Q l v l2 C h c k, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;l ≠ l2 → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;〈throw l # v | H l2 C h :: c • k | Q 〉--&gt; 〈throw l # v | c • H l2 C h :: k | Q 〉 (handle), switch back to step mode &nbsp;&nbsp;| step_handle : ∀ Q l v T T1 C h c k, &nbsp;&nbsp;&nbsp;&nbsp;(*&nbsp;the&nbsp;continuation:&nbsp;(y&nbsp;:&nbsp;T1)&nbsp;=&gt;&nbsp;reset&nbsp;l&nbsp;c&nbsp;h&nbsp;Ey&nbsp;&nbsp;*) &nbsp;&nbsp;&nbsp;&nbsp;Signatures.binds l (bind_sig T T1) Q → &nbsp;&nbsp;&nbsp;&nbsp;〈throw l # v | H l C h :: c • k | Q 〉--&gt; &nbsp;&nbsp;&nbsp;&nbsp;〈 open_bs (open_es h v) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(blk_vabs T1 (plug (H l C h :: k) (exp_bvar 0))) | c | Q 〉 where &quot;st1 --&gt; st2\" := (step st1 st2). Abstract Machine Typing . A machine state is simply by composing the previously defined typing judgements. For typ_state, a the statement has to have the same type T that is expected by the context. Inductive typing_state : state → Prop := &nbsp;&nbsp;| typ_step : ∀ R Q s c T, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R ; Q |-ctx c ~: T → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nil @ R ; Q |-stm s ~: T → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typing_state〈 s | c | Q 〉 For typ_wind the signature bound at label l has to be T3 → T1, the value has to have the expected type T3, and the types of the continuation and stack have to align at T2. &nbsp;&nbsp;| typ_wind : ∀ R Q l v c k T1 T2 T3, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cset_references_lvar l R → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Signatures.binds l (bind_sig T3 T1) Q → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R ; Q |-ctx c ~: T2 → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R ; Q |-cnt k ~: T1 ~&gt; T2 → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nil ; Q |-exp v ~: T3 → &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typing_state〈throw l # v | c • k | Q 〉 . ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Definitions.html",
    "relUrl": "/proofs/Top.SystemC.Definitions.html"
  },"27": {
    "doc": "Definitions",
    "title": "Definitions",
    "content": " ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Definitions.html",
    "relUrl": "/proofs/Top.SystemC.Definitions.html"
  },"28": {
    "doc": "Examples",
    "title": "Top.SystemC.Examples",
    "content": "The source of this file can be found on Github. This file contains some worked examples in Coq for System C. As System C is concerned with tracking effectful computation, represented by a block type, we define a base block type S0 that is used to represent some ambient, global effectful operation perhaps for performing I/O. In System C, we could define S0 using the following: interface S0 { def doSomething(): Int } . Parameter S0 : btyp. Parameter S0Wf : wf_btyp empty S0. Parameter S0Type : btype S0. Here is an example of a function which takes a block argument f of type S0 and boxes it. In System C, we could define this using the following: def id {f : S0} { box f } . Definition id_ex : blk := &nbsp;&nbsp;blk_babs S0 (stm_ret (exp_box (cset_bvar 0) (blk_bvar 0))). Naturally, it would have the type {f : S0} =&gt; S0 at {f}. Definition id_ex_typ : btyp := &nbsp;&nbsp;typ_bfun S0 (typ_capt S0 (cset_bvar 0)). Lemma id_ex_typing : empty @ {}C ; nil |-blk id_ex ~: id_ex_typ. Next, we model a simple try-catch expression which simply returns a value. This, written in our language, looks like: def example1() { try { 0 } with cap : S0 { def doSomething() { 0 } } } . As our formalism in Coq lacks integers (and other expression values), we model our expressions and expression values in Coq using a base expression type typ_base and a singular inhabitant of that type, namely exp_const. Definition try_return_immediate_typ := &nbsp;&nbsp;typ_base. Definition try_return_param_type := &nbsp;&nbsp;typ_base. Definition try_return_immediate := &nbsp;&nbsp;stm_try {}C try_return_param_type try_return_immediate_typ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stm_ret exp_const) (stm_ret exp_const). As expected, that try statement returns an Int (in our formalism, a typ_base). Lemma try_return_immediate_typing : empty @ {}C ; nil |-stm try_return_immediate ~: try_return_immediate_typ. And naturally, reduces to 0/exp_const as the effect is never invoked. As an aside, we assume the existance of three unique, fresh labels. Parameter l1 l2 l3 : label. Axiom l1l2 : l1 ≠ l2. Axiom l1l3 : l1 ≠ l3. Axiom l2l3 : l2 ≠ l3. Now, the try expression then reduces to returning a value directly out of a handler frame. Lemma try_return_immediate_s1 : &nbsp;&nbsp;〈 try_return_immediate | top | nil 〉--&gt; &nbsp;&nbsp;〈 (stm_ret exp_const) | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(H l1 {}C (stm_ret exp_const)) :: top | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(l1, bind_sig try_return_param_type try_return_immediate_typ) :: nil 〉...which, by our reduction rules, eliminates the handler frame from the top of the stack. Lemma try_return_immediate_s2 : ∀ Q, &nbsp;&nbsp;〈 (stm_ret exp_const) | (H l1 {}C (stm_ret exp_const)) :: top | Q 〉--&gt; &nbsp;&nbsp;〈 (stm_ret exp_const) | top | Q 〉. Similarly, next we model a try statement which actually throws something. In System C, this can be expressed using the following fragment: def example2() { try { cap.doSomething() } with cap : S0 { def doSomething() { 0 } } } . Definition try_return_throw_typ := &nbsp;&nbsp;typ_base. Definition try_return_throw_param_typ := &nbsp;&nbsp;typ_base. Definition try_return_throw := &nbsp;&nbsp;stm_try {}C try_return_throw_param_typ try_return_throw_typ (stm_throw (blk_bvar 0) exp_const) (stm_ret exp_const). Naturally, it still returns an Int/typ_base though. Lemma try_return_throw_typing : empty @ {}C ; nil |-stm try_return_throw ~: try_return_throw_typ. The reduction steps for this expression are a bit more complicated. First, a throw statement is reduced in the presence of a matching handler, which shifts evaluation to that handler and unwinds from there. Lemma try_return_throw_s1 : &nbsp;&nbsp;〈 try_return_throw | top | nil 〉--&gt; &nbsp;&nbsp;〈 (stm_throw (blk_handler l1) exp_const) | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(H l1 {}C (stm_ret exp_const)) :: top | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(l1, bind_sig try_return_throw_param_typ try_return_throw_typ)] 〉. Lemma try_return_throw_s2 : ∀ Q, &nbsp;&nbsp;〈 (stm_throw (blk_handler l1) exp_const) | (H l1 {}C (stm_ret exp_const)) :: top | Q 〉--&gt; &nbsp;&nbsp;〈throw l1 # exp_const | (H l1 {}C (stm_ret exp_const)) :: top • top | Q〉. Lemma try_return_throw_s3 : &nbsp;&nbsp;〈throw l1 # exp_const | (H l1 {}C (stm_ret exp_const)) :: top • top | &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(l1, bind_sig try_return_throw_param_typ try_return_throw_typ)]〉--&gt; &nbsp;&nbsp;〈 (stm_ret exp_const) | top | [(l1, bind_sig try_return_throw_param_typ try_return_throw_typ)] 〉 . This example is a little more complicated. Here, we throw while evaluating a value-binder under the handler block. def example3() { try { val x = cap.doSomething() 0 } with cap : S0 { def doSomething() { 0 } } } . Definition try_apply_throw_param_typ := typ_base. Definition try_apply_throw_typ := typ_base. Definition try_apply_throw := &nbsp;&nbsp;stm_try {}C try_apply_throw_param_typ try_apply_throw_typ &nbsp;&nbsp;&nbsp;&nbsp;(stm_val typ_base (stm_throw (blk_bvar 0) exp_const) (stm_ret (exp_bvar 0))) &nbsp;&nbsp;&nbsp;&nbsp;(stm_ret (exp_const)). Naturally, it returns an Int/typ_base again. Lemma try_apply_throw_typing : &nbsp;&nbsp;empty @ {}C ; nil |-stm try_apply_throw ~: try_apply_throw_typ. Lemma try_apply_throw_s1 : &nbsp;&nbsp;〈 try_apply_throw | top | nil 〉--&gt; &nbsp;&nbsp;〈 (stm_val typ_base (stm_throw (blk_handler l1) (exp_const)) (stm_ret (exp_bvar 0))) &nbsp;&nbsp;&nbsp;&nbsp;| (H l1 {}C (stm_ret exp_const)) :: top &nbsp;&nbsp;&nbsp;&nbsp;| [(l1, bind_sig try_apply_throw_param_typ try_apply_throw_typ)] &nbsp;&nbsp;&nbsp;〉. Lemma try_apply_throw_s2 : &nbsp;&nbsp;〈 (stm_val typ_base (stm_throw (blk_handler l1) exp_const) (stm_ret (exp_bvar 0))) &nbsp;&nbsp;&nbsp;&nbsp;| (H l1 {}C (stm_ret exp_const)) :: top &nbsp;&nbsp;&nbsp;&nbsp;| [(l1, bind_sig try_apply_throw_param_typ try_apply_throw_typ)] &nbsp;&nbsp;〉--&gt; &nbsp;&nbsp;〈 (stm_throw (blk_handler l1) exp_const) &nbsp;&nbsp;&nbsp;&nbsp;| (K typ_base (stm_ret (exp_bvar 0))) :: ((H l1 {}C (stm_ret exp_const)) :: top) &nbsp;&nbsp;&nbsp;&nbsp;| [(l1, bind_sig try_apply_throw_param_typ try_apply_throw_typ)] &nbsp;&nbsp;〉. Lemma try_apply_throw_s3 : &nbsp;&nbsp;〈 (stm_throw (blk_handler l1) exp_const) &nbsp;&nbsp;&nbsp;&nbsp;| (K typ_base (stm_ret (exp_bvar 0))) :: ((H l1 {}C (stm_ret exp_const)) :: top) &nbsp;&nbsp;&nbsp;&nbsp;| [(l1, bind_sig try_apply_throw_param_typ try_apply_throw_typ)] &nbsp;&nbsp;〉--&gt; &nbsp;&nbsp;〈throw l1 # exp_const &nbsp;&nbsp;&nbsp;&nbsp;| (K typ_base (stm_ret (exp_bvar 0))) :: ((H l1 {}C (stm_ret exp_const)) :: top) &nbsp;&nbsp;&nbsp;&nbsp;• top &nbsp;&nbsp;&nbsp;&nbsp;| [(l1, bind_sig try_apply_throw_param_typ try_apply_throw_typ)] &nbsp;&nbsp;〉. Lemma try_apply_throw_s4 : &nbsp;&nbsp;〈throw l1 # exp_const &nbsp;&nbsp;&nbsp;&nbsp;| (K typ_base (stm_ret (exp_bvar 0))) :: ((H l1 {}C (stm_ret exp_const)) :: top) &nbsp;&nbsp;&nbsp;&nbsp;• top &nbsp;&nbsp;&nbsp;&nbsp;| [(l1, bind_sig try_apply_throw_param_typ try_apply_throw_typ)] &nbsp;&nbsp;〉--&gt; &nbsp;&nbsp;〈throw l1 # exp_const &nbsp;&nbsp;&nbsp;&nbsp;| ((H l1 {}C (stm_ret exp_const)) :: top) &nbsp;&nbsp;&nbsp;&nbsp;• (K typ_base (stm_ret (exp_bvar 0))) :: top &nbsp;&nbsp;&nbsp;&nbsp;| [(l1, bind_sig try_apply_throw_param_typ try_apply_throw_typ)] &nbsp;&nbsp;〉. Lemma try_apply_throw_s5 : &nbsp;&nbsp;〈throw l1 # exp_const &nbsp;&nbsp;&nbsp;&nbsp;| ((H l1 {}C (stm_ret exp_const)) :: top) &nbsp;&nbsp;&nbsp;&nbsp;• (K typ_base (stm_ret (exp_bvar 0))) :: top &nbsp;&nbsp;&nbsp;&nbsp;| [(l1, bind_sig try_apply_throw_param_typ try_apply_throw_typ)] &nbsp;&nbsp;〉--&gt; &nbsp;&nbsp;〈 (stm_ret exp_const) &nbsp;&nbsp;&nbsp;&nbsp;| top &nbsp;&nbsp;&nbsp;&nbsp;| [(l1, bind_sig try_apply_throw_param_typ try_apply_throw_typ)] &nbsp;&nbsp;〉. (* Lemma&nbsp;cset_references_bvar_evidently&nbsp;:&nbsp;forall&nbsp;A&nbsp;(t&nbsp;s&nbsp;:&nbsp;A)&nbsp;i, &nbsp;&nbsp;(if&nbsp;cset_references_bvar_dec&nbsp;i&nbsp;(cset_bvar&nbsp;i)&nbsp;then&nbsp;t&nbsp;else&nbsp;s)&nbsp;=&nbsp;t. Proof. &nbsp;&nbsp;intros. &nbsp;&nbsp;cbv. &nbsp;&nbsp;destruct_if;&nbsp;reflexivity |. &nbsp;&nbsp;rewrite_set_facts_in&nbsp;Heqb. &nbsp;&nbsp;fnsetdec. Qed. Lemma&nbsp;cset_references_bvar_evidently_empty&nbsp;:&nbsp;forall&nbsp;A&nbsp;(t&nbsp;s&nbsp;:&nbsp;A)&nbsp;i, &nbsp;&nbsp;(if&nbsp;cset_references_bvar_dec&nbsp;i&nbsp;{}C&nbsp;then&nbsp;t&nbsp;else&nbsp;s)&nbsp;=&nbsp;s. Proof. &nbsp;&nbsp;intros. &nbsp;&nbsp;cbv. &nbsp;&nbsp;destruct_if;&nbsp;|reflexivity. &nbsp;&nbsp;rewrite_set_facts_in&nbsp;Heqb. &nbsp;&nbsp;fnsetdec. Qed. Lemma&nbsp;cset_references_bvar_evidently_not&nbsp;:&nbsp;forall&nbsp;A&nbsp;(t&nbsp;s&nbsp;:&nbsp;A)&nbsp;i&nbsp;j, &nbsp;&nbsp;i&nbsp;&lt;&gt;&nbsp;j&nbsp;-&gt; &nbsp;&nbsp;(if&nbsp;cset_references_bvar_dec&nbsp;i&nbsp;(cset_bvar&nbsp;j)&nbsp;then&nbsp;t&nbsp;else&nbsp;s)&nbsp;=&nbsp;s. Proof. &nbsp;&nbsp;intros. &nbsp;&nbsp;cbv. &nbsp;&nbsp;destruct_if;&nbsp;|reflexivity. &nbsp;&nbsp;rewrite_set_facts_in&nbsp;Heqb. &nbsp;&nbsp;fnsetdec. Qed. Lemma&nbsp;cset_references_bvar_evidently_fvar&nbsp;:&nbsp;forall&nbsp;A&nbsp;(t&nbsp;s&nbsp;:&nbsp;A)&nbsp;i&nbsp;x, &nbsp;&nbsp;(if&nbsp;cset_references_bvar_dec&nbsp;i&nbsp;(cset_fvar&nbsp;x)&nbsp;then&nbsp;t&nbsp;else&nbsp;s)&nbsp;=&nbsp;s. Proof. &nbsp;&nbsp;intros. &nbsp;&nbsp;cbv. &nbsp;&nbsp;destruct_if;&nbsp;|reflexivity. &nbsp;&nbsp;rewrite_set_facts_in&nbsp;Heqb. &nbsp;&nbsp;fnsetdec. Qed. Lemma&nbsp;cset_references_bvar_evidently_lvar&nbsp;:&nbsp;forall&nbsp;A&nbsp;(t&nbsp;s&nbsp;:&nbsp;A)&nbsp;i&nbsp;l, &nbsp;&nbsp;(if&nbsp;cset_references_bvar_dec&nbsp;i&nbsp;(cset_lvar&nbsp;l)&nbsp;then&nbsp;t&nbsp;else&nbsp;s)&nbsp;=&nbsp;s. Proof. &nbsp;&nbsp;intros. &nbsp;&nbsp;cbv. &nbsp;&nbsp;destruct_if;&nbsp;|reflexivity. &nbsp;&nbsp;rewrite_set_facts_in&nbsp;Heqb. &nbsp;&nbsp;fnsetdec. Qed. Lemma&nbsp;cset_remove_bvar_evidently&nbsp;:&nbsp;forall&nbsp;i,&nbsp;cset_remove_bvar&nbsp;i&nbsp;(cset_bvar&nbsp;i)&nbsp;=&nbsp;{}C. Proof.&nbsp;intro.&nbsp;cbv.&nbsp;f_equal.&nbsp;csetdec.&nbsp;Qed. Lemma&nbsp;cset_union_empty&nbsp;:&nbsp;forall&nbsp;C,&nbsp;cset_union&nbsp;C&nbsp;{}C&nbsp;=&nbsp;C. Proof.&nbsp;intro.&nbsp;cbv.&nbsp;destruct&nbsp;C.&nbsp;csetdec.&nbsp;Qed. Hint&nbsp;Rewrite&nbsp;cset_references_bvar_evidently&nbsp;:&nbsp;csets. Hint&nbsp;Rewrite&nbsp;cset_references_bvar_evidently_empty&nbsp;:&nbsp;csets. Hint&nbsp;Rewrite&nbsp;cset_references_bvar_evidently_fvar&nbsp;:&nbsp;csets. Hint&nbsp;Rewrite&nbsp;cset_references_bvar_evidently_lvar&nbsp;:&nbsp;csets. Hint&nbsp;Rewrite&nbsp;cset_references_bvar_evidently_not&nbsp;using&nbsp;congruence&nbsp;:&nbsp;csets. Hint&nbsp;Rewrite&nbsp;cset_remove_bvar_evidently&nbsp;:&nbsp;csets. Hint&nbsp;Rewrite&nbsp;cset_union_empty&nbsp;:&nbsp;csets. Ltac&nbsp;cleanup&nbsp;:= &nbsp;&nbsp;cbv&nbsp;open_cvt_rec open_cset open_cvt_rec open_cbt_rec;&nbsp;csetsimpl. Definition&nbsp;cap_return_tm&nbsp;:= &nbsp;&nbsp;(stm_try&nbsp;{}C&nbsp;typ_base&nbsp;typ_base &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stm_val&nbsp;(typ_capt&nbsp;(typ_vfun&nbsp;typ_base&nbsp;typ_base)&nbsp;(cset_bvar&nbsp;0)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stm_try&nbsp;(cset_bvar&nbsp;0)&nbsp;typ_base&nbsp;typ_base &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stm_def&nbsp;(cset_bvar&nbsp;1)&nbsp;(typ_vfun&nbsp;typ_base&nbsp;typ_base) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(blk_vabs&nbsp;typ_base&nbsp;(stm_throw&nbsp;(blk_bvar&nbsp;1)&nbsp;exp_const)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stm_ret&nbsp;(exp_box&nbsp;(cset_bvar&nbsp;2) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(blk_bvar&nbsp;0)))) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stm_ret&nbsp;(exp_box&nbsp;(cset_bvar&nbsp;1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(blk_vabs&nbsp;typ_base&nbsp;(stm_ret&nbsp;exp_const))))) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stm_vapp&nbsp;(blk_unbox&nbsp;(exp_bvar&nbsp;0))&nbsp;exp_const)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stm_ret&nbsp;exp_const)) . Ltac&nbsp;sig_binds_dec&nbsp;:= &nbsp;&nbsp;cbv&nbsp;Signatures.binds Signatures.get;&nbsp;simpl; &nbsp;&nbsp;&nbsp;&nbsp;repeat&nbsp;first&nbsp; reflexivity | destruct_if; try congruence. Lemma&nbsp;cap_return_typing1&nbsp;: &nbsp;&nbsp;(nil&nbsp;@&nbsp;(cset_lvar&nbsp;l1)&nbsp;;&nbsp;(l2,&nbsp;bind_sig&nbsp;typ_base&nbsp;typ_base)&nbsp;::&nbsp;(l1,&nbsp;bind_sig&nbsp;typ_base&nbsp;typ_base)&nbsp;::&nbsp;nil &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|-blk&nbsp;(blk_vabs&nbsp;typ_base&nbsp;(stm_throw&nbsp;(blk_handler&nbsp;l1)&nbsp;exp_const)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~:&nbsp;(typ_vfun&nbsp;typ_base&nbsp;typ_base)). Proof&nbsp;with&nbsp;crush. &nbsp;&nbsp;Require&nbsp;Import&nbsp;SystemC.Soundness. &nbsp;&nbsp;pick&nbsp;fresh&nbsp;x&nbsp;and&nbsp;apply&nbsp;typing_vabs. &nbsp;&nbsp;cbv&nbsp;open_es open_es_rec. &nbsp;&nbsp;pose&nbsp;proof&nbsp;(l1l2). &nbsp;&nbsp;econstructor;&nbsp;try&nbsp;instantiate&nbsp;(1&nbsp;:=&nbsp;typ_base);&nbsp;repeat&nbsp;(constructor;&nbsp;try&nbsp;fsetdec;&nbsp;try&nbsp;lsetdec)... &nbsp;&nbsp;sig_binds_dec. Qed. Lemma&nbsp;cap_return_typing2&nbsp;:&nbsp;forall&nbsp;x, &nbsp;&nbsp;(styping &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((x,&nbsp;bind_blk&nbsp;(typ_vfun&nbsp;typ_base&nbsp;typ_base)&nbsp;(capture&nbsp;(cset_lvar&nbsp;l1)))&nbsp;::&nbsp;nil) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cset_lvar&nbsp;l1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((l2,&nbsp;bind_sig&nbsp;typ_base&nbsp;typ_base)&nbsp;::&nbsp;(l1,&nbsp;bind_sig&nbsp;typ_base&nbsp;typ_base)&nbsp;::&nbsp;nil) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stm_ret&nbsp;(exp_box&nbsp;(cset_lvar&nbsp;l1)&nbsp;(blk_fvar&nbsp;x))) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(typ_capt&nbsp;(typ_vfun&nbsp;typ_base&nbsp;typ_base)&nbsp;(cset_lvar&nbsp;l1))). Proof&nbsp;with&nbsp;crush. &nbsp;&nbsp;intro&nbsp;x. &nbsp;&nbsp;assert&nbsp;(wf_sig&nbsp;nil)&nbsp;by&nbsp;constructor. &nbsp;&nbsp;assert &nbsp;&nbsp;&nbsp;&nbsp;(wf_cap&nbsp;(x, bind_blk (typ_vfun typ_base typ_base) (capture (cset_lvar l1)))&nbsp;(cset_lvar&nbsp;l1)).&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;constructor. &nbsp;&nbsp;&nbsp;&nbsp;intros&nbsp;?&nbsp;?. &nbsp;&nbsp;&nbsp;&nbsp;fsetdec. &nbsp;&nbsp;} &nbsp;&nbsp;rapply&nbsp;typing_ret... &nbsp;&nbsp;constructor... &nbsp;&nbsp;eapply&nbsp;typing_bvar_capture... &nbsp;&nbsp;-&nbsp;constructor... &nbsp;&nbsp;-&nbsp;constructor... &nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;constructor... &nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;(pose&nbsp;proof&nbsp;l1l2);&nbsp;lsetdec. Qed. Set&nbsp;Nested&nbsp;Proofs&nbsp;Allowed. Lemma&nbsp;wf_cap_union&nbsp;:&nbsp;forall&nbsp;E&nbsp;C&nbsp;D, &nbsp;&nbsp;wf_cap&nbsp;E&nbsp;C&nbsp;-&gt; &nbsp;&nbsp;wf_cap&nbsp;E&nbsp;D&nbsp;-&gt; &nbsp;&nbsp;wf_cap&nbsp;E&nbsp;(cset_union&nbsp;C&nbsp;D). Proof. &nbsp;&nbsp;intros&nbsp;*&nbsp;WfC&nbsp;WfD. &nbsp;&nbsp;destruct&nbsp;C;&nbsp;destruct&nbsp;D. &nbsp;&nbsp;cbv. &nbsp;&nbsp;inversion&nbsp;WfC;&nbsp;inversion&nbsp;WfD;&nbsp;subst. &nbsp;&nbsp;csetsimpl. &nbsp;&nbsp;constructor. &nbsp;&nbsp;intros&nbsp;?&nbsp;?. &nbsp;&nbsp;rewrite&nbsp;AtomSetFacts.union_iff&nbsp;in&nbsp;H. &nbsp;&nbsp;eauto*. Qed. Ltac&nbsp;cleanup&nbsp;::= &nbsp;&nbsp;cbv&nbsp; open_es open_es_rec open_bs open_bs_rec open_cvt open_cvt_rec open_cbt open_cbt_rec open_cs open_cs_rec open_cset;&nbsp;csetsimpl. Ltac&nbsp;solve_wf_cap_cset_fvar&nbsp;:= &nbsp;&nbsp;constructor; &nbsp;&nbsp;intros&nbsp;?&nbsp;?; &nbsp;&nbsp;match&nbsp;goal&nbsp;with &nbsp;&nbsp;|&nbsp;H&nbsp;:&nbsp;?x&nbsp;`in`&nbsp;singleton&nbsp;?y&nbsp;|-&nbsp;_&nbsp;=&gt; &nbsp;&nbsp;&nbsp;&nbsp;assert&nbsp;(x&nbsp;=&nbsp;y)&nbsp;by&nbsp;fsetdec;&nbsp;subst &nbsp;&nbsp;end; &nbsp;&nbsp;eexists;&nbsp;binds_dec. Lemma&nbsp;cap_return_typing0&nbsp;:&nbsp;exists&nbsp;T, &nbsp;&nbsp;(styping&nbsp;nil&nbsp;{}C&nbsp;nil &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cap_return_tm &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T). Proof&nbsp;with&nbsp;crush. &nbsp;&nbsp;eexists. &nbsp;&nbsp;unfold&nbsp;cap_return_tm. &nbsp;&nbsp;pose&nbsp;proof&nbsp;wf_cap_empty. &nbsp;&nbsp;Lemma&nbsp;wf_sig_nil&nbsp;:&nbsp;wf_sig&nbsp;nil.&nbsp;constructor.&nbsp;Qed. &nbsp;&nbsp;pose&nbsp;proof&nbsp;wf_sig_nil. &nbsp;&nbsp;pick&nbsp;fresh&nbsp;x&nbsp;and&nbsp;apply&nbsp;typing_try...&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;cleanup. &nbsp;&nbsp;&nbsp;&nbsp;pick&nbsp;fresh&nbsp;y&nbsp;and&nbsp;apply&nbsp;typing_val...&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pick&nbsp;fresh&nbsp;z&nbsp;and&nbsp;apply&nbsp;typing_try. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1:&nbsp;crush. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1:&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;solve_wf_cap_cset_fvar. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1:&nbsp;solve_wf_cap_cset_fvar. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1:&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cleanup. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pick&nbsp;fresh&nbsp;xx&nbsp;and&nbsp;apply&nbsp;typing_def. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1:&nbsp;crush. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1:&nbsp;solve_wf_cap_cset_fvar. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1:&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert&nbsp;(z&nbsp;&lt;&gt;&nbsp;x)&nbsp;by&nbsp;fsetdec. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pick&nbsp;fresh&nbsp;yx&nbsp;and&nbsp;apply&nbsp;typing_vabs; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert&nbsp;(yx&nbsp;&lt;&gt;&nbsp;z)&nbsp;by&nbsp;fsetdec; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert&nbsp;(yx&nbsp;&lt;&gt;&nbsp;x)&nbsp;by&nbsp;fsetdec. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cleanup. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eapply&nbsp;typing_throw;&nbsp;try&nbsp;instantiate&nbsp;(1&nbsp;:=&nbsp;typ_base)... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apply&nbsp;typing_bvar_tracked. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2:&nbsp;trivial. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2:&nbsp;solve_wf_cap_cset_fvar. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2:&nbsp;binds_dec. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2:&nbsp;crush. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1:&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repeat&nbsp;(constructor;&nbsp;simpl_env;&nbsp;try&nbsp;fsetdec). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cleanup. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert&nbsp;(z&nbsp;&lt;&gt;&nbsp;x)&nbsp;by&nbsp;fsetdec. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert&nbsp;(xx&nbsp;&lt;&gt;&nbsp;z)&nbsp;by&nbsp;fsetdec. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert&nbsp;(xx&nbsp;&lt;&gt;&nbsp;x)&nbsp;by&nbsp;fsetdec. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constructor. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1:&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constructor. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1:&nbsp;solve_wf_cap_cset_fvar. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eapply&nbsp;typing_bvar_capture. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5:&nbsp;binds_dec. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4:&nbsp;crush. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2:&nbsp;trivial. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2:&nbsp;solve_wf_cap_cset_fvar. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1:&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2:&nbsp;solve_wf_cap_cset_fvar. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1:&nbsp;apply&nbsp;wf_cap_union;&nbsp;solve_wf_cap_cset_fvar. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1:&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cleanup. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constructor. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2:&nbsp;solve_wf_cap_cset_fvar... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constructor. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1:&nbsp;solve_wf_cap_cset_fvar... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pick&nbsp;fresh&nbsp;zx&nbsp;and&nbsp;apply&nbsp;typing_vabs. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cleanup. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert&nbsp;(z&nbsp;&lt;&gt;&nbsp;x)&nbsp;by&nbsp;fsetdec. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert&nbsp;(zx&nbsp;&lt;&gt;&nbsp;z)&nbsp;by&nbsp;fsetdec. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert&nbsp;(zx&nbsp;&lt;&gt;&nbsp;x)&nbsp;by&nbsp;fsetdec. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constructor. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2:&nbsp;solve_wf_cap_cset_fvar... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constructor. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2:&nbsp;trivial. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3:&nbsp;solve_wf_cap_cset_fvar. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2:&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;solve_wf_cap_cset_fvar. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;cleanup. &nbsp;&nbsp;&nbsp;&nbsp;eapply&nbsp;typing_vapp... &nbsp;&nbsp;&nbsp;&nbsp;1:&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert&nbsp;(y&nbsp;&lt;&gt;&nbsp;x)&nbsp;by&nbsp;fsetdec. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1:&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apply&nbsp;typing_evar. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3:&nbsp;binds_dec. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2:&nbsp;trivial. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1:&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2:&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;solve_wf_cap_cset_fvar. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2:&nbsp;crush. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1:&nbsp;solve_wf_cap_cset_fvar. &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;1:&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert&nbsp;(y&nbsp;&lt;&gt;&nbsp;x)&nbsp;by&nbsp;fsetdec. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2:&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;solve_wf_cap_cset_fvar. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constructor... &nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;} &nbsp;&nbsp;constructor... &nbsp;&nbsp;constructor... &nbsp;&nbsp;constructor... &nbsp;&nbsp;constructor... Qed. (*&nbsp;def&nbsp;C&nbsp;x:&nbsp;S&nbsp;=&nbsp;b;&nbsp;s&nbsp;&nbsp;&nbsp;.=&nbsp;&nbsp;&nbsp;((x&nbsp;:&nbsp;C&nbsp;S)&nbsp;=&gt;&nbsp;s)(box&nbsp;C&nbsp;b)&nbsp;*) Definition&nbsp;sugar_def&nbsp;(C&nbsp;:&nbsp;cap)&nbsp;(S1&nbsp;:&nbsp;btyp)&nbsp;(b&nbsp;:&nbsp;blk)&nbsp;(s&nbsp;:&nbsp;stm)&nbsp;:&nbsp;stm&nbsp;:= &nbsp;&nbsp;(stm_vapp&nbsp;(blk_vabs&nbsp;(typ_capt&nbsp;S1&nbsp;C)&nbsp;s)&nbsp;(exp_box&nbsp;C&nbsp;b)). Definition&nbsp;sugar_var&nbsp;(x&nbsp;:&nbsp;atom)&nbsp;:&nbsp;blk&nbsp;:= &nbsp;&nbsp;&nbsp;&nbsp;(blk_unbox&nbsp;(exp_fvar&nbsp;x)). Lemma&nbsp;sugar_def_typing&nbsp;:&nbsp;forall&nbsp;L&nbsp;E&nbsp;R&nbsp;b&nbsp;s&nbsp;(C&nbsp;:&nbsp;cap)&nbsp;Q&nbsp;S1&nbsp;T2, &nbsp;&nbsp;R&nbsp;|=&nbsp;C&nbsp;-&gt; &nbsp;&nbsp;wf_cap&nbsp;E&nbsp;C&nbsp;-&gt; &nbsp;&nbsp;wf_cap&nbsp;E&nbsp;R&nbsp;-&gt; &nbsp;&nbsp;E&nbsp;@&nbsp;C&nbsp;;&nbsp;Q&nbsp;|-blk&nbsp;b&nbsp;~:&nbsp;S1&nbsp;-&gt; &nbsp;&nbsp;(forall&nbsp;x&nbsp;:&nbsp;atom,&nbsp;x&nbsp;`notin`&nbsp;L&nbsp;-&gt; &nbsp;&nbsp;&nbsp;&nbsp;((x, bind_val (typ_capt S1 C))&nbsp;++&nbsp;E)&nbsp;@&nbsp;R&nbsp;;&nbsp;Q&nbsp;|-stm&nbsp;(open_es&nbsp;s&nbsp;x)&nbsp;~:&nbsp;T2)&nbsp;-&gt; &nbsp;&nbsp;E&nbsp;@&nbsp;R&nbsp;;&nbsp;Q&nbsp;|-stm&nbsp;(sugar_def&nbsp;C&nbsp;S1&nbsp;b&nbsp;s)&nbsp;~:&nbsp;T2. Proof&nbsp;with&nbsp;crush. &nbsp;&nbsp;intros.&nbsp;unfold&nbsp;sugar_def. &nbsp;&nbsp;econstructor. &nbsp;&nbsp;econstructor... &nbsp;&nbsp;econstructor... Qed. Lemma&nbsp;sugar_var_typing&nbsp;:&nbsp;forall&nbsp;E&nbsp;R&nbsp;f&nbsp;S1&nbsp;C, &nbsp;&nbsp;wf_env&nbsp;E&nbsp;-&gt; &nbsp;&nbsp;wf_cap&nbsp;E&nbsp;R&nbsp;-&gt; &nbsp;&nbsp;R&nbsp;|=&nbsp;C&nbsp;-&gt; &nbsp;&nbsp;binds&nbsp;f&nbsp;(bind_val&nbsp;(typ_capt&nbsp;S1&nbsp;C))&nbsp;E&nbsp;-&gt; &nbsp;&nbsp;E&nbsp;@&nbsp;R&nbsp;;&nbsp;nil&nbsp;|-blk&nbsp;(sugar_var&nbsp;f)&nbsp;~:&nbsp;S1. Proof&nbsp;with&nbsp;crush. &nbsp;&nbsp;intros. &nbsp;&nbsp;assert&nbsp;(wf_sig&nbsp;nil)&nbsp;by&nbsp;constructor. &nbsp;&nbsp;econstructor... Qed. (**&nbsp;Finally def&nbsp;handleTick(prog&nbsp;:&nbsp;{()&nbsp;=&gt;&nbsp;Int}&nbsp;=&gt;&nbsp;Int)&nbsp;=&gt;&nbsp;Int&nbsp;= &nbsp;&nbsp;val&nbsp;stateFun&nbsp;=&nbsp;try&nbsp;{&nbsp;tick&nbsp;=&gt; &nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;res&nbsp;=&nbsp;prog&nbsp;(tick)&nbsp;in &nbsp;&nbsp;&nbsp;&nbsp;box&nbsp;{&nbsp;prog&nbsp;}&nbsp;(&nbsp;(s&nbsp;:&nbsp;Int)&nbsp;=&gt;&nbsp;res&nbsp;) &nbsp;&nbsp;}&nbsp;with&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;box&nbsp;{&nbsp;prog&nbsp;}&nbsp;(&nbsp;(s&nbsp;:&nbsp;Int)&nbsp;=&gt;&nbsp;(unbox&nbsp;resume(s))(s&nbsp;+&nbsp;1) &nbsp;&nbsp;}&nbsp;in &nbsp;&nbsp;(unbox&nbsp;stateFun)(0) *) Definition&nbsp;handle_tick_term&nbsp;:= &nbsp;&nbsp;blk_babs&nbsp;(typ_bfun&nbsp;(typ_exc&nbsp;typ_base&nbsp;typ_base)&nbsp;typ_base) &nbsp;&nbsp;&nbsp;&nbsp;(stm_val&nbsp;(*&nbsp;statefun&nbsp;*) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(typ_capt&nbsp;(typ_vfun&nbsp;typ_base&nbsp;typ_base)&nbsp;(cset_bvar&nbsp;0)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stm_try&nbsp;(cset_bvar&nbsp;0)&nbsp;typ_base&nbsp;typ_base &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(**&nbsp;body&nbsp;|&nbsp;tick&nbsp;*) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stm_val&nbsp;typ_base&nbsp;(stm_bapp&nbsp;(blk_bvar&nbsp;1)&nbsp;(cset_bvar&nbsp;0)&nbsp;(blk_bvar&nbsp;0)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stm_ret&nbsp;(exp_box&nbsp;(cset_bvar&nbsp;1)&nbsp;(blk_vabs&nbsp;typ_base&nbsp;(stm_ret&nbsp;(exp_bvar&nbsp;1)))))) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stm_val &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(typ_capt&nbsp;(typ_vfun&nbsp;typ_base&nbsp;typ_base)&nbsp;(cset_bvar&nbsp;1)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stm_vapp&nbsp;(blk_bvar&nbsp;0)&nbsp;(exp_bvar&nbsp;0)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stm_ret &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(exp_box&nbsp;(cset_bvar&nbsp;1) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(blk_vabs&nbsp;typ_base&nbsp;(stm_vapp&nbsp;(blk_unbox&nbsp;(exp_bvar&nbsp;1)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(exp_bvar&nbsp;0))))))) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(stm_vapp&nbsp;(blk_unbox&nbsp;(exp_bvar&nbsp;0))&nbsp;exp_const)). Lemma&nbsp;handle_tick_term_typing&nbsp;: &nbsp;&nbsp;exists&nbsp;T,&nbsp;empty&nbsp;@&nbsp;{}C&nbsp;;&nbsp;nil&nbsp;|-blk&nbsp;handle_tick_term&nbsp;~:&nbsp;T. Proof&nbsp;with&nbsp;notin_simpl;&nbsp;crush;&nbsp;try&nbsp;fsetdec;&nbsp;try&nbsp;fnsetdec;&nbsp;try&nbsp;lsetdec. &nbsp;&nbsp;eexists. &nbsp;&nbsp;econstructor. &nbsp;&nbsp;instantiate&nbsp;(2&nbsp;:=&nbsp;{}). &nbsp;&nbsp;intros&nbsp;prog&nbsp;progFresh. &nbsp;&nbsp;econstructor. &nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;crush. &nbsp;&nbsp;&nbsp;&nbsp;econstructor. &nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;autorewrite&nbsp;with&nbsp;csets. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cbv&nbsp;cset_fvar open_cset cset_bvar cset_references_bvar_dec cset_bvars cset_fvars cset_union cset_remove_bvar cset_lvars cset_subset_prop. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destruct_set_mem&nbsp;0&nbsp;(NatSet.F.singleton&nbsp;0);&nbsp;try&nbsp;nnotin_solve... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repeat&nbsp;split;&nbsp;try&nbsp;fnsetdec;&nbsp;try&nbsp;lsetdec... &nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;cbv&nbsp;cset_fvar open_cset cset_bvar cset_references_bvar_dec cset_bvars cset_fvars cset_union cset_remove_bvar cset_lvars cset_subset_prop... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destruct_set_mem&nbsp;0&nbsp;(NatSet.F.singleton&nbsp;0);&nbsp;try&nbsp;nnotin_solve... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace&nbsp;((NatSet.F.union&nbsp;{}N&nbsp;(NatSet.F.remove&nbsp;0&nbsp;(NatSet.F.singleton&nbsp;0)))) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with&nbsp;({}N)... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repeat&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace&nbsp;(x)&nbsp;with&nbsp;(prog). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unfold&nbsp;binds.&nbsp;simpl.&nbsp;destruct&nbsp;(prog&nbsp;==&nbsp;prog)... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;crush. &nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;cbv&nbsp;cset_fvar open_cset cset_bvar cset_references_bvar_dec cset_bvars cset_fvars cset_union cset_remove_bvar cset_lvars cset_subset_prop... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destruct_set_mem&nbsp;0&nbsp;(NatSet.F.singleton&nbsp;0);&nbsp;try&nbsp;nnotin_solve... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace&nbsp;((NatSet.F.union&nbsp;{}N&nbsp;(NatSet.F.remove&nbsp;0&nbsp;(NatSet.F.singleton&nbsp;0)))) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with&nbsp;({}N)... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;autorewrite&nbsp;with&nbsp;csets. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repeat&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;intros&nbsp;tick.&nbsp;instantiate&nbsp;(1&nbsp;:=&nbsp;singleton&nbsp;prog).&nbsp;intros&nbsp;tickFr. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;crush. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace&nbsp;(open_cset&nbsp;0&nbsp;(cset_fvar&nbsp;tick) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(open_cset&nbsp;1&nbsp;(cset_fvar&nbsp;prog)&nbsp;(cset_bvar&nbsp;0)))&nbsp;with&nbsp;(cset_fvar&nbsp;tick). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace&nbsp;(open_cvt_rec&nbsp;0&nbsp;(cset_fvar&nbsp;tick)&nbsp;typ_base)&nbsp;with &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(open_cvt&nbsp;typ_base&nbsp;(cset_fvar&nbsp;tick)). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eapply&nbsp;typing_bapp&nbsp;with&nbsp;(S1&nbsp;:=&nbsp;(typ_exc&nbsp;typ_base&nbsp;typ_base))... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;econstructor.&nbsp;intros&nbsp;t&nbsp;tisTick. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace&nbsp;t&nbsp;with&nbsp;tick. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exists&nbsp;(typ_exc&nbsp;typ_base&nbsp;typ_base). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds_dec. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fsetdec. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;cbv&nbsp;cset_union cset_fvar cset_fvars open_cset cset_lvars cset_remove_bvar cset_references_bvar_dec cset_bvars cset_bvar. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destruct_set_mem&nbsp;0&nbsp;(NatSet.F.singleton&nbsp;0);&nbsp;try&nbsp;nnotin_solve. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;autorewrite&nbsp;with&nbsp;csets. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace&nbsp;(NatSet.F.remove&nbsp;0&nbsp;(NatSet.F.singleton&nbsp;0))&nbsp;with&nbsp;({}N)... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intros&nbsp;progOrTick&nbsp;progOrTickCond. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite&nbsp;AtomSetFacts.union_iff&nbsp;in&nbsp;*. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destruct&nbsp;progOrTickCond... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;replace&nbsp;progOrTick&nbsp;with&nbsp;prog... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exists&nbsp;(typ_bfun&nbsp;(typ_exc&nbsp;typ_base&nbsp;typ_base)&nbsp;typ_base). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds_dec... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;replace&nbsp;progOrTick&nbsp;with&nbsp;tick... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exists&nbsp;(typ_exc&nbsp;typ_base&nbsp;typ_base)... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds_dec. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds_dec;&nbsp;notin_solve. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cbv&nbsp;cset_union cset_fvar open_cset cset_bvar cset_bvars cset_fvars cset_lvars cset_lvar cset_references_bvar_dec cset_remove_bvar. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destruct_set_mem&nbsp;0&nbsp;(NatSet.F.singleton&nbsp;0);&nbsp;try&nbsp;nnotin_solve... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;autorewrite&nbsp;with&nbsp;csets.&nbsp;unfold&nbsp;cset_subset_prop;&nbsp;repeat&nbsp;split... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;intros&nbsp;t&nbsp;tIsTick. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace&nbsp;t&nbsp;with&nbsp;tick... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eexists. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds_dec. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds_dec. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;crush. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;cbv&nbsp;cset_union cset_fvar open_cset cset_bvar cset_bvars cset_fvars cset_lvars cset_lvar cset_references_bvar_dec cset_remove_bvar . &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace&nbsp;(NatSet.F.mem&nbsp;1&nbsp;(NatSet.F.singleton&nbsp;0))&nbsp;with&nbsp;false... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destruct_set_mem&nbsp;0&nbsp;(NatSet.F.singleton&nbsp;0);&nbsp;try&nbsp;nnotin_solve. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f_equal... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;symmetry.&nbsp;rewrite&nbsp;&lt;-&nbsp;NatSetFacts.not_mem_iff... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cbv&nbsp;open_cvt_rec. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intros&nbsp;s.&nbsp;instantiate&nbsp;(1&nbsp;:=&nbsp;singleton&nbsp;tick&nbsp;`union`&nbsp;singleton&nbsp;prog). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intros&nbsp;sFr. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cbv&nbsp;open_es open_es_rec. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destruct&nbsp;(1&nbsp;===&nbsp;1)... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace&nbsp;(open_cset&nbsp;0&nbsp;(cset_fvar&nbsp;tick) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(open_cset&nbsp;1&nbsp;(cset_fvar&nbsp;prog)&nbsp;(cset_bvar&nbsp;1)))&nbsp;with&nbsp;(cset_fvar&nbsp;prog)... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace&nbsp;(open_cset&nbsp;0&nbsp;(cset_fvar&nbsp;prog)&nbsp;(cset_bvar&nbsp;0))&nbsp;with&nbsp;(cset_fvar&nbsp;prog)... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intros&nbsp;p&nbsp;pIsProg.&nbsp;replace&nbsp;p&nbsp;with&nbsp;prog... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exists&nbsp;(typ_bfun&nbsp;(typ_exc&nbsp;typ_base&nbsp;typ_base)&nbsp;typ_base).&nbsp;binds_dec... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instantiate&nbsp;(1&nbsp;:=&nbsp;singleton&nbsp;s&nbsp;`union`&nbsp;singleton&nbsp;tick&nbsp;`union`&nbsp;singleton&nbsp;prog). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intros&nbsp;unused&nbsp;unusedFr. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cbv&nbsp;open_es open_es_rec. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds_dec. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intros&nbsp;p&nbsp;pIsProg.&nbsp;replace&nbsp;p&nbsp;with&nbsp;prog... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exists&nbsp;(typ_bfun&nbsp;(typ_exc&nbsp;typ_base&nbsp;typ_base)&nbsp;typ_base). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds_dec... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cbv&nbsp;cset_fvar cset_bvar open_cset cset_fvars cset_bvars cset_lvars cset_references_bvar_dec cset_union cset_remove_bvar. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destruct_set_mem&nbsp;0&nbsp;(NatSet.F.singleton&nbsp;0)... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;autorewrite&nbsp;with&nbsp;csets. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f_equal... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cbv&nbsp;cset_fvar cset_bvar open_cset cset_fvars cset_bvars cset_lvars cset_references_bvar_dec cset_union cset_remove_bvar. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destruct_set_mem&nbsp;0&nbsp;(NatSet.F.singleton&nbsp;0)... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace&nbsp;(NatSet.F.mem&nbsp;1&nbsp;(NatSet.F.singleton&nbsp;1))&nbsp;with&nbsp;true... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace&nbsp;(NatSet.F.mem&nbsp;0 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NatSet.F.union&nbsp;{}N&nbsp;(NatSet.F.remove&nbsp;1&nbsp;(NatSet.F.singleton&nbsp;1))))&nbsp;with&nbsp;false... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f_equal... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;symmetry;&nbsp;rewrite&nbsp;&lt;-&nbsp;NatSetFacts.not_mem_iff... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;symmetry;&nbsp;rewrite&nbsp;&lt;-&nbsp;NatSetFacts.mem_iff... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cset_union&nbsp;(open_cset&nbsp;0&nbsp;(cset_fvar&nbsp;prog)&nbsp;(cset_bvar&nbsp;0))&nbsp;(cset_fvar&nbsp;tick)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with&nbsp;(cset_set&nbsp;(singleton&nbsp;tick&nbsp;`union`&nbsp;singleton&nbsp;prog)&nbsp;{}N&nbsp;{}L)... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intros&nbsp;progOrTick&nbsp;progOrTickCond. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rewrite&nbsp;AtomSetFacts.union_iff&nbsp;in&nbsp;*. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destruct&nbsp;progOrTickCond... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;replace&nbsp;progOrTick&nbsp;with&nbsp;tick... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exists&nbsp;(typ_exc&nbsp;typ_base&nbsp;typ_base). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds_dec...&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;replace&nbsp;progOrTick&nbsp;with&nbsp;prog... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exists&nbsp;(typ_bfun&nbsp;(typ_exc&nbsp;typ_base&nbsp;typ_base)&nbsp;typ_base)... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds_dec...&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cbv&nbsp;cset_union open_cset cset_fvar cset_fvars cset_references_bvar_dec cset_bvars cset_bvar cset_remove_bvar cset_lvars cset_lvar. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destruct_set_mem&nbsp;0&nbsp;(NatSet.F.singleton&nbsp;0)... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f_equal... &nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;intros&nbsp;unused&nbsp;unusedFr&nbsp;resume&nbsp;resumeFr. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cbv&nbsp;open_bs open_bs_rec open_es open_es_rec. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destruct&nbsp;(0&nbsp;===&nbsp;0)... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instantiate&nbsp;(1&nbsp;:=&nbsp;typ_base). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eapply&nbsp;typing_bvar_capture... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace&nbsp;(open_cset&nbsp;0&nbsp;(cset_fvar&nbsp;prog)&nbsp;(cset_bvar&nbsp;0))&nbsp;with&nbsp;(cset_fvar&nbsp;prog)... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intros&nbsp;p&nbsp;pIsProg;&nbsp;replace&nbsp;p&nbsp;with&nbsp;prog... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exists&nbsp;(typ_bfun&nbsp;(typ_exc&nbsp;typ_base&nbsp;typ_base)&nbsp;typ_base). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds_dec... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cbv&nbsp;cset_fvar cset_fvar cset_bvar cset_bvars open_cset cset_union cset_references_bvar_dec cset_lvar cset_lvars... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destruct_set_mem&nbsp;0&nbsp;(NatSet.F.singleton&nbsp;0)... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f_equal... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace&nbsp;(open_cset&nbsp;0&nbsp;(cset_fvar&nbsp;prog)&nbsp;(cset_bvar&nbsp;0))&nbsp;with&nbsp;(cset_fvar&nbsp;prog)... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intros&nbsp;p&nbsp;pIsProg;&nbsp;replace&nbsp;p&nbsp;with&nbsp;prog... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exists&nbsp;(typ_bfun&nbsp;(typ_exc&nbsp;typ_base&nbsp;typ_base)&nbsp;typ_base). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds_dec... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cbv&nbsp;cset_fvar cset_fvar cset_bvar cset_bvars open_cset cset_union cset_references_bvar_dec cset_lvar cset_lvars... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destruct_set_mem&nbsp;0&nbsp;(NatSet.F.singleton&nbsp;0)... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f_equal... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace&nbsp;(open_cset&nbsp;0&nbsp;(cset_fvar&nbsp;prog)&nbsp;(cset_bvar&nbsp;0))&nbsp;with&nbsp;(cset_fvar&nbsp;prog)... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intros&nbsp;p&nbsp;pIsProg;&nbsp;replace&nbsp;p&nbsp;with&nbsp;prog... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exists&nbsp;(typ_bfun&nbsp;(typ_exc&nbsp;typ_base&nbsp;typ_base)&nbsp;typ_base). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds_dec... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cbv&nbsp;cset_fvar cset_fvar cset_bvar cset_bvars open_cset cset_union cset_references_bvar_dec cset_lvar cset_lvars... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destruct_set_mem&nbsp;0&nbsp;(NatSet.F.singleton&nbsp;0)... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f_equal... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds_dec... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace&nbsp;(open_cset&nbsp;0&nbsp;(cset_fvar&nbsp;prog)&nbsp;(cset_bvar&nbsp;0))&nbsp;with&nbsp;(cset_fvar&nbsp;prog)... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace&nbsp;(open_cset&nbsp;1&nbsp;(cset_fvar&nbsp;prog)&nbsp;(cset_bvar&nbsp;1))&nbsp;with&nbsp;(cset_fvar&nbsp;prog)... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cbv&nbsp;cset_fvar cset_fvar cset_bvar cset_bvars open_cset cset_union cset_references_bvar_dec cset_lvar cset_lvars... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace&nbsp;(NatSet.F.mem&nbsp;1&nbsp;(NatSet.F.singleton&nbsp;1))&nbsp;with&nbsp;true... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f_equal... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;symmetry.&nbsp;rewrite&nbsp;&lt;-&nbsp;NatSetFacts.mem_iff.&nbsp;fnsetdec. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cbv&nbsp;cset_fvar cset_fvar cset_bvar cset_bvars open_cset cset_union cset_references_bvar_dec cset_lvar cset_lvars... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destruct_set_mem&nbsp;0&nbsp;(NatSet.F.singleton&nbsp;0)... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f_equal... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace&nbsp;(open_cset&nbsp;0&nbsp;(cset_fvar&nbsp;prog)&nbsp;(cset_bvar&nbsp;0))&nbsp;with&nbsp;(cset_fvar&nbsp;prog)... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intros&nbsp;p&nbsp;pIsProg;&nbsp;replace&nbsp;p&nbsp;with&nbsp;prog... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exists&nbsp;(typ_bfun&nbsp;(typ_exc&nbsp;typ_base&nbsp;typ_base)&nbsp;typ_base). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds_dec... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cbv&nbsp;cset_fvar cset_fvar cset_bvar cset_bvars open_cset cset_union cset_references_bvar_dec cset_lvar cset_lvars... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destruct_set_mem&nbsp;0&nbsp;(NatSet.F.singleton&nbsp;0)... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f_equal... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace&nbsp;(open_cset&nbsp;0&nbsp;(cset_fvar&nbsp;prog)&nbsp;(cset_bvar&nbsp;0))&nbsp;with&nbsp;(cset_fvar&nbsp;prog)... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intros&nbsp;p&nbsp;pIsProg;&nbsp;replace&nbsp;p&nbsp;with&nbsp;prog... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exists&nbsp;(typ_bfun&nbsp;(typ_exc&nbsp;typ_base&nbsp;typ_base)&nbsp;typ_base). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds_dec... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cbv&nbsp;cset_fvar cset_fvar cset_bvar cset_bvars open_cset cset_union cset_references_bvar_dec cset_lvar cset_lvars... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destruct_set_mem&nbsp;0&nbsp;(NatSet.F.singleton&nbsp;0)... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f_equal... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds_dec... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instantiate&nbsp;(1&nbsp;:=&nbsp;singleton&nbsp;resume&nbsp;`union`&nbsp;singleton&nbsp;prog&nbsp;`union`&nbsp;singleton&nbsp;unused). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intros&nbsp;s&nbsp;sFr. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cbv&nbsp;open_es open_es_rec. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destruct&nbsp;(1&nbsp;===&nbsp;0);&nbsp;try&nbsp;nnotin_solve... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace&nbsp;(open_cset&nbsp;0&nbsp;(cset_fvar&nbsp;prog)&nbsp;(cset_bvar&nbsp;0))&nbsp;with&nbsp;(cset_fvar&nbsp;prog)... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace&nbsp;(open_cset&nbsp;1&nbsp;(cset_fvar&nbsp;prog)&nbsp;(cset_bvar&nbsp;1))&nbsp;with&nbsp;(cset_fvar&nbsp;prog)... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intros&nbsp;p&nbsp;pIsProg;&nbsp;replace&nbsp;p&nbsp;with&nbsp;prog... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exists&nbsp;(typ_bfun&nbsp;(typ_exc&nbsp;typ_base&nbsp;typ_base)&nbsp;typ_base). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds_dec... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instantiate&nbsp;(1&nbsp;:=&nbsp;singleton&nbsp;s&nbsp;`union`&nbsp;singleton&nbsp;resume&nbsp;`union`&nbsp;singleton&nbsp;prog&nbsp;`union`&nbsp;singleton&nbsp;unused). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intros&nbsp;unboxResume&nbsp;unboxResumeFr. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instantiate&nbsp;(1&nbsp;:=&nbsp;typ_base). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instantiate&nbsp;(1&nbsp;:=&nbsp;(cset_fvar&nbsp;prog)). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intros&nbsp;p&nbsp;pIsProg;&nbsp;replace&nbsp;p&nbsp;with&nbsp;prog... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exists&nbsp;(typ_bfun&nbsp;(typ_exc&nbsp;typ_base&nbsp;typ_base)&nbsp;typ_base). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds_dec... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intros&nbsp;p&nbsp;pIsProg;&nbsp;replace&nbsp;p&nbsp;with&nbsp;prog... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exists&nbsp;(typ_bfun&nbsp;(typ_exc&nbsp;typ_base&nbsp;typ_base)&nbsp;typ_base). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds_dec... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intros&nbsp;p&nbsp;pIsProg;&nbsp;replace&nbsp;p&nbsp;with&nbsp;prog... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exists&nbsp;(typ_bfun&nbsp;(typ_exc&nbsp;typ_base&nbsp;typ_base)&nbsp;typ_base). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds_dec... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds_dec... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intros&nbsp;p&nbsp;pIsProg;&nbsp;replace&nbsp;p&nbsp;with&nbsp;prog... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exists&nbsp;(typ_bfun&nbsp;(typ_exc&nbsp;typ_base&nbsp;typ_base)&nbsp;typ_base). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds_dec... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unfold&nbsp;cset_subset_prop;&nbsp;repeat&nbsp;split... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;destruct&nbsp;(0&nbsp;===&nbsp;0)... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intros&nbsp;p&nbsp;pIsProg;&nbsp;replace&nbsp;p&nbsp;with&nbsp;prog... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exists&nbsp;(typ_bfun&nbsp;(typ_exc&nbsp;typ_base&nbsp;typ_base)&nbsp;typ_base). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds_dec... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intros&nbsp;p&nbsp;pIsProg;&nbsp;replace&nbsp;p&nbsp;with&nbsp;prog... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exists&nbsp;(typ_bfun&nbsp;(typ_exc&nbsp;typ_base&nbsp;typ_base)&nbsp;typ_base). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds_dec... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intros&nbsp;p&nbsp;pIsProg;&nbsp;replace&nbsp;p&nbsp;with&nbsp;prog... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exists&nbsp;(typ_bfun&nbsp;(typ_exc&nbsp;typ_base&nbsp;typ_base)&nbsp;typ_base). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds_dec... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds_dec... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cbv&nbsp;cset_fvar cset_fvar cset_bvar cset_bvars open_cset cset_union cset_references_bvar_dec cset_lvar cset_lvars... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace&nbsp;(NatSet.F.mem&nbsp;1&nbsp;(NatSet.F.singleton&nbsp;1))&nbsp;with&nbsp;true;&nbsp;f_equal... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;symmetry&nbsp;;rewrite&nbsp;&lt;-&nbsp;NatSetFacts.mem_iff... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cbv&nbsp;cset_fvar cset_fvar cset_bvar cset_bvars open_cset cset_union cset_references_bvar_dec cset_lvar cset_lvars... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace&nbsp;(NatSet.F.mem&nbsp;0&nbsp;(NatSet.F.singleton&nbsp;0))&nbsp;with&nbsp;true;&nbsp;f_equal... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;symmetry&nbsp;;rewrite&nbsp;&lt;-&nbsp;NatSetFacts.mem_iff... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace&nbsp;&nbsp;&nbsp;(open_cset&nbsp;0&nbsp;(cset_fvar&nbsp;prog)&nbsp;(cset_bvar&nbsp;0))&nbsp;with&nbsp;(cset_fvar&nbsp;prog). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;econstructor... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;intros&nbsp;p&nbsp;pIsProg;&nbsp;replace&nbsp;p&nbsp;with&nbsp;prog... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exists&nbsp;(typ_bfun&nbsp;(typ_exc&nbsp;typ_base&nbsp;typ_base)&nbsp;typ_base). &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;binds_dec... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cbv&nbsp;cset_fvar cset_fvar cset_bvar cset_bvars open_cset cset_union cset_references_bvar_dec cset_lvar cset_lvars... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace&nbsp;(NatSet.F.mem&nbsp;0&nbsp;(NatSet.F.singleton&nbsp;0))&nbsp;with&nbsp;true;&nbsp;f_equal... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;symmetry&nbsp;;rewrite&nbsp;&lt;-&nbsp;NatSetFacts.mem_iff... &nbsp;&nbsp;} &nbsp;&nbsp;instantiate&nbsp;(2&nbsp;:=&nbsp;singleton&nbsp;prog). &nbsp;&nbsp;intros&nbsp;stateFun&nbsp;stateFunFr. &nbsp;&nbsp;econstructor. &nbsp;&nbsp;destruct&nbsp;(0&nbsp;===&nbsp;0)... &nbsp;&nbsp;econstructor... &nbsp;&nbsp;instantiate&nbsp;(2&nbsp;:=&nbsp;typ_base). &nbsp;&nbsp;instantiate&nbsp;(1&nbsp;:=&nbsp;typ_base). &nbsp;&nbsp;econstructor... &nbsp;&nbsp;econstructor... &nbsp;&nbsp;econstructor... &nbsp;&nbsp;econstructor... &nbsp;&nbsp;replace&nbsp;&nbsp;&nbsp;(open_cset&nbsp;0&nbsp;(cset_fvar&nbsp;prog)&nbsp;(cset_bvar&nbsp;0))&nbsp;with&nbsp;(cset_fvar&nbsp;prog). &nbsp;&nbsp;econstructor... &nbsp;&nbsp;intros&nbsp;p&nbsp;pIsProg;&nbsp;replace&nbsp;p&nbsp;with&nbsp;prog... &nbsp;&nbsp;cbv&nbsp;cset_fvar cset_fvar cset_bvar cset_bvars open_cset cset_union cset_references_bvar_dec cset_lvar cset_lvars... &nbsp;&nbsp;replace&nbsp;(NatSet.F.mem&nbsp;0&nbsp;(NatSet.F.singleton&nbsp;0))&nbsp;with&nbsp;true;&nbsp;f_equal... &nbsp;&nbsp;symmetry&nbsp;;rewrite&nbsp;&lt;-&nbsp;NatSetFacts.mem_iff... &nbsp;&nbsp;econstructor... &nbsp;&nbsp;binds_dec. &nbsp;&nbsp;autorewrite&nbsp;with&nbsp;csets. &nbsp;&nbsp;replace&nbsp;&nbsp;&nbsp;(open_cset&nbsp;0&nbsp;(cset_fvar&nbsp;prog)&nbsp;(cset_bvar&nbsp;0))&nbsp;with&nbsp;(cset_fvar&nbsp;prog)... &nbsp;&nbsp;cbv&nbsp;cset_fvar cset_fvar cset_bvar cset_bvars open_cset cset_union cset_references_bvar_dec cset_lvar cset_lvars... &nbsp;&nbsp;replace&nbsp;(NatSet.F.mem&nbsp;0&nbsp;(NatSet.F.singleton&nbsp;0))&nbsp;with&nbsp;true;&nbsp;f_equal... &nbsp;&nbsp;symmetry&nbsp;;rewrite&nbsp;&lt;-&nbsp;NatSetFacts.mem_iff... &nbsp;&nbsp;autorewrite&nbsp;with&nbsp;csets. &nbsp;&nbsp;econstructor... &nbsp;&nbsp;intros&nbsp;p&nbsp;pIsProg;&nbsp;replace&nbsp;p&nbsp;with&nbsp;prog... &nbsp;&nbsp;exists&nbsp;&nbsp;(typ_bfun&nbsp;(typ_exc&nbsp;typ_base&nbsp;typ_base)&nbsp;typ_base)... &nbsp;&nbsp;binds_dec... &nbsp;&nbsp;econstructor... &nbsp;&nbsp;econstructor... &nbsp;&nbsp;econstructor... &nbsp;&nbsp;econstructor... &nbsp;&nbsp;replace&nbsp;&nbsp;&nbsp;(open_cset&nbsp;0&nbsp;(cset_fvar&nbsp;prog)&nbsp;(cset_bvar&nbsp;0))&nbsp;with&nbsp;(cset_fvar&nbsp;prog)... &nbsp;&nbsp;econstructor... &nbsp;&nbsp;intros&nbsp;p&nbsp;pIsProg;&nbsp;replace&nbsp;p&nbsp;with&nbsp;prog... &nbsp;&nbsp;cbv&nbsp;cset_fvar cset_fvar cset_bvar cset_bvars open_cset cset_union cset_references_bvar_dec cset_lvar cset_lvars... &nbsp;&nbsp;replace&nbsp;(NatSet.F.mem&nbsp;0&nbsp;(NatSet.F.singleton&nbsp;0))&nbsp;with&nbsp;true;&nbsp;f_equal... &nbsp;&nbsp;symmetry&nbsp;;rewrite&nbsp;&lt;-&nbsp;NatSetFacts.mem_iff... &nbsp;&nbsp;econstructor... &nbsp;&nbsp;Unshelve. &nbsp;&nbsp;all:&nbsp;repeat&nbsp;exact&nbsp;{}. Qed. *) ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Examples.html",
    "relUrl": "/proofs/Top.SystemC.Examples.html"
  },"29": {
    "doc": "Examples",
    "title": "Examples",
    "content": " ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Examples.html",
    "relUrl": "/proofs/Top.SystemC.Examples.html"
  },"30": {
    "doc": "Infrastructure",
    "title": "Top.SystemC.Infrastructure",
    "content": "The source of this file can be found on Github. This file is a (more-or-less) straight forward adaptation of the infrastructure code that is necessary to work with locally nameless. All lemmas and proofs are just concerned with binding and are not especially interesting. ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Infrastructure.html",
    "relUrl": "/proofs/Top.SystemC.Infrastructure.html"
  },"31": {
    "doc": "Infrastructure",
    "title": "Free Variables",
    "content": "Free Expression Variables . Fixpoint fv_ee (e : exp) {struct e} : atoms := &nbsp;&nbsp;match e with &nbsp;&nbsp;| exp_bvar i ⇒ {} &nbsp;&nbsp;| exp_fvar x ⇒ singleton x &nbsp;&nbsp;| exp_const ⇒ {} &nbsp;&nbsp;| exp_box C b ⇒ fv_eb b &nbsp;&nbsp;end with fv_es (s : stm) {struct s} : atoms := &nbsp;&nbsp;match s with &nbsp;&nbsp;| stm_ret e ⇒ fv_ee e &nbsp;&nbsp;| stm_val T s1 s2 ⇒ (fv_es s1) `union` (fv_es s2) &nbsp;&nbsp;| stm_def C S1 b s ⇒ (fv_eb b) `union` (fv_es s) &nbsp;&nbsp;| stm_vapp b e ⇒ (fv_eb b) `union` (fv_ee e) &nbsp;&nbsp;| stm_bapp b C g ⇒ (fv_eb b) `union` (fv_eb g) &nbsp;&nbsp;| stm_try C T1 T b g ⇒ (fv_es b) `union` (fv_es g) &nbsp;&nbsp;| stm_reset l C b g ⇒ (fv_es b) `union` (fv_es g) &nbsp;&nbsp;| stm_throw b e ⇒ fv_eb b `union` fv_ee e &nbsp;&nbsp;end with fv_eb (b : blk) {struct b} : atoms := &nbsp;&nbsp;match b with &nbsp;&nbsp;| blk_bvar i ⇒ {} &nbsp;&nbsp;| blk_fvar x ⇒ {} &nbsp;&nbsp;| blk_vabs T s ⇒ fv_es s &nbsp;&nbsp;| blk_babs S1 s ⇒ fv_es s &nbsp;&nbsp;| blk_tabs s ⇒ fv_eb s &nbsp;&nbsp;| blk_tapp s T ⇒ fv_eb s &nbsp;&nbsp;| blk_unbox e ⇒ fv_ee e &nbsp;&nbsp;| blk_handler l ⇒ {} &nbsp;&nbsp;end. Free Block Term Variables . Fixpoint fv_be (e : exp) {struct e} : atoms := &nbsp;&nbsp;match e with &nbsp;&nbsp;| exp_bvar i ⇒ {} &nbsp;&nbsp;| exp_fvar x ⇒ {} &nbsp;&nbsp;| exp_const ⇒ {} &nbsp;&nbsp;| exp_box C1 b ⇒ fv_bb b &nbsp;&nbsp;end with fv_bs (s : stm) {struct s} : atoms := &nbsp;&nbsp;match s with &nbsp;&nbsp;| stm_ret e ⇒ fv_be e &nbsp;&nbsp;| stm_val T s1 s2 ⇒ (fv_bs s1) `union` (fv_bs s2) &nbsp;&nbsp;| stm_def C1 S1 b s ⇒ (fv_bb b) `union` (fv_bs s) &nbsp;&nbsp;| stm_vapp b e ⇒ (fv_bb b) `union` (fv_be e) &nbsp;&nbsp;| stm_bapp b C1 g ⇒ (fv_bb b) `union` (fv_bb g) &nbsp;&nbsp;| stm_try C T1 T b g ⇒ (fv_bs b) `union` (fv_bs g) &nbsp;&nbsp;| stm_reset l C b g ⇒ (fv_bs b) `union` (fv_bs g) &nbsp;&nbsp;| stm_throw b e ⇒ fv_bb b `union` fv_be e &nbsp;&nbsp;end with fv_bb (b : blk) {struct b} : atoms := &nbsp;&nbsp;match b with &nbsp;&nbsp;| blk_bvar i ⇒ {} &nbsp;&nbsp;| blk_fvar x ⇒ (singleton x) &nbsp;&nbsp;| blk_vabs T s ⇒ (fv_bs s) &nbsp;&nbsp;| blk_babs S1 s ⇒ (fv_bs s) &nbsp;&nbsp;| blk_tabs s ⇒ fv_bb s &nbsp;&nbsp;| blk_tapp s T ⇒ fv_bb s &nbsp;&nbsp;| blk_unbox e ⇒ (fv_be e) &nbsp;&nbsp;| blk_handler l ⇒ {} &nbsp;&nbsp;end. Free Block Type Variables . Fixpoint fv_cvt (T : vtyp) {struct T} : atoms := &nbsp;&nbsp;match T with &nbsp;&nbsp;| typ_base ⇒ {} &nbsp;&nbsp;| typ_capt S1 C1 ⇒ (fv_cbt S1) `union` (cset_fvars C1) &nbsp;&nbsp;| typ_fvar a ⇒ {} &nbsp;&nbsp;| typ_bvar n ⇒ {} &nbsp;&nbsp;end with fv_cbt (S1 : btyp) {struct S1} : atoms := &nbsp;&nbsp;match S1 with &nbsp;&nbsp;| typ_vfun T1 T2 ⇒ (fv_cvt T1) `union` (fv_cvt T2) &nbsp;&nbsp;| typ_bfun S1 T ⇒ (fv_cbt S1) `union` (fv_cvt T) &nbsp;&nbsp;| typ_exc T1 T ⇒ (fv_cvt T1) `union` (fv_cvt T) &nbsp;&nbsp;| typ_tfun T ⇒ (fv_cbt T) &nbsp;&nbsp;end. Fixpoint fv_ce (e : exp) {struct e} : atoms := &nbsp;&nbsp;match e with &nbsp;&nbsp;| exp_bvar i ⇒ {} &nbsp;&nbsp;| exp_fvar x ⇒ {} &nbsp;&nbsp;| exp_const ⇒ {} &nbsp;&nbsp;| exp_box C1 b ⇒ (cset_fvars C1) `union` (fv_cb b) &nbsp;&nbsp;end with fv_cs (s : stm) {struct s} : atoms := &nbsp;&nbsp;match s with &nbsp;&nbsp;| stm_ret e ⇒ (fv_ce e) &nbsp;&nbsp;| stm_val T s1 s2 ⇒ (fv_cvt T) `union` (fv_cs s1) `union` (fv_cs s2) &nbsp;&nbsp;| stm_def C1 S1 b s ⇒ (cset_fvars C1) `union` (fv_cbt S1) `union` (fv_cb b) `union` (fv_cs s) &nbsp;&nbsp;| stm_vapp b e ⇒ (fv_cb b) `union` (fv_ce e) &nbsp;&nbsp;| stm_bapp b C1 g ⇒ (fv_cb b) `union` (cset_fvars C1) `union` (fv_cb g) &nbsp;&nbsp;| stm_try C1 T1 T b g ⇒ (fv_cvt T1) `union` (fv_cvt T) `union` (cset_fvars C1) `union` (fv_cs b) `union` (fv_cs g) &nbsp;&nbsp;| stm_reset l C1 b g ⇒ (cset_fvars C1) `union` (fv_cs b) `union` (fv_cs g) &nbsp;&nbsp;| stm_throw b e ⇒ fv_cb b `union` fv_ce e &nbsp;&nbsp;end with fv_cb (b : blk) {struct b} : atoms := &nbsp;&nbsp;match b with &nbsp;&nbsp;| blk_bvar i ⇒ {} &nbsp;&nbsp;| blk_fvar x ⇒ singleton x &nbsp;&nbsp;| blk_vabs T s ⇒ (fv_cvt T) `union` (fv_cs s) &nbsp;&nbsp;| blk_babs S1 s ⇒ (fv_cbt S1) `union` (fv_cs s) &nbsp;&nbsp;| blk_tabs s ⇒ (fv_cb s) &nbsp;&nbsp;| blk_tapp s T ⇒ (fv_cb s) `union` (fv_cvt T) &nbsp;&nbsp;| blk_unbox e ⇒ (fv_ce e) &nbsp;&nbsp;| blk_handler l ⇒ {} &nbsp;&nbsp;end. Free Type Variables . Fixpoint fv_tvt (T : vtyp) {struct T} : atoms := match T with &nbsp;&nbsp;| typ_base ⇒ {} &nbsp;&nbsp;| typ_capt S1 C1 ⇒ (fv_tbt S1) &nbsp;&nbsp;| typ_fvar a ⇒ singleton a &nbsp;&nbsp;| typ_bvar n ⇒ {} &nbsp;&nbsp;end with fv_tbt (S1 : btyp) {struct S1} : atoms := &nbsp;&nbsp;match S1 with &nbsp;&nbsp;| typ_vfun T1 T2 ⇒ (fv_tvt T1) `union` (fv_tvt T2) &nbsp;&nbsp;| typ_bfun S1 T ⇒ (fv_tbt S1) `union` (fv_tvt T) &nbsp;&nbsp;| typ_exc T1 T ⇒ (fv_tvt T1) `union` (fv_tvt T) &nbsp;&nbsp;| typ_tfun T ⇒ (fv_tbt T) &nbsp;&nbsp;end. Fixpoint fv_te (e : exp) {struct e} : atoms := &nbsp;&nbsp;match e with &nbsp;&nbsp;| exp_bvar i ⇒ {} &nbsp;&nbsp;| exp_fvar x ⇒ {} &nbsp;&nbsp;| exp_const ⇒ {} &nbsp;&nbsp;| exp_box C b ⇒ fv_tb b &nbsp;&nbsp;end with fv_ts (s : stm) {struct s} : atoms := &nbsp;&nbsp;match s with &nbsp;&nbsp;| stm_ret e ⇒ fv_te e &nbsp;&nbsp;| stm_val T s1 s2 ⇒ (fv_tvt T) `union` (fv_ts s1) `union` (fv_ts s2) &nbsp;&nbsp;| stm_def C S1 b s ⇒ (fv_tbt S1) `union` (fv_tb b) `union` (fv_ts s) &nbsp;&nbsp;| stm_vapp b e ⇒ (fv_tb b) `union` (fv_te e) &nbsp;&nbsp;| stm_bapp b C g ⇒ (fv_tb b) `union` (fv_tb g) &nbsp;&nbsp;| stm_try C T1 T b g ⇒ (fv_tvt T1) `union` (fv_tvt T) `union` (fv_ts b) `union` (fv_ts g) &nbsp;&nbsp;| stm_reset l C b g ⇒ (fv_ts b) `union` (fv_ts g) &nbsp;&nbsp;| stm_throw b e ⇒ fv_tb b `union` fv_te e &nbsp;&nbsp;end with fv_tb (b : blk) {struct b} : atoms := &nbsp;&nbsp;match b with &nbsp;&nbsp;| blk_bvar i ⇒ {} &nbsp;&nbsp;| blk_fvar x ⇒ {} &nbsp;&nbsp;| blk_vabs T s ⇒ fv_tvt T `union` fv_ts s &nbsp;&nbsp;| blk_babs S1 s ⇒ fv_tbt S1 `union` fv_ts s &nbsp;&nbsp;| blk_tabs s ⇒ fv_tb s &nbsp;&nbsp;| blk_tapp s T ⇒ fv_tvt T `union` fv_tb s &nbsp;&nbsp;| blk_unbox e ⇒ fv_te e &nbsp;&nbsp;| blk_handler l ⇒ {} &nbsp;&nbsp;end. Definition fv_bbind (b : binding) : atoms := &nbsp;&nbsp;match b with &nbsp;&nbsp;| bind_val T ⇒ {} &nbsp;&nbsp;| bind_blk s tracked ⇒ (fv_cbt s) &nbsp;&nbsp;| bind_blk s (capture C2) ⇒ (fv_cbt s) `union` (cset_fvars C2) &nbsp;&nbsp;| bind_typ ⇒ {} &nbsp;&nbsp;end. The second step in defining \"pick fresh\" is to define the tactic itself. It is based on the (pick fresh ... for ...) tactic defined in the Atom library. Here, we use gather_atoms to construct the set L rather than leaving it to the user to provide. Thus, invoking (pick fresh x) introduces a new atom x into the current context that is fresh for \"everything\" in the context. Tactic Notation \"pick\" \"fresh\" ident(x) := &nbsp;&nbsp;let L := gather_atoms in (pick fresh x for L). The \"pick fresh and apply\" tactic . This tactic is implementation specific only because of its reliance on gather_atoms, which is itself implementation specific. The definition below may be copied between developments without any changes, assuming that the other other developments define an appropriate gather_atoms tactic. For documentation on the tactic on which the one below is based, see the Metatheory library. Tactic Notation &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"pick\" \"fresh\" ident(atom_name) \"and\" \"apply\" constr(lemma) := &nbsp;&nbsp;let L := gather_atoms in &nbsp;&nbsp;pick fresh atom_name excluding L and apply lemma. Lemma subst_ee_intro_rec : ∀ x e u k, &nbsp;&nbsp;x `notin` fv_ee e → &nbsp;&nbsp;open_ee_rec k u e = subst_ee x u (open_ee_rec k (exp_fvar x) e) with subst_es_intro_rec : ∀ x e u k, &nbsp;&nbsp;x `notin` fv_es e → &nbsp;&nbsp;open_es_rec k u e = subst_es x u (open_es_rec k (exp_fvar x) e) with subst_eb_intro_rec : ∀ x e u k, &nbsp;&nbsp;x `notin` fv_eb e → &nbsp;&nbsp;open_eb_rec k u e = subst_eb x u (open_eb_rec k (exp_fvar x) e). Lemma subst_ee_intro : ∀ x e u, &nbsp;&nbsp;x `notin` fv_ee e → &nbsp;&nbsp;open_ee e u = subst_ee x u (open_ee e x) with subst_es_intro : ∀ x e u, &nbsp;&nbsp;x `notin` fv_es e → &nbsp;&nbsp;open_es e u = subst_es x u (open_es e x) with subst_eb_intro : ∀ x e u, &nbsp;&nbsp;x `notin` fv_eb e → &nbsp;&nbsp;open_eb e u = subst_eb x u (open_eb e x). Lemma subst_be_intro_rec : ∀ x e u k, &nbsp;&nbsp;x `notin` fv_be e → &nbsp;&nbsp;open_be_rec k u e = subst_be x u (open_be_rec k (blk_fvar x) e) with subst_bs_intro_rec : ∀ x e u k, &nbsp;&nbsp;x `notin` fv_bs e → &nbsp;&nbsp;open_bs_rec k u e = subst_bs x u (open_bs_rec k (blk_fvar x) e) with subst_bb_intro_rec : ∀ x e u k, &nbsp;&nbsp;x `notin` fv_bb e → &nbsp;&nbsp;open_bb_rec k u e = subst_bb x u (open_bb_rec k (blk_fvar x) e). Lemma subst_be_intro : ∀ x e u, &nbsp;&nbsp;x `notin` fv_be e → &nbsp;&nbsp;open_be e u = subst_be x u (open_be e x) with subst_bs_intro : ∀ x e u, &nbsp;&nbsp;x `notin` fv_bs e → &nbsp;&nbsp;open_bs e u = subst_bs x u (open_bs e x) with subst_bb_intro : ∀ x e u, &nbsp;&nbsp;x `notin` fv_bb e → &nbsp;&nbsp;open_bb e u = subst_bb x u (open_bb e x). Lemma subst_cvt_intro_rec : ∀ X T2 U k, &nbsp;&nbsp;X `notin` fv_cvt T2 → &nbsp;&nbsp;open_cvt_rec k U T2 = subst_cvt X U (open_cvt_rec k (cset_fvar X) T2) with subst_cbt_intro_rec : ∀ X T2 U k, &nbsp;&nbsp;X `notin` fv_cbt T2 → &nbsp;&nbsp;open_cbt_rec k U T2 = subst_cbt X U (open_cbt_rec k (cset_fvar X) T2). Lemma subst_cvt_intro : ∀ X T2 U, &nbsp;&nbsp;X `notin` fv_cvt T2 → &nbsp;&nbsp;open_cvt T2 U = subst_cvt X U (open_cvt T2 (cset_fvar X)) with subst_cbt_intro : ∀ X T2 U, &nbsp;&nbsp;X `notin` fv_cbt T2 → &nbsp;&nbsp;open_cbt T2 U = subst_cbt X U (open_cbt T2 (cset_fvar X)). Lemma subst_ce_intro_rec : ∀ x e u C k, &nbsp;&nbsp;x `notin` fv_ce e → &nbsp;&nbsp;open_ce_rec k u C e = subst_ce x u C (open_ce_rec k x (cset_fvar x) e) with subst_cs_intro_rec : ∀ x e u C k, &nbsp;&nbsp;x `notin` fv_cs e → &nbsp;&nbsp;open_cs_rec k u C e = subst_cs x u C (open_cs_rec k x (cset_fvar x) e) with subst_cb_intro_rec : ∀ x e u C k, &nbsp;&nbsp;x `notin` fv_cb e → &nbsp;&nbsp;open_cb_rec k u C e = subst_cb x u C (open_cb_rec k x (cset_fvar x) e). Lemma subst_ce_intro : ∀ x e u C, &nbsp;&nbsp;x `notin` fv_ce e → &nbsp;&nbsp;open_ce e u C = subst_ce x u C (open_ce e x (cset_fvar x)) with subst_cs_intro : ∀ x e u C, &nbsp;&nbsp;x `notin` fv_cs e → &nbsp;&nbsp;open_cs e u C = subst_cs x u C (open_cs e x (cset_fvar x)) with subst_cb_intro : ∀ x e u C, &nbsp;&nbsp;x `notin` fv_cb e → &nbsp;&nbsp;open_cb e u C = subst_cb x u C (open_cb e x (cset_fvar x)). ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Infrastructure.html",
    "relUrl": "/proofs/Top.SystemC.Infrastructure.html"
  },"32": {
    "doc": "Infrastructure",
    "title": "Opening Closed Lemmas",
    "content": "The naming scheme of the aux lemmas is: open_EXPRe_rec j u e = open_CE_rec i P C (open_EXPR_rec j u e) . Lemma open_cvt_rec_capt_aux : ∀ T j V i U, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;capt V → &nbsp;&nbsp;(cset_fvars V) `disjoint` (cset_fvars U) → &nbsp;&nbsp;labels_disjoint (cset_lvars V) (cset_lvars U) → &nbsp;&nbsp;open_cvt_rec j V T = open_cvt_rec i U (open_cvt_rec j V T) → &nbsp;&nbsp;T = open_cvt_rec i U T with open_cbt_rec_capt_aux : ∀ T j V i U, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;capt V → &nbsp;&nbsp;(cset_fvars V) `disjoint` (cset_fvars U) → &nbsp;&nbsp;labels_disjoint (cset_lvars V) (cset_lvars U) → &nbsp;&nbsp;open_cbt_rec j V T = open_cbt_rec i U (open_cbt_rec j V T) → &nbsp;&nbsp;T = open_cbt_rec i U T. Lemma open_cvt_rec_type_aux : ∀ T j U i C, &nbsp;&nbsp;open_tvt_rec j U T = open_cvt_rec i C (open_tvt_rec j U T) → &nbsp;&nbsp;T = open_cvt_rec i C T with open_cbt_rec_type_aux : ∀ T j U i C, &nbsp;&nbsp;open_tbt_rec j U T = open_cbt_rec i C (open_tbt_rec j U T) → &nbsp;&nbsp;T = open_cbt_rec i C T. Lemma open_cvt_rec_vtype : ∀ T U k, &nbsp;&nbsp;vtype T → &nbsp;&nbsp;T = open_cvt_rec k U T with open_cbt_rec_btype : ∀ T U k, &nbsp;&nbsp;btype T → &nbsp;&nbsp;T = open_cbt_rec k U T. Lemma open_ee_rec_expr_aux : ∀ e j v u i, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;open_ee_rec j v e = open_ee_rec i u (open_ee_rec j v e) → &nbsp;&nbsp;e = open_ee_rec i u e with open_eb_rec_expr_aux : ∀ e j v u i, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;open_eb_rec j v e = open_eb_rec i u (open_eb_rec j v e) → &nbsp;&nbsp;e = open_eb_rec i u e with open_es_rec_expr_aux : ∀ e j v u i, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;open_es_rec j v e = open_es_rec i u (open_es_rec j v e) → &nbsp;&nbsp;e = open_es_rec i u e. Lemma open_ce_rec_capt_aux : ∀ e j v u i (C D : cap), &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;capt C → &nbsp;&nbsp;(cset_fvars C) `disjoint` (cset_fvars D) → &nbsp;&nbsp;labels_disjoint (cset_lvars C) (cset_lvars D) → &nbsp;&nbsp;open_ce_rec j v C e = open_ce_rec i u D (open_ce_rec j v C e) → &nbsp;&nbsp;e = open_ce_rec i u D e with open_cb_rec_capt_aux : ∀ e j v u i (C D : cap), &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;capt C → &nbsp;&nbsp;(cset_fvars C) `disjoint` (cset_fvars D) → &nbsp;&nbsp;labels_disjoint (cset_lvars C) (cset_lvars D) → &nbsp;&nbsp;open_cb_rec j v C e = open_cb_rec i u D (open_cb_rec j v C e) → &nbsp;&nbsp;e = open_cb_rec i u D e with open_cs_rec_capt_aux : ∀ e j v u i (C D : cap), &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;capt C → &nbsp;&nbsp;(cset_fvars C) `disjoint` (cset_fvars D) → &nbsp;&nbsp;labels_disjoint (cset_lvars C) (cset_lvars D) → &nbsp;&nbsp;open_cs_rec j v C e = open_cs_rec i u D (open_cs_rec j v C e) → &nbsp;&nbsp;e = open_cs_rec i u D e. Lemma open_ce_rec_expr_aux : ∀ e j u C i P , &nbsp;&nbsp;open_ee_rec j u e = open_ce_rec i P C (open_ee_rec j u e) → &nbsp;&nbsp;e = open_ce_rec i P C e with open_cb_rec_expr_aux : ∀ e j u C i P , &nbsp;&nbsp;open_eb_rec j u e = open_cb_rec i P C (open_eb_rec j u e) → &nbsp;&nbsp;e = open_cb_rec i P C e with open_cs_rec_expr_aux : ∀ e j u C i P , &nbsp;&nbsp;open_es_rec j u e = open_cs_rec i P C (open_es_rec j u e) → &nbsp;&nbsp;e = open_cs_rec i P C e. Lemma open_ce_rec_type_aux : ∀ e j u C i P , &nbsp;&nbsp;open_te_rec j u e = open_ce_rec i P C (open_te_rec j u e) → &nbsp;&nbsp;e = open_ce_rec i P C e with open_cb_rec_type_aux : ∀ e j u C i P , &nbsp;&nbsp;open_tb_rec j u e = open_cb_rec i P C (open_tb_rec j u e) → &nbsp;&nbsp;e = open_cb_rec i P C e with open_cs_rec_type_aux : ∀ e j u C i P , &nbsp;&nbsp;open_ts_rec j u e = open_cs_rec i P C (open_ts_rec j u e) → &nbsp;&nbsp;e = open_cs_rec i P C e. Lemma open_ee_rec_type_aux : ∀ e j U i f, &nbsp;&nbsp;open_te_rec j U e = open_ee_rec i f (open_te_rec j U e) → &nbsp;&nbsp;e = open_ee_rec i f e with open_eb_rec_type_aux : ∀ e j U i f, &nbsp;&nbsp;open_tb_rec j U e = open_eb_rec i f (open_tb_rec j U e) → &nbsp;&nbsp;e = open_eb_rec i f e with open_es_rec_type_aux : ∀ e j U i f, &nbsp;&nbsp;open_ts_rec j U e = open_es_rec i f (open_ts_rec j U e) → &nbsp;&nbsp;e = open_es_rec i f e. Lemma open_be_rec_type_aux : ∀ e j U i f, &nbsp;&nbsp;open_te_rec j U e = open_be_rec i f (open_te_rec j U e) → &nbsp;&nbsp;e = open_be_rec i f e with open_bb_rec_type_aux : ∀ e j U i f, &nbsp;&nbsp;open_tb_rec j U e = open_bb_rec i f (open_tb_rec j U e) → &nbsp;&nbsp;e = open_bb_rec i f e with open_bs_rec_type_aux : ∀ e j U i f, &nbsp;&nbsp;open_ts_rec j U e = open_bs_rec i f (open_ts_rec j U e) → &nbsp;&nbsp;e = open_bs_rec i f e. Lemma open_be_rec_expr_aux : ∀ e j u i P, &nbsp;&nbsp;open_ee_rec j u e = open_be_rec i P (open_ee_rec j u e) → &nbsp;&nbsp;e = open_be_rec i P e with open_bb_rec_expr_aux : ∀ e j u i P , &nbsp;&nbsp;open_eb_rec j u e = open_bb_rec i P (open_eb_rec j u e) → &nbsp;&nbsp;e = open_bb_rec i P e with open_bs_rec_expr_aux : ∀ e j u i P , &nbsp;&nbsp;open_es_rec j u e = open_bs_rec i P (open_es_rec j u e) → &nbsp;&nbsp;e = open_bs_rec i P e. Lemma open_ce_rec_block_aux : ∀ e j u C i P, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;open_be_rec j u e = open_ce_rec i P C (open_be_rec j u e) → &nbsp;&nbsp;e = open_ce_rec i P C e with open_cb_rec_block_aux : ∀ e j u C i P, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;open_bb_rec j u e = open_cb_rec i P C (open_bb_rec j u e) → &nbsp;&nbsp;e = open_cb_rec i P C e with open_cs_rec_block_aux : ∀ e j u C i P, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;open_bs_rec j u e = open_cs_rec i P C (open_bs_rec j u e) → &nbsp;&nbsp;e = open_cs_rec i P C e. Lemma open_be_rec_capt_aux : ∀ e j u C i P, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;open_ce_rec j u C e = open_be_rec i P (open_ce_rec j u C e) → &nbsp;&nbsp;e = open_be_rec i P e with open_bb_rec_capt_aux : ∀ e j u C i P, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;open_cb_rec j u C e = open_bb_rec i P (open_cb_rec j u C e) → &nbsp;&nbsp;e = open_bb_rec i P e with open_bs_rec_capt_aux : ∀ e j u C i P, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;open_cs_rec j u C e = open_bs_rec i P (open_cs_rec j u C e) → &nbsp;&nbsp;e = open_bs_rec i P e. Lemma open_be_rec_block_aux : ∀ e j u i P, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;open_be_rec j u e = open_be_rec i P (open_be_rec j u e) → &nbsp;&nbsp;e = open_be_rec i P e with open_bb_rec_block_aux : ∀ e j u i P, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;open_bb_rec j u e = open_bb_rec i P (open_bb_rec j u e) → &nbsp;&nbsp;e = open_bb_rec i P e with open_bs_rec_block_aux : ∀ e j u i P, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;open_bs_rec j u e = open_bs_rec i P (open_bs_rec j u e) → &nbsp;&nbsp;e = open_bs_rec i P e. Lemma open_ee_rec_capt_aux : ∀ e j D u i P , &nbsp;&nbsp;open_ce_rec j D u e = open_ee_rec i P (open_ce_rec j D u e) → &nbsp;&nbsp;e = open_ee_rec i P e with open_eb_rec_capt_aux : ∀ e j D u i P , &nbsp;&nbsp;open_cb_rec j D u e = open_eb_rec i P (open_cb_rec j D u e) → &nbsp;&nbsp;e = open_eb_rec i P e with open_es_rec_capt_aux : ∀ e j D u i P , &nbsp;&nbsp;open_cs_rec j D u e = open_es_rec i P (open_cs_rec j D u e) → &nbsp;&nbsp;e = open_es_rec i P e. Lemma open_ee_rec_block_aux : ∀ e j u i P , &nbsp;&nbsp;open_be_rec j u e = open_ee_rec i P (open_be_rec j u e) → &nbsp;&nbsp;e = open_ee_rec i P e with open_eb_rec_block_aux : ∀ e j u i P , &nbsp;&nbsp;open_bb_rec j u e = open_eb_rec i P (open_bb_rec j u e) → &nbsp;&nbsp;e = open_eb_rec i P e with open_es_rec_block_aux : ∀ e j u i P , &nbsp;&nbsp;open_bs_rec j u e = open_es_rec i P (open_bs_rec j u e) → &nbsp;&nbsp;e = open_es_rec i P e. Lemma open_ce_rec_expr : ∀ e U C k, &nbsp;&nbsp;expr e → &nbsp;&nbsp;e = open_ce_rec k U C e with open_cb_rec_block : ∀ e U C k, &nbsp;&nbsp;block e → &nbsp;&nbsp;e = open_cb_rec k U C e with open_cs_rec_stmt : ∀ e U C k, &nbsp;&nbsp;stmt e → &nbsp;&nbsp;e = open_cs_rec k U C e. Lemma open_ee_rec_expr : ∀ e U k, &nbsp;&nbsp;expr e → &nbsp;&nbsp;e = open_ee_rec k U e with open_eb_rec_block : ∀ e U k, &nbsp;&nbsp;block e → &nbsp;&nbsp;e = open_eb_rec k U e with open_es_rec_stmt : ∀ e U k, &nbsp;&nbsp;stmt e → &nbsp;&nbsp;e = open_es_rec k U e. Lemma open_be_rec_expr : ∀ e U k, &nbsp;&nbsp;expr e → &nbsp;&nbsp;e = open_be_rec k U e with open_bb_rec_block : ∀ e U k, &nbsp;&nbsp;block e → &nbsp;&nbsp;e = open_bb_rec k U e with open_bs_rec_stmt : ∀ e U k, &nbsp;&nbsp;stmt e → &nbsp;&nbsp;e = open_bs_rec k U e. ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Infrastructure.html",
    "relUrl": "/proofs/Top.SystemC.Infrastructure.html"
  },"33": {
    "doc": "Infrastructure",
    "title": "Substitution / Opening Lemmas",
    "content": "Lemma subst_ee_open_ee_rec : ∀ e1 e2 x u k, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_ee x u (open_ee_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_ee_rec k (subst_ee x u e2) (subst_ee x u e1) with subst_eb_open_eb_rec : ∀ e1 e2 x u k, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_eb x u (open_eb_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_eb_rec k (subst_ee x u e2) (subst_eb x u e1) with subst_es_open_es_rec : ∀ e1 e2 x u k, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_es x u (open_es_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_es_rec k (subst_ee x u e2) (subst_es x u e1). Lemma subst_ee_open_ee : ∀ e1 e2 x u, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_ee x u (open_ee e1 e2) = &nbsp;&nbsp;&nbsp;&nbsp;open_ee (subst_ee x u e1) (subst_ee x u e2) with subst_eb_open_eb : ∀ e1 e2 x u, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_eb x u (open_eb e1 e2) = &nbsp;&nbsp;&nbsp;&nbsp;open_eb (subst_eb x u e1) (subst_ee x u e2) with subst_es_open_es : ∀ e1 e2 x u, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_es x u (open_es e1 e2) = &nbsp;&nbsp;&nbsp;&nbsp;open_es (subst_es x u e1) (subst_ee x u e2). Lemma subst_ee_open_ee_var : ∀ (x y:atom) u e, &nbsp;&nbsp;y ≠ x → &nbsp;&nbsp;expr u → &nbsp;&nbsp;open_ee (subst_ee x u e) y = subst_ee x u (open_ee e y) with subst_eb_open_eb_var : ∀ (x y:atom) u e, &nbsp;&nbsp;y ≠ x → &nbsp;&nbsp;expr u → &nbsp;&nbsp;open_eb (subst_eb x u e) y = subst_eb x u (open_eb e y) with subst_es_open_es_var : ∀ (x y:atom) u e, &nbsp;&nbsp;y ≠ x → &nbsp;&nbsp;expr u → &nbsp;&nbsp;open_es (subst_es x u e) y = subst_es x u (open_es e y). Lemma subst_ee_open_ce_rec : ∀ e f C x u k, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_ee x u (open_ce_rec k f C e) = &nbsp;&nbsp;&nbsp;&nbsp;open_ce_rec k (subst_eb x u f) C (subst_ee x u e) with subst_eb_open_cb_rec : ∀ e f C x u k, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_eb x u (open_cb_rec k f C e) = &nbsp;&nbsp;&nbsp;&nbsp;open_cb_rec k (subst_eb x u f) C (subst_eb x u e) with subst_es_open_cs_rec : ∀ e f C x u k, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_es x u (open_cs_rec k f C e) = &nbsp;&nbsp;&nbsp;&nbsp;open_cs_rec k (subst_eb x u f) C (subst_es x u e). Lemma subst_ee_open_ce : ∀ e f C x u, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_ee x u (open_ce e f C) = open_ce (subst_ee x u e) (subst_eb x u f) C with subst_eb_open_cb : ∀ e f C x u, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_eb x u (open_cb e f C) = open_cb (subst_eb x u e) (subst_eb x u f) C with subst_es_open_cs : ∀ e f C x u, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_es x u (open_cs e f C) = open_cs (subst_es x u e) (subst_eb x u f) C. Lemma subst_ee_open_ce_var : ∀ e x (y : atom) u, &nbsp;&nbsp;expr u → &nbsp;&nbsp;open_ce (subst_ee x u e) y (cset_fvar y) = subst_ee x u (open_ce e y (cset_fvar y)) with subst_eb_open_cb_var : ∀ e x (y : atom) u, &nbsp;&nbsp;expr u → &nbsp;&nbsp;open_cb (subst_eb x u e) y (cset_fvar y) = subst_eb x u (open_cb e y (cset_fvar y)) with subst_es_open_cs_var : ∀ e x (y : atom) u, &nbsp;&nbsp;expr u → &nbsp;&nbsp;open_cs (subst_es x u e) y (cset_fvar y) = subst_es x u (open_cs e y (cset_fvar y)). Lemma subst_ee_open_be_rec : ∀ e f x u k, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_ee x u (open_be_rec k f e) = &nbsp;&nbsp;&nbsp;&nbsp;open_be_rec k (subst_eb x u f) (subst_ee x u e) with subst_eb_open_bb_rec : ∀ e f x u k, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_eb x u (open_bb_rec k f e) = &nbsp;&nbsp;&nbsp;&nbsp;open_bb_rec k (subst_eb x u f) (subst_eb x u e) with subst_es_open_bs_rec : ∀ e f x u k, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_es x u (open_bs_rec k f e) = &nbsp;&nbsp;&nbsp;&nbsp;open_bs_rec k (subst_eb x u f) (subst_es x u e). Lemma subst_ee_open_be : ∀ e f x u, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_ee x u (open_be e f) = open_be (subst_ee x u e) (subst_eb x u f) with subst_eb_open_bb : ∀ e f x u, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_eb x u (open_bb e f) = open_bb (subst_eb x u e) (subst_eb x u f) with subst_es_open_bs : ∀ e f x u, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_es x u (open_bs e f) = open_bs (subst_es x u e) (subst_eb x u f). Lemma subst_ee_open_be_var : ∀ e x (y : atom) u, &nbsp;&nbsp;expr u → &nbsp;&nbsp;open_be (subst_ee x u e) y = subst_ee x u (open_be e y) with subst_eb_open_bb_var : ∀ e x (y : atom) u, &nbsp;&nbsp;expr u → &nbsp;&nbsp;open_bb (subst_eb x u e) y = subst_eb x u (open_bb e y) with subst_es_open_bs_var : ∀ e x (y : atom) u, &nbsp;&nbsp;expr u → &nbsp;&nbsp;open_bs (subst_es x u e) y = subst_es x u (open_bs e y). Lemma subst_be_open_ee_rec : ∀ e1 e2 Z P k, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_be Z P (open_ee_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_ee_rec k (subst_be Z P e2) (subst_be Z P e1) with subst_bb_open_eb_rec : ∀ e1 e2 Z P k, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_bb Z P (open_eb_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_eb_rec k (subst_be Z P e2) (subst_bb Z P e1) with subst_bs_open_es_rec : ∀ e1 e2 Z P k, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_bs Z P (open_es_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_es_rec k (subst_be Z P e2) (subst_bs Z P e1). Lemma subst_be_open_ee : ∀ e1 e2 Z P, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_be Z P (open_ee e1 e2) = open_ee (subst_be Z P e1) (subst_be Z P e2) with subst_bb_open_eb : ∀ e1 e2 Z P, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_bb Z P (open_eb e1 e2) = open_eb (subst_bb Z P e1) (subst_be Z P e2) with subst_bs_open_es : ∀ e1 e2 Z P, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_bs Z P (open_es e1 e2) = open_es (subst_bs Z P e1) (subst_be Z P e2). Lemma subst_be_open_ee_var : ∀ Z (x:atom) P e, &nbsp;&nbsp;block P → &nbsp;&nbsp;open_ee (subst_be Z P e) x = subst_be Z P (open_ee e x) with subst_bb_open_eb_var : ∀ Z (x:atom) P e, &nbsp;&nbsp;block P → &nbsp;&nbsp;open_eb (subst_bb Z P e) x = subst_bb Z P (open_eb e x) with subst_bs_open_es_var : ∀ Z (x:atom) P e, &nbsp;&nbsp;block P → &nbsp;&nbsp;open_es (subst_bs Z P e) x = subst_bs Z P (open_es e x). Lemma subst_be_open_be_rec : ∀ e1 e2 Z P k, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_be Z P (open_be_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_be_rec k (subst_bb Z P e2) (subst_be Z P e1) with subst_bb_open_bb_rec : ∀ e1 e2 Z P k, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_bb Z P (open_bb_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_bb_rec k (subst_bb Z P e2) (subst_bb Z P e1) with subst_bs_open_bs_rec : ∀ e1 e2 Z P k, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_bs Z P (open_bs_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_bs_rec k (subst_bb Z P e2) (subst_bs Z P e1). Lemma subst_be_open_be : ∀ e1 e2 Z P, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_be Z P (open_be e1 e2) = open_be (subst_be Z P e1) (subst_bb Z P e2) with subst_bb_open_bb : ∀ e1 e2 Z P, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_bb Z P (open_bb e1 e2) = open_bb (subst_bb Z P e1) (subst_bb Z P e2) with subst_bs_open_bs : ∀ e1 e2 Z P, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_bs Z P (open_bs e1 e2) = open_bs (subst_bs Z P e1) (subst_bb Z P e2). Lemma subst_be_open_be_var : ∀ Z (x:atom) P e, &nbsp;&nbsp;Z ≠ x → &nbsp;&nbsp;block P → &nbsp;&nbsp;open_be (subst_be Z P e) x = subst_be Z P (open_be e x) with subst_bb_open_bb_var : ∀ Z (x:atom) P e, &nbsp;&nbsp;Z ≠ x → &nbsp;&nbsp;block P → &nbsp;&nbsp;open_bb (subst_bb Z P e) x = subst_bb Z P (open_bb e x) with subst_bs_open_bs_var : ∀ Z (x:atom) P e, &nbsp;&nbsp;Z ≠ x → &nbsp;&nbsp;block P → &nbsp;&nbsp;open_bs (subst_bs Z P e) x = subst_bs Z P (open_bs e x). Lemma subst_ce_open_ee_rec : ∀ e1 e2 Z P C k, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_ce Z P C (open_ee_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_ee_rec k (subst_ce Z P C e2) (subst_ce Z P C e1) with subst_cb_open_eb_rec : ∀ e1 e2 Z P C k, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_cb Z P C (open_eb_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_eb_rec k (subst_ce Z P C e2) (subst_cb Z P C e1) with subst_cs_open_es_rec : ∀ e1 e2 Z P C k, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_cs Z P C (open_es_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_es_rec k (subst_ce Z P C e2) (subst_cs Z P C e1). Lemma subst_ce_open_ee : ∀ e1 e2 Z P C, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_ce Z P C (open_ee e1 e2) = open_ee (subst_ce Z P C e1) (subst_ce Z P C e2) with subst_cb_open_eb : ∀ e1 e2 Z P C, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_cb Z P C (open_eb e1 e2) = open_eb (subst_cb Z P C e1) (subst_ce Z P C e2) with subst_cs_open_es : ∀ e1 e2 Z P C, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_cs Z P C (open_es e1 e2) = open_es (subst_cs Z P C e1) (subst_ce Z P C e2). Lemma subst_ce_open_ee_var : ∀ Z (x:atom) P C e, &nbsp;&nbsp;block P → &nbsp;&nbsp;open_ee (subst_ce Z P C e) x = subst_ce Z P C (open_ee e x) with subst_cb_open_eb_var : ∀ Z (x:atom) P C e, &nbsp;&nbsp;block P → &nbsp;&nbsp;open_eb (subst_cb Z P C e) x = subst_cb Z P C (open_eb e x) with subst_cs_open_es_var : ∀ Z (x:atom) P C e, &nbsp;&nbsp;block P → &nbsp;&nbsp;open_es (subst_cs Z P C e) x = subst_cs Z P C (open_es e x). Lemma subst_be_open_ce_rec : ∀ e1 e2 Z P C k, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_be Z P (open_ce_rec k e2 C e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_ce_rec k (subst_bb Z P e2) C (subst_be Z P e1) with subst_bb_open_cb_rec : ∀ e1 e2 Z P C k, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_bb Z P (open_cb_rec k e2 C e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_cb_rec k (subst_bb Z P e2) C (subst_bb Z P e1) with subst_bs_open_cs_rec : ∀ e1 e2 Z P C k, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_bs Z P (open_cs_rec k e2 C e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_cs_rec k (subst_bb Z P e2) C (subst_bs Z P e1). Lemma subst_be_open_ce : ∀ e1 e2 Z P C, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_be Z P (open_ce e1 e2 C) = open_ce (subst_be Z P e1) (subst_bb Z P e2) C with subst_bb_open_cb : ∀ e1 e2 Z P C, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_bb Z P (open_cb e1 e2 C) = open_cb (subst_bb Z P e1) (subst_bb Z P e2) C with subst_bs_open_cs : ∀ e1 e2 Z P C, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_bs Z P (open_cs e1 e2 C) = open_cs (subst_bs Z P e1) (subst_bb Z P e2) C. Lemma subst_be_open_ce_var : ∀ Z (x:atom) P e, &nbsp;&nbsp;block P → &nbsp;&nbsp;x ≠ Z → &nbsp;&nbsp;open_ce (subst_be Z P e) x (cset_fvar x) = subst_be Z P (open_ce e x (cset_fvar x)) with subst_bb_open_cb_var : ∀ Z (x:atom) P e, &nbsp;&nbsp;block P → &nbsp;&nbsp;x ≠ Z → &nbsp;&nbsp;open_cb (subst_bb Z P e) x (cset_fvar x) = subst_bb Z P (open_cb e x (cset_fvar x)) with subst_bs_open_cs_var : ∀ Z (x:atom) P e, &nbsp;&nbsp;block P → &nbsp;&nbsp;x ≠ Z → &nbsp;&nbsp;open_cs (subst_bs Z P e) x (cset_fvar x) = subst_bs Z P (open_cs e x (cset_fvar x)). Lemma subst_ce_open_be_rec : ∀ e1 e2 Z P C k, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_ce Z P C (open_be_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_be_rec k (subst_cb Z P C e2) (subst_ce Z P C e1) with subst_cb_open_bb_rec : ∀ e1 e2 Z P C k, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_cb Z P C (open_bb_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_bb_rec k (subst_cb Z P C e2) (subst_cb Z P C e1) with subst_cs_open_bs_rec : ∀ e1 e2 Z P C k, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_cs Z P C (open_bs_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_bs_rec k (subst_cb Z P C e2) (subst_cs Z P C e1). Lemma subst_ce_open_be : ∀ e1 e2 Z P C, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_ce Z P C (open_be e1 e2) = open_be (subst_ce Z P C e1) (subst_cb Z P C e2) with subst_cb_open_bb : ∀ e1 e2 Z P C, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_cb Z P C (open_bb e1 e2) = open_bb (subst_cb Z P C e1) (subst_cb Z P C e2) with subst_cs_open_bs : ∀ e1 e2 Z P C, &nbsp;&nbsp;block P → &nbsp;&nbsp;subst_cs Z P C (open_bs e1 e2) = open_bs (subst_cs Z P C e1) (subst_cb Z P C e2). Lemma subst_ce_open_be_var : ∀ Z (x:atom) P C e, &nbsp;&nbsp;block P → &nbsp;&nbsp;x ≠ Z → &nbsp;&nbsp;open_be (subst_ce Z P C e) x = subst_ce Z P C (open_be e x) with subst_cb_open_bb_var : ∀ Z (x:atom) P C e, &nbsp;&nbsp;block P → &nbsp;&nbsp;x ≠ Z → &nbsp;&nbsp;open_bb (subst_cb Z P C e) x = subst_cb Z P C (open_bb e x) with subst_cs_open_bs_var : ∀ Z (x:atom) P C e, &nbsp;&nbsp;block P → &nbsp;&nbsp;x ≠ Z → &nbsp;&nbsp;open_bs (subst_cs Z P C e) x = subst_cs Z P C (open_bs e x). Lemma subst_cvt_open_cvt_rec : ∀ T C1 C2 X k, &nbsp;&nbsp;capt C1 → &nbsp;&nbsp;subst_cvt X C1 (open_cvt_rec k C2 T) = &nbsp;&nbsp;&nbsp;&nbsp;open_cvt_rec k (subst_cset X C1 C2) (subst_cvt X C1 T) with subst_cbt_open_cbt_rec : ∀ T C1 C2 X k, &nbsp;&nbsp;capt C1 → &nbsp;&nbsp;subst_cbt X C1 (open_cbt_rec k C2 T) = &nbsp;&nbsp;&nbsp;&nbsp;open_cbt_rec k (subst_cset X C1 C2) (subst_cbt X C1 T). Lemma subst_cvt_open_cvt : ∀ T C1 C2 X, &nbsp;&nbsp;capt C1 → &nbsp;&nbsp;subst_cvt X C1 (open_cvt T C2) = &nbsp;&nbsp;&nbsp;&nbsp;open_cvt (subst_cvt X C1 T) (subst_cset X C1 C2) with subst_cbt_open_cbt : ∀ T C1 C2 X, &nbsp;&nbsp;capt C1 → &nbsp;&nbsp;subst_cbt X C1 (open_cbt T C2) = &nbsp;&nbsp;&nbsp;&nbsp;open_cbt (subst_cbt X C1 T) (subst_cset X C1 C2). Lemma subst_cvt_open_cvt_var : ∀ T C1 X (x:atom), &nbsp;&nbsp;x ≠ X → &nbsp;&nbsp;capt C1 → &nbsp;&nbsp;subst_cvt X C1 (open_cvt T (cset_fvar x)) = &nbsp;&nbsp;&nbsp;&nbsp;open_cvt (subst_cvt X C1 T) (cset_fvar x) with subst_cbt_open_cbt_var : ∀ T C1 X (x:atom), &nbsp;&nbsp;x ≠ X → &nbsp;&nbsp;capt C1 → &nbsp;&nbsp;subst_cbt X C1 (open_cbt T (cset_fvar x)) = &nbsp;&nbsp;&nbsp;&nbsp;open_cbt (subst_cbt X C1 T) (cset_fvar x). Lemma subst_ce_open_ce_rec : ∀ e1 e2 Z P C D k, &nbsp;&nbsp;block P → &nbsp;&nbsp;capt D → &nbsp;&nbsp;subst_ce Z P D (open_ce_rec k e2 C e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_ce_rec k (subst_cb Z P D e2) (subst_cset Z D C) (subst_ce Z P D e1) with subst_cb_open_cb_rec : ∀ e1 e2 Z P C D k, &nbsp;&nbsp;block P → &nbsp;&nbsp;capt D → &nbsp;&nbsp;subst_cb Z P D (open_cb_rec k e2 C e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_cb_rec k (subst_cb Z P D e2) (subst_cset Z D C) (subst_cb Z P D e1) with subst_cs_open_cs_rec : ∀ e1 e2 Z P C D k, &nbsp;&nbsp;block P → &nbsp;&nbsp;capt D → &nbsp;&nbsp;subst_cs Z P D (open_cs_rec k e2 C e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_cs_rec k (subst_cb Z P D e2) (subst_cset Z D C) (subst_cs Z P D e1). Lemma subst_ce_open_ce : ∀ e1 e2 Z P C D, &nbsp;&nbsp;block P → &nbsp;&nbsp;capt D → &nbsp;&nbsp;subst_ce Z P D (open_ce e1 e2 C) = open_ce (subst_ce Z P D e1) (subst_cb Z P D e2) (subst_cset Z D C) with subst_cb_open_cb : ∀ e1 e2 Z P C D, &nbsp;&nbsp;block P → &nbsp;&nbsp;capt D → &nbsp;&nbsp;subst_cb Z P D (open_cb e1 e2 C) = open_cb (subst_cb Z P D e1) (subst_cb Z P D e2) (subst_cset Z D C) with subst_cs_open_cs : ∀ e1 e2 Z P C D, &nbsp;&nbsp;block P → &nbsp;&nbsp;capt D → &nbsp;&nbsp;subst_cs Z P D (open_cs e1 e2 C) = open_cs (subst_cs Z P D e1) (subst_cb Z P D e2) (subst_cset Z D C). Lemma subst_ce_open_ce_var : ∀ Z (x:atom) P e D, &nbsp;&nbsp;block P → &nbsp;&nbsp;capt D → &nbsp;&nbsp;x ≠ Z → &nbsp;&nbsp;open_ce (subst_ce Z P D e) x (cset_fvar x) = subst_ce Z P D (open_ce e x (cset_fvar x)) with subst_cb_open_cb_var : ∀ Z (x:atom) P e D, &nbsp;&nbsp;block P → &nbsp;&nbsp;capt D → &nbsp;&nbsp;x ≠ Z → &nbsp;&nbsp;open_cb (subst_cb Z P D e) x (cset_fvar x) = subst_cb Z P D (open_cb e x (cset_fvar x)) with subst_cs_open_cs_var : ∀ Z (x:atom) P e D, &nbsp;&nbsp;block P → &nbsp;&nbsp;capt D → &nbsp;&nbsp;x ≠ Z → &nbsp;&nbsp;open_cs (subst_cs Z P D e) x (cset_fvar x) = subst_cs Z P D (open_cs e x (cset_fvar x)). Lemma subst_te_open_ee_rec : ∀ e1 e2 X U k, &nbsp;&nbsp;subst_te X U (open_ee_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_ee_rec k (subst_te X U e2) (subst_te X U e1) with subst_tb_open_eb_rec : ∀ e1 e2 X U k, &nbsp;&nbsp;subst_tb X U (open_eb_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_eb_rec k (subst_te X U e2) (subst_tb X U e1) with subst_ts_open_es_rec : ∀ e1 e2 X U k, &nbsp;&nbsp;subst_ts X U (open_es_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_es_rec k (subst_te X U e2) (subst_ts X U e1). Lemma subst_te_open_ee : ∀ e1 e2 X U, &nbsp;&nbsp;subst_te X U (open_ee e1 e2) = &nbsp;&nbsp;&nbsp;&nbsp;open_ee (subst_te X U e1) (subst_te X U e2) with subst_tb_open_eb : ∀ e1 e2 X U, &nbsp;&nbsp;subst_tb X U (open_eb e1 e2) = &nbsp;&nbsp;&nbsp;&nbsp;open_eb (subst_tb X U e1) (subst_te X U e2) with subst_ts_open_es : ∀ e1 e2 X U, &nbsp;&nbsp;subst_ts X U (open_es e1 e2) = &nbsp;&nbsp;&nbsp;&nbsp;open_es (subst_ts X U e1) (subst_te X U e2). Lemma subst_te_open_be_rec : ∀ e1 e2 X U k, &nbsp;&nbsp;subst_te X U (open_be_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_be_rec k (subst_tb X U e2) (subst_te X U e1) with subst_tb_open_bb_rec : ∀ e1 e2 X U k, &nbsp;&nbsp;subst_tb X U (open_bb_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_bb_rec k (subst_tb X U e2) (subst_tb X U e1) with subst_ts_open_bs_rec : ∀ e1 e2 X U k, &nbsp;&nbsp;subst_ts X U (open_bs_rec k e2 e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_bs_rec k (subst_tb X U e2) (subst_ts X U e1). Lemma subst_te_open_be : ∀ e1 e2 X U, &nbsp;&nbsp;subst_te X U (open_be e1 e2) = &nbsp;&nbsp;&nbsp;&nbsp;open_be (subst_te X U e1) (subst_tb X U e2) with subst_tb_open_bb : ∀ e1 e2 X U, &nbsp;&nbsp;subst_tb X U (open_bb e1 e2) = &nbsp;&nbsp;&nbsp;&nbsp;open_bb (subst_tb X U e1) (subst_tb X U e2) with subst_ts_open_bs : ∀ e1 e2 X U, &nbsp;&nbsp;subst_ts X U (open_bs e1 e2) = &nbsp;&nbsp;&nbsp;&nbsp;open_bs (subst_ts X U e1) (subst_tb X U e2). Lemma subst_tvt_intro_rec : ∀ X T U k, &nbsp;&nbsp;X `notin` fv_tvt T → &nbsp;&nbsp;open_tvt_rec k U T = subst_tvt X U (open_tvt_rec k X T) with subst_tbt_intro_rec : ∀ X T U k, &nbsp;&nbsp;X `notin` fv_tbt T → &nbsp;&nbsp;open_tbt_rec k U T = subst_tbt X U (open_tbt_rec k X T). Lemma subst_te_intro_rec : ∀ X e T k, &nbsp;&nbsp;X `notin` fv_te e → &nbsp;&nbsp;open_te_rec k T e = subst_te X T (open_te_rec k X e) with subst_ts_intro_rec : ∀ X e T k, &nbsp;&nbsp;X `notin` fv_ts e → &nbsp;&nbsp;open_ts_rec k T e = subst_ts X T (open_ts_rec k X e) with subst_tb_intro_rec : ∀ X e T k, &nbsp;&nbsp;X `notin` fv_tb e → &nbsp;&nbsp;open_tb_rec k T e = subst_tb X T (open_tb_rec k X e). Lemma subst_be_fresh : ∀ a s1 s2, &nbsp;&nbsp;a `notin` fv_be s2 → &nbsp;&nbsp;subst_be a s1 s2 = s2 with subst_bs_fresh : ∀ a s1 s2, &nbsp;&nbsp;a `notin` fv_bs s2 → &nbsp;&nbsp;subst_bs a s1 s2 = s2 with subst_bb_fresh : ∀ a s1 s2, &nbsp;&nbsp;a `notin` fv_bb s2 → &nbsp;&nbsp;subst_bb a s1 s2 = s2. Lemma subst_ee_fresh : ∀ a s1 s2, &nbsp;&nbsp;a `notin` fv_ee s2 → &nbsp;&nbsp;subst_ee a s1 s2 = s2 with subst_es_fresh : ∀ a s1 s2, &nbsp;&nbsp;a `notin` fv_es s2 → &nbsp;&nbsp;subst_es a s1 s2 = s2 with subst_eb_fresh : ∀ a s1 s2, &nbsp;&nbsp;a `notin` fv_eb s2 → &nbsp;&nbsp;subst_eb a s1 s2 = s2. Lemma subst_ee_through_subst_be : ∀ a1 a2 s1 s2 s, &nbsp;&nbsp;a1 `notin` (fv_eb s1 `union` fv_bb s1 `union` fv_be s2 `union` singleton a2) → &nbsp;&nbsp;a2 `notin` (fv_eb s1 `union` fv_bb s1 `union` fv_be s2 `union` singleton a1) → &nbsp;&nbsp;subst_be a1 s1 (subst_ee a2 s2 s) = subst_ee a2 s2 (subst_be a1 s1 s) with subst_es_through_subst_bs : ∀ a1 a2 s1 s2 s, &nbsp;&nbsp;a1 `notin` (fv_eb s1 `union` fv_bb s1 `union` fv_be s2 `union` singleton a2) → &nbsp;&nbsp;a2 `notin` (fv_eb s1 `union` fv_bb s1 `union` fv_be s2 `union` singleton a1) → &nbsp;&nbsp;subst_bs a1 s1 (subst_es a2 s2 s) = subst_es a2 s2 (subst_bs a1 s1 s) with subst_eb_through_subst_bb : ∀ a1 a2 s1 s2 s, &nbsp;&nbsp;a1 `notin` (fv_eb s1 `union` fv_bb s1 `union` fv_be s2 `union` singleton a2) → &nbsp;&nbsp;a2 `notin` (fv_eb s1 `union` fv_bb s1 `union` fv_be s2 `union` singleton a1) → &nbsp;&nbsp;subst_bb a1 s1 (subst_eb a2 s2 s) = subst_eb a2 s2 (subst_bb a1 s1 s). Lemma subst_tvt_intro : ∀ X T2 U, &nbsp;&nbsp;X `notin` fv_tvt T2 → &nbsp;&nbsp;open_tvt T2 U = subst_tvt X U (open_tvt T2 X) with subst_tbt_intro : ∀ X T2 U, &nbsp;&nbsp;X `notin` fv_tbt T2 → &nbsp;&nbsp;open_tbt T2 U = subst_tbt X U (open_tbt T2 X). Lemma open_tvt_rec_type_aux : ∀ T j V i U, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;open_tvt_rec j V T = open_tvt_rec i U (open_tvt_rec j V T) → &nbsp;&nbsp;T = open_tvt_rec i U T with open_tbt_rec_type_aux : ∀ T j V i U, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;open_tbt_rec j V T = open_tbt_rec i U (open_tbt_rec j V T) → &nbsp;&nbsp;T = open_tbt_rec i U T. Lemma open_tvt_rec_capt_aux : ∀ T j C i U, &nbsp;&nbsp;open_cvt_rec j C T = open_tvt_rec i U (open_cvt_rec j C T) → &nbsp;&nbsp;T = open_tvt_rec i U T with open_tbt_rec_capt_aux : ∀ T j C i U, &nbsp;&nbsp;open_cbt_rec j C T = open_tbt_rec i U (open_cbt_rec j C T) → &nbsp;&nbsp;T = open_tbt_rec i U T. Lemma open_tvt_rec_vtype : ∀ T U k, &nbsp;&nbsp;vtype T → &nbsp;&nbsp;T = open_tvt_rec k U T with open_tbt_rec_btype : ∀ T U k, &nbsp;&nbsp;btype T → &nbsp;&nbsp;T = open_tbt_rec k U T. Lemma subst_tvt_open_tvt_rec : ∀ T1 T2 X P k, &nbsp;&nbsp;vtype P → &nbsp;&nbsp;subst_tvt X P (open_tvt_rec k T2 T1) = &nbsp;&nbsp;&nbsp;&nbsp;open_tvt_rec k (subst_tvt X P T2) (subst_tvt X P T1) with subst_tbt_open_tbt_rec : ∀ T1 T2 X P k, &nbsp;&nbsp;vtype P → &nbsp;&nbsp;subst_tbt X P (open_tbt_rec k T2 T1) = &nbsp;&nbsp;&nbsp;&nbsp;open_tbt_rec k (subst_tvt X P T2) (subst_tbt X P T1). Lemma subst_tvt_open_tvt_var : ∀ (X Y:atom) P T, &nbsp;&nbsp;Y ≠ X → &nbsp;&nbsp;vtype P → &nbsp;&nbsp;open_tvt (subst_tvt X P T) Y = subst_tvt X P (open_tvt T Y) with subst_tbt_open_tbt_var : ∀ (X Y:atom) P T, &nbsp;&nbsp;Y ≠ X → &nbsp;&nbsp;vtype P → &nbsp;&nbsp;open_tbt (subst_tbt X P T) Y = subst_tbt X P (open_tbt T Y). Lemma subst_tvt_open_cvt_rec : ∀ T1 C X P k, &nbsp;&nbsp;vtype P → &nbsp;&nbsp;subst_tvt X P (open_cvt_rec k C T1) = &nbsp;&nbsp;&nbsp;&nbsp;open_cvt_rec k C (subst_tvt X P T1) with subst_tbt_open_cbt_rec : ∀ T1 C X P k, &nbsp;&nbsp;vtype P → &nbsp;&nbsp;subst_tbt X P (open_cbt_rec k C T1) = &nbsp;&nbsp;&nbsp;&nbsp;open_cbt_rec k C (subst_tbt X P T1). Lemma subst_tvt_open_cvt_var : ∀ (X Y:atom) P T, &nbsp;&nbsp;vtype P → &nbsp;&nbsp;open_cvt (subst_tvt X P T) (cset_fvar Y) = &nbsp;&nbsp;&nbsp;&nbsp;subst_tvt X P (open_cvt T (cset_fvar Y)) with subst_tbt_open_cbt_var : ∀ (X Y:atom) P T, &nbsp;&nbsp;vtype P → &nbsp;&nbsp;open_cbt (subst_tbt X P T) (cset_fvar Y) = &nbsp;&nbsp;&nbsp;&nbsp;subst_tbt X P (open_cbt T (cset_fvar Y)). Lemma subst_cvt_fresh : ∀ X C T, &nbsp;&nbsp;X `notin` fv_cvt T → &nbsp;&nbsp;T = subst_cvt X C T with subst_cbt_fresh : ∀ X C T, &nbsp;&nbsp;X `notin` fv_cbt T → &nbsp;&nbsp;T = subst_cbt X C T. Lemma subst_cvt_open_tvt_rec : ∀ T C1 U X k, &nbsp;&nbsp;capt C1 → &nbsp;&nbsp;subst_cvt X C1 (open_tvt_rec k U T) = &nbsp;&nbsp;&nbsp;&nbsp;open_tvt_rec k (subst_cvt X C1 U) (subst_cvt X C1 T) with subst_cbt_open_tbt_rec : ∀ T C1 U X k, &nbsp;&nbsp;capt C1 → &nbsp;&nbsp;subst_cbt X C1 (open_tbt_rec k U T) = &nbsp;&nbsp;&nbsp;&nbsp;open_tbt_rec k (subst_cvt X C1 U) (subst_cbt X C1 T). Lemma subst_cvt_open_tvt : ∀ T C1 U X, &nbsp;&nbsp;capt C1 → &nbsp;&nbsp;subst_cvt X C1 (open_tvt T U) = &nbsp;&nbsp;&nbsp;&nbsp;open_tvt (subst_cvt X C1 T) (subst_cvt X C1 U) with subst_cbt_open_tbt : ∀ T C1 U X, &nbsp;&nbsp;capt C1 → &nbsp;&nbsp;subst_cbt X C1 (open_tbt T U) = &nbsp;&nbsp;&nbsp;&nbsp;open_tbt (subst_cbt X C1 T) (subst_cvt X C1 U). Lemma subst_cvt_open_tvt_var : ∀ T C1 X Y, &nbsp;&nbsp;Y ≠ X → &nbsp;&nbsp;capt C1 → &nbsp;&nbsp;subst_cvt X C1 (open_tvt T Y) = &nbsp;&nbsp;&nbsp;&nbsp;open_tvt (subst_cvt X C1 T) Y with subst_cbt_open_tbt_var : ∀ T C1 X Y, &nbsp;&nbsp;Y ≠ X → &nbsp;&nbsp;capt C1 → &nbsp;&nbsp;subst_cbt X C1 (open_tbt T Y) = &nbsp;&nbsp;&nbsp;&nbsp;open_tbt (subst_cbt X C1 T) Y. Lemma subst_tvt_open_cvt : ∀ T1 C X P, &nbsp;&nbsp;vtype P → &nbsp;&nbsp;subst_tvt X P (open_cvt T1 C) = &nbsp;&nbsp;&nbsp;&nbsp;open_cvt (subst_tvt X P T1) C with subst_tbt_open_cbt : ∀ T1 C X P, &nbsp;&nbsp;vtype P → &nbsp;&nbsp;subst_tbt X P (open_cbt T1 C) = &nbsp;&nbsp;&nbsp;&nbsp;open_cbt (subst_tbt X P T1) C. Lemma subst_te_open_ce_rec : ∀ e1 e2 C X U k, &nbsp;&nbsp;vtype U → &nbsp;&nbsp;subst_te X U (open_ce_rec k e2 C e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_ce_rec k (subst_tb X U e2) C (subst_te X U e1) with subst_tb_open_cb_rec : ∀ e1 e2 C X U k, &nbsp;&nbsp;vtype U → &nbsp;&nbsp;subst_tb X U (open_cb_rec k e2 C e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_cb_rec k (subst_tb X U e2) C (subst_tb X U e1) with subst_ts_open_cs_rec : ∀ e1 e2 C X U k, &nbsp;&nbsp;vtype U → &nbsp;&nbsp;subst_ts X U (open_cs_rec k e2 C e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_cs_rec k (subst_tb X U e2) C (subst_ts X U e1). Lemma subst_te_open_ce : ∀ e1 e2 C X U, &nbsp;&nbsp;vtype U → &nbsp;&nbsp;subst_te X U (open_ce e1 e2 C) = &nbsp;&nbsp;&nbsp;&nbsp;open_ce (subst_te X U e1) (subst_tb X U e2) C with subst_tb_open_cb : ∀ e1 e2 C X U, &nbsp;&nbsp;vtype U → &nbsp;&nbsp;subst_tb X U (open_cb e1 e2 C) = &nbsp;&nbsp;&nbsp;&nbsp;open_cb (subst_tb X U e1) (subst_tb X U e2) C with subst_ts_open_cs : ∀ e1 e2 C X U, &nbsp;&nbsp;vtype U → &nbsp;&nbsp;subst_ts X U (open_cs e1 e2 C) = &nbsp;&nbsp;&nbsp;&nbsp;open_cs (subst_ts X U e1) (subst_tb X U e2) C. Lemma subst_tvt_open_tvt : ∀ T1 T2 X P, &nbsp;&nbsp;vtype P → &nbsp;&nbsp;subst_tvt X P (open_tvt T1 T2) = &nbsp;&nbsp;&nbsp;&nbsp;open_tvt (subst_tvt X P T1) (subst_tvt X P T2) with subst_tbt_open_tbt : ∀ T1 T2 X P, &nbsp;&nbsp;vtype P → &nbsp;&nbsp;subst_tbt X P (open_tbt T1 T2) = &nbsp;&nbsp;&nbsp;&nbsp;open_tbt (subst_tbt X P T1) (subst_tvt X P T2). Lemma subst_tvt_fresh : ∀ X U T, &nbsp;&nbsp;X `notin` fv_tvt T → &nbsp;&nbsp;T = subst_tvt X U T with subst_tbt_fresh : ∀ X U T, &nbsp;&nbsp;X `notin` fv_tbt T → &nbsp;&nbsp;T = subst_tbt X U T. Lemma subst_te_intro : ∀ x e u, &nbsp;&nbsp;x `notin` fv_te e → &nbsp;&nbsp;open_te e u = subst_te x u (open_te e x) with subst_ts_intro : ∀ x e u, &nbsp;&nbsp;x `notin` fv_ts e → &nbsp;&nbsp;open_ts e u = subst_ts x u (open_ts e x) with subst_tb_intro : ∀ x e u, &nbsp;&nbsp;x `notin` fv_tb e → &nbsp;&nbsp;open_tb e u = subst_tb x u (open_tb e x). Lemma subst_te_open_te_rec : ∀ e1 W X U k, &nbsp;&nbsp;vtype U → &nbsp;&nbsp;subst_te X U (open_te_rec k W e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_te_rec k (subst_tvt X U W) (subst_te X U e1) with subst_tb_open_tb_rec : ∀ e1 W X U k, &nbsp;&nbsp;vtype U → &nbsp;&nbsp;subst_tb X U (open_tb_rec k W e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_tb_rec k (subst_tvt X U W) (subst_tb X U e1) with subst_ts_open_ts_rec : ∀ e1 W X U k, &nbsp;&nbsp;vtype U → &nbsp;&nbsp;subst_ts X U (open_ts_rec k W e1) = &nbsp;&nbsp;&nbsp;&nbsp;open_ts_rec k (subst_tvt X U W) (subst_ts X U e1). Lemma subst_te_open_te : ∀ e1 W X U, &nbsp;&nbsp;vtype U → &nbsp;&nbsp;subst_te X U (open_te e1 W) = &nbsp;&nbsp;&nbsp;&nbsp;open_te (subst_te X U e1) (subst_tvt X U W) with subst_tb_open_tb : ∀ e1 W X U, &nbsp;&nbsp;vtype U → &nbsp;&nbsp;subst_tb X U (open_tb e1 W) = &nbsp;&nbsp;&nbsp;&nbsp;open_tb (subst_tb X U e1) (subst_tvt X U W) with subst_ts_open_ts : ∀ e1 W X U, &nbsp;&nbsp;vtype U → &nbsp;&nbsp;subst_ts X U (open_ts e1 W) = &nbsp;&nbsp;&nbsp;&nbsp;open_ts (subst_ts X U e1) (subst_tvt X U W). Lemma open_te_rec_expr_aux : ∀ e j v T i, &nbsp;&nbsp;open_ee_rec j v e = open_te_rec i T (open_ee_rec j v e) → &nbsp;&nbsp;e = open_te_rec i T e with open_tb_rec_expr_aux : ∀ e j v T i, &nbsp;&nbsp;open_eb_rec j v e = open_tb_rec i T (open_eb_rec j v e) → &nbsp;&nbsp;e = open_tb_rec i T e with open_ts_rec_expr_aux : ∀ e j v T i, &nbsp;&nbsp;open_es_rec j v e = open_ts_rec i T (open_es_rec j v e) → &nbsp;&nbsp;e = open_ts_rec i T e. Lemma open_te_rec_block_aux : ∀ e j v T i, &nbsp;&nbsp;open_be_rec j v e = open_te_rec i T (open_be_rec j v e) → &nbsp;&nbsp;e = open_te_rec i T e with open_tb_rec_block_aux : ∀ e j v T i, &nbsp;&nbsp;open_bb_rec j v e = open_tb_rec i T (open_bb_rec j v e) → &nbsp;&nbsp;e = open_tb_rec i T e with open_ts_rec_block_aux : ∀ e j v T i, &nbsp;&nbsp;open_bs_rec j v e = open_ts_rec i T (open_bs_rec j v e) → &nbsp;&nbsp;e = open_ts_rec i T e. Lemma open_te_rec_capt_aux : ∀ e j C v T i, &nbsp;&nbsp;open_ce_rec j v C e = open_te_rec i T (open_ce_rec j v C e) → &nbsp;&nbsp;e = open_te_rec i T e with open_tb_rec_capt_aux : ∀ e j C v T i, &nbsp;&nbsp;open_cb_rec j v C e = open_tb_rec i T (open_cb_rec j v C e) → &nbsp;&nbsp;e = open_tb_rec i T e with open_ts_rec_capt_aux : ∀ e j C v T i, &nbsp;&nbsp;open_cs_rec j v C e = open_ts_rec i T (open_cs_rec j v C e) → &nbsp;&nbsp;e = open_ts_rec i T e. Lemma open_te_rec_type_aux : ∀ e j U T i, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;open_te_rec j U e = open_te_rec i T (open_te_rec j U e) → &nbsp;&nbsp;e = open_te_rec i T e with open_tb_rec_type_aux : ∀ e j U T i, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;open_tb_rec j U e = open_tb_rec i T (open_tb_rec j U e) → &nbsp;&nbsp;e = open_tb_rec i T e with open_ts_rec_type_aux : ∀ e j U T i, &nbsp;&nbsp;i ≠ j → &nbsp;&nbsp;open_ts_rec j U e = open_ts_rec i T (open_ts_rec j U e) → &nbsp;&nbsp;e = open_ts_rec i T e. Lemma open_te_rec_expr : ∀ k T e, &nbsp;&nbsp;expr e → &nbsp;&nbsp;e = open_te_rec k T e with open_ts_rec_stmt : ∀ k T e, &nbsp;&nbsp;stmt e → &nbsp;&nbsp;e = open_ts_rec k T e with open_tb_rec_block : ∀ k T e, &nbsp;&nbsp;block e → &nbsp;&nbsp;e = open_tb_rec k T e. Lemma subst_ee_open_te_rec : ∀ e T x u k, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_ee x u (open_te_rec k T e) = &nbsp;&nbsp;&nbsp;&nbsp;open_te_rec k T (subst_ee x u e) with subst_eb_open_tb_rec : ∀ e T x u k, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_eb x u (open_tb_rec k T e) = &nbsp;&nbsp;&nbsp;&nbsp;open_tb_rec k T (subst_eb x u e) with subst_es_open_ts_rec : ∀ e T x u k, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_es x u (open_ts_rec k T e) = &nbsp;&nbsp;&nbsp;&nbsp;open_ts_rec k T (subst_es x u e). Lemma subst_ee_open_te: ∀ e T x u, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_ee x u (open_te e T) = &nbsp;&nbsp;&nbsp;&nbsp;open_te (subst_ee x u e) T with subst_eb_open_tb : ∀ e T x u, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_eb x u (open_tb e T) = &nbsp;&nbsp;&nbsp;&nbsp;open_tb (subst_eb x u e) T with subst_es_open_ts: ∀ e T x u, &nbsp;&nbsp;expr u → &nbsp;&nbsp;subst_es x u (open_ts e T) = &nbsp;&nbsp;&nbsp;&nbsp;open_ts (subst_es x u e) T. Lemma subst_ee_open_te_var : ∀ (x y:atom) u e, &nbsp;&nbsp;y ≠ x → &nbsp;&nbsp;expr u → &nbsp;&nbsp;open_te (subst_ee x u e) y = subst_ee x u (open_te e y) with subst_eb_open_tb_var : ∀ (x y:atom) u e, &nbsp;&nbsp;y ≠ x → &nbsp;&nbsp;expr u → &nbsp;&nbsp;open_tb (subst_eb x u e) y = subst_eb x u (open_tb e y) with subst_es_open_ts_var : ∀ (x y:atom) u e, &nbsp;&nbsp;y ≠ x → &nbsp;&nbsp;expr u → &nbsp;&nbsp;open_ts (subst_es x u e) y = subst_es x u (open_ts e y). Lemma subst_be_open_te_rec : ∀ e T x u k, &nbsp;&nbsp;block u → &nbsp;&nbsp;subst_be x u (open_te_rec k T e) = &nbsp;&nbsp;&nbsp;&nbsp;open_te_rec k T (subst_be x u e) with subst_bb_open_tb_rec : ∀ e T x u k, &nbsp;&nbsp;block u → &nbsp;&nbsp;subst_bb x u (open_tb_rec k T e) = &nbsp;&nbsp;&nbsp;&nbsp;open_tb_rec k T (subst_bb x u e) with subst_bs_open_ts_rec : ∀ e T x u k, &nbsp;&nbsp;block u → &nbsp;&nbsp;subst_bs x u (open_ts_rec k T e) = &nbsp;&nbsp;&nbsp;&nbsp;open_ts_rec k T (subst_bs x u e). Lemma subst_be_open_te: ∀ e T x u, &nbsp;&nbsp;block u → &nbsp;&nbsp;subst_be x u (open_te e T) = &nbsp;&nbsp;&nbsp;&nbsp;open_te (subst_be x u e) T with subst_bb_open_tb : ∀ e T x u, &nbsp;&nbsp;block u → &nbsp;&nbsp;subst_bb x u (open_tb e T) = &nbsp;&nbsp;&nbsp;&nbsp;open_tb (subst_bb x u e) T with subst_bs_open_ts: ∀ e T x u, &nbsp;&nbsp;block u → &nbsp;&nbsp;subst_bs x u (open_ts e T) = &nbsp;&nbsp;&nbsp;&nbsp;open_ts (subst_bs x u e) T. Lemma subst_be_open_te_var : ∀ (x y:atom) u e, &nbsp;&nbsp;y ≠ x → &nbsp;&nbsp;block u → &nbsp;&nbsp;open_te (subst_be x u e) y = subst_be x u (open_te e y) with subst_bb_open_tb_var : ∀ (x y:atom) u e, &nbsp;&nbsp;y ≠ x → &nbsp;&nbsp;block u → &nbsp;&nbsp;open_tb (subst_bb x u e) y = subst_bb x u (open_tb e y) with subst_bs_open_ts_var : ∀ (x y:atom) u e, &nbsp;&nbsp;y ≠ x → &nbsp;&nbsp;block u → &nbsp;&nbsp;open_ts (subst_bs x u e) y = subst_bs x u (open_ts e y). Lemma subst_ce_open_te_rec : ∀ e T x u C k, &nbsp;&nbsp;capt C → &nbsp;&nbsp;block u → &nbsp;&nbsp;subst_ce x u C (open_te_rec k T e) = &nbsp;&nbsp;&nbsp;&nbsp;open_te_rec k (subst_cvt x C T) (subst_ce x u C e) with subst_cb_open_tb_rec : ∀ e T x u C k, &nbsp;&nbsp;capt C → &nbsp;&nbsp;block u → &nbsp;&nbsp;subst_cb x u C (open_tb_rec k T e) = &nbsp;&nbsp;&nbsp;&nbsp;open_tb_rec k (subst_cvt x C T) (subst_cb x u C e) with subst_cs_open_ts_rec : ∀ e T x u C k, &nbsp;&nbsp;capt C → &nbsp;&nbsp;block u → &nbsp;&nbsp;subst_cs x u C (open_ts_rec k T e) = &nbsp;&nbsp;&nbsp;&nbsp;open_ts_rec k (subst_cvt x C T) (subst_cs x u C e). Lemma subst_ce_open_te: ∀ e T x u C, &nbsp;&nbsp;capt C → &nbsp;&nbsp;block u → &nbsp;&nbsp;subst_ce x u C (open_te e T) = &nbsp;&nbsp;&nbsp;&nbsp;open_te (subst_ce x u C e) (subst_cvt x C T) with subst_cb_open_tb : ∀ e T x u C, &nbsp;&nbsp;capt C → &nbsp;&nbsp;block u → &nbsp;&nbsp;subst_cb x u C (open_tb e T) = &nbsp;&nbsp;&nbsp;&nbsp;open_tb (subst_cb x u C e) (subst_cvt x C T) with subst_cs_open_ts: ∀ e T x u C, &nbsp;&nbsp;capt C → &nbsp;&nbsp;block u → &nbsp;&nbsp;subst_cs x u C (open_ts e T) = &nbsp;&nbsp;&nbsp;&nbsp;open_ts (subst_cs x u C e) (subst_cvt x C T). Lemma subst_ce_open_te_var : ∀ (x y:atom) u e C, &nbsp;&nbsp;y ≠ x → &nbsp;&nbsp;capt C → &nbsp;&nbsp;block u → &nbsp;&nbsp;open_te (subst_ce x u C e) y = subst_ce x u C (open_te e y) with subst_cb_open_tb_var : ∀ (x y:atom) u e C, &nbsp;&nbsp;y ≠ x → &nbsp;&nbsp;capt C → &nbsp;&nbsp;block u → &nbsp;&nbsp;open_tb (subst_cb x u C e) y = subst_cb x u C (open_tb e y) with subst_cs_open_ts_var : ∀ (x y:atom) u e C, &nbsp;&nbsp;y ≠ x → &nbsp;&nbsp;capt C → &nbsp;&nbsp;block u → &nbsp;&nbsp;open_ts (subst_cs x u C e) y = subst_cs x u C (open_ts e y). ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Infrastructure.html",
    "relUrl": "/proofs/Top.SystemC.Infrastructure.html"
  },"34": {
    "doc": "Infrastructure",
    "title": "Infrastructure",
    "content": " ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Infrastructure.html",
    "relUrl": "/proofs/Top.SystemC.Infrastructure.html"
  },"35": {
    "doc": "Lemmas",
    "title": "Top.SystemC.Lemmas",
    "content": "The source of this file can be found on Github. This file mostly contains lemmas about wellformedness. Properties of wellformed types, capability sets, typing judgements and so forth. It finally also contains regularity properties: given a typing judgements we can extract information about the compontents. In particular, we know that certain components are locally closed, wellformed, etc. ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Lemmas.html",
    "relUrl": "/proofs/Top.SystemC.Lemmas.html"
  },"36": {
    "doc": "Lemmas",
    "title": " Properties of Wellformedness",
    "content": "If a type is well-formed in an environment, then it is locally closed. Lemma capt_from_wf_cap : ∀ E T, &nbsp;&nbsp;wf_cap E T → capt T. Lemma vtype_from_wf_vtyp : ∀ E T, &nbsp;&nbsp;wf_vtyp E T → vtype T with btype_from_wf_btyp : ∀ E T, &nbsp;&nbsp;wf_btyp E T → btype T. The remaining properties are analogous to the properties that we need to show for the typing relations. Lemma wf_cap_subset : ∀ E R R0, &nbsp;&nbsp;R |= R0 → &nbsp;&nbsp;wf_cap E R → &nbsp;&nbsp;wf_cap E R0. Lemma wf_cap_weakening : ∀ T E F G, &nbsp;&nbsp;wf_cap (G ++ E) T → &nbsp;&nbsp;ok (G ++ F ++ E) → &nbsp;&nbsp;wf_cap (G ++ F ++ E) T. Lemma wf_cap_weaken_head : ∀ T E F, &nbsp;&nbsp;wf_cap E T → &nbsp;&nbsp;ok (F ++ E) → &nbsp;&nbsp;wf_cap (F ++ E) T. Lemma wf_cap_bind_head : ∀ E R x S1, &nbsp;&nbsp;ok ([(x, bind_blk S1 tracked)] ++ E) → &nbsp;&nbsp;wf_cap E R → &nbsp;&nbsp;wf_cap ([(x, bind_blk S1 tracked)] ++ E) (cset_union R (cset_fvar x)). Lemma wf_cap_lvar : ∀ E l, &nbsp;&nbsp;wf_cap E (cset_lvar l). Lemma wf_cap_labels : ∀ E c, &nbsp;&nbsp;wf_cap E (from_labels (bound_labels c)). Lemma wf_vtyp_weakening : ∀ T E F G, &nbsp;&nbsp;wf_vtyp (G ++ E) T → &nbsp;&nbsp;ok (G ++ F ++ E) → &nbsp;&nbsp;wf_vtyp (G ++ F ++ E) T with wf_btyp_weakening : ∀ T E F G, &nbsp;&nbsp;wf_btyp (G ++ E) T → &nbsp;&nbsp;ok (G ++ F ++ E) → &nbsp;&nbsp;wf_btyp (G ++ F ++ E) T. Lemma wf_vtyp_weaken_head : ∀ T E F, &nbsp;&nbsp;wf_vtyp E T → &nbsp;&nbsp;ok (F ++ E) → &nbsp;&nbsp;wf_vtyp (F ++ E) T with wf_btyp_weaken_head : ∀ T E F, &nbsp;&nbsp;wf_btyp E T → &nbsp;&nbsp;ok (F ++ E) → &nbsp;&nbsp;wf_btyp (F ++ E) T. Lemma wf_cap_strengthening : ∀ E F x U T, &nbsp;wf_cap (F ++ [(x, bind_val U)] ++ E) T → &nbsp;wf_cap (F ++ E) T. Lemma wf_vtyp_strengthening : ∀ E F x U T, &nbsp;wf_vtyp (F ++ [(x, bind_val U)] ++ E) T → &nbsp;wf_vtyp (F ++ E) T with wf_btyp_strengthening : ∀ E F x U T, &nbsp;&nbsp;wf_btyp (F ++ [(x, bind_val U)] ++ E) T → &nbsp;&nbsp;wf_btyp (F ++ E) T. Lemma wf_cap_strengthening_blk : ∀ E F x U C T, &nbsp;wf_cap (F ++ [(x, bind_blk U (capture C))] ++ E) T → &nbsp;wf_cap (F ++ E) T. Lemma wf_cap_strengthening_typ : ∀ E F X T, &nbsp;wf_cap (F ++ [(X, bind_typ)] ++ E) T → &nbsp;wf_cap (F ++ E) T. Lemma wf_vtyp_strengthening_blk : ∀ E F x U C T, &nbsp;wf_vtyp (F ++ [(x, bind_blk U (capture C))] ++ E) T → &nbsp;wf_vtyp (F ++ E) T with wf_btyp_strengthening_blk : ∀ E F x U C T, &nbsp;&nbsp;wf_btyp (F ++ [(x, bind_blk U (capture C))] ++ E) T → &nbsp;&nbsp;wf_btyp (F ++ E) T. Lemma wf_cap_strengthening_blk_tracked : ∀ E F x U T, &nbsp;&nbsp;x `notin` cset_fvars T → &nbsp;&nbsp;wf_cap (F ++ [(x, bind_blk U tracked)] ++ E) T → &nbsp;&nbsp;wf_cap (F ++ E) T. Lemma notin_fvars_open_cset : ∀ x k T C, &nbsp;&nbsp;x `notin` (cset_fvars T `union` cset_fvars C) → &nbsp;&nbsp;x `notin` cset_fvars (open_cset k T C). Lemma notin_fv_cvt_open_cvt : ∀ x k T C, &nbsp;&nbsp;x `notin` (fv_cvt T `union` cset_fvars C) → &nbsp;&nbsp;x `notin` fv_cvt (open_cvt_rec k C T) with notin_fv_cbt_open_cbt : ∀ x k T C, &nbsp;&nbsp;x `notin` (fv_cbt T `union` cset_fvars C) → &nbsp;&nbsp;x `notin` fv_cbt (open_cbt_rec k C T). Lemma notin_fv_cvt_open_tvt : ∀ x k T U, &nbsp;&nbsp;x `notin` (fv_cvt T `union` fv_cvt U) → &nbsp;&nbsp;x `notin` (fv_cvt (open_tvt_rec k U T)) with notin_fv_cbt_open_tbt : ∀ x k T U, &nbsp;&nbsp;x `notin` (fv_cbt T `union` fv_cvt U) → &nbsp;&nbsp;x `notin` (fv_cbt (open_tbt_rec k U T)). Lemma wf_vtyp_strengthening_blk_tracked : ∀ E F x U T, &nbsp;x `notin` fv_cvt T → &nbsp;wf_vtyp (F ++ [(x, bind_blk U tracked)] ++ E) T → &nbsp;wf_vtyp (F ++ E) T with wf_btyp_strengthening_blk_tracked : ∀ E F x U T, &nbsp;&nbsp;x `notin` fv_cbt T → &nbsp;&nbsp;wf_btyp (F ++ [(x, bind_blk U tracked)] ++ E) T → &nbsp;&nbsp;wf_btyp (F ++ E) T. Lemma wf_cap_subst_tracked : ∀ F E U Z P T, &nbsp;&nbsp;wf_cap (F ++ [(Z, bind_blk U tracked)] ++ E) T → &nbsp;&nbsp;wf_cap E P → &nbsp;&nbsp;ok (map (subst_bbind Z P) F ++ E) → &nbsp;&nbsp;wf_cap (map (subst_bbind Z P) F ++ E) (subst_cset Z P T). Lemma wf_vtyp_subst_tracked : ∀ F E Z U C T, &nbsp;&nbsp;wf_vtyp (F ++ [(Z, bind_blk U tracked)] ++ E) T → &nbsp;&nbsp;wf_cap E C → &nbsp;&nbsp;ok (map (subst_bbind Z C) F ++ E) → &nbsp;&nbsp;ok (F ++ [(Z, bind_blk U tracked)] ++ E) → &nbsp;&nbsp;wf_vtyp (map (subst_bbind Z C) F ++ E) (subst_cvt Z C T) with wf_btyp_subst_tracked : ∀ F E Z U C T, &nbsp;&nbsp;wf_btyp (F ++ [(Z, bind_blk U tracked)] ++ E) T → &nbsp;&nbsp;wf_cap E C → &nbsp;&nbsp;ok (map (subst_bbind Z C) F ++ E) → &nbsp;&nbsp;ok (F ++ [(Z, bind_blk U tracked)] ++ E) → &nbsp;&nbsp;wf_btyp (map (subst_bbind Z C) F ++ E) (subst_cbt Z C T). ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Lemmas.html",
    "relUrl": "/proofs/Top.SystemC.Lemmas.html"
  },"37": {
    "doc": "Lemmas",
    "title": " Properties of Wellformed Environments",
    "content": "Lemma ok_from_wf_env : ∀ E, &nbsp;&nbsp;wf_env E → &nbsp;&nbsp;ok E. We add ok_from_wf_env as a hint here since it helps blur the distinction between wf_env and ok in proofs. The lemmas in the Environment library use ok, whereas here we naturally have (or can easily show) the stronger wf_env. Thus, ok_from_wf_env serves as a bridge that allows us to use the environments library. Lemma wf_vtyp_from_binds_typ : ∀ x U E, &nbsp;&nbsp;wf_env E → &nbsp;&nbsp;binds x (bind_val U) E → &nbsp;&nbsp;wf_vtyp E U. Lemma wf_vtyp_from_wf_env_typ : ∀ x T E, &nbsp;&nbsp;wf_env ([(x, bind_val T)] ++ E) → &nbsp;&nbsp;wf_vtyp E T. Lemma wf_btyp_from_binds_blk : ∀ x U Q E, &nbsp;&nbsp;wf_env E → &nbsp;&nbsp;binds x (bind_blk U Q) E → &nbsp;&nbsp;wf_btyp E U. Lemma wf_btyp_from_wf_env_blk : ∀ x T Q E, &nbsp;&nbsp;wf_env ([(x, bind_blk T Q)] ++ E) → &nbsp;&nbsp;wf_btyp E T. Lemma wf_vtyp_from_sig_binds : ∀ Q l T1 T, &nbsp;&nbsp;wf_sig Q → &nbsp;&nbsp;Signatures.binds l (bind_sig T1 T) Q → &nbsp;&nbsp;wf_vtyp empty T. Lemma wf_vtyp_from_sig_binds_val : ∀ Q l T1 T, &nbsp;&nbsp;wf_sig Q → &nbsp;&nbsp;Signatures.binds l (bind_sig T1 T) Q → &nbsp;&nbsp;wf_vtyp empty T1. ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Lemmas.html",
    "relUrl": "/proofs/Top.SystemC.Lemmas.html"
  },"38": {
    "doc": "Lemmas",
    "title": " Properties of wf_env",
    "content": "These properties are analogous to the properties that we need to show for the typing relations. Lemma wf_env_tail : ∀ E F, &nbsp;&nbsp;wf_env (F ++ E) → &nbsp;&nbsp;wf_env E. Lemma wf_env_strengthening : ∀ x T E F, &nbsp;&nbsp;wf_env (F ++ [(x, bind_val T)] ++ E) → &nbsp;&nbsp;wf_env (F ++ E). Lemma wf_env_strengthening_blk : ∀ x S1 C E F, &nbsp;&nbsp;wf_env (F ++ [(x, bind_blk S1 (capture C))] ++ E) → &nbsp;&nbsp;wf_env (F ++ E). Lemma wf_env_subst_tracked : ∀ x U E F C, &nbsp;&nbsp;wf_env (F ++ [(x, bind_blk U tracked)] ++ E) → &nbsp;&nbsp;wf_cap E C → &nbsp;&nbsp;wf_env (map (subst_bbind x C) F ++ E). Environment is unchanged by substitution for a fresh name . Lemma notin_fv_cap_wf : ∀ E (X : atom) C, &nbsp;&nbsp;wf_cap E C → &nbsp;&nbsp;X `notin` dom E → &nbsp;&nbsp;X `notin` cset_fvars C. Lemma notin_cset_fvars_open_cset : ∀ (Y X : atom) k c, &nbsp;&nbsp;X `notin` cset_fvars (open_cset k (cset_fvar Y) c) → &nbsp;&nbsp;X `notin` cset_fvars c. Lemma notin_fv_cvt_open_cvt_rec : ∀ (Y X : atom) k T, &nbsp;&nbsp;X `notin` fv_cvt (open_cvt_rec k (cset_fvar Y) T) → &nbsp;&nbsp;X `notin` fv_cvt T with notin_fv_cbt_open_cbt_rec : ∀ (Y X : atom) k T, &nbsp;&nbsp;X `notin` fv_cbt (open_cbt_rec k (cset_fvar Y) T) → &nbsp;&nbsp;X `notin` fv_cbt T. Lemma notin_fv_cvt_open_tvt_rec : ∀ (Y X : atom) k T, &nbsp;&nbsp;X `notin` fv_cvt (open_tvt_rec k Y T) → &nbsp;&nbsp;X `notin` fv_cvt T with notin_fv_cbt_open_tbt_rec : ∀ (Y X : atom) k T, &nbsp;&nbsp;X `notin` fv_cbt (open_tbt_rec k Y T) → &nbsp;&nbsp;X `notin` fv_cbt T. Lemma notin_fv_cvt_wf : ∀ E (X : atom) T, &nbsp;&nbsp;wf_vtyp E T → &nbsp;&nbsp;X `notin` dom E → &nbsp;&nbsp;X `notin` fv_cvt T with notin_fv_cbt_wf : ∀ E (X : atom) T, &nbsp;&nbsp;wf_btyp E T → &nbsp;&nbsp;X `notin` dom E → &nbsp;&nbsp;X `notin` fv_cbt T. Lemma subst_cvt_fresh_wf_vtyp : ∀ T x C, &nbsp;&nbsp;wf_vtyp empty T → &nbsp;&nbsp;T = subst_cvt x C T. Lemma wf_cset_in_dom : ∀ E C, &nbsp;&nbsp;wf_cap E C → &nbsp;&nbsp;cset_fvars C `subset` dom E. Lemma map_subst_cvt_id : ∀ G Z P, &nbsp;&nbsp;wf_env G → &nbsp;&nbsp;Z `notin` dom G → &nbsp;&nbsp;G = map (subst_bbind Z P) G. Lemma notin_union_split : ∀ x a1 a2, &nbsp;&nbsp;x `notin` (a1 `union` a2) ↔ x `notin` a1 ∧ x `notin` a2. ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Lemmas.html",
    "relUrl": "/proofs/Top.SystemC.Lemmas.html"
  },"39": {
    "doc": "Lemmas",
    "title": "Properties about free variables",
    "content": "Lemma notin_fv_ee_opened_ee : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_ee s1 → &nbsp;&nbsp;x `notin` fv_ee s2 → &nbsp;&nbsp;x `notin` fv_ee (open_ee_rec k s2 s1) with notin_fv_es_opened_es : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_es s1 → &nbsp;&nbsp;x `notin` fv_ee s2 → &nbsp;&nbsp;x `notin` fv_es (open_es_rec k s2 s1) with notin_fv_eb_opened_eb : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_eb s1 → &nbsp;&nbsp;x `notin` fv_ee s2 → &nbsp;&nbsp;x `notin` fv_eb (open_eb_rec k s2 s1). Lemma notin_fv_be_opened_be : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_be s1 → &nbsp;&nbsp;x `notin` fv_bb s2 → &nbsp;&nbsp;x `notin` fv_be (open_be_rec k s2 s1) with notin_fv_bs_opened_bs : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_bs s1 → &nbsp;&nbsp;x `notin` fv_bb s2 → &nbsp;&nbsp;x `notin` fv_bs (open_bs_rec k s2 s1) with notin_fv_bb_opened_bb : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_bb s1 → &nbsp;&nbsp;x `notin` fv_bb s2 → &nbsp;&nbsp;x `notin` fv_bb (open_bb_rec k s2 s1). Lemma notin_fv_be_opened_ee : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_be s1 → &nbsp;&nbsp;x `notin` fv_be s2 → &nbsp;&nbsp;x `notin` fv_be (open_ee_rec k s2 s1) with notin_fv_bs_opened_es : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_bs s1 → &nbsp;&nbsp;x `notin` fv_be s2 → &nbsp;&nbsp;x `notin` fv_bs (open_es_rec k s2 s1) with notin_fv_bb_opened_eb : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_bb s1 → &nbsp;&nbsp;x `notin` fv_be s2 → &nbsp;&nbsp;x `notin` fv_bb (open_eb_rec k s2 s1). Lemma notin_fv_ee_open_ce : ∀ x k s1 C s2, &nbsp;&nbsp;x `notin` fv_ee (open_ce_rec k s2 C s1) → &nbsp;&nbsp;x `notin` fv_ee s1 with notin_fv_es_open_cs : ∀ x k s1 C s2, &nbsp;&nbsp;x `notin` fv_es (open_cs_rec k s2 C s1) → &nbsp;&nbsp;x `notin` fv_es s1 with notin_fv_eb_open_cb : ∀ x k s1 C s2, &nbsp;&nbsp;x `notin` fv_eb (open_cb_rec k s2 C s1) → &nbsp;&nbsp;x `notin` fv_eb s1. Lemma notin_fv_be_open_ce : ∀ x k s1 C s2, &nbsp;&nbsp;x `notin` fv_be (open_ce_rec k s2 C s1) → &nbsp;&nbsp;x `notin` fv_be s1 with notin_fv_bs_open_cs : ∀ x k s1 C s2, &nbsp;&nbsp;x `notin` fv_bs (open_cs_rec k s2 C s1) → &nbsp;&nbsp;x `notin` fv_bs s1 with notin_fv_bb_open_cb : ∀ x k s1 C s2, &nbsp;&nbsp;x `notin` fv_bb (open_cb_rec k s2 C s1) → &nbsp;&nbsp;x `notin` fv_bb s1. Lemma notin_fv_ee_open_ee : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_ee (open_ee_rec k s2 s1) → &nbsp;&nbsp;x `notin` fv_ee s1 with notin_fv_es_open_es : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_es (open_es_rec k s2 s1) → &nbsp;&nbsp;x `notin` fv_es s1 with notin_fv_eb_open_eb : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_eb (open_eb_rec k s2 s1) → &nbsp;&nbsp;x `notin` fv_eb s1. Lemma notin_fv_be_open_ee : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_be (open_ee_rec k s2 s1) → &nbsp;&nbsp;x `notin` fv_be s1 with notin_fv_bs_open_es : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_bs (open_es_rec k s2 s1) → &nbsp;&nbsp;x `notin` fv_bs s1 with notin_fv_bb_open_eb : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_bb (open_eb_rec k s2 s1) → &nbsp;&nbsp;x `notin` fv_bb s1. Lemma notin_fv_be_open_be : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_be (open_be_rec k s2 s1) → &nbsp;&nbsp;x `notin` fv_be s1 with notin_fv_bs_open_bs : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_bs (open_bs_rec k s2 s1) → &nbsp;&nbsp;x `notin` fv_bs s1 with notin_fv_bb_open_bb : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_bb (open_bb_rec k s2 s1) → &nbsp;&nbsp;x `notin` fv_bb s1. Lemma notin_fv_ee_open_be : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_ee (open_be_rec k s2 s1) → &nbsp;&nbsp;x `notin` fv_ee s1 with notin_fv_es_open_bs : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_es (open_bs_rec k s2 s1) → &nbsp;&nbsp;x `notin` fv_es s1 with notin_fv_eb_open_bb : ∀ x k s1 s2, &nbsp;&nbsp;x `notin` fv_eb (open_bb_rec k s2 s1) → &nbsp;&nbsp;x `notin` fv_eb s1. Lemma notin_fv_ee_open_te : ∀ x k T s, &nbsp;&nbsp;x `notin` fv_ee (open_te_rec k T s) → &nbsp;&nbsp;x `notin` fv_ee s with notin_fv_es_open_ts : ∀ x k T s, &nbsp;&nbsp;x `notin` fv_es (open_ts_rec k T s) → &nbsp;&nbsp;x `notin` fv_es s with notin_fv_eb_open_tb : ∀ x k T s, &nbsp;&nbsp;x `notin` fv_eb (open_tb_rec k T s) → &nbsp;&nbsp;x `notin` fv_eb s. Lemma notin_fv_ee_etyping : ∀ E Q e T x, &nbsp;&nbsp;E ; Q |-exp e ~: T → &nbsp;&nbsp;x `notin` dom E → &nbsp;&nbsp;x `notin` fv_ee e with notin_fv_es_styping : ∀ E R Q e T x, &nbsp;&nbsp;E @ R ; Q |-stm e ~: T → &nbsp;&nbsp;x `notin` dom E → &nbsp;&nbsp;x `notin` fv_es e with notin_fv_eb_btyping : ∀ E R Q e T x, &nbsp;&nbsp;E @ R ; Q |-blk e ~: T → &nbsp;&nbsp;x `notin` dom E → &nbsp;&nbsp;x `notin` fv_eb e. Lemma notin_fv_be_open_te : ∀ x k T s, &nbsp;&nbsp;x `notin` fv_be (open_te_rec k T s) → &nbsp;&nbsp;x `notin` fv_be s with notin_fv_bs_open_ts : ∀ x k T s, &nbsp;&nbsp;x `notin` fv_bs (open_ts_rec k T s) → &nbsp;&nbsp;x `notin` fv_bs s with notin_fv_bb_open_tb : ∀ x k T s, &nbsp;&nbsp;x `notin` fv_bb (open_tb_rec k T s) → &nbsp;&nbsp;x `notin` fv_bb s. Lemma notin_fv_be_etyping : ∀ E Q e T x, &nbsp;&nbsp;E ; Q |-exp e ~: T → &nbsp;&nbsp;x `notin` dom E → &nbsp;&nbsp;x `notin` fv_be e with notin_fv_bs_styping : ∀ E R Q e T x, &nbsp;&nbsp;E @ R ; Q |-stm e ~: T → &nbsp;&nbsp;x `notin` dom E → &nbsp;&nbsp;x `notin` fv_bs e with notin_fv_bb_btyping : ∀ E R Q e T x, &nbsp;&nbsp;E @ R ; Q |-blk e ~: T → &nbsp;&nbsp;x `notin` dom E → &nbsp;&nbsp;x `notin` fv_bb e. Lemma notin_fv_tvt_open_cvt_rec : ∀ (Y X : atom) k T, &nbsp;&nbsp;X `notin` fv_tvt (open_cvt_rec k (cset_fvar Y) T) → &nbsp;&nbsp;X `notin` fv_tvt T with notin_fv_tbt_open_cbt_rec : ∀ (Y X : atom) k T, &nbsp;&nbsp;X `notin` fv_tbt (open_cbt_rec k (cset_fvar Y) T) → &nbsp;&nbsp;X `notin` fv_tbt T. Lemma notin_fv_tvt_open_tvt_rec : ∀ (Y X : atom) k T, &nbsp;&nbsp;X `notin` fv_tvt (open_tvt_rec k Y T) → &nbsp;&nbsp;X `notin` fv_tvt T with notin_fv_tbt_open_tbt_rec : ∀ (Y X : atom) k T, &nbsp;&nbsp;X `notin` fv_tbt (open_tbt_rec k Y T) → &nbsp;&nbsp;X `notin` fv_tbt T. Lemma notin_fv_tvt_wf : ∀ E (X : atom) T, &nbsp;&nbsp;wf_vtyp E T → &nbsp;&nbsp;X `notin` dom E → &nbsp;&nbsp;X `notin` fv_tvt T with notin_fv_tbt_wf : ∀ E (X : atom) T, &nbsp;&nbsp;wf_btyp E T → &nbsp;&nbsp;X `notin` dom E → &nbsp;&nbsp;X `notin` fv_tbt T. Lemma map_subst_tbind_id : ∀ G Z P, &nbsp;&nbsp;wf_env G → &nbsp;&nbsp;Z `notin` dom G → &nbsp;&nbsp;G = map (subst_tbind Z P) G. Lemma wf_cap_subst_tbind : ∀ F E Z P C, &nbsp;&nbsp;wf_cap (F ++ [(Z, bind_typ)] ++ E) C → &nbsp;&nbsp;wf_vtyp E P → &nbsp;&nbsp;ok (F ++ E) → &nbsp;&nbsp;wf_cap (map (subst_tbind Z P) F ++ E) C. Lemma wf_vtyp_subst_tbind : ∀ F E Z P T, &nbsp;&nbsp;wf_vtyp (F ++ [(Z, bind_typ)] ++ E) T → &nbsp;&nbsp;wf_vtyp E P → &nbsp;&nbsp;ok (F ++ E) → &nbsp;&nbsp;wf_vtyp (map (subst_tbind Z P) F ++ E) (subst_tvt Z P T) with wf_btyp_subst_tbind : ∀ F E Z P T, &nbsp;&nbsp;wf_btyp (F ++ [(Z, bind_typ)] ++ E) T → &nbsp;&nbsp;wf_vtyp E P → &nbsp;&nbsp;ok (F ++ E) → &nbsp;&nbsp;wf_btyp (map (subst_tbind Z P) F ++ E) (subst_tbt Z P T). Lemma wf_env_subst_tbind : ∀ X U E F, &nbsp;&nbsp;wf_env (F ++ [(X, bind_typ)] ++ E) → &nbsp;&nbsp;wf_vtyp E U → &nbsp;&nbsp;wf_env (map (subst_tbind X U) F ++ E). Lemma wf_typ_open : ∀ E U T, &nbsp;&nbsp;ok E → &nbsp;&nbsp;wf_btyp E (typ_tfun T) → &nbsp;&nbsp;wf_vtyp E U → &nbsp;&nbsp;wf_btyp E (open_tbt T U). ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Lemmas.html",
    "relUrl": "/proofs/Top.SystemC.Lemmas.html"
  },"40": {
    "doc": "Lemmas",
    "title": " Regularity of relations",
    "content": "Lemma etyping_regular : ∀ E Q e T, &nbsp;&nbsp;E ; Q |-exp e ~: T → &nbsp;&nbsp;wf_env E ∧ expr e ∧ wf_vtyp E T ∧ wf_sig Q with btyping_regular : ∀ E R Q (b : blk) S, &nbsp;&nbsp;E @ R ; Q |-blk b ~: S → &nbsp;&nbsp;wf_env E ∧ block b ∧ wf_btyp E S ∧ wf_cap E R ∧ wf_sig Q with styping_regular : ∀ E R Q s T, &nbsp;&nbsp;E @ R ; Q |-stm s ~: T → &nbsp;&nbsp;wf_env E ∧ stmt s ∧ wf_vtyp E T ∧ wf_cap E R ∧ wf_sig Q. Lemma typing_ctx_regular : ∀ R Q c T, &nbsp;&nbsp;(R ; Q |-ctx c ~: T) → &nbsp;&nbsp;wf_cap empty R ∧ wf_sig Q. Lemma typing_cnt_regular : ∀ C Q c S T, &nbsp;&nbsp;(C ; Q |-cnt c ~: S ~&gt; T) → &nbsp;&nbsp;wf_cap empty C ∧ wf_sig Q. ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Lemmas.html",
    "relUrl": "/proofs/Top.SystemC.Lemmas.html"
  },"41": {
    "doc": "Lemmas",
    "title": " Automation",
    "content": "The lemma ok_from_wf_env was already added above as a hint since it helps blur the distinction between wf_env and ok in proofs. As currently stated, the regularity lemmas are ill-suited to be used with auto and eauto since they end in conjunctions. Even if we were, for example, to split sub_regularity into three separate lemmas, the resulting lemmas would be usable only by eauto and there is no guarantee that eauto would be able to find proofs effectively. Thus, the hints below apply the regularity lemmas and type_from_wf_typ to discharge goals about local closure and well-formedness, but in such a way as to minimize proof search. The first hint introduces an wf_env fact into the context. It works well when combined with the lemmas relating wf_env and wf_typ. We choose to use those lemmas explicitly via (auto using ...) tactics rather than add them as hints. When used this way, the explicitness makes the proof more informative rather than more cluttered (with useless details). The other three hints try outright to solve their respective goals. Extra Lemmas using automation concerning plug Lemma notin_fv_es_plug : ∀ k e R C T1 T2 x, &nbsp;&nbsp;R ; C |-cnt k ~: T1 ~&gt; T2 → &nbsp;&nbsp;x `notin` fv_ee e → &nbsp;&nbsp;x `notin` fv_es (plug k e). Lemma notin_fv_bs_plug : ∀ k e R C T1 T2 x, &nbsp;&nbsp;R ; C |-cnt k ~: T1 ~&gt; T2 → &nbsp;&nbsp;x `notin` fv_be e → &nbsp;&nbsp;x `notin` fv_bs (plug k e). ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Lemmas.html",
    "relUrl": "/proofs/Top.SystemC.Lemmas.html"
  },"42": {
    "doc": "Lemmas",
    "title": "Lemmas",
    "content": " ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Lemmas.html",
    "relUrl": "/proofs/Top.SystemC.Lemmas.html"
  },"43": {
    "doc": "Soundness",
    "title": "Top.SystemC.Soundness",
    "content": "The source of this file can be found on Github. ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Soundness.html",
    "relUrl": "/proofs/Top.SystemC.Soundness.html"
  },"44": {
    "doc": "Soundness",
    "title": "Soundness",
    "content": "The proof of soundness is split the following aspects: . | Substitution. See file SystemC.Substitution. For instance etyping_through_subst_ee shows that substituting an expression in an expression preserves expression-typing, and styping_through_subst_bs shows that substituting a block into a statement preserves statement-typing). | Plugging. Lemma 3.4 in the paper is proven (in a variation) by unwind_step. | Preservation. We show type preservation of reducing statements (preservation_stmt) and machine states (preservation_step). | Progress. We show type progress for statements (progress_stmt) and machine states (progress_step). | . ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Soundness.html",
    "relUrl": "/proofs/Top.SystemC.Soundness.html"
  },"45": {
    "doc": "Soundness",
    "title": " Context Plugging",
    "content": "This helper lemma is important: it says that given a continuation and some variable x, plugging the variable in the position of the hole is well-typed. This lemma roughly corresponds to Lemma 3.6 in the paper. Lemma unwind_step : ∀ L Q x C T1 T2 k, &nbsp;&nbsp;wf_vtyp empty T1 → &nbsp;&nbsp;wf_cap empty C → &nbsp;&nbsp;C ; Q |-cnt k ~: T1 ~&gt; T2 → &nbsp;&nbsp;x `notin` L → &nbsp;&nbsp;[(x, bind_val T1)] @ C ; Q |-stm (plug k x) ~: T2. Helper lemma showing that plug doesn't introduce binders. Lemma plugging : ∀ (x : atom) k C Q T1 T2, &nbsp;&nbsp;C ; Q |-cnt k ~: T1 ~&gt; T2 → &nbsp;&nbsp;open_es (plug k 0) x = plug k x. ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Soundness.html",
    "relUrl": "/proofs/Top.SystemC.Soundness.html"
  },"46": {
    "doc": "Soundness",
    "title": " Preservation",
    "content": "As discussed in SystemC.Definitions, the operational semantics of SystemC is mechanized as an abstract machine, separating redexes that depend on the evaulation context from those that do not. In consequence, the preservation Theorem 3.4 from the paper, maps to two separate theorems in the mechanization: . | preservation_stmt shows that reducing statement regardless of the context preserves the type. | preservation_step shows that stepping from one state to another preserves the typability of the machine state. | . Further more, the pure reductions for expressions (preservation_expr) and blocks (preservation_block) also preserve types, correspondingly. Lemma preservation_block : ∀ E R Q b b' S1, &nbsp;&nbsp;btyping E R Q b S1 → &nbsp;&nbsp;bred b b' → &nbsp;&nbsp;btyping E R Q b' S1. Lemma preservation_expr : ∀ E Q b b' S1, &nbsp;&nbsp;etyping E Q b S1 → &nbsp;&nbsp;ered b b' → &nbsp;&nbsp;etyping E Q b' S1. Lemma preservation_stmt : ∀ E R Q s s' T, &nbsp;&nbsp;styping E R Q s T → &nbsp;&nbsp;sred s s' → &nbsp;&nbsp;styping E R Q s' T. Lemma preservation_step : ∀ s1 s2, &nbsp;&nbsp;typing_state s1 → &nbsp;&nbsp;s1 --&gt; s2 → &nbsp;&nbsp;typing_state s2. ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Soundness.html",
    "relUrl": "/proofs/Top.SystemC.Soundness.html"
  },"47": {
    "doc": "Soundness",
    "title": " Progress",
    "content": "Like with preservation, for progress, we have two lemmas: . | progress_stmt shows that a well-typed statement can take a step | progress_step shows that a well-typed machine can take a step | . ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Soundness.html",
    "relUrl": "/proofs/Top.SystemC.Soundness.html"
  },"48": {
    "doc": "Soundness",
    "title": "Canonical forms",
    "content": "We start by proving the usual canonical forms lemmas. Lemma canonical_form_tabs : ∀ e T R Q, &nbsp;&nbsp;bvalue e → &nbsp;&nbsp;btyping empty R Q e (typ_tfun T) → &nbsp;&nbsp;∃ e1, e = blk_tabs e1. Lemma canonical_form_vabs : ∀ e U1 U2 R Q, &nbsp;&nbsp;bvalue e → &nbsp;&nbsp;btyping empty R Q e (typ_vfun U1 U2) → &nbsp;&nbsp;∃ V, ∃ e1, e = blk_vabs V e1. Lemma canonical_form_babs : ∀ e U1 U2 R Q, &nbsp;&nbsp;bvalue e → &nbsp;&nbsp;btyping empty R Q e (typ_bfun U1 U2) → &nbsp;&nbsp;∃ V, ∃ e1, e = blk_babs V e1. Lemma canonical_form_box : ∀ e R Q C, &nbsp;&nbsp;evalue e → &nbsp;&nbsp;etyping empty Q e (typ_capt R C) → &nbsp;&nbsp;∃ s, e = exp_box C s. Note that due to the slightly different representation of capability-types, we also have canonical forms for those Lemma canonical_form_exc : ∀ b R Q T1 T, &nbsp;&nbsp;bvalue b → &nbsp;&nbsp;empty @ R ; Q |-blk b ~: (typ_exc T1 T) → &nbsp;&nbsp;∃ l, b = blk_handler l ∧ Signatures.binds l (bind_sig T1 T) Q. ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Soundness.html",
    "relUrl": "/proofs/Top.SystemC.Soundness.html"
  },"49": {
    "doc": "Soundness",
    "title": "Progress",
    "content": "Lemma progress_block : ∀ b S1 R Q, &nbsp;&nbsp;empty @ R ; Q |-blk b ~: S1 → &nbsp;&nbsp;bvalue b ∨ ∃ b', b --&gt;b b'. Lemma progress_expr : ∀ Q e T, &nbsp;&nbsp;empty ; Q |-exp e ~: T → &nbsp;&nbsp;evalue e ∨ ∃ e', e --&gt;e e'. Lemma progress_stmt : ∀ s T R Q, &nbsp;&nbsp;empty @ R ; Q |-stm s ~: T → &nbsp;&nbsp;machine_redex s ∨ ∃ s', s --&gt;s s'. Lemma progress_step : ∀ s1, &nbsp;&nbsp;typing_state s1 → &nbsp;&nbsp;done s1 ∨ ∃ s2, s1 --&gt; s2. ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Soundness.html",
    "relUrl": "/proofs/Top.SystemC.Soundness.html"
  },"50": {
    "doc": "Substitution",
    "title": "Top.SystemC.Substitution",
    "content": "The source of this file can be found on Github. ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Substitution.html",
    "relUrl": "/proofs/Top.SystemC.Substitution.html"
  },"51": {
    "doc": "Substitution",
    "title": "Weakening",
    "content": "The standard lemmas for weakening the environment in typing. Lemma etyping_weakening : ∀ E F G Q e T, &nbsp;&nbsp;etyping (G ++ E) Q e T → &nbsp;&nbsp;wf_env (G ++ F ++ E) → &nbsp;&nbsp;etyping (G ++ F ++ E) Q e T with btyping_weakening : ∀ E F G R Q e T, &nbsp;&nbsp;btyping (G ++ E) R Q e T → &nbsp;&nbsp;wf_env (G ++ F ++ E) → &nbsp;&nbsp;btyping (G ++ F ++ E) R Q e T with styping_weakening : ∀ E F G R Q e T, &nbsp;&nbsp;styping (G ++ E) R Q e T → &nbsp;&nbsp;wf_env (G ++ F ++ E) → &nbsp;&nbsp;styping (G ++ F ++ E) R Q e T. Lemma restriction_transitive : ∀ C1 C2 C3, &nbsp;&nbsp;C1 |= C2 → &nbsp;&nbsp;C2 |= C3 → &nbsp;&nbsp;C1 |= C3. ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Substitution.html",
    "relUrl": "/proofs/Top.SystemC.Substitution.html"
  },"52": {
    "doc": "Substitution",
    "title": "Capture Subsumption",
    "content": "Here we show that capture subsumption on blocks and statements is admissible. Lemma btyping_weaken_restriction : ∀ C E R Q b S1, &nbsp;&nbsp;R |= C → &nbsp;&nbsp;wf_cap E R → &nbsp;&nbsp;E @ C ; Q |-blk b ~: S1 → &nbsp;&nbsp;E @ R ; Q |-blk b ~: S1 with styping_weaken_restriction : ∀ C E R Q s T, &nbsp;&nbsp;R |= C → &nbsp;&nbsp;wf_cap E R → &nbsp;&nbsp;E @ C ; Q |-stm s ~: T → &nbsp;&nbsp;E @ R ; Q |-stm s ~: T. ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Substitution.html",
    "relUrl": "/proofs/Top.SystemC.Substitution.html"
  },"53": {
    "doc": "Substitution",
    "title": "Substitution",
    "content": "We show the standard property that substitution preserves typing. Substitution of expressions into terms . Lemma etyping_through_subst_ee : ∀ U E F Q x T e u, &nbsp;&nbsp;etyping (F ++ [(x, bind_val U)] ++ E) Q e T → &nbsp;&nbsp;etyping E Q u U → &nbsp;&nbsp;etyping (F ++ E) Q (subst_ee x u e) T with btyping_through_subst_eb : ∀ U E F R Q x T e u, &nbsp;&nbsp;btyping (F ++ [(x, bind_val U)] ++ E) R Q e T → &nbsp;&nbsp;etyping E Q u U → &nbsp;&nbsp;btyping (F ++ E) R Q (subst_eb x u e) T with styping_through_subst_es : ∀ U E F R Q x T e u, &nbsp;&nbsp;styping (F ++ [(x, bind_val U)] ++ E) R Q e T → &nbsp;&nbsp;etyping E Q u U → &nbsp;&nbsp;styping (F ++ E) R Q (subst_es x u e) T. Substitution of monomorphic blocks into terms . Lemma etyping_through_subst_be : ∀ U C E F Q x T e u, &nbsp;&nbsp;etyping (F ++ [(x, bind_blk U (capture C))] ++ E) Q e T → &nbsp;&nbsp;btyping E C Q u U → &nbsp;&nbsp;etyping (F ++ E) Q (subst_be x u e) T with btyping_through_subst_bb : ∀ U C E F R Q x T e u, &nbsp;&nbsp;btyping (F ++ [(x, bind_blk U (capture C))] ++ E) R Q e T → &nbsp;&nbsp;btyping E C Q u U → &nbsp;&nbsp;btyping (F ++ E) R Q (subst_bb x u e) T with styping_through_subst_bs : ∀ U C E F R Q x T e u, &nbsp;&nbsp;styping (F ++ [(x, bind_blk U (capture C))] ++ E) R Q e T → &nbsp;&nbsp;btyping E C Q u U → &nbsp;&nbsp;styping (F ++ E) R Q (subst_bs x u e) T. Substitution of polymorphic blocks into terms . Lemma etyping_through_subst_ce : ∀ (C : cap) U E F Q x T e u, &nbsp;&nbsp;etyping (F ++ [(x, bind_blk U tracked)] ++ E) Q e T → &nbsp;&nbsp;wf_cap E C → &nbsp;&nbsp;btyping E C Q u U → &nbsp;&nbsp;etyping (map (subst_bbind x C) F ++ E) Q (subst_ce x u C e) (subst_cvt x C T) with btyping_through_subst_cb : ∀ (C : cap) U E F R Q x T e u, &nbsp;&nbsp;btyping (F ++ [(x, bind_blk U tracked)] ++ E) R Q e T → &nbsp;&nbsp;wf_cap E C → &nbsp;&nbsp;btyping E C Q u U → &nbsp;&nbsp;btyping (map (subst_bbind x C) F ++ E) (subst_cset x C R) Q (subst_cb x u C e) (subst_cbt x C T) with styping_through_subst_cs : ∀ (C : cap) U E F R Q x T e u, &nbsp;&nbsp;styping (F ++ [(x, bind_blk U tracked)] ++ E) R Q e T → &nbsp;&nbsp;wf_cap E C → &nbsp;&nbsp;btyping E C Q u U → &nbsp;&nbsp;styping (map (subst_bbind x C) F ++ E) (subst_cset x C R) Q (subst_cs x u C e) (subst_cvt x C T). Substitution of types into terms . We use our own induction principle to speed up termination checking. Lemma typing_through_subst_t_ : ∀ U E Q X, (∀ E_ Q_ e T, &nbsp;&nbsp;etyping E_ Q_ e T → &nbsp;&nbsp;(∀ F, E_ = F ++ [(X, bind_typ)] ++ E → &nbsp;&nbsp;&nbsp;Q_ = Q → &nbsp;&nbsp;&nbsp;wf_vtyp E U → &nbsp;&nbsp;&nbsp;etyping ((map (subst_tbind X U) F) ++ E) Q (subst_te X U e) (subst_tvt X U T))) ∧ (∀ E_ R Q_ e T, &nbsp;&nbsp;styping E_ R Q_ e T → &nbsp;&nbsp;(∀ F, E_ = F ++ [(X, bind_typ)] ++ E → &nbsp;&nbsp;&nbsp;Q_ = Q → &nbsp;&nbsp;&nbsp;wf_vtyp E U → &nbsp;&nbsp;&nbsp;styping ((map (subst_tbind X U) F) ++ E) R Q (subst_ts X U e) (subst_tvt X U T))) ∧ (∀ E_ R Q_ e T, &nbsp;&nbsp;btyping E_ R Q_ e T → &nbsp;&nbsp;(∀ F, E_ = F ++ [(X, bind_typ)] ++ E → &nbsp;&nbsp;&nbsp;Q_ = Q → &nbsp;&nbsp;&nbsp;wf_vtyp E U → &nbsp;&nbsp;&nbsp;btyping ((map (subst_tbind X U) F) ++ E) R Q (subst_tb X U e) (subst_tbt X U T))). We now can state the lemmas as it is more common, using the helper above Lemma etyping_through_subst_te: ∀ U E F Q X e T, &nbsp;&nbsp;wf_vtyp E U → &nbsp;&nbsp;etyping (F ++ [(X, bind_typ)] ++ E) Q e T → &nbsp;&nbsp;etyping ((map (subst_tbind X U) F) ++ E) Q (subst_te X U e) (subst_tvt X U T). Lemma styping_through_subst_ts : ∀ U E F R Q X e T, &nbsp;&nbsp;wf_vtyp E U → &nbsp;&nbsp;styping (F ++ [(X, bind_typ)] ++ E) R Q e T → &nbsp;&nbsp;styping ((map (subst_tbind X U) F) ++ E) R Q (subst_ts X U e) (subst_tvt X U T). Lemma btyping_through_subst_tb : ∀ U E F R Q X e T, &nbsp;&nbsp;wf_vtyp E U → &nbsp;&nbsp;btyping (F ++ [(X, bind_typ)] ++ E) R Q e T → &nbsp;&nbsp;btyping ((map (subst_tbind X U) F) ++ E) R Q (subst_tb X U e) (subst_tbt X U T). ",
    "url": "/oopsla-2022-artifact/proofs/Top.SystemC.Substitution.html",
    "relUrl": "/proofs/Top.SystemC.Substitution.html"
  },"54": {
    "doc": "Boxing and Unboxing",
    "title": "Boxing and Unboxing",
    "content": "As we observed earlier, by default functions and capabilites are second class – they cannot be returned nor stored in mutable cells and can only be passed as second-class parameters to other functions. We can lift this restriction by boxing these functions and capabilities, reifying the set of captured capabilites from the binder to the type. interface Greeter { def sayHello(): Unit } def myGreeter() { try { // boxing a capability and storing it in a mutable variable var capturedGreeter = box greeter; // unboxing requires `greeter` to be in scope def user() { (unbox capturedGreeter).sayHello() } // automatic boxing of `user`, stored in a value binder val firstClassUser: () =&gt; Unit at {greeter} = user; // automatic unboxing of firstClassUser firstClassUser() } with greeter : Greeter { def sayHello() { println(\"Hello World!\"); resume(()) } } } . Here, we box greeter to store it in the mutable cell capturedGreeter. Note that System C supports automatic boxing and unboxing, and we could have omitted box. We can also explicitly annotate the expected capability set as box {greeter} greeter. In the function user, we unbox the captured first-class block and call sayHello. The fact that we unbox it is reflected in the inferred capability set annotated on user. Boxed values act as normal first-class values in System C until unboxed. In particular, they can be passed as values to value-polymorphic functions. def invoke[T](v : T){f : (T) =&gt; Unit}: Unit { f(v) } def indirectMyGreeter { greeter: Greeter }: Unit { val capturedGreeter = box greeter; invoke(capturedGreeter){ (f : Greeter at { greeter }) =&gt; f.sayHello() } } . Hovering over capturedGreeter shows how the capture is reflected in the type. ",
    "url": "/oopsla-2022-artifact/boxing/",
    "relUrl": "/boxing/"
  },"55": {
    "doc": "Boxing and Unboxing",
    "title": "Reasoning about Purity",
    "content": "Boxes reflect capture of tracked variables in their types. Let us assume the following function in the standard library: . // def setTimeout(callback: () =&gt; Unit at {}, duration: Int): Unit . Its implementation uses the FFI to JavaScript. System C is implemented as a compiler to JavaScript and requires a monadic runtime. The value passed to the JavaScript builtin window.setTimeout should not make use of any control effects or effect handlers since it will be called later outside of all possible handlers. To express this, we require the callback to be “pure” (i.e. () =&gt; Unit at {}). We can still use the unsafe println function, as illustrated in the following example . setTimeout(box { () =&gt; println(\"Hello after 2 seconds!\") }, 2000) . ",
    "url": "/oopsla-2022-artifact/boxing/#reasoning-about-purity",
    "relUrl": "/boxing/#reasoning-about-purity"
  },"56": {
    "doc": "Capabilities",
    "title": "Capabilities and Effects",
    "content": " ",
    "url": "/oopsla-2022-artifact/capability/#capabilities-and-effects",
    "relUrl": "/capability/#capabilities-and-effects"
  },"57": {
    "doc": "Capabilities",
    "title": "Interfaces",
    "content": "Capability (and effect) types in System C are introduced with the interface keyword. For example, the following introduces the capability type Greeter which has an operation sayHello associated with it. interface Greeter { def sayHello(): Unit } . To use it, we can require an instance of the Greeter capability type: . def useGreeter { g: Greeter } { g.sayHello() } . Notice how interfaces and capabilities are block types enclosed in curly braces. They are second-class. Finally, to actually call useGreeter, we need to handle it with a concrete handler which implements the Greeter interface and produces an concrete instance of the Greeter interface: . def myGreeter() { try { useGreeter {greeter} } with greeter: Greeter { def sayHello() { println(\"Hello World!\"); resume(()) } } } . System C features effect handlers: after printing \"Hello World\", we resume evaluation at the point of the call to sayHello. myGreeter() . Side-Effects . While capabilities can be used to precisely track side effects, in our draft implementation we chose to expose the (unsafe) builtin function println, which is not tracked. We can simply track access to the console by defining: . interface Console { def println(msg: String): Unit } def myFunction { console: Console } { console.println(\"hello\"); def nested() { console.println(\"world\") } nested() } . Type checking the example we can see that for nested, we infer a capability set of {console}. ",
    "url": "/oopsla-2022-artifact/capability/#interfaces",
    "relUrl": "/capability/#interfaces"
  },"58": {
    "doc": "Capabilities",
    "title": "Using Multiple Effects and Capabilities",
    "content": "A capability type can have more than one operation, and these operations can also return values; for example: . interface Bank { def debit(amount: Int): Unit def credit(amount: Int): Unit def balance(): Int } . Here is a small example which implements the Bank interface: . def simpleAccount(): Unit { var balance = 0; try { bank.debit(10); bank.credit(5); println(bank.balance()) } with bank: Bank { def debit(amount: Int) { balance = balance - amount; resume(()) } def credit(amount: Int) { balance = balance + amount; resume(()) } def balance() { resume(balance) } } } . We can abstract over the handler for Bank and also add exceptions, for example, when you would overdraft your account. interface AccountExc { def outOfMoney[A](): A } def account[T] { exc: AccountExc } { prog: {Bank} =&gt; T } : T { var balance = 0; try { prog {bank} } with bank : Bank { def debit(amount : Int) { if (amount &gt; balance) { exc.outOfMoney() } else { balance = balance - amount; resume(()) } } def credit(amount : Int) { balance = balance + amount; resume(()) } def balance() { resume(balance) } } } def userProgram(): Unit { try { account {exc} { {bank:Bank} =&gt; bank.credit(10); bank.debit(5); println(bank.balance()) } } with exc: AccountExc { def outOfMoney[A]() { println(\"Too bad.\") } } } . userProgram() . You can try changing the argument of debit from 5 to something larger then 10 and then rerun the program. ",
    "url": "/oopsla-2022-artifact/capability/#using-multiple-effects-and-capabilities",
    "relUrl": "/capability/#using-multiple-effects-and-capabilities"
  },"59": {
    "doc": "Capabilities",
    "title": "Polymorphism through Second Class Capabilities",
    "content": "System C supports effect polymorphism through capability polymorphism. For example, here is a function which calls a second function which may perform some effectful operation. def invoke { f : () =&gt; Unit }: Unit { f() } def useInvoke() { try { invoke { () =&gt; useGreeter {greeter} } } with greeter: Greeter { def sayHello() { println(\"Hello World from useInvoke!\"); resume(()) } } } . Contextual effect polymorphism means: In the block passed to invoke, we can simply use any capability that is lexically in scope. useInvoke() . This seems unsafe – what if f escaped? However, it cannot, as by default, capabilities in System C are second class – that is, they can only be passed as parameters and never returned. Moreover, functions which close over second class capabilities have the capability recorded on their binding, and by default, functions themselves are second class. Syntatically, second-class (block) parameters are denoted by {} instead of (). def otherInvoke() { try { // here inner closes over greeter, which is recorded on the binding def inner() { greeter.sayHello() } inner() } with greeter : Greeter { def sayHello() { println(\"Hello World from useInvoke!\"); resume(()) } } } . ",
    "url": "/oopsla-2022-artifact/capability/#polymorphism-through-second-class-capabilities",
    "relUrl": "/capability/#polymorphism-through-second-class-capabilities"
  },"60": {
    "doc": "Capabilities",
    "title": "Transparent wrapping and aliasing",
    "content": "Finally, capabilities and blocks can be bound to different names. However, our type system records which tracked capabilities each block binder closes over, effectively performing some form of aliasing analysis. For example, for aliased capabilities, we can bind greeter to checker but the binding for checker still reflects the underlying bound capability: . def boundInvoke() { try { def checker1 = greeter; def checker2 = { () =&gt; greeter.sayHello() }; checker1.sayHello() } with greeter : Greeter { def sayHello() { println(\"Hello World from useInvoke!\"); resume(()) } } } . ",
    "url": "/oopsla-2022-artifact/capability/#transparent-wrapping-and-aliasing",
    "relUrl": "/capability/#transparent-wrapping-and-aliasing"
  },"61": {
    "doc": "Capabilities",
    "title": "Capability-sets on Continuations",
    "content": "Here is a more complex example with nested effect handlers that illustrates how capability sets on continuations are computed. def continuations() { try { try { try { g1.sayHello(); g3.sayHello() } with g3 : Greeter { // here the capability set on f is {g1, g2}, since the program closes over // g1 and the handler closes over g2. def sayHello() { val f = resume; g2.sayHello(); f(()) } } } with g2 : Greeter { // here the capability set on g is {g1}, since the handler itself closes // over g1 def sayHello() { val g = resume; g1.sayHello(); g(()) } } } with g1 : Greeter { // here the capability set on h is empty, since neither the handled // program, nor the body of sayHello close over anything: def sayHello() { val h = resume; // even in this nested handler, the continuation has capability {}, // since the program doesn't close over anything and the handler only // closes over the outer continuation h, which itself has set {}. try { () } with g4: Greeter { def sayHello() { val i = resume; h(()); i(()) }} } } } . ",
    "url": "/oopsla-2022-artifact/capability/#capability-sets-on-continuations",
    "relUrl": "/capability/#capability-sets-on-continuations"
  },"62": {
    "doc": "Capabilities",
    "title": "Capabilities",
    "content": " ",
    "url": "/oopsla-2022-artifact/capability/",
    "relUrl": "/capability/"
  },"63": {
    "doc": "Case Studies",
    "title": "Case Studies",
    "content": "Here we report on (additional) examples that illustrate the expressivity of System C. ",
    "url": "/oopsla-2022-artifact/casestudies.html",
    "relUrl": "/casestudies.html"
  },"64": {
    "doc": "Tutorial",
    "title": "Tutorial of System C",
    "content": "In this interactive demo we will take you through a brief introduction to System C and a quick tour of its features. You can find all examples from the paper on this page. Editors . In general, you will find a lot of small code snippets that can you can typecheck and run in the browser. For example, this is a program that prints out “Hello World!”. Try clicking typecheck and run to load the editor (this can take a while the first time). def sayHello(): Unit { println(\"Hello World!\") } . The editor comes with basic support for System C – try hovering over println! . You can also modify the program and then click typecheck and run again to run the typechecker. Alternatively, in the editor you can also use the keybinding &lt;CTRL+Enter&gt; on Windows or &lt;CMD+Enter&gt; on MacOS. REPLs . Sometimes you will also find REPL windows. To run the code example, just click the run button! . sayHello() . Like with other editors, you can freely change the REPL input. Since REPLs are always single-line, you can simply press &lt;ENTER&gt; instead of clicking run. ",
    "url": "/oopsla-2022-artifact/tutorial/#tutorial-of-system-c",
    "relUrl": "/tutorial/#tutorial-of-system-c"
  },"65": {
    "doc": "Tutorial",
    "title": "Tutorial",
    "content": " ",
    "url": "/oopsla-2022-artifact/tutorial/",
    "relUrl": "/tutorial/"
  },"66": {
    "doc": "Proofs",
    "title": "Proofs",
    "content": "Copyright Notice The proofs were based on an existing proof of System-F-Sub in locally nameless by Brian Aydemir and Arthur Charguéraud, Aaron Bohannon, Jeffrey Vaughan, and Dimitrios Vytiniotis. While the definitions heavily changed, the infrastructure code regarding bindings is still very similar. Proof Sources . The documentation on this page is automatically generated from Coq proof files. The files can be found in the github repository of this artifact: . https://github.com/se-tuebingen/oopsla-2022-artifact/tree/main/coq . Not all proof-files are equally well documented. For the artifact, we carefully prepared the following files, which we recommend to look at. ",
    "url": "/oopsla-2022-artifact/proofs/",
    "relUrl": "/proofs/"
  },"67": {
    "doc": "Proofs",
    "title": "Definitions of Syntax, Typing, and Semantics",
    "content": "In file Definitions, you can inspect the Coq definitions and compare them with the paper’s definition. ",
    "url": "/oopsla-2022-artifact/proofs/#definitions-of-syntax-typing-and-semantics",
    "relUrl": "/proofs/#definitions-of-syntax-typing-and-semantics"
  },"68": {
    "doc": "Proofs",
    "title": "Main Theorems",
    "content": "File Soundness lists the main theorems, like progress and preservation. File Substitution contains lemmas about context weakening as well as the standard substitution lemmas. ",
    "url": "/oopsla-2022-artifact/proofs/#main-theorems",
    "relUrl": "/proofs/#main-theorems"
  },"69": {
    "doc": "Home",
    "title": "Effects, Capabilities, and Boxes",
    "content": "Welcome to our artifact website! . Our artifact consists of the following components: . | Coq Proofs. We documented our Coq proofs, highlighting the most important aspects and contrasting the definitions with the paper. We recommend you look at the definitions as well as at the theorems. | Interactive Demo. This website contains additional casestudies, examples from the paper, and additional explanation on capabilities and boxing. All examples can be typechecked and edited in the browser! . | . ",
    "url": "/oopsla-2022-artifact/#effects-capabilities-and-boxes",
    "relUrl": "/#effects-capabilities-and-boxes"
  },"70": {
    "doc": "Home",
    "title": "Github Repository",
    "content": "The sources of this artifact can be found in the following github repository: . https://github.com/se-tuebingen/oopsla-2022-artifact . ",
    "url": "/oopsla-2022-artifact/#github-repository",
    "relUrl": "/#github-repository"
  },"71": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "/oopsla-2022-artifact/",
    "relUrl": "/"
  },"72": {
    "doc": "Basics",
    "title": "Basics",
    "content": "System C supports basic datatypes, such as numbers, strings, functions, and booleans. def hello(): Unit { val one = 1; val hello = \"Hello\"; val check = true; println(hello) } . In addition to these basic datatypes, it also has support for inductive datatypes; for example: . type Color { Red() Green() Blue() } . You can try it out! . println(Red()) . As usual, datatypes can also take type parameteres and be recursive: . type Pair[A, B] { Pair(fst: A, snd: B) } type List[A] { Cons(head: A, tail: List[A]) Nil() } . Datatypes can be destructed using pattern matching: . def doPair() { Pair(1, 2) match { case Pair(x, y) =&gt; println(x + y) }; val z = Pair(Pair(1, 2), 3) match { case Pair(Pair(x, y), z) =&gt; x + y + z }; println(z); // this is shorthand for Cons(1, Cons(2, Cons(3, Nil()))) val l = [1, 2, 3]; val z1 = l match { case Nil() =&gt; 0 case Cons(x, tl) =&gt; x + 1 }; println(z1); () } . doPair() . ",
    "url": "/oopsla-2022-artifact/intro/",
    "relUrl": "/intro/"
  },"73": {
    "doc": "Paper Examples",
    "title": "Examples from the Paper",
    "content": "Here we include executable variants of all examples from the paper. ",
    "url": "/oopsla-2022-artifact/paper.html#examples-from-the-paper",
    "relUrl": "/paper.html#examples-from-the-paper"
  },"74": {
    "doc": "Paper Examples",
    "title": "Paper Examples",
    "content": " ",
    "url": "/oopsla-2022-artifact/paper.html",
    "relUrl": "/paper.html"
  },"75": {
    "doc": "Use and Mention",
    "title": "Distinguishing between Use and Mention",
    "content": "As observed by Colin Gordon (2020), one issue with capability-based effect systems is that they often fail to distinguish between the actual usage of a capability from when a capability is simply mentioned or passed through a section of code. Consider the following example, where we are given two capabilities, one for reading from and one for writing to a cell in memory: . interface Write[T] { def write(value: T): Unit def read(): T } interface Read[T] { def read(): T } def fork(pureFunction: () =&gt; Unit at {}): Unit { () } def mereMention[T] { x : Read[T] } { y: Write[T] } { fork(box { () =&gt; // here we mention `y`, but do not really \"use\" it. def z1(v: T) { y.write(v) } // same here. val z2 = box { () =&gt; y.read() }; () }); () } . In more traditional capability systems we would observe that the boxed blocked passed to fork captures the write capability y and hence could not be parallelized safely. However, as the only mentions of y are (1) behind a function z1, which is never called and (2) an inert boxed value z2, System C can safely conclude that we do not actually use the y capability and can safely call fork. This is indiciated by the type assigned to it, which is () =&gt; Unit at {} – a boxed thunk which requires no capability at usage (unboxing). This example might be perhaps a bit contrived, but System C also deals with similar problems that come up in real life. Consider an example due to Gordon; we have a UI, for which computation which modifies the UI must take place on dedicated UI threads. interface UI { def use(): Unit } interface Field { def setLabel(text: String): Unit } def application { ui : UI } { def field = new Field { def setLabel(text: String) { ui.use() } }; def forkThread(run: () =&gt; Unit at {}): Unit { return () } def forkUIThread(run: () =&gt; Unit at {ui}): Unit { return () } forkThread({() =&gt; val tmp = 42; // some expensive computation forkUIThread({() =&gt; field.setLabel(\"The result is \" ++ show(tmp)) }) }); () } . Here, we are given a global UI capability which must be passed through a background worker thread before it is used to report the final result on the UI thread. The intermediate thread must not use the UI capability. A more traditional capability system would conservatively approximate that the function passed to forkThread closes over field, which in turn closes over ui. In contrast, System C is able to accurately observe that it never uses it and hence can be safely run. ",
    "url": "/oopsla-2022-artifact/casestudies/passthrough.html#distinguishing-between-use-and-mention",
    "relUrl": "/casestudies/passthrough.html#distinguishing-between-use-and-mention"
  },"76": {
    "doc": "Use and Mention",
    "title": "Use and Mention",
    "content": " ",
    "url": "/oopsla-2022-artifact/casestudies/passthrough.html",
    "relUrl": "/casestudies/passthrough.html"
  },"77": {
    "doc": "Region-based Local State",
    "title": "Local Backtrackable State",
    "content": "Since System C features effect handlers and multiple resumptions, mutable state needs to be used with care. Take the following standard handler for ambiguity that runs explores all possible choices. interface Amb { def flip(): Boolean } def allChoices { prog : {Amb} =&gt; Unit }: Unit { try { prog {amb} } with amb: Amb { def flip() { resume(true); resume(false) } } } . If we declare the mutable variable outside of the handler for ambiguity, changes should be persisted across different explored alternatives: . def stateExample1() { var x = 1; allChoices { {amb: Amb} =&gt; if (amb.flip()) { x = 2 } else { () }; println(x) } } . stateExample1() . whereas, if we declare the mutable variable within the handler for ambiguity, it should perform backtracking: . def stateExample2() { allChoices { {amb: Amb} =&gt; var x = 1; if (amb.flip()) { x = 2 } else { () }; println(x) } } . stateExample2() . In order to achieve this correct backtracking behaviour, state is allocated on the stack, captured together with the continuation and restored on resumption. ",
    "url": "/oopsla-2022-artifact/casestudies/regions.html#local-backtrackable-state",
    "relUrl": "/casestudies/regions.html#local-backtrackable-state"
  },"78": {
    "doc": "Region-based Local State",
    "title": "Regions",
    "content": "In fact, all local mutable variables are allocated in corresponding regions. The regions become visible, when trying to close over the references: . def stateExample1b() { var x = 1; val closure = box { () =&gt; x }; () } . The inferred capability set for closure is {stateExample1b}. This illustrates that x is allocated in a region associated with the current function definition. We could also make this more explicit as: . def stateExample1c() { region r { var x in r = 1; val closure = box { () =&gt; x }; () } } . Now, the inferred capability set at closure is {r}. Regions are second-class and can be passed to functions: . def newCounter {pool: Region} { var state in pool = 0; return box { () =&gt; println(state); state = state + 1 } } . Hovering over newCounter, we can see that the inferred return type is () =&gt; Unit at {pool}. That is, we return a function that closes over the region that we passed to it. Let us allocate a fresh region and use the above defined function: . def stateExample3() { region pool { val c1 = newCounter {pool}; val c2 = newCounter {pool}; c1(); c1(); c2(); c1(); c2() } } . stateExample3() . ",
    "url": "/oopsla-2022-artifact/casestudies/regions.html#regions",
    "relUrl": "/casestudies/regions.html#regions"
  },"79": {
    "doc": "Region-based Local State",
    "title": "Backtrackable Regions",
    "content": "Of course the two concepts can be combined and regions show the correct backtracking behavior. def exampleProgram {amb:Amb} {reg:Region} { var x in reg = 1; if (amb.flip()) { x = 2 } else { () }; println(x) } def stateExample4() { region pool { allChoices { {amb: Amb} =&gt; exampleProgram {amb} {pool} } } } . stateExample4() . and nested the other way around: . def stateExample5() { allChoices { {amb: Amb} =&gt; region pool { exampleProgram {amb} {pool} } } } . stateExample5() . ",
    "url": "/oopsla-2022-artifact/casestudies/regions.html#backtrackable-regions",
    "relUrl": "/casestudies/regions.html#backtrackable-regions"
  },"80": {
    "doc": "Region-based Local State",
    "title": "Region-based Local State",
    "content": " ",
    "url": "/oopsla-2022-artifact/casestudies/regions.html",
    "relUrl": "/casestudies/regions.html"
  },"81": {
    "doc": "Scheduling (with continuations and mutable cells)",
    "title": "Scheduling Tasks and Continuations",
    "content": "Writing a safe, co-operatively threaded scheduler in an effect safe manner can be hard, as it requires treating continuations as first-class values. Continuations might indirectly close over other capabilities and we want to prevent that capabilities leave their defining scope indirectly through continuations. System C can safely express this though – the following is a skeleton of a scheduler. import immutable/list // we first draft a naive implementation of a queue def emptyQueue[T]() { Nil[T]() } def enqueue[T](q: List[T], el: T): List[T] { Cons(el, q) } def nonEmpty[T](q: List[T]) { size(q) &gt; 0 } def dequeue[T](q: List[T]) { reverse(q) match { case Nil() =&gt; panic[(List[T], T)](\"Empty queue\") case Cons(hd, tl) =&gt; (reverse(tl), hd) }} // now we define the interface of our scheduler interface Proc { def fork(): Boolean } // and implement the scheduler itself def schedule { p: { Proc } =&gt; Unit }: Unit { // \"processes\" spawned by fork are stored in this local mutable cell var q: List[() =&gt; Unit at {p, schedule}] = emptyQueue(); // we run the program with our own scheduler try { p {proc} } with proc: Proc { // forking enqueues the continuation twice def fork() { q = enqueue(q, box { () =&gt; resume(true) }); q = enqueue(q, box { () =&gt; resume(false) }) } }; // finally, while there are continuations, we dequeue and force them while (nonEmpty(q)) { dequeue(q) match { case (rest, k) =&gt; // this \"type-ascription\" is necessary due to our preliminary // implementation of local type inference for matches val k2: () =&gt; Unit at {p, schedule} = k; q = rest; // force the continuation (unbox k2)() } } } // Example using the scheduler interface Exc { def abort(): Unit } def example() { try { schedule { {p:Proc} =&gt; if (p.fork()) { println(\"(1)\"); if (p.fork()) { println(\"(2)\"); exc.abort() } else { println(\"(3)\") } } else { println(\"(4)\") } } } with exc: Exc { def abort() { println(\"aborted\") }} } . Note how the use of local mutable state is safely encapsulated in function schedule, which does not close over anything. We can run the above example, which forks two threads and aborts with an outer capability: . example() . Here, schedule takes in a program which expects a given Proc capability. As this program is a second-class argument, it can use additional capabilities that are not reflected in its type (but are on its binder) due to System C’s contextual effect polymorphism. In particular, these capabilities may be captured on the continuation term resume. However, as those capabilities are second class, they cannot leak through the resumption and the entire program is safe – in particular, the resumption cannot leak even though it is stored in the mutable cell q, as q is second-class itself and valid only within the context of the scheduler region. In the example above, calling exc.abort() not only terminates one “thread”, but the scheduler as a whole. This is the expected behavior: The handler for exceptions is located outside of the scheduler and thus the continuation captured and discarded by abort also includes the scheduler itself. ",
    "url": "/oopsla-2022-artifact/casestudies/scheduler.html#scheduling-tasks-and-continuations",
    "relUrl": "/casestudies/scheduler.html#scheduling-tasks-and-continuations"
  },"82": {
    "doc": "Scheduling (with continuations and mutable cells)",
    "title": "Scheduling (with continuations and mutable cells)",
    "content": " ",
    "url": "/oopsla-2022-artifact/casestudies/scheduler.html",
    "relUrl": "/casestudies/scheduler.html"
  },"83": {
    "doc": "Section 1",
    "title": "Section 1",
    "content": "Section 1 – Introduction . interface Exc { def throw(msg: String): Unit } type File { FileHandle(id: Int) } def eachLine(file: File) { f: String =&gt; Unit }: Unit { () } def open(path: String) {exc:Exc}: File { FileHandle(0) } def process(path: String) {exc1: Exc}: Unit { def abort(): Unit { exc1.throw(\"processing aborted\") } try { eachLine(open(path){exc2}) { (line: String) =&gt; abort() } } with exc2: Exc { def throw(msg: String) { () }} } . ",
    "url": "/oopsla-2022-artifact/paper/section1.html",
    "relUrl": "/paper/section1.html"
  },"84": {
    "doc": "Section 2",
    "title": "Section 2 – Global Capabilities",
    "content": "interface Exc { def throw(msg: String): Unit } interface Console { def println[A](a: A): Unit } interface Time { def now(): Int } // console and time are \"global\" -- that is, module wide capabilities def globalCapabilities { console: Console } { time: Time }: Unit { def sayTime() { console.println(\"The current time is: \" ++ show(time.now())) } // other blocks closing only over console or time def sayHello() { console.println(\"Hello!\") } def currentTime() { time.now() } def repeat(n: Int) { f: () =&gt; Unit }: Unit { if (n == 0) { () } else { f(); repeat(n - 1) {f} } } repeat(3) { () =&gt; console.println(\"Hello!\") }; repeat(3) { () =&gt; sayTime() }; def parallelWrong { f: () =&gt; Unit } { g: () =&gt; Unit }: Unit { () } // this wrong definition admits the following call: parallelWrong { () =&gt; console.println(\"Hello, \") } { () =&gt; console.println(\"world!\") }; // \"correct\" specification def parallel(f: () =&gt; Unit at {}, g: () =&gt; Unit at {}): Unit { () } // try commenting out the below call to see type errors // parallel( // box { () =&gt; console.println(\"Hello, \") }, // box { () =&gt; console.println(\"world!\") }); // same here, this is illtyped: // val firstClassWrong = box {} { () =&gt; console.println(\"Hello, \") }; val firstClassInfer = box { () =&gt; sayTime() }; def sayTimeThrice(): Unit { repeat(3) { () =&gt; sayTime() } } // 2.1.4 Capability Polymorphism def repeater { f: () =&gt; Unit }: (Int) =&gt; Unit at { f } { return box { (n: Int) =&gt; repeat(n) {f} } } val repeatTime = repeater { sayTime }; // some more variants illustrating closure and capability sets val b = sayTime; val n = repeater { () =&gt; sayTime() }; val n1 = repeater { sayTime }; val b2 : () =&gt; Unit at {console, time} = box { () =&gt; (unbox n)(3) }; val b3 = n(3); val b4 = { () =&gt; n(3) }; val r = repeater { b }; () } . Support Code for Running Examples . def run[T] { prog : {Console} {Time} =&gt; T }: T { try { prog {console} {time} } with console: Console { def println[A](msg: A) { println(msg); resume(()) } } with time: Time { def now() { resume(timestamp()) } } } . We can run the above examples . run {globalCapabilities} . ",
    "url": "/oopsla-2022-artifact/paper/section2.html#section-2--global-capabilities",
    "relUrl": "/paper/section2.html#section-2--global-capabilities"
  },"85": {
    "doc": "Section 2",
    "title": "Section 2 – Local Capabilities and Effect Handlers",
    "content": "interface Stopwatch { def elapsed(): Int } def localCapabilities { console: Console } { time: Time }: Unit { try { console.println(\"hello\"); exc.throw(\"world\"); console.println(\"done\") } with exc: Exc { def throw(msg: String) { console.println(msg ++ \"!\") } }; // uncomment the following example to see a type error: // try { return (box exc) } with exc: Exc { def throw(msg: String) { () } }; () } . Again, we can run the above examples: . run {localCapabilities} . ",
    "url": "/oopsla-2022-artifact/paper/section2.html#section-2--local-capabilities-and-effect-handlers",
    "relUrl": "/paper/section2.html#section-2--local-capabilities-and-effect-handlers"
  },"86": {
    "doc": "Section 2",
    "title": "Example 2.1",
    "content": "interface FileHandle { def readByte(pos: Int): Int } def withFile[T](path: String) { prog: {FileHandle} =&gt; T }: T { try { prog {fh} } with fh: FileHandle { def readByte(pos: Int) { resume(pos + 42) } } } def fileExample() { withFile(\"A.txt\") { {fileA: FileHandle} =&gt; val offsetReader : Int =&gt; Int at {fileA} = withFile(\"B.txt\") { {fileB: FileHandle} =&gt; val offset = fileB.readByte(0); return box { (pos: Int) =&gt; fileA.readByte(pos + offset) } }; (unbox offsetReader)(10) } } . Running the example will print 92 (0 + 42 + 42 + 10). fileExample() . ",
    "url": "/oopsla-2022-artifact/paper/section2.html#example-21",
    "relUrl": "/paper/section2.html#example-21"
  },"87": {
    "doc": "Section 2",
    "title": "Effect Handlers",
    "content": "def effectHandlers { console: Console } { time: Time }: Unit { val before = time.now(); try { def report(t: Int) { console.println(show(t) ++ \"ms\") } report(watch.elapsed()); report(watch.elapsed()); report(watch.elapsed()) } with watch: Stopwatch { def elapsed() { // we can observe the capture of `resume` by boxing it: val k = box resume; resume(time.now() - before) } } } . run {effectHandlers} . ",
    "url": "/oopsla-2022-artifact/paper/section2.html#effect-handlers",
    "relUrl": "/paper/section2.html#effect-handlers"
  },"88": {
    "doc": "Section 2",
    "title": "Section 2",
    "content": " ",
    "url": "/oopsla-2022-artifact/paper/section2.html",
    "relUrl": "/paper/section2.html"
  },"89": {
    "doc": "Section 4",
    "title": "Section 4.2 – Mutable State",
    "content": "interface State[S] { def get(): S def set(v: S): Unit } def handleState[S, R](init: S) { prog: {State[S]} =&gt; R }: R { val stateFun: S =&gt; R at {prog} = try { val res = prog { state }; return box {prog} { (s: S) =&gt; res } } with state: State[S] { def get() { box { (s: S) =&gt; (unbox resume(s))(s) } } def set(v: S) { box { (_: S) =&gt; (unbox resume(()))(v) } } }; return (unbox stateFun)(init) } . handleState(0) { {s: State[Int]} =&gt; println(s.get()); s.set(2); println(s.get()) } . For more details on regions, also see the corresponding regions case study. def regions1() { region r { var x in r = 42; val t = x; x = (t + 1) } } . def regions2() { region r { var x in r = 42; val f: () =&gt; Int at {r} = box { () =&gt; x }; (unbox f)() } } . regions2() . ",
    "url": "/oopsla-2022-artifact/paper/section4.html#section-42--mutable-state",
    "relUrl": "/paper/section4.html#section-42--mutable-state"
  },"90": {
    "doc": "Section 4",
    "title": "Example 4.1",
    "content": "See the scheduler case study . ",
    "url": "/oopsla-2022-artifact/paper/section4.html#example-41",
    "relUrl": "/paper/section4.html#example-41"
  },"91": {
    "doc": "Section 4",
    "title": "Section 4.4 – Effect Handlers and Object Orientation",
    "content": "Similar examples can be found in the regions case study. Support code to run the example from Section 2. interface Console { def println[A](a: A): Unit } def run[T] { prog : {Console} =&gt; T }: T { try { prog {console} } with console: Console { def println[A](msg: A) { println(msg); resume(()) } } } . interface Counter { def inc(): Unit def get(): Int } def counterExample { console: Console }: Unit { def makeCounter { pool: Region }: Counter at {pool, console} { var count in pool = 0; def c = new Counter { def inc() { console.println(count); count = count + 1 } def get() { count } }; return box c } region r { val c1 = makeCounter {r}; val c2 = makeCounter {r}; c1.inc(); c1.inc(); c2.inc(); console.println(c1.get()); console.println(c2.get()) } } . run {counterExample} . ",
    "url": "/oopsla-2022-artifact/paper/section4.html#section-44--effect-handlers-and-object-orientation",
    "relUrl": "/paper/section4.html#section-44--effect-handlers-and-object-orientation"
  },"92": {
    "doc": "Section 4",
    "title": "Section 4",
    "content": " ",
    "url": "/oopsla-2022-artifact/paper/section4.html",
    "relUrl": "/paper/section4.html"
  }
}
